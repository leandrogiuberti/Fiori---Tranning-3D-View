{"version":3,"file":"TreeNode.js","names":["sap","ui","define","___tmpData","createTmpData","deleteTmpData","getTmpData","TreeNode","id","label","expanded","expandable","childTreeNodes","tmpDataId","constructor","props","this","adjustPlaceholderChildTreeNode","setTreeNodeFactory","treeNodeFactory","getData","getTreeNodeFactory","hasPlaceholderTreeNode","find","treeNode","undefined","length","addPlaceholderTreeNode","removePlaceHolderChildTreeNode","push","splice","getChildTreeNodeById","childTreeNode","addChildTreeNode","parentTreeNode","register","addChildTreeNodes","treeNodes","addChildTreeNodeAtIndex","insertionIndex","removeChildTreeNode","index","indexOf","deRegister","delete","slice","deleteChildTreeNodes","registerTreeNode","deRegisterTreeNode","tmpData","setExpanded","updateUI","testMode","saveFocus","setBusy","fetchChildTreeNodes","setExpandable","restoreFocus","cache","get","fetchChildTreeNodesImpl","set","Promise","resolve","updateRecursively","childTreeNodesFromServer","updateChildren","selectNewChildTreeNode","childTreeNodeFromServer","oldTreeNode","getTreeNode","getParentTreeNode","i","updateTreeNodeProperties","Object","assign","targetTreeNode","sourceTreeNode","excludeProperties","propertyName","value","visitChildNodesRecursively","callback","visitParentNodesRecursively","isVisible","isExpanded","node","parentNode","hasChildNodes","hasExpandedChildNode"],"sources":["TreeNode.ts"],"sourcesContent":["/*!\n * SAPUI5\n * Copyright (c) 2025 SAP SE or an SAP affiliate company. All rights reserved.\n * \n */\nimport { createTmpData, deleteTmpData, getTmpData, TmpData } from \"./tmpData\";\nimport { BaseTreeNodeFactory } from \"./TreeNodeFactory\";\n\nexport interface TreeNodeProperties {\n    id: string;\n    label: string;\n    expanded?: boolean;\n    expandable?: boolean;\n}\n\nexport default class TreeNode {\n    id: string;\n    label: string;\n    expanded: boolean;\n    expandable: boolean;\n    childTreeNodes: Array<TreeNode> = [];\n    tmpDataId: string; // TODO wrong naming\n    constructor(props: TreeNodeProperties) {\n        this.id = props.id;\n        this.label = props.label;\n        this.expanded = props.expanded ?? false;\n        this.expandable = props.expandable ?? false;\n        this.adjustPlaceholderChildTreeNode();\n    }\n    setTreeNodeFactory(treeNodeFactory: BaseTreeNodeFactory) {\n        this.getData().treeNodeFactory = treeNodeFactory;\n    }\n    getTreeNodeFactory(): BaseTreeNodeFactory {\n        return this.getData().treeNodeFactory;\n    }\n    hasPlaceholderTreeNode(): boolean {\n        return this.childTreeNodes.find((treeNode: TreeNode) => treeNode.id === \"dummy\") !== undefined;\n    }\n    adjustPlaceholderChildTreeNode() {\n        // TODO public/private\n        if (this.expandable) {\n            if (this.childTreeNodes.length === 0) {\n                this.addPlaceholderTreeNode(); // TODO explanation\n            }\n        } else {\n            if (this.hasPlaceholderTreeNode()) {\n                this.removePlaceHolderChildTreeNode();\n            }\n        }\n    }\n    addPlaceholderTreeNode() {\n        // TODO rename dummy -> placeholder\n        if (this.hasPlaceholderTreeNode()) {\n            return;\n        }\n        this.childTreeNodes.push({ id: \"dummy\" } as TreeNode);\n    }\n    removePlaceHolderChildTreeNode() {\n        if (!this.hasPlaceholderTreeNode()) {\n            return;\n        }\n        this.childTreeNodes.splice(0, 1);\n    }\n    getChildTreeNodeById(id: string): TreeNode {\n        for (const childTreeNode of this.childTreeNodes) {\n            if (childTreeNode.id === id) {\n                return childTreeNode;\n            }\n        }\n    }\n    addChildTreeNode(treeNode: TreeNode) {\n        this.expandable = true;\n        this.removePlaceHolderChildTreeNode();\n        this.childTreeNodes.push(treeNode);\n        treeNode.getData().parentTreeNode = this;\n        treeNode.register();\n    }\n    addChildTreeNodes(treeNodes: Array<TreeNode>) {\n        for (const treeNode of treeNodes) {\n            this.addChildTreeNode(treeNode);\n        }\n    }\n    addChildTreeNodeAtIndex(treeNode: TreeNode, insertionIndex: number) {\n        this.expandable = true;\n        this.removePlaceHolderChildTreeNode();\n        this.childTreeNodes.splice(insertionIndex, 0, treeNode);\n        treeNode.getData().parentTreeNode = this;\n        treeNode.register();\n    }\n    removeChildTreeNode(treeNode: TreeNode) {\n        const index = this.childTreeNodes.indexOf(treeNode);\n        if (index < 0) {\n            return;\n        }\n        this.childTreeNodes.splice(index, 1);\n        treeNode.getData().parentTreeNode = null;\n        treeNode.deRegister();\n        this.adjustPlaceholderChildTreeNode();\n    }\n    delete() {\n        // delete children\n        for (const childTreeNode of this.childTreeNodes.slice()) {\n            if (childTreeNode.id === \"dummy\") {\n                continue;\n            }\n            childTreeNode.delete();\n        }\n        // detach from parent (+unregister)\n        const parentTreeNode = this.getData().parentTreeNode;\n        if (parentTreeNode) {\n            parentTreeNode.removeChildTreeNode(this);\n        }\n        if (this.tmpDataId) {\n            deleteTmpData(this.tmpDataId);\n        }\n    }\n    deleteChildTreeNodes() {\n        for (const childTreeNode of this.childTreeNodes.slice()) {\n            if (childTreeNode.id === \"dummy\") {\n                continue;\n            }\n            childTreeNode.delete();\n        }\n    }\n    register() {\n        const parentTreeNode = this.getData().parentTreeNode;\n        if (!parentTreeNode.getTreeNodeFactory()) {\n            return; // parent node not registered -> registration at the moment not possible TODO explantion\n        }\n        parentTreeNode.getTreeNodeFactory().registerTreeNode(this);\n        for (const childTreeNode of this.childTreeNodes) {\n            if (childTreeNode.id === \"dummy\") {\n                continue;\n            }\n            childTreeNode.register();\n        }\n    }\n    deRegister() {\n        if (!this.getTreeNodeFactory()) {\n            return; // not registered -> nothing todo\n        }\n        this.getTreeNodeFactory().deRegisterTreeNode(this);\n        for (const childTreeNode of this.childTreeNodes) {\n            if (childTreeNode.id === \"dummy\") {\n                continue;\n            }\n            childTreeNode.deRegister();\n        }\n    }\n    /**\n     * storage for private data TODO\n     * @returns {object}\n     */\n    getData(): TmpData {\n        if (!this.tmpDataId) {\n            const tmpData = createTmpData();\n            this.tmpDataId = tmpData.tmpDataId;\n            return tmpData;\n        }\n        return getTmpData(this.tmpDataId);\n    }\n\n    async setExpanded(expanded: boolean, updateUI?: boolean) {\n        this.expanded = expanded;\n        if (this.getTreeNodeFactory().testMode) {\n            return;\n        }\n        this.getTreeNodeFactory().saveFocus();\n        if (this.expanded) {\n            // expand\n            try {\n                this.deleteChildTreeNodes();\n                this.getTreeNodeFactory().setBusy(true);\n                const childTreeNodes = await this.fetchChildTreeNodes();\n                if (childTreeNodes.length === 0) {\n                    this.expanded = false;\n                    this.setExpandable(false);\n                } else {\n                    this.addChildTreeNodes(childTreeNodes);\n                }\n            } finally {\n                this.getTreeNodeFactory().setBusy(false);\n            }\n        } else {\n            // collapse\n            this.deleteChildTreeNodes();\n        }\n        if (updateUI) {\n            this.getTreeNodeFactory().updateUI();\n        }\n        this.getTreeNodeFactory().restoreFocus();\n    }\n\n    async fetchChildTreeNodes(): Promise<Array<TreeNode>> {\n        // check cache\n        const treeNodeFactory = this.getTreeNodeFactory();\n        let childTreeNodes: Array<TreeNode> = treeNodeFactory.cache.get(this.id) as Array<TreeNode>;\n        if (childTreeNodes) {\n            return childTreeNodes;\n        }\n        // ajax call\n        childTreeNodes = await this.fetchChildTreeNodesImpl();\n        // update cache\n        treeNodeFactory.cache.set(this.id, childTreeNodes);\n        return childTreeNodes;\n    }\n\n    fetchChildTreeNodesImpl(): Promise<Array<TreeNode>> {\n        return Promise.resolve([]);\n    }\n\n    setExpandable(expandable: boolean) {\n        this.expandable = expandable;\n        this.adjustPlaceholderChildTreeNode();\n    }\n\n    async updateRecursively(): Promise<void> {\n        const childTreeNodesFromServer = await this.fetchChildTreeNodes();\n        this.updateChildren(childTreeNodesFromServer);\n        for (const childTreeNode of this.childTreeNodes) {\n            if (childTreeNode.id === \"dummy\") {\n                continue;\n            }\n            if (!childTreeNode.expanded) {\n                continue;\n            }\n            await childTreeNode.updateRecursively();\n        }\n    }\n\n    updateChildren(childTreeNodesFromServer: Array<TreeNode>) {\n        const selectNewChildTreeNode = (childTreeNodeFromServer) => {\n            const oldTreeNode = this.getTreeNodeFactory().getTreeNode(childTreeNodeFromServer.id);\n            if (oldTreeNode) {\n                // reuse existing node\n                oldTreeNode.getParentTreeNode().removeChildTreeNode(oldTreeNode);\n                return oldTreeNode;\n            } else {\n                // use server node\n                return childTreeNodeFromServer;\n            }\n        };\n\n        if (childTreeNodesFromServer.length === 0) {\n            this.deleteChildTreeNodes();\n            this.expanded = false;\n            this.setExpandable(false);\n            return;\n        }\n        this.removePlaceHolderChildTreeNode();\n        let childTreeNode: TreeNode;\n        for (let i = 0; i < childTreeNodesFromServer.length; ++i) {\n            const childTreeNodeFromServer = childTreeNodesFromServer[i];\n            if (i <= this.childTreeNodes.length - 1) {\n                // 1 node exists at position i\n                childTreeNode = this.childTreeNodes[i];\n                if (childTreeNode.id === childTreeNodeFromServer.id) {\n                    // 1.1 correct node at position i -> nothing todo\n                } else {\n                    // 1.2 wrong node at position i -> add child node at position i\n                    childTreeNode = selectNewChildTreeNode(childTreeNodeFromServer);\n                    this.addChildTreeNodeAtIndex(childTreeNode, i);\n                }\n            } else {\n                // 2 no node at position i -> add new node\n                childTreeNode = selectNewChildTreeNode(childTreeNodeFromServer);\n                this.addChildTreeNode(childTreeNode);\n            }\n\n            // update node properties\n            //  childTreeNode.label = childTreeNodeFromServer.label;\n            this.updateTreeNodeProperties(childTreeNode, childTreeNodeFromServer);\n            Object.assign(childTreeNode.getData(), childTreeNodeFromServer.getData());\n            if (childTreeNode.expandable !== childTreeNodeFromServer.expandable) {\n                if (childTreeNodeFromServer.expandable) {\n                    childTreeNode.setExpandable(true);\n                } else {\n                    childTreeNode.deleteChildTreeNodes();\n                    childTreeNode.setExpandable(false);\n                    childTreeNode.expanded = false;\n                }\n            }\n\n            // if server node not used -> delete\n            if (childTreeNode !== childTreeNodeFromServer) {\n                childTreeNodeFromServer.delete();\n            }\n        }\n        // delete superfluous nodes\n        while (this.childTreeNodes.length > childTreeNodesFromServer.length) {\n            childTreeNode = this.childTreeNodes[this.childTreeNodes.length - 1];\n            if (childTreeNode.id === \"dummy\") {\n                this.removePlaceHolderChildTreeNode();\n            } else {\n                childTreeNode.delete();\n            }\n        }\n    }\n\n    updateTreeNodeProperties(targetTreeNode: TreeNode, sourceTreeNode: TreeNode) {\n        const excludeProperties = [\"id\", \"expanded\", \"expandable\", \"childTreeNodes\", \"tmpDataId\"];\n        for (const propertyName in sourceTreeNode) {\n            if (excludeProperties.indexOf(propertyName) >= 0) {\n                continue;\n            }\n            const value = sourceTreeNode[propertyName];\n            if ([\"number\", \"string\", \"boolean\"].indexOf(typeof value) < 0) {\n                continue;\n            }\n            targetTreeNode[propertyName] = value;\n        }\n    }\n\n    visitChildNodesRecursively(callback): void {\n        for (const childTreeNode of this.childTreeNodes) {\n            if (childTreeNode.id === \"dummy\") {\n                continue;\n            }\n            callback(childTreeNode);\n            childTreeNode.visitChildNodesRecursively(callback);\n        }\n    }\n\n    visitParentNodesRecursively(callback): void {\n        const parentTreeNode = this.getParentTreeNode();\n        if (parentTreeNode) {\n            callback(parentTreeNode);\n            parentTreeNode.visitParentNodesRecursively(callback);\n        }\n    }\n\n    getParentTreeNode(): TreeNode {\n        return this.getData().parentTreeNode;\n    }\n\n    isVisible(): boolean {\n        const isExpanded = function (node: TreeNode) {\n            if (!node.expanded) {\n                return false;\n            }\n            const parentNode = node.getParentTreeNode();\n            if (!parentNode) {\n                return true;\n            }\n            return isExpanded(parentNode);\n        };\n        const parentNode = this.getParentTreeNode();\n        if (!parentNode) {\n            return true;\n        }\n        return isExpanded(parentNode);\n    }\n\n    hasChildNodes(): boolean {\n        for (const childTreeNode of this.childTreeNodes) {\n            if (childTreeNode.id === \"dummy\") {\n                continue;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    hasExpandedChildNode(): boolean {\n        for (const childTreeNode of this.childTreeNodes) {\n            if (childTreeNode.id === \"dummy\") {\n                continue;\n            }\n            if (childTreeNode.expanded || childTreeNode.hasExpandedChildNode()) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"],"mappings":"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","ignoreList":[]}