{"version":3,"file":"SuggestionHandler.js","names":["sap","ui","define","Log","__i18n","__AppSuggestionProvider","__RecentlyUsedSuggestionProvider","__SinaSuggestionProvider","___SuggestionType","__TimeMerger","SearchHelper","___eventlogging_UserEvents","Element","_interopRequireDefault","obj","__esModule","default","i18n","AppSuggestionProvider","RecentlyUsedSuggestionProvider","SinaSuggestionProvider","SuggestionType","SuggestionTypeProperties","TimeMerger","UserEventType","SuggestionHandler","_oLogger","model","suggestionProviders","keyboardRelaxationTime","uiUpdateInterval","uiClearOldSuggestionsTimeOut","recentlyUsedSuggestionProvider","appSuggestionProvider","timeMerger","suggestionProvidersPromise","sinaNext","firstInsertion","busyIndicator","performanceLoggerSuggestionMethods","clearSuggestionTimer","suggestionResultSetCounter","suggestionHeaders","generatedPositions","doSuggestionInternalDelayed","constructor","params","this","getLogger","config","suggestionKeyboardRelaxationTime","supportsRecentlyUsedSuggestions","suggestionHandler","delayedExecution","doSuggestionInternal","bind","bRecentSearches","abortSuggestions","clearSuggestions","undefined","setProperty","clearTimeout","abort","getSuggestionProviders","then","i","length","suggestionProvider","method","performanceLogger","leaveMethod","name","initAsync","isUshell","push","searchBusinessObjects","Promise","resolve","createSinaSuggestionProviders","providerConfigurations","suggestionTypes","SearchTermHistory","SearchTermData","DataSource","boSuggestions","Object","aiSuggestions","SearchTermAI","k","providerConfiguration","isSuggestionPopupVisible","suggestions","document","querySelectorAll","Array","from","some","suggestion","offsetParent","doSuggestion","filter","searchTerm","toLocaleLowerCase","indexOf","autoSelectAppSuggestion","getSuggestions","suggestionTerm","getProperty","trim","insertSuggestions","enterMethod","isSearch","comments","eventLogger","logEvent","type","SUGGESTION_REQUEST","dataSourceKey","id","promises","pending","window","setTimeout","process","results","j","result","Error","error","stack","catch","generateSuggestionHeader","insertSuggestion","header","uiSuggestionType","App","label","getText","helpLink","aiSuggestionsHeaderHelpLink","dataSource","labelPlural","isRecentEntry","position","Header","uiSuggestionTypeOfSuggestionsInSection","enableBusyIndicator","enabled","properties","BusyIndicator","splice","checkDuplicate","checkRelevancy","action","grouped","index","slice","insertIntoSuggestionList","isWebCompSearchFieldGroupEnabled","sortSuggestions","limitSuggestions","updateSuggestions","flagReplace","maxPosition","resultSetPosition","duplicateCheckResult","isHeaderGenerationEnabled","getDataSource","appDataSource","DataSourceType","BusinessObject","sort","s1","s2","cmp","getSuggestionLimit","suggestionTypeData","Infinity","limit","allDataSource","favDataSource","limitDsAll","numberSuggestions","suggestionType","number","searchFieldInShellId","input","getElementById","suggestionKey","suggestionRows","getSuggestionRows","suggestionRow","getBindingContext","getObject","getSelected","key","_iPopupListSelectedIndex","setSelected","rerender"],"sources":["SuggestionHandler.ts"],"sourcesContent":["/*!\n * SAPUI5\n * Copyright (c) 2025 SAP SE or an SAP affiliate company. All rights reserved.\n * \n */\nimport Log, { Logger } from \"sap/base/Log\";\nimport SearchModel from \"sap/esh/search/ui/SearchModel\";\nimport i18n from \"../i18n\";\nimport { Filter } from \"../sinaNexTS/sina/Filter\";\nimport { Sina } from \"../sinaNexTS/sina/Sina\";\nimport AppSuggestionProvider, { AppSuggestion } from \"./AppSuggestionProvider\";\nimport RecentlyUsedSuggestionProvider from \"./RecentlyUsedSuggestionProvider\";\nimport SinaSuggestionProvider from \"./SinaSuggestionProvider\";\nimport { SuggestionProvider } from \"./SuggestionProvider\";\nimport {\n    Type as SuggestionType,\n    SuggestionType as SuggestionTypeProperties,\n    Suggestion,\n    SuggestionHeader,\n} from \"./SuggestionType\";\nimport TimeMerger from \"./TimeMerger\";\n// import TransactionSuggestionProvider, { TransactionSuggestion } from \"./TransactionSuggestionProvider\";\nimport * as SearchHelper from \"sap/esh/search/ui/SearchHelper\";\nimport { UserEventType } from \"../eventlogging/UserEvents\";\nimport { AbortableFunction } from \"sap/esh/search/ui/SearchHelper\";\nimport SearchInput from \"../controls/searchfieldgroup/SearchInput\";\nimport ColumnListItem from \"sap/m/ColumnListItem\";\nimport Element from \"sap/ui/core/Element\";\n\nexport default class SuggestionHandler {\n    private _oLogger: Logger;\n    private model: SearchModel;\n    private suggestionProviders: Array<SuggestionProvider>;\n    private keyboardRelaxationTime: number;\n    private readonly uiUpdateInterval = 500;\n    private readonly uiClearOldSuggestionsTimeOut = 1000;\n    private recentlyUsedSuggestionProvider: RecentlyUsedSuggestionProvider;\n    private appSuggestionProvider: AppSuggestionProvider;\n    private timeMerger: TimeMerger;\n    private suggestionProvidersPromise?: Promise<Array<SuggestionProvider>>;\n    private sinaNext: Sina;\n    private firstInsertion?: boolean;\n    private busyIndicator?: boolean;\n    private performanceLoggerSuggestionMethods: string[];\n    private clearSuggestionTimer?: number;\n    private suggestionResultSetCounter: number;\n    private suggestionHeaders: Record<number, boolean>;\n    private generatedPositions: { maxPosition: number; position: Record<string, number> };\n    private doSuggestionInternalDelayed: AbortableFunction<typeof this.doSuggestionInternal>;\n    // public transactionSuggestionProvider: TransactionSuggestionProvider;\n\n    // init\n    // ===================================================================\n    constructor(params: { model: SearchModel }) {\n        // members\n        this._oLogger = Log.getLogger(\"sap.esh.search.ui.suggestions.SuggestionHandler\");\n        this.model = params.model;\n        this.suggestionProviders = [];\n\n        // times\n        this.keyboardRelaxationTime = this.model.config.suggestionKeyboardRelaxationTime;\n\n        // recently used suggestion provider\n        if (this.supportsRecentlyUsedSuggestions()) {\n            this.recentlyUsedSuggestionProvider = new RecentlyUsedSuggestionProvider({\n                model: this.model,\n                suggestionHandler: this,\n            });\n        }\n\n        // apps suggestion provider\n        this.appSuggestionProvider = new AppSuggestionProvider({\n            model: this.model,\n            suggestionHandler: this,\n        });\n\n        // decorator for delayed suggestion execution, make delayed by default 400ms\n        this.doSuggestionInternalDelayed = SearchHelper.delayedExecution(\n            this.doSuggestionInternal.bind(this),\n            this.keyboardRelaxationTime\n        );\n\n        // time merger for merging returning suggestions callbacks\n        this.timeMerger = new TimeMerger();\n\n        this.performanceLoggerSuggestionMethods = []; // performance logging: Remember all method names of (open) suggestion calls (needed for 'abortSuggestion -> leaveMethod')\n    }\n\n    private supportsRecentlyUsedSuggestions(): boolean {\n        if (!this.model.config.bRecentSearches) return false;\n        return true;\n    }\n\n    // private supportsTransactionSuggestions(): boolean {\n    //     return false; // deactivate until S4 decides to activate it\n    //     // if (window.sap[\"cf\"]) return false; // no transaction suggestions in cFLP/multiprovider\n    //     // if (!this.model.config.isUshell) return false; // transaction suggestions are only shown in ushell\n    //     // if (\n    //     //     this.model.sinaNext.provider.serverInfo &&\n    //     //     this.model.sinaNext.provider.serverInfo.Services &&\n    //     //     this.model.sinaNext.provider.serverInfo.Services.results &&\n    //     //     this.model.sinaNext.provider.serverInfo.Services.results.length > 0\n    //     // ) {\n    //     //     for (const capability of this.model.sinaNext.provider.serverInfo.Services.results) {\n    //     //         if (capability.Id === \"TransactionSuggestions\") return true;\n    //     //     }\n    //     // }\n    //     // return false;\n    // }\n\n    // abort suggestions\n    // ===================================================================\n    public abortSuggestions(clearSuggestions?: boolean): void {\n        if (clearSuggestions === undefined || clearSuggestions === true) {\n            this.model.setProperty(\"/suggestions\", []);\n            this.model.setProperty(\"/isBusySuggestions\", false);\n            // console.log(\"xx sug clear\");\n        }\n        if (this.clearSuggestionTimer) {\n            clearTimeout(this.clearSuggestionTimer);\n            this.clearSuggestionTimer = null;\n        }\n        this.doSuggestionInternalDelayed.abort(); // abort time delayed calls\n        this.getSuggestionProviders().then((suggestionProviders: Array<SuggestionProvider>) => {\n            for (let i = 0; i < suggestionProviders.length; ++i) {\n                const suggestionProvider = suggestionProviders[i];\n                suggestionProvider.abortSuggestions();\n            }\n            this.timeMerger.abort();\n\n            for (const method of this.performanceLoggerSuggestionMethods) {\n                this.model.config.performanceLogger?.leaveMethod({\n                    name: method,\n                });\n            }\n            this.performanceLoggerSuggestionMethods = [];\n        });\n    }\n\n    // get suggestion providers dependend on server capabilities\n    // ===================================================================\n    private getSuggestionProviders(): Promise<Array<SuggestionProvider>> {\n        // check cache\n        if (this.suggestionProvidersPromise) {\n            return this.suggestionProvidersPromise;\n        }\n\n        this.suggestionProvidersPromise = this.model.initAsync().then(() => {\n            // link to sina\n            this.sinaNext = this.model.sinaNext;\n\n            // init list of suggestion providers (app suggestions are always available)\n            const suggestionProviders = [];\n            if (this.model.config.isUshell) {\n                suggestionProviders.push(this.appSuggestionProvider);\n            }\n\n            if (this.supportsRecentlyUsedSuggestions()) {\n                suggestionProviders.push(this.recentlyUsedSuggestionProvider);\n            }\n\n            // if no business obj search configured -> just use app suggestion provider\n            if (!this.model.config.searchBusinessObjects) {\n                return Promise.resolve(suggestionProviders);\n            }\n\n            // create sina suggestion providers\n            suggestionProviders.push(...this.createSinaSuggestionProviders());\n\n            // transactions suggestion provider\n            // if (this.supportsTransactionSuggestions()) {\n            //     this.transactionSuggestionProvider = new TransactionSuggestionProvider({\n            //         model: this.model,\n            //         suggestionHandler: this,\n            //     });\n            //     suggestionProviders.push(this.transactionSuggestionProvider);\n            // }\n\n            return Promise.resolve(suggestionProviders);\n        });\n\n        return this.suggestionProvidersPromise;\n    }\n\n    // create sina suggestion providers\n    // ===================================================================\n    private createSinaSuggestionProviders(): Array<SinaSuggestionProvider> {\n        // provider configuration\n        const providerConfigurations = [\n            {\n                suggestionTypes: [SuggestionType.SearchTermHistory],\n            },\n            {\n                suggestionTypes: [SuggestionType.SearchTermData],\n            },\n            {\n                suggestionTypes: [SuggestionType.DataSource],\n            },\n        ];\n        if (this.model.config.boSuggestions) {\n            providerConfigurations.push({\n                suggestionTypes: [SuggestionType.Object],\n            });\n        }\n        if (this.model.config.aiSuggestions) {\n            // just evaluate config flag\n            // user settings is checked in SinaSuggestionProvider and may change during runtime\n            providerConfigurations.push({\n                suggestionTypes: [SuggestionType.SearchTermAI],\n            });\n        }\n        // create suggestion providers\n        const suggestionProviders = [];\n        for (let k = 0; k < providerConfigurations.length; ++k) {\n            const providerConfiguration = providerConfigurations[k];\n            suggestionProviders.push(\n                new SinaSuggestionProvider({\n                    model: this.model,\n                    sinaNext: this.sinaNext,\n                    suggestionTypes: providerConfiguration.suggestionTypes,\n                    suggestionHandler: this,\n                })\n            );\n        }\n\n        return suggestionProviders;\n    }\n\n    // check if suggestions are visible\n    // ===================================================================\n    private isSuggestionPopupVisible(): boolean {\n        // Get all elements with class searchSuggestion\n        const suggestions = document.querySelectorAll(\".searchSuggestion\");\n        // Check if any element is visible (has offsetParent)\n        return Array.from(suggestions).some(\n            (suggestion) => (suggestion as HTMLElement).offsetParent !== null\n        );\n    }\n\n    // do suggestions\n    // ===================================================================\n    public doSuggestion(filter: Filter): void {\n        if (\n            filter?.searchTerm?.toLocaleLowerCase().indexOf(\"/o\") === 0 ||\n            filter?.searchTerm?.toLocaleLowerCase().indexOf(\"/n\") === 0\n        ) {\n            this.abortSuggestions(true);\n            // disable suggestions for tcodes\n            return;\n        }\n        const clearSuggestions = filter?.searchTerm?.length === 0;\n        // - clear suggestions only if search field was empty (ai suggestions, recent suggestions)\n        // - for other suggestions types first for some time the old suggestions are displayed (see this.clearSuggestionTimer)\n        this.abortSuggestions(clearSuggestions);\n        this.doSuggestionInternalDelayed(filter); // time delayed\n    }\n\n    // auto select app suggestion\n    // ===================================================================\n    public autoSelectAppSuggestion(filter: Filter): Promise<AppSuggestion> {\n        return this.appSuggestionProvider.getSuggestions(filter).then(function (suggestions) {\n            return suggestions[0] as AppSuggestion;\n        });\n    }\n\n    // public autoSelectTransactionSuggestion(key = \"\"): TransactionSuggestion | void {\n    //     key = key.toUpperCase();\n    //     return this.transactionSuggestionProvider?.transactionSuggestions.find((suggestion) => {\n    //         return suggestion.key === key;\n    //     });\n    // }\n\n    // do suggestion internal\n    // ===================================================================\n    private doSuggestionInternal(filter: Filter) {\n        /* eslint no-loop-func:0 */\n\n        this.firstInsertion = true;\n        this.busyIndicator = false;\n        this.model.setProperty(\"/isBusySuggestions\", false);\n        const suggestionTerm = this.model.getProperty(\"/uiFilter/searchTerm\");\n\n        // no suggestions for *\n        if (suggestionTerm.trim() === \"*\") {\n            this.insertSuggestions([], 0);\n            return;\n        }\n\n        const method = `Suggestions for term ${suggestionTerm}`;\n        this.performanceLoggerSuggestionMethods.push(method);\n        this.model.config.performanceLogger?.enterMethod(\n            { name: method },\n            { isSearch: true, comments: `suggestion term: ${suggestionTerm}` }\n        );\n\n        // log suggestion request\n        this.model.eventLogger.logEvent({\n            type: UserEventType.SUGGESTION_REQUEST,\n            suggestionTerm: this.model.getProperty(\"/uiFilter/searchTerm\"),\n            dataSourceKey: this.model.getProperty(\"/uiFilter/dataSource\").id,\n        });\n\n        // get suggestion providers\n        this.getSuggestionProviders()\n            .then((suggestionProviders: Array<SuggestionProvider>) => {\n                // get suggestion promises from all providers\n                const promises: Array<Promise<Array<Suggestion>>> = [];\n                let pending = suggestionProviders.length;\n                for (let i = 0; i < suggestionProviders.length; ++i) {\n                    const suggestionProvider = suggestionProviders[i];\n                    promises.push(suggestionProvider.getSuggestions(filter));\n                }\n\n                // display empty suggestions list just with busy indicator\n                if (this.isSuggestionPopupVisible()) {\n                    // do this time delayed in order to avoid flickering\n                    // otherwise we would have: old suggestions/busy indicator/new suggestions\n                    if (this.clearSuggestionTimer) {\n                        clearTimeout(this.clearSuggestionTimer);\n                    }\n                    this.clearSuggestionTimer = window.setTimeout(() => {\n                        this.clearSuggestionTimer = null;\n                        this.insertSuggestions([], pending);\n                    }, this.uiClearOldSuggestionsTimeOut);\n                } else {\n                    // immediately display busy indicator\n                    this.insertSuggestions([], pending);\n                }\n\n                // process suggestions using time merger\n                // (merge returning suggestion callbacks happening within a time slot\n                // in order to reduce number of UI updates)\n                this.timeMerger.abort();\n                this.timeMerger = new TimeMerger(promises, this.uiUpdateInterval);\n                this.timeMerger.process((results: Array<Array<Suggestion>>) => {\n                    pending -= results.length;\n                    const suggestions: Array<Suggestion> = [];\n                    for (let j = 0; j < results.length; ++j) {\n                        const result = results[j];\n                        if (result && result instanceof Error) {\n                            this._oLogger.error(\n                                \"A suggestion provider reported an error while getting suggestions for term '\" +\n                                    filter.searchTerm +\n                                    \"'\\n\" +\n                                    result.stack || result + \"\"\n                            );\n                            continue;\n                        }\n                        if (typeof result !== \"object\") {\n                            this._oLogger.error(\n                                \"A suggestion provider returned a bad response \" +\n                                    filter.searchTerm +\n                                    \"'\\n\" +\n                                    result\n                            );\n                            continue;\n                        }\n                        suggestions.push(...result);\n                    }\n                    if (pending > 0 && suggestions.length === 0) {\n                        return; // empty result -> return and don't update (flicker) suggestions on UI\n                    }\n                    if (this.clearSuggestionTimer) {\n                        clearTimeout(this.clearSuggestionTimer);\n                        this.clearSuggestionTimer = null;\n                    }\n                    this.insertSuggestions(suggestions, pending);\n                    if (pending === 0) {\n                        for (const method of this.performanceLoggerSuggestionMethods) {\n                            this.model.config.performanceLogger?.leaveMethod({\n                                name: method,\n                            });\n                        }\n                        this.performanceLoggerSuggestionMethods = [];\n                    }\n                });\n            })\n            .catch(() => {\n                for (const method of this.performanceLoggerSuggestionMethods) {\n                    this.model.config.performanceLogger?.leaveMethod({\n                        name: method,\n                    });\n                }\n                this.performanceLoggerSuggestionMethods = [];\n            });\n    }\n\n    // generate suggestion header\n    // ===================================================================\n    private generateSuggestionHeader(insertSuggestion): SuggestionHeader {\n        const header: Partial<SuggestionHeader> = {};\n        switch (insertSuggestion.uiSuggestionType) {\n            // case SuggestionType.Transaction:\n            //     header.label = i18n.getText(\"label_transactions\");\n            //     break;\n            case SuggestionType.App:\n                header.label = i18n.getText(\"label_apps\");\n                break;\n            case SuggestionType.DataSource:\n                header.label = i18n.getText(\"searchIn\");\n                break;\n            case SuggestionType.SearchTermData:\n            case SuggestionType.SearchTermHistory:\n                header.label = i18n.getText(\"searchFor\");\n                break;\n            case SuggestionType.SearchTermAI:\n                header.label = i18n.getText(\"searchTermAIHeader\");\n                header.helpLink = this.model.config.aiSuggestionsHeaderHelpLink;\n                break;\n            case SuggestionType.Object:\n                header.label = insertSuggestion.dataSource.labelPlural; // default label\n                header.dataSource = insertSuggestion.dataSource;\n                break;\n        }\n        if (insertSuggestion.isRecentEntry) {\n            header.label = i18n.getText(\"label_recently_used\");\n        }\n        header.position = insertSuggestion.position;\n        header.suggestionResultSetCounter = this.suggestionResultSetCounter;\n        header.uiSuggestionType = SuggestionType.Header;\n        header.uiSuggestionTypeOfSuggestionsInSection = insertSuggestion.uiSuggestionType;\n        return header as SuggestionHeader;\n    }\n\n    // enable busy indicator suggestion (waiting for suggestions)\n    // ===================================================================\n    private enableBusyIndicator(suggestions, enabled: boolean) {\n        if (enabled) {\n            // enable -> add busy indicator suggestions\n            suggestions.push({\n                position: SuggestionTypeProperties.properties[SuggestionType.BusyIndicator].position,\n                uiSuggestionType: SuggestionType.BusyIndicator,\n            });\n            return;\n        }\n        // disable -> remove busy indicator suggestion\n        for (let i = 0; i < suggestions.length; ++i) {\n            const suggestion = suggestions[i];\n            if (suggestion.uiSuggestionType === SuggestionType.BusyIndicator) {\n                suggestions.splice(i, 1);\n                return;\n            }\n        }\n    }\n\n    // check for duplicate suggestion\n    // ===================================================================\n    checkDuplicate(\n        suggestions: Array<Suggestion>,\n        insertSuggestion: Suggestion\n    ): {\n        action: \"append\" | \"replace\" | \"skip\";\n        index?: number; // only if action is replace\n    } {\n        const checkRelevancy = function (insertSuggestion: Suggestion): boolean {\n            return (\n                insertSuggestion.uiSuggestionType === SuggestionType.SearchTermHistory ||\n                (insertSuggestion.uiSuggestionType === SuggestionType.SearchTermData &&\n                    !insertSuggestion.dataSource)\n            );\n        };\n\n        if (!checkRelevancy(insertSuggestion)) {\n            return {\n                action: \"append\",\n            };\n        }\n\n        for (let i = 0; i < suggestions.length; ++i) {\n            const suggestion = suggestions[i];\n            if (!checkRelevancy(suggestion)) {\n                continue;\n            }\n            if (insertSuggestion.searchTerm === suggestion.searchTerm) {\n                if (\n                    insertSuggestion.grouped &&\n                    insertSuggestion.uiSuggestionType === SuggestionType.SearchTermData &&\n                    suggestion.uiSuggestionType === SuggestionType.SearchTermHistory\n                ) {\n                    // for the top grouped suggestions: prefer data based suggestion\n                    // over history based suggestions because\n                    // - upper lower case of history and data based suggestions may differ\n                    // - upper lower case should be identical for all grouped suggestions\n                    return {\n                        action: \"replace\",\n                        index: i,\n                    };\n                }\n                return {\n                    action: \"skip\",\n                };\n            }\n        }\n        return {\n            action: \"append\",\n        };\n    }\n\n    // insert suggestions\n    // ===================================================================\n    private insertSuggestions(insertSuggestions, pending: number): void {\n        // get suggestions from model\n        let suggestions: Array<Suggestion> = this.model.getProperty(\"/suggestions\").slice(); // copy list (updateSuggestions needs to access old list via data binding)\n\n        // unsorted insert of suggestions\n        suggestions = this.insertIntoSuggestionList(insertSuggestions, suggestions);\n\n        // adjust busy indicator\n        if (!this.busyIndicator && pending > 0) {\n            if (!this.model.config.isWebCompSearchFieldGroupEnabled()) {\n                this.enableBusyIndicator(suggestions, true);\n            }\n            this.busyIndicator = true;\n            this.model.setProperty(\"/isBusySuggestions\", true);\n        }\n        if (this.busyIndicator && pending === 0) {\n            if (!this.model.config.isWebCompSearchFieldGroupEnabled()) {\n                this.enableBusyIndicator(suggestions, false);\n            }\n            this.busyIndicator = false;\n            this.model.setProperty(\"/isBusySuggestions\", false);\n        }\n\n        // sort\n        this.sortSuggestions(suggestions);\n\n        // remove suggestions if over limit\n        // (limit needs to be done here because history and search term suggestions are merged)\n        this.limitSuggestions(suggestions);\n\n        // set suggestions in model\n        this.updateSuggestions(suggestions);\n        //this.model.setProperty('/suggestions', suggestions);\n    }\n\n    // insert into suggestion list\n    // ===================================================================\n    private insertIntoSuggestionList(\n        insertSuggestions: Array<Suggestion>,\n        suggestions: Array<Suggestion>\n    ): Array<Suggestion> {\n        // do we need to replace?\n        let flagReplace = false;\n        if (this.firstInsertion) {\n            this.firstInsertion = false;\n            flagReplace = true;\n        }\n\n        // reset global fields\n        if (flagReplace) {\n            suggestions = [];\n            this.suggestionHeaders = {};\n            this.suggestionResultSetCounter = 0;\n            this.generatedPositions = {\n                maxPosition: SuggestionTypeProperties.properties[SuggestionType.Object].position,\n                position: {},\n            };\n        }\n\n        // increase result set counter (used for sorting)\n        this.suggestionResultSetCounter += 1;\n\n        // add sorting information to the suggestions\n        for (let i = 0; i < insertSuggestions.length; ++i) {\n            const insertSuggestion = insertSuggestions[i];\n\n            // for object suggestions:\n            // overwrite position by a generated position for grouping object suggestions by datasource\n            // object suggestions from recent storage are not affected by this logic (they are displayed in the recent section)\n            if (\n                insertSuggestion.uiSuggestionType === SuggestionType.Object &&\n                !insertSuggestion.isRecentEntry\n            ) {\n                let position = this.generatedPositions.position[insertSuggestion.dataSource.id];\n                if (!position) {\n                    this.generatedPositions.maxPosition += 1;\n                    position = this.generatedPositions.maxPosition;\n                    this.generatedPositions.position[insertSuggestion.dataSource.id] = position;\n                }\n                insertSuggestion.position = position;\n            }\n\n            // set fields used in sorting\n            insertSuggestion.suggestionResultSetCounter = this.suggestionResultSetCounter;\n            insertSuggestion.resultSetPosition = i;\n\n            // additional duplicate check for search term suggestions\n            const duplicateCheckResult = this.checkDuplicate(suggestions, insertSuggestion);\n            switch (duplicateCheckResult.action) {\n                case \"append\":\n                    suggestions.push(insertSuggestion);\n                    break;\n                case \"skip\":\n                    continue;\n                case \"replace\":\n                    //var toBeReplacedSuggestion = suggestions[duplicateCheckResult.index];\n                    suggestions.splice(duplicateCheckResult.index, 1, insertSuggestion);\n                    //insertSuggestion.suggestionResultSetCounter = toBeReplacedSuggestion.suggestionResultSetCounter;\n                    //insertSuggestion.resultSetPosition = toBeReplacedSuggestion.resultSetPosition;\n                    break;\n            }\n\n            if (this.isHeaderGenerationEnabled() && !this.suggestionHeaders[insertSuggestion.position]) {\n                suggestions.push(this.generateSuggestionHeader(insertSuggestion));\n                this.suggestionHeaders[insertSuggestion.position] = true;\n            }\n        }\n\n        return suggestions;\n    }\n\n    // check whether we need to generate headers\n    // ===================================================================\n    private isHeaderGenerationEnabled(): boolean {\n        // no headings for app datsource\n        if (this.model.getDataSource() === this.model.appDataSource) {\n            return false;\n        }\n\n        // no headings if bo suggestions are deactivated datasource is businessobject (connector)\n        if (\n            !this.model.config.boSuggestions &&\n            this.model.getDataSource().type === this.sinaNext.DataSourceType.BusinessObject\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    // sort suggestions\n    // ===================================================================\n    private sortSuggestions(suggestions) {\n        suggestions.sort(function (s1, s2) {\n            // position is main sort field\n            let cmp = s1.position - s2.position;\n            if (cmp !== 0) {\n                return cmp;\n            }\n\n            // headers are always on top of each section\n            if (s1.uiSuggestionType === SuggestionType.Header) {\n                return -1;\n            }\n            if (s2.uiSuggestionType === SuggestionType.Header) {\n                return 1;\n            }\n\n            // special: grouped search term suggestions on top\n            // grouped: the first search term suggestion with sub suggestions by datasource\n            // for instance: sally in All\n            //               sally in Employees\n            //               sally in Customers\n            if (s1.grouped && !s2.grouped) {\n                return -1;\n            }\n            if (!s1.grouped && s2.grouped) {\n                return 1;\n            }\n\n            // sort by result set\n            cmp = s1.suggestionResultSetCounter - s2.suggestionResultSetCounter;\n            if (cmp !== 0) {\n                return cmp;\n            }\n\n            // sort by position in result set\n            cmp = s1.resultSetPosition - s2.resultSetPosition;\n            return cmp;\n        });\n    }\n\n    // get suggestion limit\n    // ===================================================================\n    public getSuggestionLimit(uiSuggestionType: SuggestionType): number {\n        const suggestionTypeData = SuggestionTypeProperties.properties[uiSuggestionType];\n        if (typeof suggestionTypeData === \"undefined\") {\n            return Infinity;\n        }\n        let limit;\n        if (\n            this.model.getDataSource() === this.model.sinaNext.allDataSource ||\n            this.model.getDataSource() === this.model.favDataSource\n        ) {\n            limit = suggestionTypeData.limitDsAll;\n        } else {\n            limit = suggestionTypeData.limit;\n        }\n        return limit;\n    }\n\n    // limit suggestions\n    // ===================================================================\n    limitSuggestions(suggestions: Array<Suggestion>): void {\n        const numberSuggestions = {};\n\n        for (let i = 0; i < suggestions.length; ++i) {\n            const suggestion = suggestions[i];\n            let suggestionType = suggestion.uiSuggestionType;\n            if (suggestionType === SuggestionType.SearchTermHistory) {\n                suggestionType = SuggestionType.SearchTermData; // history and data suggestions are merged\n            }\n            const limit = this.getSuggestionLimit(suggestionType);\n            let number = numberSuggestions[suggestionType];\n            if (typeof number === \"undefined\") {\n                number = 0;\n                numberSuggestions[suggestionType] = number;\n            }\n            if (number >= limit) {\n                suggestions.splice(i, 1);\n                --i;\n                continue;\n            }\n            numberSuggestions[suggestionType] = number + 1;\n        }\n    }\n\n    // update suggestions with restore old selected suggestion\n    // ===================================================================\n    private updateSuggestions(suggestions: Array<Suggestion>): void {\n        const searchFieldInShellId = \"searchFieldInShell-input\";\n        let input = Element.getElementById(searchFieldInShellId) as unknown as SearchInput;\n        if (!input) {\n            input = this.model.getProperty(\"/inputHelp\");\n        }\n\n        // get selected entry in old suggestion list\n        let suggestionKey;\n        if (!this.model.config.isWebCompSearchFieldGroupEnabled()) {\n            const suggestionRows = input.getSuggestionRows() as unknown as ColumnListItem[];\n            for (let i = 0; i < suggestionRows.length; ++i) {\n                const suggestionRow = suggestionRows[i];\n                const suggestion = suggestionRow.getBindingContext().getObject() as Suggestion;\n                if (suggestionRow.getSelected()) {\n                    suggestionKey = suggestion.key;\n                }\n            }\n        }\n\n        // update suggestions\n        this.model.setProperty(\"/suggestions\", suggestions);\n        // console.log(\"xx sug update\", suggestions);\n        // console.log(\"suggestions:\", suggestions);\n\n        // restore selected entry (ugly time delayed logic)\n        if (!this.model.config.isWebCompSearchFieldGroupEnabled()) {\n            if (!suggestionKey) {\n                return;\n            }\n            window.setTimeout(() => {\n                const suggestionRows = input.getSuggestionRows() as unknown as ColumnListItem[];\n                for (let j = 0; j < suggestionRows.length; ++j) {\n                    const suggestionRow = suggestionRows[j];\n                    const suggestion = suggestionRow.getBindingContext().getObject() as Suggestion;\n                    if (suggestion.key === suggestionKey) {\n                        input[\"_oSuggPopover\"]._iPopupListSelectedIndex = j; // ugly\n                        suggestionRow.setSelected(true);\n                        suggestionRow.rerender();\n                    }\n                }\n            }, 100);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]}