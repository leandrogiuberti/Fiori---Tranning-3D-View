{"version":3,"file":"MockSuggestionTypesProvider.js","names":["sap","ui","define","____sina_Capabilities","___sample2_Provider","Capabilities","Sample2Provider","MockSuggestionTypesProvider","id","aiSuggestionConfig","count","timeout","initAsync","properties","returnVal","super","capabilities","nlq","nlqEnabledInfoOnDataSource","executeSuggestionQuery","query","searchTerm","getSearchTerm","suggestionCfgsFromSearchTerm","split","map","term","trim","reduce","acc","type","countStr","timeoutStr","parseInt","this","console","log","JSON","stringify","suggestionCfgs","ai","suggestionItemCfgs","dataSource","getDataSource","queryTypes","types","queryCalculationModes","calculationModes","isRequested","includes","bo","history","maxTimeout","Object","entries","i","push","toUpperCase","Math","max","items","cfg","_createSuggestion","filter","_","dir","Promise","resolve","setTimeout","sina","_createSuggestionResultSet","title","label","undefined","_createSearchTermSuggestion","calculationMode","SuggestionCalculationMode","History","createFilter","Data","_createSearchTermAISuggestion","_createDataSourceSuggestion","__exports","__esModule"],"sources":["MockSuggestionTypesProvider.ts"],"sourcesContent":["/*!\n * SAPUI5\n * Copyright (c) 2025 SAP SE or an SAP affiliate company. All rights reserved.\n * \n */\nimport { Capabilities } from \"../../sina/Capabilities\";\nimport { SuggestionQuery } from \"../../sina/SuggestionQuery\";\nimport { SuggestionResultSet } from \"../../sina/SuggestionResultSet\";\nimport { AbstractProviderConfiguration } from \"../AbstractProvider\";\nimport { Provider as Sample2Provider } from \"../sample2/Provider\";\n\n// SuggestionTypeNameInSearchbox copied from SuggestionTypes\nexport type SuggestionTypeNameInSearchbox = \"bo\" | \"history\" | \"dataSource\" | \"ai\";\n\nexport class MockSuggestionTypesProvider extends Sample2Provider {\n    readonly id = \"mock_suggestiontypes\";\n\n    aiSuggestionConfig: { count: number; timeout: number } = {\n        count: 0,\n        timeout: 0,\n    };\n\n    override async initAsync(\n        properties: AbstractProviderConfiguration\n    ): Promise<{ capabilities: Capabilities }> {\n        let returnVal = await super.initAsync(properties);\n\n        // take over returnValue, but add nlq capabilities\n        returnVal = {\n            ...returnVal,\n            capabilities: new Capabilities({\n                ...returnVal?.capabilities,\n                nlq: true,\n                nlqEnabledInfoOnDataSource: true,\n            }),\n        };\n        return returnVal;\n    }\n    // Overwrite suggestion logic from mock/SuggestionTypes\n    override async executeSuggestionQuery(query: SuggestionQuery): Promise<SuggestionResultSet> {\n        // searchTerm:3:2000ms history:1:10000ms dataSource:5:12000ms searchTermAndDataSource:5:12000ms\n        // ignore 'ms' for now\n        // TODO add icons (to some? configurable?)\n\n        // parse and split search term\n        const searchTerm = query.getSearchTerm();\n        const suggestionCfgsFromSearchTerm: Record<\n            SuggestionTypeNameInSearchbox,\n            { count: number; timeout: number }\n        > = searchTerm\n            .split(/ +/g) // split by space\n            .map((term) => term.trim().split(\":\"))\n            // type, count, timeout: // on clashes last definition wins\n            .reduce(\n                (acc, [type, countStr, timeoutStr]) => ({\n                    ...acc,\n                    [type]: {\n                        count: parseInt(countStr, 10) || 0,\n                        timeout: parseInt(timeoutStr, 10) || 0,\n                    },\n                }),\n                {} as Record<SuggestionTypeNameInSearchbox, { count: number; timeout: number }>\n            );\n\n        // for ai suggestions as these are sent only with empty-searchTerm adding SearchTermAI:x:y configuration just\n        // changes the configuration state here, so that upon next empty searchTerm the AI suggestions are added\n        if (suggestionCfgsFromSearchTerm[\"ai\"]) {\n            // update ai-state from searchTerm\n            this.aiSuggestionConfig = suggestionCfgsFromSearchTerm[\"ai\"];\n            console.log(`AI suggestion updated: ${JSON.stringify(this.aiSuggestionConfig)}`);\n        }\n\n        // combine searchterm & AI suggestion\n        const suggestionCfgs = {\n            ...{ ai: this.aiSuggestionConfig },\n            ...suggestionCfgsFromSearchTerm,\n        };\n\n        // create individual configurations for all suggestion items\n        const suggestionItemCfgs: Array<{\n            type: SuggestionTypeNameInSearchbox;\n            searchTerm: string;\n            dataSource: string;\n        }> = [];\n\n        // figure out what is requested, possibly multiple are possible\n        const dataSource = query.getDataSource().id;\n        const queryTypes = (query.types || []) as string[];\n        const queryCalculationModes = (query.calculationModes || []) as string[];\n        const isRequested: Record<SuggestionTypeNameInSearchbox, boolean> = {\n            dataSource:\n                queryTypes.includes(\"DataSource\") && //\n                !queryCalculationModes.includes(\"History\"),\n            bo:\n                (queryTypes.includes(\"SearchTerm\") || //\n                    queryTypes.includes(\"SearchTermAndDataSource\")) &&\n                !queryCalculationModes.includes(\"History\"),\n            history: queryCalculationModes.includes(\"History\"),\n            ai:\n                queryTypes.includes(\"SearchTermAI\") && //\n                queryCalculationModes.includes(\"Data\"),\n        };\n\n        let maxTimeout = 0;\n        // go through configurations and check if current request is asking for it, if yes, create suggestion items\n        for (const [type, { count, timeout }] of Object.entries(suggestionCfgs)) {\n            if (!isRequested[type] || count <= 0) {\n                // skip if not requested\n                continue;\n            }\n            for (let i = 0; i < count; i++) {\n                suggestionItemCfgs.push({\n                    //\n                    type: type as SuggestionTypeNameInSearchbox,\n                    searchTerm: `${type} ${i + 1}/${count} <b>${type?.toUpperCase() + \" \" + (i + 1)}</b> of ${count}`,\n                    dataSource,\n                });\n            }\n            maxTimeout = Math.max(maxTimeout, timeout);\n        }\n\n        const items = suggestionItemCfgs\n            .map((cfg) => this._createSuggestion(cfg)) //\n            .filter((_) => _); // remove undefined\n\n        console.log(`SuggestionTypes: suggestion (${query.types} - ${query.calculationModes})`);\n        console.dir(items);\n\n        // wait for timeout, simulate backend\n        if (maxTimeout > 0) {\n            await new Promise((resolve) => setTimeout(resolve, maxTimeout));\n        }\n\n        return this.sina._createSuggestionResultSet({\n            title: \"Suggestions\",\n            query,\n            items,\n        });\n    }\n\n    //configurations: { [name: string]: string[] } = {\n    //    default: [\"emptyDataSource\"],\n    //};\n\n    _createSuggestion(cfg: {\n        type: SuggestionTypeNameInSearchbox;\n        searchTerm?: string;\n        label?: string;\n        dataSource?: string;\n    }) {\n        // create suggestions based on config array\n        const searchTerm = cfg.searchTerm ?? \"\";\n        const label = cfg.label ?? searchTerm;\n        const dataSource = cfg.dataSource ? this.sina.getDataSource(cfg.dataSource) : undefined;\n\n        switch (cfg.type) {\n            case \"history\":\n                return this.sina._createSearchTermSuggestion({\n                    searchTerm,\n                    label,\n                    calculationMode: this.sina.SuggestionCalculationMode.History,\n                    filter: this.sina.createFilter({\n                        dataSource,\n                        searchTerm,\n                    }),\n                });\n            // case \"searchTerm\":\n            case \"bo\":\n                return this.sina._createSearchTermSuggestion({\n                    searchTerm,\n                    label,\n                    calculationMode: this.sina.SuggestionCalculationMode.Data,\n                    filter: this.sina.createFilter({\n                        dataSource,\n                        searchTerm,\n                    }),\n                });\n            case \"ai\":\n                return this.sina._createSearchTermAISuggestion({\n                    searchTerm,\n                    label,\n                    calculationMode: this.sina.SuggestionCalculationMode.Data,\n                    filter: this.sina.createFilter({\n                        dataSource,\n                        searchTerm,\n                    }),\n                });\n            case \"dataSource\":\n                return this.sina._createDataSourceSuggestion({\n                    calculationMode: this.sina.SuggestionCalculationMode.Data,\n                    dataSource,\n                    label,\n                });\n            // case \"searchTermAndDataSource\":\n            //     return this.sina._createSearchTermAndDataSourceSuggestion({\n            //         searchTerm,\n            //         dataSource,\n            //         label,\n            //         calculationMode: this.sina.SuggestionCalculationMode.Data,\n            //         filter: this.sina.createFilter({\n            //             dataSource,\n            //             searchTerm,\n            //         }),\n            //     });\n            default:\n                return undefined;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]}