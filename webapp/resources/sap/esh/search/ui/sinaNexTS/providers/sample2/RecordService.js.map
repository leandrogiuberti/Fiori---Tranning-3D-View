{"version":3,"file":"RecordService.js","names":["sap","ui","define","___Util","____sina_ComplexCondition","____sina_SimpleCondition","formatRawValue","getMatchedStringValues","isValuePairMatched","readFile","ComplexCondition","SimpleCondition","RecordService","sina","dataSourceIds","records","constructor","this","loadRecords","length","dataSourceId","csv","push","parseCsv2RecordSet","parsedCsv","parseCsv2ArraySet","attributeIds","index","values","valueMap","createAttributeValueMap","record","id","rawValues","Object","map","value","rawValue","stringValues","stringValue","rows","split","filter","l","trim","row","cells","cell","inQuotes","char","i","attributeId","sValue","type","getDataSource","getAttributeMetadata","e","attributesMetadata","attributeMetadata","undefined","getRecordsByDataSourceId","recordSet","getResponse","query","results","matchedRecords","searchTerm","searchedDataSourceIds","dataSource","includes","rootCondition","conditions","getRecordsByConditions","getRecordsBySimpleCondition","attribute","operator","resultsToDisplay","getDisplayedRecords","totalCount","condition","recordsCondition0","recordsCondition1","intersectRecords","uniteRecords","attributeRawValue","records1","records2","r1","some","r2","record1Ids","Set","concat","has","recordsDisplayed","sortAttributeId","sortOrder","order","sortRecords","top","slice","skip","sort","v1","v2","localeCompare","toString","Date","getTime","__exports","__esModule"],"sources":["RecordService.ts"],"sourcesContent":["/*!\n * SAPUI5\n * Copyright (c) 2025 SAP SE or an SAP affiliate company. All rights reserved.\n * \n */\nimport { Sina } from \"../../sina/Sina\";\nimport { Value as RawValue } from \"../../sina/types\";\nimport { formatRawValue, getMatchedStringValues, isValuePairMatched, readFile } from \"./Util\";\nimport { Query } from \"../../sina/Query\";\nimport { ComparisonOperator } from \"../../sina/ComparisonOperator\";\nimport { ComplexCondition } from \"../../sina/ComplexCondition\";\nimport { SimpleCondition } from \"../../sina/SimpleCondition\";\n\ninterface SimpleConditionData {\n    attributeId: string;\n    // stringValue: string;\n    rawValue: RawValue; // may need for filtering\n    operator: string;\n}\nexport interface RecordResponse {\n    results: Record[]; // total results\n    resultsToDisplay: Record[]; // results with top, skip, sort\n    totalCount: number;\n}\n\nexport interface StringRawValuePair {\n    stringValue: string;\n    rawValue: RawValue;\n}\n\nexport interface AttributeValueMap {\n    [key: string]: StringRawValuePair;\n}\n\nexport interface Record {\n    id: string; // example 'purchaseOrders_1', used for intersect/unite records\n    dataSourceId: string;\n    valueMap: AttributeValueMap;\n    rawValues: RawValue[];\n    stringValues: string[];\n}\n\nexport class RecordService {\n    sina: Sina;\n    dataSourceIds = [] as string[];\n    records = [] as Record[];\n\n    constructor(sina: Sina, dataSourceIds: string[]) {\n        this.sina = sina;\n        this.dataSourceIds = dataSourceIds;\n    }\n\n    async loadRecords(): Promise<void> {\n        if (this.records.length > 0) {\n            return;\n        }\n\n        for (const dataSourceId of this.dataSourceIds) {\n            const csv = await readFile(\n                `/resources/sap/esh/search/ui/sinaNexTS/providers/sample2/data/${dataSourceId}.csv`\n            );\n            this.records.push(...this.parseCsv2RecordSet(dataSourceId, csv));\n        }\n    }\n\n    private parseCsv2RecordSet(dataSourceId: string, csv: string): Record[] {\n        const parsedCsv = this.parseCsv2ArraySet(csv);\n        const attributeIds = parsedCsv[0]; // header\n        const records: Record[] = [];\n\n        for (let index = 1; index < parsedCsv.length; index++) {\n            const values = parsedCsv[index];\n            const valueMap = this.createAttributeValueMap(dataSourceId, attributeIds, values);\n\n            const record = {\n                id: `${dataSourceId}_${index}`,\n                dataSourceId: dataSourceId,\n                valueMap: valueMap,\n                rawValues: Object.values(valueMap).map((value) => value.rawValue),\n                stringValues: Object.values(valueMap).map((value) => value.stringValue),\n            } as Record;\n\n            records.push(record);\n        }\n        return records;\n    }\n\n    private parseCsv2ArraySet(csv: string): string[][] {\n        /* \n        input: '\"FIRST_NAME\",\"LAST_NAME\", ...\\n\"Sally\",\"Spring\", ...\\n\"John\",\"Doe\", ...'\n        output: [[\"FIRST_NAME\", \"LAST_NAME\", ...], [\"Sally\", \"Spring\", ...], [\"John\", \"Doe\", ...]]\n         */\n        const rows = csv\n            .split(\"\\n\")\n            .filter((l) => l.trim() !== \"\")\n            .map((row) => {\n                const cells = [];\n                let cell = \"\";\n                let inQuotes = false;\n\n                for (const char of row) {\n                    if (char === '\"') {\n                        inQuotes = !inQuotes;\n                    } else if (char === \",\" && !inQuotes) {\n                        cells.push(cell);\n                        cell = \"\";\n                    } else {\n                        cell += char;\n                    }\n                }\n\n                cells.push(cell);\n                return cells;\n            });\n        return rows;\n    }\n\n    private createAttributeValueMap(\n        dataSourceId: string,\n        attributeIds: string[],\n        stringValues: string[]\n    ): AttributeValueMap {\n        const valueMap = {};\n\n        for (let i = 0; i < attributeIds.length; i++) {\n            const attributeId = attributeIds[i];\n            const sValue = stringValues[i];\n            try {\n                const type = this.sina.getDataSource(dataSourceId).getAttributeMetadata(attributeId).type;\n                valueMap[attributeId] = {\n                    stringValue: sValue,\n                    rawValue: formatRawValue(sValue, type),\n                };\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            } catch (e) {\n                valueMap[attributeId] = {\n                    stringValue: sValue,\n                    rawValue: sValue,\n                };\n            }\n        }\n\n        // insert default values for single attributes not present in CSV\n        const attributesMetadata = this.sina.getDataSource(dataSourceId).attributesMetadata;\n        for (const attributeMetadata of attributesMetadata) {\n            if (valueMap[attributeMetadata.id] === undefined && attributeMetadata.type !== \"Group\") {\n                valueMap[attributeMetadata.id] = {\n                    stringValue: \"default attribute value\",\n                    rawValue: formatRawValue(\"default attribute value\", attributeMetadata.type), // formatRawValue is able to create default value of different types\n                };\n            }\n        }\n\n        return valueMap;\n    }\n\n    getRecordsByDataSourceId(dataSourceId: string, records?: Record[]): Record[] {\n        let recordSet = [];\n        if (records) {\n            recordSet = records;\n        } else {\n            recordSet = this.records;\n        }\n        return recordSet.filter((record) => record.dataSourceId === dataSourceId);\n    }\n\n    getResponse(query: Query): RecordResponse {\n        let results = [];\n        const matchedRecords = [];\n        const searchTerm = query.filter.searchTerm;\n        const searchedDataSourceIds =\n            query.filter.dataSource.id !== \"All\" ? [query.filter.dataSource.id] : this.dataSourceIds;\n\n        for (const record of this.records) {\n            if (\n                searchedDataSourceIds.includes(record.dataSourceId) &&\n                getMatchedStringValues(record.stringValues, searchTerm).length > 0\n            ) {\n                matchedRecords.push(record);\n            }\n        }\n\n        if (\n            query.filter.rootCondition instanceof ComplexCondition &&\n            query.filter.rootCondition.conditions.length > 0\n        ) {\n            // Query has ComplexCondition\n            results = this.getRecordsByConditions(matchedRecords, query.filter.rootCondition);\n        } else if (query.filter.rootCondition instanceof SimpleCondition) {\n            // Query has SimpleCondition\n            results = this.getRecordsBySimpleCondition(matchedRecords, {\n                attributeId: query.filter.rootCondition.attribute,\n                rawValue: query.filter.rootCondition.value,\n                operator: query.filter.rootCondition.operator,\n            });\n        } else {\n            // Query has no Condition\n            results = matchedRecords;\n        }\n\n        return {\n            results: results,\n            resultsToDisplay: this.getDisplayedRecords(results, query),\n            totalCount: results.length,\n        };\n    }\n\n    getRecordsByConditions(records: Record[], condition: SimpleCondition | ComplexCondition): Record[] {\n        // recursive filter records by condition object\n        // complex condition object has properties: type = \"Complex\", conditions (array of child conditions), and operator = \"And\" or \"Or\"\n        // simple condition object has properties: type = \"Simple\", attribute (string), value (string), and operator = \"Eq\", \"Gt\", \"Lt\", etc.\n        // if complex condition has operator \"And\", intersectRecords of getRecordsByConditions its child conditions\n        // if complex condition has operator \"Or\", uniteRecords of getRecordsByConditions child conditions\n        // if simple condition, getRecordsBySimpleCondition condition\n\n        if (condition instanceof ComplexCondition) {\n            let recordsCondition0 = this.getRecordsByConditions(records, condition.conditions[0]);\n\n            for (let i = 1; i < condition.conditions.length; i++) {\n                const recordsCondition1 = this.getRecordsByConditions(records, condition.conditions[i]);\n                if (condition.operator === \"And\") {\n                    recordsCondition0 = this.intersectRecords(recordsCondition0, recordsCondition1);\n                } else if (condition.operator === \"Or\") {\n                    recordsCondition0 = this.uniteRecords(recordsCondition0, recordsCondition1);\n                }\n            }\n\n            return recordsCondition0;\n        } else {\n            return this.getRecordsBySimpleCondition(records, {\n                attributeId: condition.attribute,\n                rawValue: condition.value,\n                operator: condition.operator,\n            } as SimpleConditionData);\n        }\n    }\n\n    private getRecordsBySimpleCondition(records: Record[], condition: SimpleConditionData): Record[] {\n        try {\n            return records.filter((record) => {\n                const attributeRawValue = record.valueMap[condition.attributeId].rawValue;\n                return isValuePairMatched(\n                    attributeRawValue,\n                    condition.rawValue,\n                    condition.operator as ComparisonOperator\n                );\n            });\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        } catch (e) {\n            return [];\n        }\n    }\n\n    private intersectRecords(records1: Record[], records2: Record[]): Record[] {\n        return records1.filter((r1) => records2.some((r2) => r1.id === r2.id));\n    }\n\n    private uniteRecords(records1: Record[], records2: Record[]): Record[] {\n        const record1Ids = new Set(records1.map((r1) => r1.id)); // Set of IDs for faster lookups\n        return records1.concat(records2.filter((r2) => !record1Ids.has(r2.id)));\n    }\n\n    private getDisplayedRecords(records: Record[], query: Query): Record[] {\n        let recordsDisplayed = records;\n\n        // order records\n        const sortAttributeId = query?.sortOrder[0]?.id;\n        const order = query?.sortOrder[0]?.order;\n        if (sortAttributeId && order) {\n            recordsDisplayed = this.sortRecords(recordsDisplayed, sortAttributeId, order);\n        }\n\n        // set top records\n        if (query.top) {\n            recordsDisplayed = recordsDisplayed.slice(0, query.top);\n        }\n\n        // set skip records\n        if (query.skip) {\n            recordsDisplayed = recordsDisplayed.slice(query.skip);\n        }\n        return recordsDisplayed;\n    }\n\n    sortRecords(records: Record[], attributeId: string, sort?: \"Ascending\" | \"Descending\"): Record[] {\n        return records.sort((r1, r2) => {\n            const v1 = r1.valueMap[attributeId].rawValue;\n            const v2 = r2.valueMap[attributeId].rawValue;\n\n            if (sort === \"Descending\") {\n                if (typeof v1 === \"string\" && typeof v2 === \"string\") {\n                    return (v2 as string).localeCompare(v1 as string);\n                }\n                if (typeof v1 === \"number\" && typeof v2 === \"number\") {\n                    return (v2 as number) - (v1 as number);\n                }\n                if (typeof v1 === \"boolean\" && typeof v2 === \"boolean\") {\n                    return (v2.toString() as string).localeCompare(v1.toString() as string);\n                }\n                if (v1 instanceof Date && v2 instanceof Date) {\n                    return (v2 as Date).getTime() / 1000 - (v1 as Date).getTime() / 1000;\n                }\n                return 1;\n            } else {\n                if (typeof v1 === \"string\" && typeof v2 === \"string\") {\n                    return (v1 as string).localeCompare(v2 as string);\n                }\n                if (typeof v1 === \"number\" && typeof v2 === \"number\") {\n                    return (v1 as number) - (v2 as number);\n                }\n                if (typeof v1 === \"boolean\" && typeof v2 === \"boolean\") {\n                    return (v1.toString() as string).localeCompare(v2.toString() as string);\n                }\n                if (v1 instanceof Date && v2 instanceof Date) {\n                    return (v1 as Date).getTime() / 1000 - (v2 as Date).getTime() / 1000;\n                }\n                return 1;\n            }\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]}