{"version":3,"file":"definitions.js","names":["sap","ui","define","reservedCharacters","reservedWords","replaceAll","original","search","replacement","split","join","escapeSingleQuote","value","replace","escapeDoubleQuoteAndBackslash","escapeQuery","query","escapedQuery","trim","specialCharacter","specialWord","startsWith","substring","length","endsWith","RegExp","escapeQueryWithCustomLength","escapeQueryWithDefaultLength","existValueInEnum","type","Object","keys","filter","k","isNaN","Number","NearOrdering","ListValues","clazz","this","constructor","name","values","item","toStatement","map","NullValue","BooleanValue","toString","NumberValue","String","StringValue","isQuoted","isSingleQuoted","withoutEnclosing","parseFloat","ViewParameter","param","HierarchyFacet","facetColumn","rootIds","levels","id","NearOperator","distance","ordering","InListOperator","InList","operator","SpatialReferenceSystemsOperatorBase","functionName","SpatialReferenceSystemsOperator","WithinOperator","super","CoveredByOperator","IntersectsOperator","pointCoordinates","x","y","PointValues","point","MultiPointValues","points","LineStringValues","toLineStringArray","CircularStringValues","MultiLineStringValues","lineStrings","lineString","PolygonValues","toPolygonStringArray","polygon","MultiPolygonValues","polygons","GeometryCollectionValues","geometryCollection","geometry","RangeValues","start","end","excludeStart","excludeEnd","Comparison","property","valueAsReservedWord","searchOptions","escapeValueCharStart","escapeValueCharEnd","isODataComparison","ComparisonOperator","propertyValues","valueQuery","comparisonOperator","comparisonStatement","addFuzzySearchOptions","ScopeComparison","Error","Term","term","doEshEscaping","finalTerm","escapePhrase","returnValue","Phrase","phrase","finalPhrase","Near","terms","forEach","push","nearStatement","Property","prefixOperator","LogicalOperator","SearchQueryLogicalOperator","SearchQueryPrefixOperator","returnStatement","fuzzinessThreshold","fuzzySearchOptions","weight","undefined","Expression","items","ROW","AUTH","FILTER","FILTERWF","BOOST","operatorValue","i","NOT","not","itemsScopes","SearchQueryComparisonOperator","ESOrderType","SEARCH_DEFAULTS","scope","PropertyAlias","path","alias","Alias","DynamicView","select","aliases","properties","paths","conditions","listOfAliases","condition","key","CustomFunction","arguments","argumentsValue","singleArgumentValue","FilterFunction","Array","isArray","element","customFunction","oDataFilter","expressionStatement","deserialize","jsonO","deserializedComparison","returnExpression","returnDynamicView","returnCustomFunction","includes","returnFilterFunction","JSON","stringify","__exports","__esModule"],"sources":["definitions.ts"],"sourcesContent":["/*!\n * SAPUI5\n * Copyright (c) 2025 SAP SE or an SAP affiliate company. All rights reserved.\n * \n */\n/* eslint-disable max-classes-per-file */\n/** Copyright 2019 SAP SE or an SAP affiliate company. All rights reserved. */\n\n\nconst reservedCharacters = [\"\\\\\", \"-\", \"(\", \")\", \"~\", \"^\", \"?\", \"\\\"\", \":\", \"'\", \"[\", \"]\"]; //add new elements at the end of the array\nconst reservedWords = [\"AND\", \"OR\", \"NOT\"];\n\nfunction replaceAll(original: string, search: string, replacement: string): string {\n  return original.split(search).join(replacement);\n}\n\nexport const escapeSingleQuote = (value: string): string => {\n  return value.replace(/'/g, \"''\");\n}\n\nexport const escapeDoubleQuoteAndBackslash = (value: string): string => {\n  return value.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\");\n}\n\n\nexport function escapeQuery(query: string): string {\n  let escapedQuery: string = query ? query.trim() : \"\";\n  if (escapedQuery !== \"\") {\n    for (const specialCharacter of reservedCharacters) {\n      if (specialCharacter) {\n        if (specialCharacter === \"'\") {\n          escapedQuery = escapeSingleQuote(escapedQuery);\n        } else {\n          escapedQuery = replaceAll(escapedQuery, specialCharacter, \"\\\\\" + specialCharacter);\n        }\n      }\n    }\n    for (const specialWord of reservedWords) {\n      if (escapedQuery === specialWord) {\n        escapedQuery = \"\\\"\" + specialWord + \"\\\"\";\n      }\n      if (escapedQuery.startsWith(specialWord + \" \")) {\n        escapedQuery = \"\\\"\" + specialWord + \"\\\" \" + escapedQuery.substring(specialWord.length + 1);\n      }\n      if (escapedQuery.endsWith(\" \" + specialWord)) {\n        escapedQuery = escapedQuery.substring(0, escapedQuery.length - (specialWord.length + 1)) + \" \\\"\" + specialWord + \"\\\"\";\n      }\n      //escapedQuery = replaceAll(escapedQuery, \" \" + specialWord + \" \", \" \\\"\" + specialWord + \"\\\" \");\n      escapedQuery = escapedQuery.replace(new RegExp(` ${specialWord} `, 'g'), ` \\\"${specialWord}\\\" `);\n    }\n  }\n\n  //if (escapedQuery === \"\") {\n  //  escapedQuery = \" \";\n  //}\n  return escapedQuery;\n}\n\nexport function escapeQueryWithCustomLength(query: string, length: number): string {\n  return escapeQuery(query).substring(0, length);\n}\n\nexport function escapeQueryWithDefaultLength(query: string): string {\n  return escapeQuery(query).substring(0, 1500);\n}\n\nexport function existValueInEnum(type: any, value: any): boolean {\n  return Object.keys(type).filter(k => isNaN(Number(k))).filter(k => type[k] === value).length > 0;\n}\nexport interface ISearchOptions {\n  fuzzinessThreshold?: number;\n  weight?: number;\n  fuzzySearchOptions?: string;\n}\n\nexport interface IToStatement {\n  readonly clazz: string;\n  toStatement(): string;\n}\n\nexport interface IComparison {\n  property: string | IToStatement;\n  operator: (SearchQueryComparisonOperator | ComparisonOperator | NearOperator);\n  value?: string | IToStatement;\n  valueAsReservedWord?: boolean;\n  searchOptions?: ISearchOptions;\n}\n\nexport interface IScopeComparison {\n  values: string[];\n}\n\nexport interface ITerm {\n  term: string;\n  searchOptions?: ISearchOptions;\n  isQuoted?: boolean;\n  doEshEscaping?: boolean;\n}\n\nexport interface IPhrase {\n  phrase: string;\n  searchOptions?: ISearchOptions;\n  doEshEscaping?: boolean;\n}\n\nexport enum NearOrdering {\n  Ordered = \"O\",\n  Unordered = \"U\"\n}\nexport interface INear {\n  terms: string[] | IToStatement[];\n  distance: number;\n  ordering?: NearOrdering;\n  searchOptions?: ISearchOptions;\n}\n\nexport interface IGroupBy {\n  properties: string[];\n  aggregateCountAlias?: string;\n}\n\nexport interface INearOperator {\n  distance: number;\n  ordering?: NearOrdering;\n}\n\nexport interface IHierarchyFacet {\n  facetColumn: string;\n  rootIds: (string | null)[];\n  levels: number;\n}\n\nexport interface IListValues {\n  values: string[];\n}\n\nexport class ListValues implements IToStatement {\n  readonly clazz = this.constructor.name;\n  values: (string | IToStatement) [];\n\n  constructor(item: IListValues) {\n    this.values = item.values;\n  }\n  toStatement(): string {\n    return `[${this.values.map((value) => typeof value === \"string\" ? \"'\" + escapeSingleQuote(value) + \"'\" : value.toStatement()).join(\",\")}]`;\n  }\n}\n\nexport class NullValue implements IToStatement {\n  readonly clazz = this.constructor.name;\n  constructor() {};\n  toStatement(): string {\n    return \"null\";\n  }\n}\n\nexport class BooleanValue implements IToStatement {\n  readonly clazz = this.constructor.name;\n  value: Boolean;\n  constructor(item: {value: Boolean}) {\n    this.value = item.value;\n  };\n  toStatement(): string {\n    return this.value.toString();\n  }\n}\n\nexport class NumberValue implements IToStatement {\n  readonly clazz = this.constructor.name;\n  value: Number | String;\n  constructor(item: {value: Number | String}) {\n    this.value = item.value;\n  };\n  toStatement(): string {\n    return String(this.value);\n  }\n}\n\nexport interface IStringValue {\n  value: string;\n  isQuoted?: boolean;\n  isSingleQuoted?: boolean;\n  withoutEnclosing?: boolean;\n}\nexport class StringValue implements IToStatement {\n  readonly clazz = this.constructor.name;\n  \n  value: string;\n  isQuoted?: boolean;\n  isSingleQuoted?: boolean;\n  withoutEnclosing?: boolean;\n  \n  constructor(item: IStringValue) {\n    this.value = item.value;\n    this.isQuoted = item.isQuoted;\n    this.isSingleQuoted = item.isSingleQuoted;\n    this.withoutEnclosing = item.withoutEnclosing;\n  };\n  \n  toStatement(): string {\n    if (this.withoutEnclosing) {\n      return String(Number.parseFloat(this.value));\n    }\n    if (this.isQuoted) {\n      return `\"${escapeDoubleQuoteAndBackslash(this.value)}\"`;\n    } \n    if (this.isSingleQuoted) {\n      return `'${escapeSingleQuote(this.value)}'`;\n    }\n    return this.value;\n  }\n\n}\n\n\nexport interface IViewParameter {\n  param: string;\n}\nexport class ViewParameter implements IViewParameter {\n  readonly clazz = this.constructor.name;\n  param: string;\n\n  constructor(item: IViewParameter) {\n    this.param = item.param;\n  }\n\n  toStatement(): string {\n    return `param \"${escapeDoubleQuoteAndBackslash(this.param)}\"`;\n  }\n}\n\nexport class HierarchyFacet implements IToStatement {\n  readonly clazz = this.constructor.name;\n  facetColumn: string;\n  rootIds: (string | null)[];\n  levels: number;\n\n  constructor(item: IHierarchyFacet) {\n    this.facetColumn = item.facetColumn;\n    this.rootIds = item.rootIds;\n    this.levels = item.levels;\n  }\n  toStatement(): string {\n    return `(${this.facetColumn},(${this.rootIds.map(id => id ? \"'\" + id + \"'\" : \"null\").join(\",\")}),${this.levels})`;\n  }\n}\nexport class NearOperator implements IToStatement {\n  readonly clazz = this.constructor.name;\n  distance: number;\n  ordering?: NearOrdering;\n\n  constructor(item: INearOperator) {\n    this.distance = item.distance;\n    this.ordering = item.ordering;\n  }\n  toStatement(): string {\n    return `:NEAR(${this.distance}${this.ordering ? \",\" + this.ordering : \"\"}):`;\n  }\n}\n\nexport enum InListOperator {\n  AND = \"AND\",\n  OR = \"OR\"\n}\n\nexport interface IInList {\n  operator: InListOperator;\n  values: string[];\n}\n\nexport class InList implements IToStatement {\n  readonly clazz = this.constructor.name;\n  operator: InListOperator;\n  values: string[];\n\n  constructor(item: IInList) {\n    this.operator = item.operator;\n    this.values = item.values;\n  }\n  toStatement(): string {\n    return `${this.operator}(${this.values.join(\" \")})`;\n  }\n}\n\ninterface ISpatialReferenceSystemsOperator {\n  id?: number;\n}\n\nclass SpatialReferenceSystemsOperatorBase implements IToStatement {\n  readonly clazz = this.constructor.name;\n  protected functionName: string;\n  protected id?: null | number;\n\n  constructor(functionName: string, id?: null | number) {\n    this.functionName = functionName;\n    this.id = id;\n  }\n\n  toStatement(): string {\n    return `:${this.functionName}${this.id ? \"(\" + this.id + \")\" : \"\"}:`;\n  }\n}\nexport class SpatialReferenceSystemsOperator implements IToStatement {\n  readonly clazz = this.constructor.name;\n  id?: number;\n\n  constructor(item: ISpatialReferenceSystemsOperator) {\n    this.id = item.id;\n  }\n\n  toStatement(): string {\n    return `:${this.id ? \"(\" + this.id + \"):\" : \"\"}`;\n  }\n}\n\nexport class WithinOperator extends SpatialReferenceSystemsOperatorBase {\n  constructor(item: ISpatialReferenceSystemsOperator) {\n    super(\"WITHIN\", item.id);\n  }\n}\n\nexport class CoveredByOperator extends SpatialReferenceSystemsOperatorBase {\n  constructor(item: ISpatialReferenceSystemsOperator) {\n    super(\"COVERED_BY\", item.id);\n  }\n}\n\nexport class IntersectsOperator extends SpatialReferenceSystemsOperatorBase {\n  constructor(item: ISpatialReferenceSystemsOperator) {\n    super(\"INTERSECTS\", item.id);\n  }\n}\n\ninterface IPoint {\n  x: number;\n  y: number;\n}\n\nconst pointCoordinates = (item: IPoint): string => `${item.x} ${item.y}`;\n\n\nexport class PointValues implements IToStatement {\n  readonly clazz = this.constructor.name;\n  point: IPoint;\n\n  constructor(point: IPoint) {\n    this.point = point;\n  }\n  toStatement(): string {\n    return `POINT(${pointCoordinates(this.point)})`;\n  }\n}\n\nexport class MultiPointValues implements IToStatement {\n  readonly clazz = this.constructor.name;\n  points: IPoint[];\n\n  constructor(points: IPoint[]) {\n    this.points = points;\n  }\n  toStatement(): string {\n    return `MULTIPOINT(${this.points.map((point) => \"(\" + pointCoordinates(point) + \")\").join(\",\")})`;\n  }\n}\n\nexport class LineStringValues implements IToStatement {\n  readonly clazz = this.constructor.name;\n  protected points: IPoint[];\n\n  constructor(points: IPoint[]) {\n    this.points = points;\n  }\n\n  toStatement(): string {\n    return `LINESTRING${LineStringValues.toLineStringArray(this.points)}`;\n  }\n\n  static toLineStringArray(points: IPoint[]) {\n    return `(${points.map((point) => pointCoordinates(point)).join(\", \")})`;\n  }\n}\n\nexport class CircularStringValues extends LineStringValues {\n\n  constructor(points: IPoint[]) {\n    super(points);\n  }\n\n  toStatement(): string {\n    return `CIRCULARSTRING${LineStringValues.toLineStringArray(this.points)}`;\n  }\n}\n\nexport class MultiLineStringValues implements IToStatement {\n  readonly clazz = this.constructor.name;\n  protected lineStrings: IPoint[][];\n\n  constructor(points: IPoint[][]) {\n    this.lineStrings = points;\n  }\n  toStatement(): string {\n    return `MULTILINESTRING(${this.lineStrings.map((lineString) => LineStringValues.toLineStringArray(lineString)).join(\", \")})`;\n  }\n}\n\nexport class PolygonValues extends MultiLineStringValues {\n\n  constructor(points: IPoint[][]) {\n    super(points);\n  }\n\n  toStatement(): string {\n    return `POLYGON${PolygonValues.toPolygonStringArray(this.lineStrings)}`;\n  }\n\n  static toPolygonStringArray(polygon: IPoint[][]) {\n    return `(${polygon.map((lineString) => LineStringValues.toLineStringArray(lineString)).join(\", \")})`;\n  }\n}\n\nexport class MultiPolygonValues implements IToStatement {\n  readonly clazz = this.constructor.name;\n  polygons: IPoint[][][];\n\n  constructor(polygons: IPoint[][][]) {\n    this.polygons = polygons;\n  }\n\n  toStatement(): string {\n    return `MULTIPOLYGON(${this.polygons.map((polygon) => PolygonValues.toPolygonStringArray(polygon)).join(\", \")})`;\n  }\n}\n\n\nexport class GeometryCollectionValues implements IToStatement {\n  readonly clazz = this.constructor.name;\n  geometryCollection: IToStatement[];\n\n  constructor(geometryCollection: IToStatement[]) {\n    this.geometryCollection = geometryCollection;\n  }\n\n  toStatement(): string {\n    return `GEOMETRYCOLLECTION(${this.geometryCollection.map((geometry) => geometry.toStatement()).join(\", \")})`;\n  }\n}\n\n\nexport interface IRangeValue {\n  start: string | number;\n  end: string | number;\n  excludeStart?: boolean;\n  excludeEnd?: boolean;\n}\n\nexport class RangeValues implements IToStatement {\n  readonly clazz = this.constructor.name;\n  start: string | number;\n  end: string | number;\n  excludeStart?: boolean;\n  excludeEnd?: boolean;\n\n  constructor(item: IRangeValue) {\n    this.start = item.start;\n    this.end = item.end;\n    this.excludeStart = item.excludeStart;\n    this.excludeEnd = item.excludeEnd;\n  }\n  toStatement(): string {\n    return `${this.excludeStart ? \"]\" : \"[\"}${escapeQuery(this.start.toString())} ${escapeQuery(this.end.toString())}${this.excludeEnd ? \"[\" : \"]\"}`;\n  }\n}\n\nexport class Comparison implements IToStatement {\n  readonly clazz = this.constructor.name;\n  property: string | IToStatement;\n  operator: (SearchQueryComparisonOperator | ComparisonOperator | NearOperator | SpatialReferenceSystemsOperator | WithinOperator | CoveredByOperator | IntersectsOperator);\n  value?: string | IToStatement;\n  valueAsReservedWord?: boolean;\n  searchOptions?: ISearchOptions;\n\n  constructor(item: IComparison) {\n    this.property = item.property;\n    this.operator = item.operator;\n    this.value = item.value;\n    this.valueAsReservedWord = item.valueAsReservedWord;\n    this.searchOptions = item.searchOptions;\n  }\n\n  public toStatement(): string {\n    let escapeValueCharStart = \"\";\n    let escapeValueCharEnd = \"\";\n    /* \n    if (existValueInEnum(ComparisonOperator, this.operator)) {\n      if (this.valueAsReservedWord) {\n        escapeValueCharStart = \"\";\n        escapeValueCharEnd = \"\";\n      } else {\n        escapeValueCharStart = \"'\";\n        escapeValueCharEnd = \"'\";\n      }\n    } else if (this.operator === SearchQueryComparisonOperator.Fuzzy) {\n      escapeValueCharStart = \"(\";\n      escapeValueCharEnd = \")\";\n    } */\n    let isODataComparison = false;\n    if (existValueInEnum(ComparisonOperator, this.operator)) {\n      isODataComparison = true;\n      if (this.value && ((this.value instanceof NullValue) || (this.value instanceof BooleanValue) || (this.value instanceof NumberValue) || (this.value instanceof ListValues) || (this.value instanceof ViewParameter))) {\n        this.valueAsReservedWord = true;\n      }\n      if (this.valueAsReservedWord) {\n        escapeValueCharStart = \"\";\n        escapeValueCharEnd = \"\";\n      } else {\n        escapeValueCharStart = \"'\";\n        escapeValueCharEnd = \"'\";\n      }\n    }\n    const propertyValues = typeof (this.property) === \"string\" ? this.property : this.property.toStatement();\n    let valueQuery = \"\";\n    if (this.value) {\n      if (typeof (this.value) === \"string\") {\n        if (isODataComparison) {\n          valueQuery = escapeSingleQuote(this.value);\n        } else {\n          valueQuery = escapeQuery(this.value.toString());\n        }\n      } else {\n        valueQuery = this.value.toStatement();\n      }\n      // valueQuery = typeof (this.value) === \"string\" ? escapeQuery(this.value.toString()) : this.value.toStatement();\n    }\n    const comparisonOperator = typeof (this.operator) === \"string\" ? this.operator : this.operator.toStatement();\n    const comparisonStatement = propertyValues + comparisonOperator + escapeValueCharStart + valueQuery + escapeValueCharEnd;\n    return addFuzzySearchOptions(comparisonStatement, this.searchOptions);\n  }\n}\n\nexport class ScopeComparison implements IToStatement {\n  public readonly clazz = this.constructor.name;\n  values: string[];\n\n  constructor(item: IScopeComparison) {\n    this.values = item.values;\n  }\n\n  public toStatement(): string {\n    if (this.values.length === 0) {\n      throw new Error(\"ScopeComparison values cannot be empty\");\n    }\n    return this.values.length > 1 ? `SCOPE:(${this.values.join(\" OR \")})` : `SCOPE:${this.values[0]}`;\n  }\n}\nexport class Term implements IToStatement {\n  public readonly clazz = this.constructor.name;\n  term: string;\n  searchOptions?: ISearchOptions;\n  isQuoted?: boolean;\n  doEshEscaping?: boolean;\n\n  constructor(item: ITerm) {\n    this.term = item.term;\n    this.searchOptions = item.searchOptions;\n    this.isQuoted = item.isQuoted;\n    if (typeof(item.doEshEscaping) != 'undefined' && item.doEshEscaping != null)\n    {\n      this.doEshEscaping = item.doEshEscaping;\n    } else {\n      this.doEshEscaping = true;\n    }\n  }\n\n  public toStatement(): string {\n    let finalTerm;\n    if (this.doEshEscaping) {\n      finalTerm = this.isQuoted ? '\"' + escapePhrase(this.term) + '\"' : escapeQuery(this.term);\n    } else {\n      finalTerm = this.isQuoted ? '\"' + this.term + '\"' : this.term;\n    }\n    return addFuzzySearchOptions(finalTerm, this.searchOptions);\n  }\n}\n\nexport const escapePhrase = (value: string): string => {\n  let returnValue = value.replace(/\\\\/g, '\\\\\\\\');\n  returnValue = returnValue.replace(/\"/g, '\\\\\"');\n  // returnValue = returnValue.replace(/\\*/g, '\\\\*'); // do not escape *\n  returnValue = returnValue.replace(/\\?/g, '\\\\?');\n  returnValue = returnValue.replace(/\\'/g, \"''\");\n  return returnValue;\n}\n\nexport class Phrase implements IToStatement {\n  readonly clazz = this.constructor.name;\n  phrase: string;\n  searchOptions?: ISearchOptions;\n  doEshEscaping?: boolean;\n\n  constructor(item: IPhrase) {\n    this.phrase = item.phrase;\n    this.searchOptions = item.searchOptions;\n    if (typeof(item.doEshEscaping) != 'undefined' && item.doEshEscaping != null)\n    {\n      this.doEshEscaping = item.doEshEscaping;\n    } else {\n      this.doEshEscaping = true;\n    }\n  }\n\n  public toStatement(): string {\n    let finalPhrase;\n    if (this.doEshEscaping) {\n      finalPhrase = escapePhrase(this.phrase);\n    } else {\n      finalPhrase = this.phrase;\n    }\n    // return addFuzzySearchOptions(\"\\\"\" + replaceAll(this.phrase, '\"', '\\\\\"') + \"\\\"\", this.searchOptions);\n    // return addFuzzySearchOptions(\"\\\"\" + this.phrase.replace(/\"/g, '\\\\\"') + \"\\\"\", this.searchOptions);\n    // return addFuzzySearchOptions(\"\\\"\" + escapePhrase(this.phrase) + \"\\\"\", this.searchOptions);\n    return addFuzzySearchOptions(\"\\\"\" + finalPhrase + \"\\\"\", this.searchOptions);\n  }\n}\n\n\nexport class Near implements IToStatement {\n  readonly clazz = this.constructor.name;\n  terms: string[] | IToStatement[];\n  distance: number;\n  ordering?: NearOrdering;\n  searchOptions?: ISearchOptions;\n\n  constructor(item: INear) {\n    this.terms = item.terms;\n    this.distance = item.distance;\n    this.ordering = item.ordering;\n    this.searchOptions = item.searchOptions;\n  }\n\n  public toStatement(): string {\n    const values: string[] = [];\n    this.terms.forEach((value: string | IToStatement) => {\n      values.push(typeof value === \"string\" ? value : value.toStatement())\n    })\n    const nearStatement = `NEAR(${this.distance}${this.ordering ? \",\" + this.ordering : \"\"}):(${values.join(\" \")})`;\n    return addFuzzySearchOptions(nearStatement, this.searchOptions);\n  }\n}\n\nexport interface IProperty {\n  property: string;\n  prefixOperator?: SearchQueryPrefixOperator;\n}\nexport class Property implements IToStatement {\n  readonly clazz = this.constructor.name;\n  property: string;\n  prefixOperator?: SearchQueryPrefixOperator;\n  // searchOptions: ISearchOptions\n\n  constructor(item: IProperty) {\n    this.property = item.property;\n    this.prefixOperator = item.prefixOperator;\n  }\n\n  public toStatement(): string {\n    if (this.prefixOperator) {\n      return this.prefixOperator + \" \" + this.property;\n    }\n    return this.property;\n  }\n}\n\n\nexport enum LogicalOperator {\n  and = \"and\",\n  or = \"or\",\n  not = \"not\"\n}\n\nexport enum SearchQueryLogicalOperator {\n  AND = \"AND\",\n  TIGHT_AND = \"\",\n  OR = \"OR\",\n  NOT = \"NOT\",\n  ROW = \"ROW\",\n  AUTH = \"AUTH\",\n  FILTER = \"FILTER\",\n  FILTERWF = \"FILTERWF\",\n  BOOST = \"BOOST\",\n}\n\nexport enum SearchQueryPrefixOperator {\n  AND = \"AND\",\n  OR = \"OR\",\n  NOT = \"NOT\",\n  AND_NOT = \"AND NOT\",\n  OR_NOT = \"OR NOT\",\n}\nexport interface IExpression {\n  operator?: (LogicalOperator | SearchQueryLogicalOperator);\n  items: IToStatement[];\n  searchOptions?: ISearchOptions;\n}\n\nfunction addFuzzySearchOptions(item: string, searchOptions?: ISearchOptions): string {\n  let returnStatement = item;\n  if (searchOptions) {\n    if (searchOptions.fuzzinessThreshold) {\n      returnStatement = returnStatement + \"~\" + searchOptions.fuzzinessThreshold.toString();\n    }\n    if (searchOptions.fuzzySearchOptions) {\n      if (!searchOptions.fuzzinessThreshold) {\n        returnStatement = returnStatement + \"~0.8\";//default fuzzinessThreshold\n      }\n      returnStatement = returnStatement + \"[\" + searchOptions.fuzzySearchOptions + \"]\";\n    }\n    if (searchOptions.weight !== undefined) {\n      returnStatement = `${returnStatement}^${searchOptions.weight}`;\n    }\n  }\n  return returnStatement;\n\n}\n\nexport class Expression implements IToStatement {\n  public readonly clazz = this.constructor.name;\n  operator?: (LogicalOperator | SearchQueryLogicalOperator);\n  items: IToStatement[];\n  searchOptions?: ISearchOptions;\n\n  constructor(item: IExpression) {\n    this.operator = item.operator;\n    this.items = item.items;\n    this.searchOptions = item.searchOptions;\n  }\n\n  toStatement(): string {\n    let returnStatement = \"\";\n    switch (this.operator) {\n      case SearchQueryLogicalOperator.ROW:\n      case SearchQueryLogicalOperator.AUTH:\n      case SearchQueryLogicalOperator.FILTER:\n      case SearchQueryLogicalOperator.FILTERWF:\n      case SearchQueryLogicalOperator.BOOST:\n        let operatorValue = this.items.map(i => i.toStatement()).join(\" \" + this.operator + \" \");\n        if (!operatorValue.startsWith(\"(\")) {\n          operatorValue = \"(\" + operatorValue + \")\";\n        }\n        returnStatement = this.operator + \":\" + operatorValue;\n        break;\n      case SearchQueryLogicalOperator.NOT:\n        if (this.items.length > 1) {\n          throw new Error(\"Invalid operator. NOT operator is allowed only on a single item.\");\n        }\n        returnStatement = \"(NOT \" + this.items[0].toStatement() + \")\";\n        break;\n      case LogicalOperator.not:\n        if (this.items.length > 1) {\n          throw new Error(\"Invalid operator. 'not' operator is allowed only on a single item.\");\n        }\n        returnStatement = \"not \" + this.items[0].toStatement();\n        break;\n      default:\n        if (!this.items || this.items.length == 0) {\n          return \"\"; \n        } else if (this.items.length > 1) {\n          const itemsScopes = this.items.filter(i => { return (i instanceof ScopeComparison) });\n          if (itemsScopes.length > 0) {\n            returnStatement = this.items.map(i => i.toStatement()).join(`${this.operator === \"\" ? \" \" : \" \" + this.operator + \" \"}`);\n          } else {\n            returnStatement = \"(\" + this.items.map(i => i.toStatement()).join(`${this.operator === \"\" ? \" \" : \" \" + this.operator + \" \"}`) + \")\";\n          }\n        } else {\n          returnStatement = this.items[0].toStatement();\n        }\n        break;\n    }\n    return addFuzzySearchOptions(returnStatement, this.searchOptions);\n  }\n}\n\nexport enum SearchQueryComparisonOperator {\n  // eslint-disable-next-line no-shadow\n  Search = \":\",\n  EqualCaseInsensitive = \":EQ:\",\n  NotEqualCaseInsensitive = \":NE:\",\n  LessThanCaseInsensitive = \":LT:\",\n  LessThanOrEqualCaseInsensitive = \":LE:\",\n  GreaterThanCaseInsensitive = \":GT:\",\n  GreaterThanOrEqualCaseInsensitive = \":GE:\",\n  EqualCaseSensitive = \":EQ(S):\",\n  NotEqualCaseSensitive = \":NE(S):\",\n  LessThanCaseSensitive = \":LT(S):\",\n  LessThanOrEqualCaseSensitive = \":LE(S):\",\n  GreaterThanCaseSensitive = \":GT(S):\",\n  GreaterThanOrEqualCaseSensitive = \":GE(S):\",\n  IsNull = \":IS:NULL\",\n  BetweenCaseInsensitive = \":BT:\",\n  BetweenCaseSensitive = \":BT(S):\",\n  DescendantOf = \":DESCENDANT_OF:\",\n  ChildOf = \":CHILD_OF:\",\n}\n\nexport enum ComparisonOperator {\n  Equal = \" eq \",\n  NotEqual = \" ne \",\n  GreaterThan = \" gt \",\n  LessThan = \" lt \",\n  GreaterThanOrEqualTo = \" ge \",\n  LessThanOrEqualTo = \" le \",\n  Is = \" is \",\n  In = \" in \",\n  IsNot = \" is not \"\n}\n\nexport enum ESOrderType {\n  Ascending = \"ASC\",\n  Descending = \"DESC\",\n}\n\nexport interface IESOrdering {\n  key: string;\n  order?: ESOrderType;\n}\n\nexport interface IESSearchOptions {\n  $top?: number;\n  $skip?: number;\n  $orderby?: IESOrdering[];\n  query?: string;\n  /**\n   * This filter is used only for special search features like fuzzy,... For basic filtering please use 'oDataFilter' property\n  */\n  searchQueryFilter?: Expression;\n  /**\n   * This filter is used only for basic filtering. Please use 'searchQueryFilter' property for special search features like fuzzy,..\n  */\n  oDataFilter?: Expression;\n  whyfound?: boolean;\n  scope?: string;\n  $select?: string[];\n  $count?: boolean;\n  facets?: string[];\n  groupby?: IGroupBy;\n  estimate?: boolean;\n  facetlimit?: number;\n  wherefound?: boolean;\n  suggestTerm?: string;\n  metadataCall?: boolean;\n  metadataObjects?: IMetadataObjects;\n  resourcePath?: string;\n  $apply?: string | FilterFunction | CustomFunction;\n  filteredgroupby?: boolean;\n  facetroot?: HierarchyFacet[];\n  eshParameters?: {\n    [key: string]: string\n  },\n  dynamicview?: DynamicView[],\n  freeStyleText?: string;\n  valuehierarchy?: string;\n}\n\nexport interface IMetadataObjects{\n  format?: string;\n  collectionReference?: string;\n  entitySets?: string;\n  contextEntitySet?: string;\n  primitiveTyp?: string;\n}\n\nexport const SEARCH_DEFAULTS = {\n  query: \"\",\n  scope: \"\",\n};\n\nexport interface IEsearchRequestInterface {\n  path: string;\n  parameters: any;\n}\n\nexport interface IAlias {\n  type: string,\n  alias: string,\n}\n\nexport interface IPropertyAlias {\n  path: string[],\n  alias: string,\n}\n\nexport class PropertyAlias implements IPropertyAlias, IToStatement {\n  readonly clazz = this.constructor.name;\n  path: string[];\n  alias: string;\n\n  constructor(item: IPropertyAlias) {\n    this.path = item.path;\n    this.alias = item.alias;\n  }\n\n  toStatement(): string {\n    return `${this.path.join(\".\")} ${this.alias}`;\n    // return `${this.path.map((item)=> \"\\\"\" + escapeDoubleQuoteAndBackslash(item) + \"\\\"\").join(\".\")} ${this.alias}`;\n  }\n}\nexport class Alias implements IAlias, IToStatement {\n  readonly clazz = this.constructor.name;\n  type: string;\n  alias: string;\n\n  constructor(item: IAlias) {\n    this.type = item.type;\n    this.alias = item.alias;\n  }\n\n  toStatement(): string {\n    return `${this.type} ${this.alias}`;\n    // return `\"${escapeDoubleQuoteAndBackslash(this.type)}\" ${this.alias}`;\n  }\n}\n\nexport interface IDynamicView {\n  name: string;\n  select: string[];\n  aliases?: Alias[];\n  properties: PropertyAlias[];\n  paths: (string | string[])[][];\n  conditions?: (Comparison | Expression)[];\n}\n\nexport class DynamicView implements IDynamicView, IToStatement {\n  readonly clazz = this.constructor.name;\n  name: string;\n  select: string[];\n  aliases?: Alias[];\n  properties: PropertyAlias[];\n  paths: (string | string[])[][];\n  conditions?: (Comparison | Expression)[];\n\n  constructor(item: IDynamicView) {\n    this.name = item.name;\n    this.select = item.select;\n    this.aliases = item.aliases;\n    this.properties = item.properties;\n    this.paths = item.paths;\n    this.conditions = item.conditions;\n  }\n  \n\n  toStatement(): string {\n    let returnValue: {[key: string]: string} = {\n      name: this.name,\n      select: this.select.join(\", \"),\n    };\n    let listOfAliases: string[] = [];\n    if (this.aliases) {\n      returnValue.aliases = this.aliases.map((alias) => {return alias.toStatement()}).join(\", \");\n      listOfAliases = this.aliases.map((item) => item.alias);\n    }\n    returnValue.properties = this.properties.map((property) => {return property.toStatement()}).join(\", \");\n    returnValue.paths = this.paths.map((paths) => {return paths.map((path) => { return (typeof(path) === 'string') ? path : path.join(\".\")} ).join('/')}).join(\", \")\n    if (this.conditions) {\n      returnValue.conditions = this.conditions.map((condition) => {Â return condition.toStatement();}).join(\", \")\n    }\n    return Object.keys(returnValue).map(key => {return `${key}: ${returnValue[key]}`}).join(\"; \")+\";\";\n  }\n}\n\nexport interface ICustomFunction {\n  name: string | string[];\n  arguments?: {\n    [key: string]: any\n  }\n}\nexport class CustomFunction implements ICustomFunction, IToStatement {\n  readonly clazz = this.constructor.name;\n  name: string | string[];\n  arguments?: {\n    [key: string]: any\n  }\n\n  constructor(item: ICustomFunction) {\n    this.name = item.name;\n    this.arguments = item.arguments;\n  }\n\n  toStatement(): string {\n    let argumentsValue = '';\n    if (this.arguments) {\n      argumentsValue = Object.keys(this.arguments).map((key) => {\n        let singleArgumentValue = `${key}=`;\n        if (this.arguments && typeof(this.arguments[key]) === 'string') {\n          singleArgumentValue = `'${escapeSingleQuote(this.arguments[key])}'`;\n        } else if (this.arguments && this.arguments[key] && typeof(this.arguments[key]) === 'object') {\n          if (typeof(this.arguments[key].toStatement) === \"function\") { \n            if (this.arguments[key] instanceof CustomFunction || this.arguments[key] instanceof FilterFunction) {\n              singleArgumentValue = this.arguments[key].toStatement();\n            } else {\n              if(this.arguments[key] instanceof NumberValue) {\n                singleArgumentValue =  this.arguments[key].toStatement();\n              } else {\n                singleArgumentValue = `'${this.arguments[key].toStatement()}'`;\n              }\n            }\n          } else if (Array.isArray(this.arguments[key])) {\n            singleArgumentValue = \"[\" + this.arguments[key].map((element: any) => {\n              if(element instanceof NumberValue) {\n                return element.toStatement();\n              } else if(typeof(element) === 'string') {\n                return `'${escapeSingleQuote(element)}'`;\n              } else {\n                return String(element)\n              }\n            }).join(\",\") + \"]\";\n          } else {\n            throw new Error(\"Unexpected object: \" + this.arguments[key])\n          }\n        }\n        else {\n          singleArgumentValue = String(this.arguments ? String(this.arguments[key]) : '');\n        }\n        \n        return `${key}=${singleArgumentValue}`\n      }).join(\",\")\n    }\n    return `${typeof(this.name) === \"string\" ? this.name : this.name.join(\".\")}(${argumentsValue})`;\n  }\n}\n\nexport interface IFilterFunction {\n  customFunction: CustomFunction | Expression;\n  oDataFilter?: Expression | Comparison;\n}\nexport class FilterFunction implements IFilterFunction, IToStatement {\n  readonly clazz = this.constructor.name;\n  customFunction: CustomFunction | Expression;\n  oDataFilter?: Expression | Comparison;\n\n  constructor(item: IFilterFunction) {\n    this.customFunction = item.customFunction;\n    this.oDataFilter = item.oDataFilter;\n  }\n  \n  toStatement(): string {\n    let returnStatement ;\n    if (this.customFunction instanceof Expression) {\n      let expressionStatement = `Search.search(query='${this.customFunction.toStatement()}')`;\n      if (this.oDataFilter) {\n        expressionStatement += ` and ${this.oDataFilter.toStatement()}`\n      }\n      returnStatement = `filter(${expressionStatement})`;\n    } else {\n      returnStatement = `filter(${this.customFunction.toStatement()}`;\n      if (this.oDataFilter) {\n        returnStatement += ` and ${this.oDataFilter.toStatement()}`\n      }\n      returnStatement += \")\";\n    }\n    return returnStatement;\n  }\n}\n\n\n\nexport const deserialize = (jsonO: any): any => {\n  //const jsonO = JSON.parse(jsonStr);\n  if (typeof jsonO === \"object\") {\n    switch (jsonO.clazz) {\n      case \"Property\":\n        return new Property(jsonO);\n      case \"Near\":\n        jsonO.terms = jsonO.terms.map((item: string | IToStatement) => deserialize(item));\n        return new Near(jsonO);\n      case \"Phrase\":\n        return new Phrase(jsonO);\n      case \"RangeValues\":\n        return new RangeValues(jsonO);\n      case \"GeometryCollectionValues\":\n        return new GeometryCollectionValues(jsonO.geometryCollection.map((item: any) => deserialize(item)));\n      case \"MultiPolygonValues\":\n        return new MultiPolygonValues(jsonO.polygons);\n      case \"MultiLineStringValues\":\n        return new MultiLineStringValues(jsonO.lineStrings);\n      case \"CircularStringValues\":\n        return new CircularStringValues(jsonO.points)\n      case \"LineStringValues\":\n        return new LineStringValues(jsonO.points);\n      case \"MultiPointValues\":\n        return new MultiPointValues(jsonO.points);\n      case \"PointValues\":\n        return new PointValues(jsonO.point);\n      case \"SpatialReferenceSystemsOperator\":\n        return new SpatialReferenceSystemsOperator(jsonO);\n      case \"SpatialReferenceSystemsOperatorBase\":\n        return new SpatialReferenceSystemsOperatorBase(jsonO);\n      case \"InList\":\n        return new InList(jsonO);\n      case \"NearOperator\":\n        return new NearOperator(jsonO);\n      case \"Term\":\n        return new Term(jsonO);\n      case \"HierarchyFacet\":\n        return new HierarchyFacet(jsonO);\n      case \"Comparison\":\n        const deserializedComparison = new Comparison(jsonO);\n        if (typeof deserializedComparison.property === \"object\") {\n          deserializedComparison.property = deserialize(deserializedComparison.property);\n        }\n        if (deserializedComparison.operator && typeof deserializedComparison.operator === \"object\") {\n          deserializedComparison.operator = deserialize(deserializedComparison.operator);\n        }\n        if (deserializedComparison.value && typeof deserializedComparison.value === \"object\") {\n          deserializedComparison.value = deserialize(deserializedComparison.value);\n        }\n        return deserializedComparison;\n      case \"ScopeComparison\":\n        return new ScopeComparison(jsonO);\n      case \"WithinOperator\":\n        return new WithinOperator(jsonO);\n      case \"PolygonValues\":\n        return new PolygonValues(jsonO.lineStrings);\n      case \"CoveredByOperator\":\n        return new CoveredByOperator(jsonO);\n      case \"IntersectsOperator\":\n        return new IntersectsOperator(jsonO);\n      case \"Expression\":\n        const returnExpression = new Expression(jsonO);\n        returnExpression.items = returnExpression.items.map((item) => deserialize(item));\n        return returnExpression;\n      case \"DynamicView\":\n        const returnDynamicView = new DynamicView(jsonO);\n        returnDynamicView.properties = returnDynamicView.properties.map((property) => deserialize(property));\n        if (returnDynamicView.aliases) {\n          returnDynamicView.aliases = returnDynamicView.aliases.map((alias) => deserialize(alias));\n        }\n        if (returnDynamicView.conditions) {\n          if (Array.isArray(returnDynamicView.conditions)) {\n            returnDynamicView.conditions = returnDynamicView.conditions.map((condition) => deserialize(condition));\n          } else {\n            returnDynamicView.conditions = deserialize(returnDynamicView.conditions);\n          }\n        }\n        return returnDynamicView;\n      case \"Alias\":\n        return new Alias(jsonO);\n      case \"PropertyAlias\":\n        return new PropertyAlias(jsonO);\n      case \"ListValues\":\n        const returnValue = new ListValues(jsonO)\n        returnValue.values = returnValue.values.map(element => deserialize(element));\n        return returnValue;\n      case \"ViewParameter\":\n        return new ViewParameter(jsonO);\n      case \"NullValue\":\n        return new NullValue();\n      case \"BooleanValue\":\n        return new BooleanValue(jsonO);\n      case \"NumberValue\":\n        return new NumberValue(jsonO);\n      case \"StringValue\":\n        return new StringValue(jsonO);\n      case \"CustomFunction\":\n          const returnCustomFunction: ICustomFunction = new CustomFunction(jsonO);\n          if (returnCustomFunction.arguments) {\n            Object.keys(returnCustomFunction.arguments).map((key) => {\n              if (returnCustomFunction.arguments && typeof(returnCustomFunction.arguments[key]) === 'object' && typeof(returnCustomFunction.arguments[key].clazz) === \"string\") {\n                if([\"CustomFunction\",\"FilterFunction\"].includes(returnCustomFunction.arguments[key].clazz)) {\n                  returnCustomFunction.arguments[key] = deserialize(returnCustomFunction.arguments[key])  \n                } else {\n                  throw new Error(`Invalid statement in: ${key} = ${returnCustomFunction.arguments[key]}`)\n                }\n              }\n            })\n          }\n          return returnCustomFunction;\n        case \"FilterFunction\":\n            const returnFilterFunction: IFilterFunction = new FilterFunction(jsonO);\n            returnFilterFunction.customFunction = deserialize(returnFilterFunction.customFunction);\n            if (returnFilterFunction.oDataFilter) {\n              returnFilterFunction.oDataFilter = deserialize(returnFilterFunction.oDataFilter)\n            }\n            return returnFilterFunction;\n        default:\n          throw new Error(\"not implemented: \" + JSON.stringify(jsonO));\n    }\n  }\n  return jsonO;\n}"],"mappings":"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","ignoreList":[]}