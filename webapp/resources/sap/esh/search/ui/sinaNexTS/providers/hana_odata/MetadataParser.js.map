{"version":3,"file":"MetadataParser.js","names":["sap","ui","define","____core_Log","____sina_AttributeType","____sina_AttributeFormatType","____sina_MatchingStrategy","____core_errors","____sina_i18n","Log","AttributeType","AttributeFormatType","MatchingStrategy","UnknownAttributeTypeError","UnknownPresentationUsageError","getText","AccessUsageConversionMap","PresentationUsageConversionMap","MetadataParser","log","provider","presentationUsageConversionMap","accessUsageConversionMap","sina","constructor","this","_setAnnotationValue","annotations","annotationName","value","annotationParts","split","annotationPart","annotationPointer","dummyEntryName","i","length","undefined","Array","isArray","push","concat","propName","fillMetadataBuffer","dataSource","attributes","attributesMetadata","id","attributeMetadataMap","cdsAnnotations","dataSourceAnnotations","attributeAnnotations","attributeMetadata","attributeMap","fillPublicMetadataBuffer","e","error","label","toString","parser","_createCDSAnnotationsParser","parseCDSAnnotationsForDataSource","displayOrderIndex","displayOrder","labelRaw","annotationsAttr","typeAndFormat","_parseAttributeTypeAndFormat","type","publicAttributeMetadata","_createAttributeMetadata","isKey","isSortable","usage","_parseUsage","format","matchingStrategy","_parseMatchingStrategy","isHierarchy","hierarchyDefinition","hierarchyName","name","hierarchyDisplayType","displayType","isHierarchyDefinition","isHierarchyDataSource","hierarchyAttribute","attributeName","_private","semanticObjectType","SemanticObjectTypeId","supportsTextSearch","Text","Exact","attributeId","presentationUsage","toUpperCase","ImageUrl","String","LongText","SEMANTICS","CONTACT","PHOTO","IMAGEURL","ImageBlob","Double","Integer","Time","Date","Timestamp","GeoJson","startsWith","warn","Title","Detail","isFacet","AdvancedSearch","facetPosition","iconUrlAttributeName","facetIconUrlAttributeName","Facet","isFilteringAttribute","parseDynamicMetadata","searchResult","metadata","dataSourceId","dataSourceMetadata","dynamicAttributeMetadata","parseDynamicAttributeMetadata","getDataSource","$Type","getAttributeMetadata","dynamic","getUniqueDataSourceFromSearchResult","data","items","prevDataSourceId","item","context","__exports","__esModule"],"sources":["MetadataParser.ts"],"sourcesContent":["/*!\n * SAPUI5\n * Copyright (c) 2025 SAP SE or an SAP affiliate company. All rights reserved.\n * \n */\nimport { Log } from \"../../core/Log\";\nimport { AjaxClient as Client } from \"../../core/AjaxClient\";\nimport { HANAOdataMetadataResponse, Provider } from \"./Provider\";\nimport { AttributeType } from \"../../sina/AttributeType\";\nimport { AttributeFormatType } from \"../../sina/AttributeFormatType\";\nimport { MatchingStrategy } from \"../../sina/MatchingStrategy\";\nimport { Sina } from \"../../sina/Sina\";\nimport { UnknownAttributeTypeError, UnknownPresentationUsageError } from \"../../core/errors\";\nimport { DataSource } from \"../../sina/DataSource\";\nimport { HANAOdataSearchResponseResult } from \"./Provider\";\nimport { AttributeUsageType } from \"../../sina/AttributeUsageType\";\nimport { AttributeMetadata } from \"../../sina/AttributeMetadata\";\nimport { HierarchyDefinition } from \"./HierarchyMetadataParser\";\nimport { getText } from \"../../sina/i18n\";\n\nenum AccessUsageConversionMap {\n    \"AUTO_FACET\",\n    \"SUGGESTION\",\n}\n\nenum PresentationUsageConversionMap {\n    \"TITLE\",\n    \"SUMMARY\",\n    \"DETAIL\",\n    \"IMAGE\",\n    \"THUMBNAIL\",\n    \"HIDDEN\",\n}\n\nexport interface Attribute {\n    isFilteringAttribute: boolean;\n    labelRaw: string;\n    label: string;\n    type: string;\n    presentationUsage: string[];\n    // accessUsage: [],\n    isFacet: boolean;\n    facetPosition: number;\n    facetIconUrlAttributeName: string;\n    isSortable: boolean;\n    supportsTextSearch: boolean;\n    displayOrder: number;\n    annotationsAttr: any;\n    unknownAnnotation: unknown[];\n    hierarchyDefinition: Map<string, HierarchyDefinition>;\n    isKey: boolean;\n}\n\nexport interface EntitySet {\n    schema: string;\n    keys: string[];\n    attributeMap: Map<string, Attribute>;\n    resourceBundle?: string; // url pointing to resource bundle\n    labelResourceBundle?: string;\n    label: string;\n    labelPlural: string;\n    annotations: Record<string, object>;\n    hierarchyDefinitionsMap: object;\n    icon: string;\n    name: string;\n    dataSource: DataSource;\n}\n\nexport interface ServerMetadataMap {\n    businessObjectMap: Map<string, unknown>; // entity map with attributes and datasource id as key\n    businessObjectList: unknown[]; // list of all entities for convenience\n    dataSourceMap: Map<string, DataSource>; // datasource map with entityset name as key\n    dataSourcesList: DataSource[]; // list of all datasources for convenience\n}\n\nexport abstract class MetadataParser {\n    log: Log;\n    provider: Provider;\n    presentationUsageConversionMap: PresentationUsageConversionMap;\n    accessUsageConversionMap: AccessUsageConversionMap;\n    sina: Sina;\n\n    constructor(provider: Provider) {\n        this.log = new Log(\"hana_odata metadata parser\");\n        this.provider = provider;\n        this.sina = provider.sina;\n    }\n\n    abstract fireRequest(client: Client, url: string): Promise<unknown>;\n    abstract parseResponse(metaXML: unknown): Promise<ServerMetadataMap>;\n\n    // annotations: Object to store parsed annotations as properties\n    // annotationName: Name of annotation in Dot Notation: UI.IDENTIFICATION.POSITION\n    // value: can be a single value, like a string, or an array of objects, like UI.IDENTIFICATION = [ { POSITION: 5 }, { POSITION: 6, TYPE:AS_CONNECTED_FIELD, VALUEQUALIFIER:'somegroup' } ]\n    protected _setAnnotationValue(annotations: object, annotationName: string, value): void {\n        const annotationParts = annotationName.split(\".\");\n        let annotationPart;\n        let annotationPointer = annotations;\n        const dummyEntryName = \"___temporaryDummyEntriesForArrays___\";\n        let i;\n\n        // Step 01: create object structure for annoation\n        for (i = 0; i < annotationParts.length - 1; i++) {\n            annotationPart = annotationParts[i];\n            if (annotationPointer[annotationPart] === undefined) {\n                annotationPointer[annotationPart] = {};\n                annotationPointer = annotationPointer[annotationPart];\n            } else if (Array.isArray(annotationPointer[annotationPart])) {\n                // at this level an array was created for a previous annotation with the same name\n                // thus we need to create a dummy entry in that array for merging the current\n                // annotation into the array structure\n                annotationPointer[dummyEntryName] = annotationPointer[dummyEntryName] || {};\n                if (!annotationPointer[dummyEntryName][annotationPart]) {\n                    annotationPointer[dummyEntryName][annotationPart] = {};\n                    annotationPointer[annotationPart].push(annotationPointer[dummyEntryName][annotationPart]);\n                }\n                annotationPointer = annotationPointer[dummyEntryName][annotationPart];\n            } else if (typeof annotationPointer[annotationPart] === \"object\") {\n                annotationPointer = annotationPointer[annotationPart];\n            } else if (typeof annotationPointer[annotationPart] === \"boolean\") {\n                // for handling something like this:\n                //      @Semantics.URL: true\n                //      @Semantics.URL.mimeType: \"anotherAttribute\"\n                // if @Semantics.URL.mimeType is set, than @Semantics.URL is implicitely assumed to be 'true'\n                annotationPointer[annotationPart] = {};\n                annotationPointer = annotationPointer[annotationPart];\n            } else {\n                // should never happen!\n                return;\n            }\n        }\n\n        // Step 02: set value for annotation.\n        if (i < annotationParts.length) {\n            annotationPart = annotationParts[i];\n            if (annotationPointer[annotationPart] === undefined) {\n                // value can be simple value, like string, or array\n                annotationPointer[annotationPart] = value;\n            } else if (Array.isArray(annotationPointer[annotationPart])) {\n                // existing value could be an array, in which case the new value needs to be mixed in\n                if (Array.isArray(value)) {\n                    // new value is an array, which can be appended to the existing array value\n                    annotationPointer[annotationPart] = annotationPointer[annotationPart].concat(value);\n                } else {\n                    // new value is a simple value. In this case create a dummy entry in the existing array\n                    // (or use the dummy entry which had been created before) and add the new value to that entry.\n                    annotationPointer[dummyEntryName] = annotationPointer[dummyEntryName] || {};\n                    if (!annotationPointer[dummyEntryName][annotationPart]) {\n                        annotationPointer[dummyEntryName][annotationPart] = value;\n                        annotationPointer[annotationPart].push(\n                            annotationPointer[dummyEntryName][annotationPart]\n                        );\n                    } else {\n                        for (const propName in value) {\n                            if (!annotationPointer[dummyEntryName][annotationPart][propName]) {\n                                annotationPointer[dummyEntryName][annotationPart][propName] = value[propName];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public fillMetadataBuffer(dataSource: DataSource, attributes: EntitySet): void {\n        if (dataSource.attributesMetadata[0].id !== \"dummy\") {\n            // check if buffer already filled\n            return;\n        }\n        dataSource.attributesMetadata = [];\n        dataSource.attributeMetadataMap = {};\n\n        const cdsAnnotations = {\n            dataSourceAnnotations: {}, // Key-Value-Map for CDS annotations\n            attributeAnnotations: {}, // Key-Value-Map (keys: attribute names) of Key-Value-Maps (keys: annotation names) for CDS annotations\n        };\n\n        cdsAnnotations.dataSourceAnnotations = dataSource.annotations;\n\n        for (const attributeMetadata in attributes.attributeMap) {\n            try {\n                this.fillPublicMetadataBuffer(\n                    dataSource,\n                    attributes.attributeMap[attributeMetadata],\n                    cdsAnnotations\n                );\n            } catch (e) {\n                // not allowed by linter:\n                this.log.error(\n                    \"Attribue \" +\n                        attributeMetadata +\n                        \" of DataSource \" +\n                        dataSource.label +\n                        \" can not be filled in meta data\" +\n                        e.toString()\n                );\n            }\n        }\n\n        const parser = this.sina._createCDSAnnotationsParser({\n            dataSource: dataSource,\n            cdsAnnotations: cdsAnnotations,\n        });\n        parser.parseCDSAnnotationsForDataSource();\n    }\n\n    public fillPublicMetadataBuffer(\n        dataSource: DataSource,\n        attributeMetadata: HANAOdataMetadataResponse,\n        cdsAnnotations\n    ) {\n        const displayOrderIndex = attributeMetadata.displayOrder;\n\n        // Prepare annotations for being passed over to the CDS annotations parser\n        const attributeAnnotations = (cdsAnnotations.attributeAnnotations[attributeMetadata.labelRaw] = {});\n\n        for (const propName in attributeMetadata.annotationsAttr) {\n            attributeAnnotations[propName] = attributeMetadata.annotationsAttr[propName];\n        }\n\n        const typeAndFormat = this._parseAttributeTypeAndFormat(\n            attributeMetadata,\n            dataSource,\n            attributeMetadata.labelRaw\n        );\n\n        if (typeAndFormat && typeAndFormat.type) {\n            const publicAttributeMetadata = this.sina._createAttributeMetadata({\n                id: attributeMetadata.labelRaw,\n                label: attributeMetadata.label || attributeMetadata.labelRaw,\n                isKey: attributeMetadata.isKey || false,\n                isSortable: attributeMetadata.isSortable,\n                usage: this._parseUsage(attributeMetadata, displayOrderIndex) || {},\n                type: typeAndFormat.type,\n                format: typeAndFormat.format,\n                matchingStrategy: this._parseMatchingStrategy(attributeMetadata),\n                isHierarchy: !!attributeMetadata.hierarchyDefinition,\n                hierarchyName: attributeMetadata?.hierarchyDefinition?.name,\n                hierarchyDisplayType: attributeMetadata?.hierarchyDefinition?.displayType,\n            });\n\n            // move flag isHierarchyDefinition from attribute to datasource\n            if (\n                attributeMetadata.hierarchyDefinition &&\n                attributeMetadata.hierarchyDefinition?.isHierarchyDefinition\n            ) {\n                dataSource.isHierarchyDataSource = true;\n                dataSource.hierarchyName = attributeMetadata.hierarchyDefinition?.name;\n                dataSource.hierarchyAttribute = attributeMetadata.hierarchyDefinition?.attributeName;\n                dataSource.hierarchyDisplayType = attributeMetadata.hierarchyDefinition?.displayType;\n            }\n            publicAttributeMetadata._private.semanticObjectType = attributeMetadata.SemanticObjectTypeId;\n\n            dataSource.attributesMetadata.push(publicAttributeMetadata);\n            dataSource.attributeMetadataMap[publicAttributeMetadata.id] = publicAttributeMetadata;\n        }\n    }\n\n    private _parseMatchingStrategy(attributeMetadata: HANAOdataMetadataResponse): MatchingStrategy {\n        if (attributeMetadata.supportsTextSearch === true) {\n            return MatchingStrategy.Text;\n        }\n        return MatchingStrategy.Exact;\n    }\n\n    private _parseAttributeTypeAndFormat(\n        attributeMetadata: Partial<HANAOdataMetadataResponse>, // server side attribute metadata\n        dataSource: DataSource,\n        attributeId: string\n    ): {\n        type: AttributeType;\n        format?: AttributeFormatType;\n    } {\n        for (let i = 0; i < attributeMetadata.presentationUsage.length; i++) {\n            const presentationUsage = attributeMetadata.presentationUsage[i] || \"\";\n            switch (presentationUsage.toUpperCase()) {\n                case \"SUMMARY\":\n                    continue;\n                case \"DETAIL\":\n                    continue;\n                case \"TITLE\":\n                    continue;\n                case \"HIDDEN\":\n                    continue;\n                case \"FACTSHEET\":\n                    continue;\n                case \"THUMBNAIL\":\n                case \"IMAGE\":\n                    return {\n                        type: AttributeType.ImageUrl,\n                    };\n                case \"LONGTEXT\":\n                    return {\n                        type: AttributeType.String,\n                        format: AttributeFormatType.LongText,\n                    };\n                default:\n                    throw new UnknownPresentationUsageError(presentationUsage);\n            }\n        }\n\n        switch (attributeMetadata.type) {\n            case \"Edm.Binary\":\n                if (attributeMetadata.annotationsAttr) {\n                    if (\n                        (attributeMetadata.annotationsAttr.SEMANTICS &&\n                            attributeMetadata.annotationsAttr.SEMANTICS.CONTACT &&\n                            attributeMetadata.annotationsAttr.SEMANTICS.CONTACT.PHOTO) ||\n                        (attributeMetadata.annotationsAttr.SEMANTICS &&\n                            attributeMetadata.annotationsAttr.SEMANTICS.IMAGEURL)\n                    ) {\n                        return {\n                            type: AttributeType.ImageBlob,\n                        };\n                    }\n                }\n                return {\n                    type: AttributeType.String,\n                };\n                break;\n            case \"Edm.String\":\n            case \"Edm.PrimitiveType\":\n            case \"Edm.Boolean\":\n            case \"Edm.Byte\":\n            case \"Edm.Guid\":\n                return {\n                    type: AttributeType.String,\n                };\n            case \"Edm.Double\":\n            case \"Edm.Decimal\":\n            case \"Edm.Float\":\n            case \"Edm.Single\":\n            case \"Edm.SingleRange\":\n                return {\n                    type: AttributeType.Double,\n                };\n            case \"Edm.Int16\":\n            case \"Edm.Int32\":\n            case \"Edm.Int64\":\n                return {\n                    type: AttributeType.Integer,\n                };\n            // case \"Edm.Time\": // HANA 1.0 types not supported anymore\n            case \"Edm.TimeOfDay\":\n                return {\n                    type: AttributeType.Time,\n                };\n            case \"Edm.Date\":\n                return {\n                    type: AttributeType.Date,\n                };\n            // case \"Edm.DateTime\": // HANA 1.0 types not supported anymore\n            case \"Edm.DateTimeOffset\":\n                return {\n                    type: AttributeType.Timestamp,\n                };\n            case \"Collection(Edm.String)\":\n                return {\n                    type: AttributeType.String,\n                };\n            case \"Edm.GeometryPoint\":\n            case \"Edm.GeographyPoint\":\n            case \"GeoJson\":\n                return {\n                    type: AttributeType.GeoJson,\n                };\n            default:\n                if (attributeMetadata.type && attributeMetadata.type.startsWith(\"Collection\")) {\n                    this.log.warn(\n                        \"Unsupported data type \" +\n                            attributeMetadata.type +\n                            \" of attribute \" +\n                            attributeMetadata.labelRaw +\n                            \" in \" +\n                            dataSource.label\n                    );\n                    return {\n                        type: AttributeType.String,\n                    };\n                }\n\n                throw new UnknownAttributeTypeError(\n                    getText(\"error.sina.unsupportedOdataType\", [\n                        attributeMetadata.type,\n                        attributeMetadata.labelRaw || attributeId,\n                        dataSource.label,\n                    ])\n                );\n        }\n    }\n\n    private _parseUsage(attributeMetadata, displayOrderIndex: number): AttributeUsageType {\n        const usage: AttributeUsageType = {};\n        for (let i = 0; i < attributeMetadata.presentationUsage.length; i++) {\n            const id = attributeMetadata.presentationUsage[i].toUpperCase() || \"\";\n            if (id === \"TITLE\") {\n                usage.Title = {\n                    displayOrder: displayOrderIndex,\n                };\n            }\n\n            if (\n                id === \"SUMMARY\" ||\n                id === \"DETAIL\" ||\n                id === \"IMAGE\" ||\n                id === \"THUMBNAIL\" ||\n                id === \"LONGTEXT\"\n                //||id === \"#HIDDEN\"\n            ) {\n                usage.Detail = {\n                    displayOrder: displayOrderIndex,\n                };\n            }\n        }\n\n        if (attributeMetadata.isFacet) {\n            usage.AdvancedSearch = {\n                displayOrder: attributeMetadata.facetPosition || displayOrderIndex || 100,\n                iconUrlAttributeName: attributeMetadata.facetIconUrlAttributeName,\n            };\n            usage.Facet = {\n                displayOrder: attributeMetadata.facetPosition || displayOrderIndex || 100,\n                iconUrlAttributeName: attributeMetadata.facetIconUrlAttributeName,\n            };\n        }\n\n        if (attributeMetadata.isFilteringAttribute) {\n            usage.AdvancedSearch = {\n                displayOrder: attributeMetadata.facetPosition || displayOrderIndex || 100,\n                iconUrlAttributeName: attributeMetadata.facetIconUrlAttributeName,\n            };\n        }\n\n        return usage;\n    }\n\n    public parseDynamicMetadata(searchResult: HANAOdataSearchResponseResult) {\n        // check that we have dynamic metadata\n        if (!searchResult) {\n            return;\n        }\n        const metadata = searchResult[\"@com.sap.vocabularies.Search.v1.Metadata\"];\n        if (!metadata) {\n            return;\n        }\n\n        // generate attributes from dynamic metadata\n        for (const dataSourceId in metadata) {\n            const dataSourceMetadata = metadata[dataSourceId];\n            for (const attributeId in dataSourceMetadata) {\n                if (attributeId === \"$Kind\") {\n                    continue;\n                }\n                const dynamicAttributeMetadata = dataSourceMetadata[attributeId];\n                this.parseDynamicAttributeMetadata(\n                    this.sina.getDataSource(dataSourceId),\n                    attributeId,\n                    dynamicAttributeMetadata\n                );\n            }\n        }\n    }\n\n    public parseDynamicAttributeMetadata(\n        dataSource: DataSource,\n        attributeId: string,\n        dynamicAttributeMetadata\n    ): void {\n        const typeAndFormat = this._parseAttributeTypeAndFormat(\n            {\n                presentationUsage: [],\n                type: dynamicAttributeMetadata.$Type,\n            },\n            dataSource,\n            attributeId\n        );\n\n        let attributeMetadata: AttributeMetadata;\n        try {\n            attributeMetadata = dataSource.getAttributeMetadata(attributeId) as AttributeMetadata;\n        } catch (e) {\n            this.log.warn(\"Error while getting attribute metadata: \" + e);\n        }\n\n        if (attributeMetadata) {\n            // update\n            if (!attributeMetadata._private.dynamic) {\n                return; // only update dynamic attributes\n            }\n            attributeMetadata.label = dynamicAttributeMetadata[\"@SAP.Common.Label\"];\n            attributeMetadata.type = typeAndFormat.type;\n            attributeMetadata.format = typeAndFormat?.format;\n            attributeMetadata.usage =\n                dynamicAttributeMetadata[\"@EnterpriseSearch.filteringFacet.default\"] === true\n                    ? {\n                          Facet: {\n                              displayOrder:\n                                  dynamicAttributeMetadata[\n                                      \"@EnterpriseSearch.filteringFacet.displayPosition\"\n                                  ] ||\n                                  attributeMetadata.usage?.Facet?.displayOrder ||\n                                  20,\n                              iconUrlAttributeName:\n                                  dynamicAttributeMetadata[\"@EnterpriseSearch.filteringFacet.iconUrl\"] ||\n                                  attributeMetadata.iconUrlAttributeName ||\n                                  \"\",\n                          },\n                      }\n                    : {};\n            attributeMetadata.isSortable =\n                dynamicAttributeMetadata[\"@EnterpriseSearchHana.isSortable\"] ||\n                attributeMetadata.isSortable ||\n                false;\n        } else {\n            // append\n            attributeMetadata = this.sina._createAttributeMetadata({\n                id: attributeId,\n                label: dynamicAttributeMetadata[\"@SAP.Common.Label\"],\n                isKey: false,\n                isSortable: dynamicAttributeMetadata[\"@EnterpriseSearchHana.isSortable\"] || false,\n                usage:\n                    dynamicAttributeMetadata[\"@EnterpriseSearch.filteringFacet.default\"] === true\n                        ? {\n                              Facet: {\n                                  displayOrder:\n                                      dynamicAttributeMetadata[\n                                          \"@EnterpriseSearch.filteringFacet.displayPosition\"\n                                      ] || 20,\n                                  iconUrlAttributeName:\n                                      dynamicAttributeMetadata[\"@EnterpriseSearch.filteringFacet.iconUrl\"] ||\n                                      \"\",\n                              },\n                          }\n                        : {},\n                type: typeAndFormat.type,\n                format: typeAndFormat?.format,\n                matchingStrategy: MatchingStrategy.Exact,\n                _private: {\n                    dynamic: true,\n                },\n            });\n            dataSource.attributesMetadata.push(attributeMetadata);\n            dataSource.attributeMetadataMap[attributeMetadata.id] = attributeMetadata;\n        }\n    }\n\n    public getUniqueDataSourceFromSearchResult(searchResult): DataSource {\n        const data = searchResult.data;\n        if (!data) {\n            return;\n        }\n        const items = data.value;\n        if (!items) {\n            return;\n        }\n        let dataSourceId, prevDataSourceId;\n        for (let i = 0; i < items.length; ++i) {\n            const item = items[i];\n            const context = item[\"@odata.context\"];\n            if (!context) {\n                return;\n            }\n            dataSourceId = context.split(\"#\")[1];\n            if (!dataSourceId) {\n                return;\n            }\n            if (prevDataSourceId && prevDataSourceId !== dataSourceId) {\n                return;\n            }\n            prevDataSourceId = dataSourceId;\n        }\n        return this.sina.getDataSource(dataSourceId);\n    }\n}\n"],"mappings":";;;;;AAAAA,IAAAC,GAAAC,OAAA,4JAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAAA,mBAKSC,EAAGN,EAAA,aAGHO,EAAaN,EAAA,uBACbO,EAAmBN,EAAA,6BACnBO,EAAgBN,EAAA,0BAEhBO,EAAyBN,EAAA,mCAAEO,EAA6BP,EAAA,uCAMxDQ,EAAOP,EAAA,eAEXQ,EAAwB,SAAxBA,OAAwB,8BAAxBA,IAAwB,qCAAxBA,CAAwB,EAAxBA,GAAwB,QAKxBC,EAA8B,SAA9BA,OAA8B,oBAA9BA,IAA8B,wBAA9BA,IAA8B,sBAA9BA,IAA8B,oBAA9BA,IAA8B,4BAA9BA,IAA8B,6BAA9BA,CAA8B,EAA9BA,GAA8B,IAkD5B,MAAeC,EAClBC,IACAC,SACAC,+BACAC,yBACAC,KAEAC,YAAYJ,GACRK,KAAKN,IAAM,IAAIV,EAAI,8BACnBgB,KAAKL,SAAWA,EAChBK,KAAKF,KAAOH,EAASG,IACzB,CAQUG,oBAAoBC,EAAqBC,EAAwBC,GACvE,MAAMC,EAAkBF,EAAeG,MAAM,KAC7C,IAAIC,EACJ,IAAIC,EAAoBN,EACxB,MAAMO,EAAiB,uCACvB,IAAIC,EAGJ,IAAKA,EAAI,EAAGA,EAAIL,EAAgBM,OAAS,EAAGD,IAAK,CAC7CH,EAAiBF,EAAgBK,GACjC,GAAIF,EAAkBD,KAAoBK,UAAW,CACjDJ,EAAkBD,GAAkB,CAAC,EACrCC,EAAoBA,EAAkBD,EAC1C,MAAO,GAAIM,MAAMC,QAAQN,EAAkBD,IAAkB,CAIzDC,EAAkBC,GAAkBD,EAAkBC,IAAmB,CAAC,EAC1E,IAAKD,EAAkBC,GAAgBF,GAAiB,CACpDC,EAAkBC,GAAgBF,GAAkB,CAAC,EACrDC,EAAkBD,GAAgBQ,KAAKP,EAAkBC,GAAgBF,GAC7E,CACAC,EAAoBA,EAAkBC,GAAgBF,EAC1D,MAAO,UAAWC,EAAkBD,KAAoB,SAAU,CAC9DC,EAAoBA,EAAkBD,EAC1C,MAAO,UAAWC,EAAkBD,KAAoB,UAAW,CAK/DC,EAAkBD,GAAkB,CAAC,EACrCC,EAAoBA,EAAkBD,EAC1C,KAAO,CAEH,MACJ,CACJ,CAGA,GAAIG,EAAIL,EAAgBM,OAAQ,CAC5BJ,EAAiBF,EAAgBK,GACjC,GAAIF,EAAkBD,KAAoBK,UAAW,CAEjDJ,EAAkBD,GAAkBH,CACxC,MAAO,GAAIS,MAAMC,QAAQN,EAAkBD,IAAkB,CAEzD,GAAIM,MAAMC,QAAQV,GAAQ,CAEtBI,EAAkBD,GAAkBC,EAAkBD,GAAgBS,OAAOZ,EACjF,KAAO,CAGHI,EAAkBC,GAAkBD,EAAkBC,IAAmB,CAAC,EAC1E,IAAKD,EAAkBC,GAAgBF,GAAiB,CACpDC,EAAkBC,GAAgBF,GAAkBH,EACpDI,EAAkBD,GAAgBQ,KAC9BP,EAAkBC,GAAgBF,GAE1C,KAAO,CACH,IAAK,MAAMU,KAAYb,EAAO,CAC1B,IAAKI,EAAkBC,GAAgBF,GAAgBU,GAAW,CAC9DT,EAAkBC,GAAgBF,GAAgBU,GAAYb,EAAMa,EACxE,CACJ,CACJ,CACJ,CACJ,CACJ,CACJ,CAEOC,mBAAmBC,EAAwBC,GAC9C,GAAID,EAAWE,mBAAmB,GAAGC,KAAO,QAAS,CAEjD,MACJ,CACAH,EAAWE,mBAAqB,GAChCF,EAAWI,qBAAuB,CAAC,EAEnC,MAAMC,EAAiB,CACnBC,sBAAuB,CAAC,EACxBC,qBAAsB,CAAC,GAG3BF,EAAeC,sBAAwBN,EAAWjB,YAElD,IAAK,MAAMyB,KAAqBP,EAAWQ,aAAc,CACrD,IACI5B,KAAK6B,yBACDV,EACAC,EAAWQ,aAAaD,GACxBH,EAER,CAAE,MAAOM,GAEL9B,KAAKN,IAAIqC,MACL,YACIJ,EACA,kBACAR,EAAWa,MACX,kCACAF,EAAEG,WAEd,CACJ,CAEA,MAAMC,EAASlC,KAAKF,KAAKqC,4BAA4B,CACjDhB,WAAYA,EACZK,eAAgBA,IAEpBU,EAAOE,kCACX,CAEOP,yBACHV,EACAQ,EACAH,GAEA,MAAMa,EAAoBV,EAAkBW,aAG5C,MAAMZ,EAAwBF,EAAeE,qBAAqBC,EAAkBY,UAAY,CAAC,EAEjG,IAAK,MAAMtB,KAAYU,EAAkBa,gBAAiB,CACtDd,EAAqBT,GAAYU,EAAkBa,gBAAgBvB,EACvE,CAEA,MAAMwB,EAAgBzC,KAAK0C,6BACvBf,EACAR,EACAQ,EAAkBY,UAGtB,GAAIE,GAAiBA,EAAcE,KAAM,CACrC,MAAMC,EAA0B5C,KAAKF,KAAK+C,yBAAyB,CAC/DvB,GAAIK,EAAkBY,SACtBP,MAAOL,EAAkBK,OAASL,EAAkBY,SACpDO,MAAOnB,EAAkBmB,OAAS,MAClCC,WAAYpB,EAAkBoB,WAC9BC,MAAOhD,KAAKiD,YAAYtB,EAAmBU,IAAsB,CAAC,EAClEM,KAAMF,EAAcE,KACpBO,OAAQT,EAAcS,OACtBC,iBAAkBnD,KAAKoD,uBAAuBzB,GAC9C0B,cAAe1B,EAAkB2B,oBACjCC,cAAe5B,GAAmB2B,qBAAqBE,KACvDC,qBAAsB9B,GAAmB2B,qBAAqBI,cAIlE,GACI/B,EAAkB2B,qBAClB3B,EAAkB2B,qBAAqBK,sBACzC,CACExC,EAAWyC,sBAAwB,KACnCzC,EAAWoC,cAAgB5B,EAAkB2B,qBAAqBE,KAClErC,EAAW0C,mBAAqBlC,EAAkB2B,qBAAqBQ,cACvE3C,EAAWsC,qBAAuB9B,EAAkB2B,qBAAqBI,WAC7E,CACAd,EAAwBmB,SAASC,mBAAqBrC,EAAkBsC,qBAExE9C,EAAWE,mBAAmBN,KAAK6B,GACnCzB,EAAWI,qBAAqBqB,EAAwBtB,IAAMsB,CAClE,CACJ,CAEQQ,uBAAuBzB,GAC3B,GAAIA,EAAkBuC,qBAAuB,KAAM,CAC/C,OAAO/E,EAAiBgF,IAC5B,CACA,OAAOhF,EAAiBiF,KAC5B,CAEQ1B,6BACJf,EACAR,EACAkD,GAKA,IAAK,IAAI3D,EAAI,EAAGA,EAAIiB,EAAkB2C,kBAAkB3D,OAAQD,IAAK,CACjE,MAAM4D,EAAoB3C,EAAkB2C,kBAAkB5D,IAAM,GACpE,OAAQ4D,EAAkBC,eACtB,IAAK,UACD,SACJ,IAAK,SACD,SACJ,IAAK,QACD,SACJ,IAAK,SACD,SACJ,IAAK,YACD,SACJ,IAAK,YACL,IAAK,QACD,MAAO,CACH5B,KAAM1D,EAAcuF,UAE5B,IAAK,WACD,MAAO,CACH7B,KAAM1D,EAAcwF,OACpBvB,OAAQhE,EAAoBwF,UAEpC,QACI,MAAM,IAAIrF,EAA8BiF,GAEpD,CAEA,OAAQ3C,EAAkBgB,MACtB,IAAK,aACD,GAAIhB,EAAkBa,gBAAiB,CACnC,GACKb,EAAkBa,gBAAgBmC,WAC/BhD,EAAkBa,gBAAgBmC,UAAUC,SAC5CjD,EAAkBa,gBAAgBmC,UAAUC,QAAQC,OACvDlD,EAAkBa,gBAAgBmC,WAC/BhD,EAAkBa,gBAAgBmC,UAAUG,SAClD,CACE,MAAO,CACHnC,KAAM1D,EAAc8F,UAE5B,CACJ,CACA,MAAO,CACHpC,KAAM1D,EAAcwF,QAExB,MACJ,IAAK,aACL,IAAK,oBACL,IAAK,cACL,IAAK,WACL,IAAK,WACD,MAAO,CACH9B,KAAM1D,EAAcwF,QAE5B,IAAK,aACL,IAAK,cACL,IAAK,YACL,IAAK,aACL,IAAK,kBACD,MAAO,CACH9B,KAAM1D,EAAc+F,QAE5B,IAAK,YACL,IAAK,YACL,IAAK,YACD,MAAO,CACHrC,KAAM1D,EAAcgG,SAG5B,IAAK,gBACD,MAAO,CACHtC,KAAM1D,EAAciG,MAE5B,IAAK,WACD,MAAO,CACHvC,KAAM1D,EAAckG,MAG5B,IAAK,qBACD,MAAO,CACHxC,KAAM1D,EAAcmG,WAE5B,IAAK,yBACD,MAAO,CACHzC,KAAM1D,EAAcwF,QAE5B,IAAK,oBACL,IAAK,qBACL,IAAK,UACD,MAAO,CACH9B,KAAM1D,EAAcoG,SAE5B,QACI,GAAI1D,EAAkBgB,MAAQhB,EAAkBgB,KAAK2C,WAAW,cAAe,CAC3EtF,KAAKN,IAAI6F,KACL,yBACI5D,EAAkBgB,KAClB,iBACAhB,EAAkBY,SAClB,OACApB,EAAWa,OAEnB,MAAO,CACHW,KAAM1D,EAAcwF,OAE5B,CAEA,MAAM,IAAIrF,EACNE,EAAQ,kCAAmC,CACvCqC,EAAkBgB,KAClBhB,EAAkBY,UAAY8B,EAC9BlD,EAAWa,SAI/B,CAEQiB,YAAYtB,EAAmBU,GACnC,MAAMW,EAA4B,CAAC,EACnC,IAAK,IAAItC,EAAI,EAAGA,EAAIiB,EAAkB2C,kBAAkB3D,OAAQD,IAAK,CACjE,MAAMY,EAAKK,EAAkB2C,kBAAkB5D,GAAG6D,eAAiB,GACnE,GAAIjD,IAAO,QAAS,CAChB0B,EAAMwC,MAAQ,CACVlD,aAAcD,EAEtB,CAEA,GACIf,IAAO,WACPA,IAAO,UACPA,IAAO,SACPA,IAAO,aACPA,IAAO,WAET,CACE0B,EAAMyC,OAAS,CACXnD,aAAcD,EAEtB,CACJ,CAEA,GAAIV,EAAkB+D,QAAS,CAC3B1C,EAAM2C,eAAiB,CACnBrD,aAAcX,EAAkBiE,eAAiBvD,GAAqB,IACtEwD,qBAAsBlE,EAAkBmE,2BAE5C9C,EAAM+C,MAAQ,CACVzD,aAAcX,EAAkBiE,eAAiBvD,GAAqB,IACtEwD,qBAAsBlE,EAAkBmE,0BAEhD,CAEA,GAAInE,EAAkBqE,qBAAsB,CACxChD,EAAM2C,eAAiB,CACnBrD,aAAcX,EAAkBiE,eAAiBvD,GAAqB,IACtEwD,qBAAsBlE,EAAkBmE,0BAEhD,CAEA,OAAO9C,CACX,CAEOiD,qBAAqBC,GAExB,IAAKA,EAAc,CACf,MACJ,CACA,MAAMC,EAAWD,EAAa,4CAC9B,IAAKC,EAAU,CACX,MACJ,CAGA,IAAK,MAAMC,KAAgBD,EAAU,CACjC,MAAME,EAAqBF,EAASC,GACpC,IAAK,MAAM/B,KAAegC,EAAoB,CAC1C,GAAIhC,IAAgB,QAAS,CACzB,QACJ,CACA,MAAMiC,EAA2BD,EAAmBhC,GACpDrE,KAAKuG,8BACDvG,KAAKF,KAAK0G,cAAcJ,GACxB/B,EACAiC,EAER,CACJ,CACJ,CAEOC,8BACHpF,EACAkD,EACAiC,GAEA,MAAM7D,EAAgBzC,KAAK0C,6BACvB,CACI4B,kBAAmB,GACnB3B,KAAM2D,EAAyBG,OAEnCtF,EACAkD,GAGJ,IAAI1C,EACJ,IACIA,EAAoBR,EAAWuF,qBAAqBrC,EACxD,CAAE,MAAOvC,GACL9B,KAAKN,IAAI6F,KAAK,2CAA6CzD,EAC/D,CAEA,GAAIH,EAAmB,CAEnB,IAAKA,EAAkBoC,SAAS4C,QAAS,CACrC,MACJ,CACAhF,EAAkBK,MAAQsE,EAAyB,qBACnD3E,EAAkBgB,KAAOF,EAAcE,KACvChB,EAAkBuB,OAAST,GAAeS,OAC1CvB,EAAkBqB,MACdsD,EAAyB,8CAAgD,KACnE,CACIP,MAAO,CACHzD,aACIgE,EACI,qDAEJ3E,EAAkBqB,OAAO+C,OAAOzD,cAChC,GACJuD,qBACIS,EAAyB,6CACzB3E,EAAkBkE,sBAClB,KAGZ,CAAC,EACXlE,EAAkBoB,WACduD,EAAyB,qCACzB3E,EAAkBoB,YAClB,KACR,KAAO,CAEHpB,EAAoB3B,KAAKF,KAAK+C,yBAAyB,CACnDvB,GAAI+C,EACJrC,MAAOsE,EAAyB,qBAChCxD,MAAO,MACPC,WAAYuD,EAAyB,qCAAuC,MAC5EtD,MACIsD,EAAyB,8CAAgD,KACnE,CACIP,MAAO,CACHzD,aACIgE,EACI,qDACC,GACTT,qBACIS,EAAyB,6CACzB,KAGZ,CAAC,EACX3D,KAAMF,EAAcE,KACpBO,OAAQT,GAAeS,OACvBC,iBAAkBhE,EAAiBiF,MACnCL,SAAU,CACN4C,QAAS,QAGjBxF,EAAWE,mBAAmBN,KAAKY,GACnCR,EAAWI,qBAAqBI,EAAkBL,IAAMK,CAC5D,CACJ,CAEOiF,oCAAoCV,GACvC,MAAMW,EAAOX,EAAaW,KAC1B,IAAKA,EAAM,CACP,MACJ,CACA,MAAMC,EAAQD,EAAKzG,MACnB,IAAK0G,EAAO,CACR,MACJ,CACA,IAAIV,EAAcW,EAClB,IAAK,IAAIrG,EAAI,EAAGA,EAAIoG,EAAMnG,SAAUD,EAAG,CACnC,MAAMsG,EAAOF,EAAMpG,GACnB,MAAMuG,EAAUD,EAAK,kBACrB,IAAKC,EAAS,CACV,MACJ,CACAb,EAAea,EAAQ3G,MAAM,KAAK,GAClC,IAAK8F,EAAc,CACf,MACJ,CACA,GAAIW,GAAoBA,IAAqBX,EAAc,CACvD,MACJ,CACAW,EAAmBX,CACvB,CACA,OAAOpG,KAAKF,KAAK0G,cAAcJ,EACnC,EACH,IAAAc,EAAA,CAAAC,WAAA,MAAAD,EAAAzH,iBAAA,OAAAyH,CAAA","ignoreList":[]}