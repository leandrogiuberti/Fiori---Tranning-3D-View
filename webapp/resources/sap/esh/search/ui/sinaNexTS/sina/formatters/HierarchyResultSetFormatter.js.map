{"version":3,"file":"HierarchyResultSetFormatter.js","names":["sap","ui","define","___SearchQuery","___Formatter","sinaUtil","___FilteredDataSource","SearchQuery","Formatter","FilteredDataSource","HierarchyResultSetFormatter","initAsync","Promise","resolve","format","resultSet","formatAsync","sina","configuration","FF_hierarchyBreadcrumbs","query","dataSource","filter","hierarchyDataSource","getHierarchyDataSource","staticHierarchyAttributeMetadata","getStaticHierarchyAttributeMetadata","items","forEach","resultSetItem","this","processResultSetItem","getHierarchyNodePath","hierarchyNodePaths","hierarchyAttributeName","hierarchyNodePath","name","params","assembleTitleNavigationTarget","assembleHierarchyAttributeNavigationTarget","id","path","length","lastNode","staticHierarchyAttribute","attributesMap","mergedTitleValues","assembleTitle","setDefaultNavigationTarget","createStaticHierarchySearchNavigationTarget","value","exchangeDataSourceForFilteredDataSource","hierarchyAttributeNavigationTargetLabel","constructHierarchyAttributeNavigationTargetLabel","tooltip","_constructTooltip","searchInAreaOverwriteMode","splice","map","label","join","__exports","__esModule"],"sources":["HierarchyResultSetFormatter.ts"],"sourcesContent":["/*!\n * SAPUI5\n * Copyright (c) 2025 SAP SE or an SAP affiliate company. All rights reserved.\n * \n */\nimport { HierarchyNodePath } from \"../HierarchyNodePath\";\nimport { ResultSet } from \"../ResultSet\";\nimport { SearchQuery } from \"../SearchQuery\";\nimport { SearchResultSet } from \"../SearchResultSet\";\nimport { Formatter } from \"./Formatter\";\nimport * as sinaUtil from \"../util\";\nimport { SearchResultSetItem } from \"../SearchResultSetItem\";\nimport { DataSource } from \"../DataSource\";\nimport { AttributeMetadata } from \"../AttributeMetadata\";\nimport { FilteredDataSource } from \"../FilteredDataSource\";\n\ninterface ResultListItemParams {\n    resultSetItem: SearchResultSetItem;\n    dataSource: DataSource;\n    hierarchyDataSource: DataSource;\n    staticHierarchyAttributeMetadata: AttributeMetadata;\n}\nexport class HierarchyResultSetFormatter extends Formatter {\n    initAsync(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    format(resultSet: ResultSet): ResultSet {\n        return resultSet;\n    }\n\n    async formatAsync(resultSet: SearchResultSet): Promise<SearchResultSet> {\n        // check feature flag: title links, tooltips, attribute links are only generated in case the breadcrumb is switched on\n        if (!resultSet.sina.configuration.FF_hierarchyBreadcrumbs) {\n            return resultSet;\n        }\n\n        // Only reformat search results instead of facet items in show more dialog\n        // The second condition is to exclude hierarchy facets which also send SearchQuery\n        if (!(resultSet.query instanceof SearchQuery)) {\n            return resultSet;\n        }\n\n        // check that there is a hierarchy datasource\n        const dataSource = resultSet.query.filter.dataSource;\n        const hierarchyDataSource = dataSource.getHierarchyDataSource();\n        if (!hierarchyDataSource) {\n            return resultSet;\n        }\n        const staticHierarchyAttributeMetadata = dataSource.getStaticHierarchyAttributeMetadata();\n        if (!staticHierarchyAttributeMetadata) {\n            return resultSet;\n        }\n        // process all items\n        resultSet.items.forEach((resultSetItem) => {\n            this.processResultSetItem({\n                resultSetItem: resultSetItem,\n                dataSource: dataSource,\n                hierarchyDataSource: hierarchyDataSource,\n                staticHierarchyAttributeMetadata: staticHierarchyAttributeMetadata,\n            });\n        });\n\n        return resultSet;\n    }\n\n    private getHierarchyNodePath(\n        hierarchyNodePaths: Array<HierarchyNodePath>,\n        hierarchyAttributeName: string\n    ) {\n        if (!hierarchyNodePaths) {\n            return;\n        }\n        for (const hierarchyNodePath of hierarchyNodePaths) {\n            if (hierarchyNodePath.name === hierarchyAttributeName) {\n                return hierarchyNodePath;\n            }\n        }\n    }\n\n    private processResultSetItem(params: ResultListItemParams) {\n        this.assembleTitleNavigationTarget(params);\n        this.assembleHierarchyAttributeNavigationTarget(params);\n    }\n\n    private assembleTitleNavigationTarget(params: ResultListItemParams) {\n        // determine hierarchy node id of result list item (= folder in DSP) (needed for filter condition)\n        const hierarchyNodePath = this.getHierarchyNodePath(\n            params.resultSetItem.hierarchyNodePaths,\n            params.staticHierarchyAttributeMetadata.id\n        );\n        if (!hierarchyNodePath || !hierarchyNodePath.path || hierarchyNodePath.path.length < 1) {\n            return;\n        }\n        const lastNode = hierarchyNodePath.path[hierarchyNodePath.path.length - 1];\n\n        // determine static hierarch attribute\n        const staticHierarchyAttribute =\n            params.resultSetItem.attributesMap[params.staticHierarchyAttributeMetadata.id];\n\n        // assemble title\n        const mergedTitleValues = sinaUtil.assembleTitle(params.resultSetItem);\n\n        // assemble navigation target\n        params.resultSetItem.setDefaultNavigationTarget(\n            params.resultSetItem.sina.createStaticHierarchySearchNavigationTarget(\n                lastNode.id,\n                mergedTitleValues || staticHierarchyAttribute?.value || \"\",\n                this.exchangeDataSourceForFilteredDataSource(params.dataSource),\n                \"\",\n                params.staticHierarchyAttributeMetadata.id\n            )\n        );\n    }\n\n    private assembleHierarchyAttributeNavigationTarget(params: ResultListItemParams) {\n        const staticHierarchyAttribute =\n            params.resultSetItem.attributesMap[params.staticHierarchyAttributeMetadata.id];\n        if (!staticHierarchyAttribute) {\n            return;\n        }\n        const hierarchyAttributeNavigationTargetLabel =\n            this.constructHierarchyAttributeNavigationTargetLabel(params);\n        staticHierarchyAttribute.setDefaultNavigationTarget(\n            params.resultSetItem.sina.createStaticHierarchySearchNavigationTarget(\n                staticHierarchyAttribute.value,\n                hierarchyAttributeNavigationTargetLabel, // for filter condition value label\n                this.exchangeDataSourceForFilteredDataSource(params.dataSource),\n                hierarchyAttributeNavigationTargetLabel, // for targetNavigation label\n                params.staticHierarchyAttributeMetadata.id\n            )\n        );\n        staticHierarchyAttribute.tooltip = this._constructTooltip(params);\n    }\n\n    private exchangeDataSourceForFilteredDataSource(dataSource: DataSource): DataSource {\n        if (\n            dataSource.sina.configuration?.searchInAreaOverwriteMode === true &&\n            dataSource instanceof FilteredDataSource\n        ) {\n            dataSource = dataSource.dataSource;\n        }\n        return dataSource;\n    }\n\n    private _constructTooltip(params: ResultListItemParams): string {\n        // get hierarchy node path\n        const hierarchyNodePath = this.getHierarchyNodePath(\n            params.resultSetItem.hierarchyNodePaths,\n            params.staticHierarchyAttributeMetadata.id\n        );\n        if (!hierarchyNodePath || !hierarchyNodePath.path || hierarchyNodePath.path.length < 1) {\n            return \"\";\n        }\n        const path = hierarchyNodePath.path;\n        // get last part of path, in folder scenario, it should be the parent folder\n        const lastNode = path[path.length - 1];\n        // Specific case: if the result item is a folder object, the path includes also the item folder itself\n        // then the second last part of the path is the parent folder, we remove the last part of the path\n        if (\n            lastNode.id !==\n            params.resultSetItem.attributesMap[params.staticHierarchyAttributeMetadata.id].value\n        ) {\n            path.splice(path.length - 1, 1);\n        }\n        // join path parts\n        return path.map((path) => path.label).join(\" / \");\n    }\n\n    private constructHierarchyAttributeNavigationTargetLabel(params: ResultListItemParams): string {\n        // get hierarchy node path\n        const hierarchyNodePath = this.getHierarchyNodePath(\n            params.resultSetItem.hierarchyNodePaths,\n            params.staticHierarchyAttributeMetadata.id\n        );\n        const staticHierarchyAttribute =\n            params.resultSetItem.attributesMap[params.staticHierarchyAttributeMetadata.id];\n        if (\n            !hierarchyNodePath ||\n            !hierarchyNodePath.path ||\n            hierarchyNodePath.path.length < 1 ||\n            !staticHierarchyAttribute\n        ) {\n            return \"\";\n        }\n        const path = hierarchyNodePath.path;\n        // get last part of path, in folder scenario, it should be the parent folder\n        let lastNode = path[path.length - 1];\n        // Specific case: if the result item is a folder object, the path includes also the item folder itself\n        // then the second last part of the path is the parent folder\n        if (\n            lastNode.id !==\n                params.resultSetItem.attributesMap[params.staticHierarchyAttributeMetadata.id].value &&\n            path.length > 1\n        ) {\n            lastNode = path[path.length - 2];\n        }\n        return lastNode.label || staticHierarchyAttribute.label || \"\";\n    }\n}\n"],"mappings":"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","ignoreList":[]}