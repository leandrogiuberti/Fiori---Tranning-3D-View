{"version":3,"file":"HierarchyResultSetFormatter-dbg.js","names":["sap","ui","define","___SearchQuery","___Formatter","sinaUtil","___FilteredDataSource","SearchQuery","Formatter","FilteredDataSource","HierarchyResultSetFormatter","initAsync","Promise","resolve","format","resultSet","formatAsync","sina","configuration","FF_hierarchyBreadcrumbs","query","dataSource","filter","hierarchyDataSource","getHierarchyDataSource","staticHierarchyAttributeMetadata","getStaticHierarchyAttributeMetadata","items","forEach","resultSetItem","processResultSetItem","getHierarchyNodePath","hierarchyNodePaths","hierarchyAttributeName","hierarchyNodePath","name","params","assembleTitleNavigationTarget","assembleHierarchyAttributeNavigationTarget","id","path","length","lastNode","staticHierarchyAttribute","attributesMap","mergedTitleValues","assembleTitle","setDefaultNavigationTarget","createStaticHierarchySearchNavigationTarget","value","exchangeDataSourceForFilteredDataSource","hierarchyAttributeNavigationTargetLabel","constructHierarchyAttributeNavigationTargetLabel","tooltip","_constructTooltip","searchInAreaOverwriteMode","splice","map","label","join","__exports","__esModule"],"sources":["HierarchyResultSetFormatter.ts"],"sourcesContent":["/*!\n * SAPUI5\n * Copyright (c) 2025 SAP SE or an SAP affiliate company. All rights reserved.\n * \n */\nimport { HierarchyNodePath } from \"../HierarchyNodePath\";\nimport { ResultSet } from \"../ResultSet\";\nimport { SearchQuery } from \"../SearchQuery\";\nimport { SearchResultSet } from \"../SearchResultSet\";\nimport { Formatter } from \"./Formatter\";\nimport * as sinaUtil from \"../util\";\nimport { SearchResultSetItem } from \"../SearchResultSetItem\";\nimport { DataSource } from \"../DataSource\";\nimport { AttributeMetadata } from \"../AttributeMetadata\";\nimport { FilteredDataSource } from \"../FilteredDataSource\";\n\ninterface ResultListItemParams {\n    resultSetItem: SearchResultSetItem;\n    dataSource: DataSource;\n    hierarchyDataSource: DataSource;\n    staticHierarchyAttributeMetadata: AttributeMetadata;\n}\nexport class HierarchyResultSetFormatter extends Formatter {\n    initAsync(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    format(resultSet: ResultSet): ResultSet {\n        return resultSet;\n    }\n\n    async formatAsync(resultSet: SearchResultSet): Promise<SearchResultSet> {\n        // check feature flag: title links, tooltips, attribute links are only generated in case the breadcrumb is switched on\n        if (!resultSet.sina.configuration.FF_hierarchyBreadcrumbs) {\n            return resultSet;\n        }\n\n        // Only reformat search results instead of facet items in show more dialog\n        // The second condition is to exclude hierarchy facets which also send SearchQuery\n        if (!(resultSet.query instanceof SearchQuery)) {\n            return resultSet;\n        }\n\n        // check that there is a hierarchy datasource\n        const dataSource = resultSet.query.filter.dataSource;\n        const hierarchyDataSource = dataSource.getHierarchyDataSource();\n        if (!hierarchyDataSource) {\n            return resultSet;\n        }\n        const staticHierarchyAttributeMetadata = dataSource.getStaticHierarchyAttributeMetadata();\n        if (!staticHierarchyAttributeMetadata) {\n            return resultSet;\n        }\n        // process all items\n        resultSet.items.forEach((resultSetItem) => {\n            this.processResultSetItem({\n                resultSetItem: resultSetItem,\n                dataSource: dataSource,\n                hierarchyDataSource: hierarchyDataSource,\n                staticHierarchyAttributeMetadata: staticHierarchyAttributeMetadata,\n            });\n        });\n\n        return resultSet;\n    }\n\n    private getHierarchyNodePath(\n        hierarchyNodePaths: Array<HierarchyNodePath>,\n        hierarchyAttributeName: string\n    ) {\n        if (!hierarchyNodePaths) {\n            return;\n        }\n        for (const hierarchyNodePath of hierarchyNodePaths) {\n            if (hierarchyNodePath.name === hierarchyAttributeName) {\n                return hierarchyNodePath;\n            }\n        }\n    }\n\n    private processResultSetItem(params: ResultListItemParams) {\n        this.assembleTitleNavigationTarget(params);\n        this.assembleHierarchyAttributeNavigationTarget(params);\n    }\n\n    private assembleTitleNavigationTarget(params: ResultListItemParams) {\n        // determine hierarchy node id of result list item (= folder in DSP) (needed for filter condition)\n        const hierarchyNodePath = this.getHierarchyNodePath(\n            params.resultSetItem.hierarchyNodePaths,\n            params.staticHierarchyAttributeMetadata.id\n        );\n        if (!hierarchyNodePath || !hierarchyNodePath.path || hierarchyNodePath.path.length < 1) {\n            return;\n        }\n        const lastNode = hierarchyNodePath.path[hierarchyNodePath.path.length - 1];\n\n        // determine static hierarch attribute\n        const staticHierarchyAttribute =\n            params.resultSetItem.attributesMap[params.staticHierarchyAttributeMetadata.id];\n\n        // assemble title\n        const mergedTitleValues = sinaUtil.assembleTitle(params.resultSetItem);\n\n        // assemble navigation target\n        params.resultSetItem.setDefaultNavigationTarget(\n            params.resultSetItem.sina.createStaticHierarchySearchNavigationTarget(\n                lastNode.id,\n                mergedTitleValues || staticHierarchyAttribute?.value || \"\",\n                this.exchangeDataSourceForFilteredDataSource(params.dataSource),\n                \"\",\n                params.staticHierarchyAttributeMetadata.id\n            )\n        );\n    }\n\n    private assembleHierarchyAttributeNavigationTarget(params: ResultListItemParams) {\n        const staticHierarchyAttribute =\n            params.resultSetItem.attributesMap[params.staticHierarchyAttributeMetadata.id];\n        if (!staticHierarchyAttribute) {\n            return;\n        }\n        const hierarchyAttributeNavigationTargetLabel =\n            this.constructHierarchyAttributeNavigationTargetLabel(params);\n        staticHierarchyAttribute.setDefaultNavigationTarget(\n            params.resultSetItem.sina.createStaticHierarchySearchNavigationTarget(\n                staticHierarchyAttribute.value,\n                hierarchyAttributeNavigationTargetLabel, // for filter condition value label\n                this.exchangeDataSourceForFilteredDataSource(params.dataSource),\n                hierarchyAttributeNavigationTargetLabel, // for targetNavigation label\n                params.staticHierarchyAttributeMetadata.id\n            )\n        );\n        staticHierarchyAttribute.tooltip = this._constructTooltip(params);\n    }\n\n    private exchangeDataSourceForFilteredDataSource(dataSource: DataSource): DataSource {\n        if (\n            dataSource.sina.configuration?.searchInAreaOverwriteMode === true &&\n            dataSource instanceof FilteredDataSource\n        ) {\n            dataSource = dataSource.dataSource;\n        }\n        return dataSource;\n    }\n\n    private _constructTooltip(params: ResultListItemParams): string {\n        // get hierarchy node path\n        const hierarchyNodePath = this.getHierarchyNodePath(\n            params.resultSetItem.hierarchyNodePaths,\n            params.staticHierarchyAttributeMetadata.id\n        );\n        if (!hierarchyNodePath || !hierarchyNodePath.path || hierarchyNodePath.path.length < 1) {\n            return \"\";\n        }\n        const path = hierarchyNodePath.path;\n        // get last part of path, in folder scenario, it should be the parent folder\n        const lastNode = path[path.length - 1];\n        // Specific case: if the result item is a folder object, the path includes also the item folder itself\n        // then the second last part of the path is the parent folder, we remove the last part of the path\n        if (\n            lastNode.id !==\n            params.resultSetItem.attributesMap[params.staticHierarchyAttributeMetadata.id].value\n        ) {\n            path.splice(path.length - 1, 1);\n        }\n        // join path parts\n        return path.map((path) => path.label).join(\" / \");\n    }\n\n    private constructHierarchyAttributeNavigationTargetLabel(params: ResultListItemParams): string {\n        // get hierarchy node path\n        const hierarchyNodePath = this.getHierarchyNodePath(\n            params.resultSetItem.hierarchyNodePaths,\n            params.staticHierarchyAttributeMetadata.id\n        );\n        const staticHierarchyAttribute =\n            params.resultSetItem.attributesMap[params.staticHierarchyAttributeMetadata.id];\n        if (\n            !hierarchyNodePath ||\n            !hierarchyNodePath.path ||\n            hierarchyNodePath.path.length < 1 ||\n            !staticHierarchyAttribute\n        ) {\n            return \"\";\n        }\n        const path = hierarchyNodePath.path;\n        // get last part of path, in folder scenario, it should be the parent folder\n        let lastNode = path[path.length - 1];\n        // Specific case: if the result item is a folder object, the path includes also the item folder itself\n        // then the second last part of the path is the parent folder\n        if (\n            lastNode.id !==\n                params.resultSetItem.attributesMap[params.staticHierarchyAttributeMetadata.id].value &&\n            path.length > 1\n        ) {\n            lastNode = path[path.length - 2];\n        }\n        return lastNode.label || staticHierarchyAttribute.label || \"\";\n    }\n}\n"],"mappings":"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","ignoreList":[]}