{"version":3,"file":"LabelCalculator-dbg.js","names":["sap","ui","define","___errors","SinaError","DuplicateException","node","constructor","properties","message","name","Node","data","obj","parent","nodeId","labelCalculator","childMap","children","insert","keyPath","length","options","calculateLabel","key","subNode","push","recalculateLabels","slice","leafs","collectLeafs","i","isLeaf","hasSibling","isChildOfRoot","collectPath","force","reverse","setLabel","LabelCalculator","rootNode","e","setFallbackLabel","__exports","__esModule"],"sources":["LabelCalculator.ts"],"sourcesContent":["/*!\n * SAPUI5\n * Copyright (c) 2025 SAP SE or an SAP affiliate company. All rights reserved.\n * \n */\nimport { SinaError } from \"./errors\";\n\nclass DuplicateException extends SinaError {\n    node: Node;\n\n    constructor(properties: { message?: string; node: Node }) {\n        properties.message = properties.message ?? \"Duplicate node\";\n        super({\n            message: properties.message,\n            name: \"DuplicateException\",\n        });\n        this.node = properties.node;\n    }\n}\n\n/**\n * Creates unique labels for system data sources.\n * \n * examples:\n * datasource     system client    --> calculated label\n * Purchase Order CER    002           Purchase Order\n * Sales Order    CER    002           Sales Order\n\n * datasource     system client    --> calculated label         include system to make label unique\n * Purchase Order CER    002           Purchase Order CER\n * Purchase Order CES    003           Purchase Order CES\n\n * datasource     system client    --> calculated label        include system and client to make label unique\n * Purchase Order CES    002           Purchase Order CES 002\n * Purchase Order CES    003           Purchase Order CES 003\n\n * datasource     system client    --> calculated label\n * Purchase Order CER    002           Purchase Order duplicate ...\n * Purchase Order CER    002           Purchase Order duplicate ...\n */\nclass Node {\n    data: { label: string; labelPlural: string };\n    obj: unknown;\n    parent: Node;\n    nodeId: string;\n    labelCalculator: LabelCalculator;\n    childMap: { [key: string]: Node };\n    children: Array<Node>;\n\n    constructor(parent: Node, nodeId: string, labelCalculator: LabelCalculator) {\n        this.parent = parent;\n        this.nodeId = nodeId;\n        this.labelCalculator = labelCalculator;\n        this.childMap = {};\n        this.children = [];\n    }\n\n    insert(keyPath: Array<string>, obj: unknown) {\n        // check for end of recursion\n        if (keyPath.length === 0) {\n            this.data = this.labelCalculator.options.data(obj);\n            this.obj = obj;\n            this.calculateLabel();\n            return;\n        }\n\n        // insert recursively into tree\n        const key = keyPath[0];\n        let subNode = this.childMap[key];\n        if (keyPath.length === 1 && subNode) {\n            throw new DuplicateException({\n                node: subNode,\n            });\n        }\n        if (!subNode) {\n            subNode = new Node(this, key, this.labelCalculator);\n            this.childMap[key] = subNode;\n            this.children.push(subNode);\n            if (this.children.length === 2) {\n                this.children[0].recalculateLabels();\n                // whenever a node gets a sibling -> recalculate labels of node because due to\n                // the sibling we need to add more keys to the label to make the label unique\n            }\n        }\n        subNode.insert(keyPath.slice(1), obj);\n    }\n\n    recalculateLabels() {\n        const leafs = [];\n        this.collectLeafs(leafs);\n        for (let i = 0; i < leafs.length; ++i) {\n            leafs[i].calculateLabel();\n        }\n    }\n\n    collectLeafs(leafs) {\n        if (this.isLeaf()) {\n            leafs.push(this);\n            return;\n        }\n        for (let i = 0; i < this.children.length; ++i) {\n            this.children[i].collectLeafs(leafs);\n        }\n    }\n\n    isLeaf() {\n        return this.children.length === 0;\n    }\n\n    hasSibling() {\n        return this.parent && this.parent.children.length >= 2;\n    }\n\n    isChildOfRoot() {\n        return this.parent && this.parent.nodeId === \"__ROOT\";\n    }\n\n    collectPath(keyPath: Array<string>, force?: boolean) {\n        if (!this.parent) {\n            return;\n        }\n        if (force || this.hasSibling() || this.isChildOfRoot()) {\n            keyPath.push(this.nodeId);\n            force = true;\n        }\n        if (this.parent) {\n            this.parent.collectPath(keyPath, force);\n        }\n    }\n\n    calculateLabel() {\n        // collect keys = labels\n        const keyPath = [];\n        this.collectPath(keyPath);\n        keyPath.reverse();\n\n        // calculate label\n        this.labelCalculator.options.setLabel(this.obj, keyPath, this.data);\n    }\n}\n\nexport class LabelCalculator {\n    options: {\n        data: (objToBeLabeled: unknown) => {\n            label: string;\n            labelPlural: string;\n        };\n        key: (objToBeLabeled: unknown) => Array<string>;\n        setFallbackLabel: (objToBeLabeled, data) => void;\n        setLabel: (objToBeLabeled, keyPath, data) => void;\n    };\n    rootNode: Node;\n\n    constructor(options) {\n        this.options = options;\n        this.rootNode = new Node(null, \"__ROOT\", this);\n    }\n\n    calculateLabel(obj: unknown): void {\n        const key = this.options.key(obj);\n        try {\n            // insert datasource into datasource tree\n            // for the inserted datasource a unique label is calculated\n            // for datasource in sibling tree branches the label is recalculated\n            this.rootNode.insert(key, obj);\n        } catch (e) {\n            if (e.name === \"DuplicateException\") {\n                this.options.setFallbackLabel(e.node.obj, e.node.data); // set fallback label for already existing node\n                this.options.setFallbackLabel(obj, this.options.data(obj)); // and for duplicate node\n                return;\n            }\n            throw e;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]}