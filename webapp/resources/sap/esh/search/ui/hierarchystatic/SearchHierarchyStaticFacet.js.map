{"version":3,"file":"SearchHierarchyStaticFacet.js","names":["sap","ui","define","__TreeNodeFactory","__SearchHierarchyStaticTreeNode","___SearchHelperSequentializeDecorator","___controls_facets_FacetTypeUI","_interopRequireDefault","obj","__esModule","default","TreeNodeFactory","SearchHierarchyStaticTreeNode","sequentializedExecution","FacetTypeUI","SearchHierarchyStaticFacet","static","model","attributeId","dataSource","filter","title","sina","facetType","facetIndex","position","treeNodeFactory","rootTreeNode","constructor","properties","this","sinaNext","HierarchyStatic","create","rootTreeNodePath","treeNodeConstructor","busyIndicator","createRootTreeNode","id","rootNodeId","label","facet","updateTree","setFacetIndex","index","setRootTreeNodePath","initAsync","childTreeNodes","fetchChildTreeNodes","addChildTreeNodes","activateFilters","fireSearchQuery","notifyFilterChanged","doUpdateTree","updateRecursively","mixinFilterNodes","updateUI","getComplexConditionOfFacet","complexCondition","rootCondition","conditions","containsAttribute","getFilterConditions","filterConditions","condition","push","hasFilter","visitChildNodesRecursively","node","filterCondition","getTreeNode","value","autoExpandFirstFilterNode","handleModelUpdate","delete","firstFilterNode","isVisible","getParentTreeNode","expanded","updateNodesFromHierarchyNodePaths","hierarchyNodePaths","i","length","hierarchyNodePath","name","updateNodePath","path"],"sources":["SearchHierarchyStaticFacet.ts"],"sourcesContent":["/*!\n * SAPUI5\n * Copyright (c) 2025 SAP SE or an SAP affiliate company. All rights reserved.\n * \n */\n/*!\n * The SearchHierarchyStaticFacet class is used for the model representation of static hierarchy facets.\n * The corresponding UI control is SearchFacetHierarchyStatic.\n */\n\nimport SearchModel from \"sap/esh/search/ui/SearchModel\";\nimport { ComplexCondition } from \"../sinaNexTS/sina/ComplexCondition\";\nimport { DataSource } from \"../sinaNexTS/sina/DataSource\";\nimport { Filter } from \"../sinaNexTS/sina/Filter\";\nimport { HierarchyNodePath } from \"../sinaNexTS/sina/HierarchyNodePath\";\nimport { SimpleCondition } from \"../sinaNexTS/sina/SimpleCondition\";\nimport { Sina } from \"../sinaNexTS/sina/Sina\";\nimport TreeNodeFactory from \"../tree/TreeNodeFactory\";\nimport SearchHierarchyStaticTreeNode from \"./SearchHierarchyStaticTreeNode\";\nimport { sequentializedExecution } from \"../SearchHelperSequentializeDecorator\";\nimport { FacetTypeUI } from \"../controls/facets/FacetTypeUI\";\n\nexport interface SearchHierarchyStaticFacetOptions {\n    model: SearchModel;\n    attributeId: string;\n    dataSource: DataSource;\n    filter: Filter;\n    title: string;\n}\nexport default class SearchHierarchyStaticFacet {\n    public static readonly rootNodeId = \"$$ROOT$$\";\n    model: SearchModel;\n    attributeId: string;\n    dataSource: DataSource;\n    filter: Filter;\n    title: string;\n    sina: Sina;\n    facetType: string; // ToDo\n    facetIndex: number;\n    position: number;\n    treeNodeFactory: TreeNodeFactory<SearchHierarchyStaticTreeNode, typeof SearchHierarchyStaticTreeNode>;\n    rootTreeNode: SearchHierarchyStaticTreeNode;\n\n    constructor(properties: SearchHierarchyStaticFacetOptions) {\n        this.model = properties.model;\n        this.sina = this.model.sinaNext;\n        this.attributeId = properties.attributeId;\n        this.dataSource = properties.dataSource;\n        this.filter = properties.filter;\n        this.facetType = FacetTypeUI.HierarchyStatic;\n        this.title = properties.title;\n        this.facetIndex = -1;\n        this.position = -1;\n        this.treeNodeFactory = TreeNodeFactory.create<\n            SearchHierarchyStaticTreeNode,\n            typeof SearchHierarchyStaticTreeNode\n        >({\n            model: this.model,\n            rootTreeNodePath: `/facets/${this.facetIndex}/rootTreeNode`, // updated in setFacetIndex\n            treeNodeConstructor: SearchHierarchyStaticTreeNode,\n            busyIndicator: this.model.busyIndicator,\n        });\n        this.rootTreeNode = this.treeNodeFactory.createRootTreeNode({\n            id: SearchHierarchyStaticFacet.rootNodeId,\n            label: \"Root\",\n            facet: this,\n        });\n        this.updateTree = sequentializedExecution(this.updateTree);\n    }\n\n    setFacetIndex(index: number) {\n        this.facetIndex = index;\n        this.treeNodeFactory.setRootTreeNodePath(`/facets/${this.facetIndex}/rootTreeNode`);\n    }\n\n    async initAsync(): Promise<void> {\n        const childTreeNodes = await this.rootTreeNode.fetchChildTreeNodes();\n        this.rootTreeNode.addChildTreeNodes(childTreeNodes);\n    }\n\n    async activateFilters(): Promise<void> {\n        try {\n            await this.model.fireSearchQuery();\n            this.model.notifyFilterChanged();\n        } finally {\n            //\n        }\n    }\n\n    updateTree(): Promise<void> {\n        // not sure whether sequentialized decorator does work on async methods\n        // therefore use this wrapper\n        return this.doUpdateTree();\n    }\n\n    async doUpdateTree(): Promise<void> {\n        await this.treeNodeFactory.updateRecursively();\n        await this.mixinFilterNodes();\n        this.treeNodeFactory.updateUI();\n    }\n    getComplexConditionOfFacet(): ComplexCondition {\n        for (const complexCondition of (this.filter.rootCondition as ComplexCondition).conditions) {\n            if (complexCondition.containsAttribute(this.attributeId)) {\n                return complexCondition as ComplexCondition;\n            }\n        }\n        return null;\n    }\n\n    getFilterConditions(): Array<SimpleCondition> {\n        const filterConditions: Array<SimpleCondition> = [];\n        const complexCondition = this.getComplexConditionOfFacet();\n        if (!complexCondition) {\n            return filterConditions;\n        }\n        for (const condition of complexCondition.conditions) {\n            filterConditions.push(condition as SimpleCondition);\n        }\n        return filterConditions;\n    }\n\n    async mixinFilterNodes(): Promise<void> {\n        // reset filter flags for complete tree\n        this.rootTreeNode.hasFilter = false;\n        this.rootTreeNode.visitChildNodesRecursively(function (node) {\n            node.hasFilter = false;\n        });\n        // set filter flag from filter conditions\n        const filterConditions = this.getFilterConditions();\n        for (const filterCondition of filterConditions) {\n            const node = this.treeNodeFactory.getTreeNode(filterCondition.value as string);\n            if (!node) {\n                continue; // TODO shall never happen\n            }\n            node.hasFilter = true;\n        }\n        // auto expand first filter\n        await this.autoExpandFirstFilterNode();\n    }\n\n    handleModelUpdate() {\n        this.treeNodeFactory.updateUI();\n    }\n\n    delete() {\n        this.treeNodeFactory.delete();\n    }\n\n    async autoExpandFirstFilterNode(): Promise<void> {\n        // determine first node with filter\n        let firstFilterNode: SearchHierarchyStaticTreeNode = null;\n        this.rootTreeNode.visitChildNodesRecursively(function (node) {\n            if (node.hasFilter && !firstFilterNode) {\n                firstFilterNode = node;\n            }\n        });\n        if (!firstFilterNode) {\n            return;\n        }\n        if (firstFilterNode.isVisible()) {\n            return;\n        }\n        // expand nodes following path to root node\n        let node = firstFilterNode.getParentTreeNode();\n        while (node) {\n            node.expanded = true;\n            node = node.getParentTreeNode();\n        }\n        // update tree\n        await this.treeNodeFactory.updateRecursively();\n    }\n\n    updateNodesFromHierarchyNodePaths(hierarchyNodePaths: Array<HierarchyNodePath>): void {\n        for (let i = 0; i < hierarchyNodePaths.length; ++i) {\n            const hierarchyNodePath = hierarchyNodePaths[i];\n            if (hierarchyNodePath.name !== this.attributeId) {\n                continue;\n            }\n            this.rootTreeNode.updateNodePath(hierarchyNodePath.path, 0);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]}