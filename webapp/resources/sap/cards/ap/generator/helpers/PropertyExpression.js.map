{"version":3,"file":"PropertyExpression.js","names":["sap","ui","define","Log","BindingParser","___config_FormatterOptions","___utils_CommonUtils","___Formatter","getFormatterConfiguration","extractValueWithoutBooleanExprBinding","getDialogModel","hasBooleanBindingExpression","createFormatterExpression","isExpression","propertyValue","startsWith","isI18nExpression","endsWith","hasFormatter","includes","formatValue","propertyName","propertyValueFormatters","oMatchedFormatterDetail","find","oFormatterDetail","property","getArrangements","options","model","isPropertyBoolean","isBooleanProperty","unitOfMeasures","textArrangements","propertyHasBinding","replace","matchedUomObj","arrangement","name","matchedUOMName","value","matchedArrangementObj","textArrangement","matchedArrangementName","propertyHasFormatter","matchedUOMHasFormatter","matchedArrangementHasFormatter","matchedUOM","matchedArrangement","updatedVal","isArrangementBoolean","isUoMBoolean","getExpressionBindingForBooleanTypes","slice","getFormattedValue","index","indexOf","formattedValue","properties","getProperty","type","propertyParts","split","selectedNavProperty","selectedProperty","navigationalProperties","selectedNavPropertyObj","propertiesOfNavProperty","Array","isArray","selectedPropertyObj","expressionBinding","parts","uom","length","formatFloat","formatUnit","part1","part2","concat","extractPathWithoutUOM","extractPathExpressionWithoutUOM","hasUOM","substring","getExpressionParts","expression","startSymbols","endSymbols","count","part","skipNext","i","trim","push","extractPropertyConfigurationWithoutTextArrangement","mCardManifest","textArrangementOptions","getTextArrangementFromCardManifest","textArrangementIndex","propertyPaths","formatterExpression","forEach","hasTextArrangement","hasFormatterBinding","parseFormatterExpression","propertyPath","remainingExpression","join","textArrangementProperty","prop","option","arrangementType","propertyPathWithoutUOM","matchedTextArrangement","resolvePropertyPathFromExpression","path","hasBinding","selectedFormatter","updateAndGetSelectedFormatters","mManifest","configuration","parameters","_propertyFormatting","Object","keys","arrangements","text","key","isNavigationForId","isNavigationForDescription","propertyKeyForId","navigationKeyForId","navigationKeyForDescription","propertyKeyForDescription","navigationalPropertiesForDescription","navigationalPropertiesForId","formatterOptions","formatterName","formatter","bindingInfo","complexParser","propertyExpression","bindingPartial","lastIndexOf","parametersExpression","hasParameters","formatterParameters","parameter","startIndex","endIndex","JSON","parse","error","formatterConfig","parametersLength","formatterConfigParameters","updatePropertiesForObjectType","__exports","__esModule"],"sources":["PropertyExpression.ts"],"sourcesContent":["/*!\n * SAP UI development toolkit for HTML5 (SAPUI5)\n *  * (c) Copyright 2009-2025 SAP SE. All rights reserved\n */\nimport Log from \"sap/base/Log\";\nimport BindingParser from \"sap/ui/base/BindingParser\";\nimport { CardManifest } from \"sap/ui/integration/widgets/Card\";\nimport JSONModel from \"sap/ui/model/json/JSONModel\";\nimport { ArrangementOptions } from \"../app/controls/ArrangementsEditor\";\nimport { getFormatterConfiguration } from \"../config/FormatterOptions\";\nimport { extractValueWithoutBooleanExprBinding, getDialogModel, hasBooleanBindingExpression } from \"../utils/CommonUtils\";\nimport type { FormatterConfiguration, FormatterConfigurationMap } from \"./Formatter\";\nimport { createFormatterExpression } from \"./Formatter\";\n\ntype JSONObject = {\n\t[key: string]: string | boolean | number;\n};\n\ntype FormatterConfigParameters = string | JSONObject;\n\ntype ParsedFormatterExpression = {\n\tformatterName: string;\n\tpropertyPath: string;\n\tparameters: Array<FormatterConfigParameters>;\n};\n\ntype PropertyFormattingOptions = {\n\tunitOfMeasures: Array<{\n\t\t[key: string]: string;\n\t}>;\n\ttextArrangements: ArrangementOptions[];\n\tpropertyValueFormatters: FormatterConfigurationMap;\n};\n\n/**\n * This function checks if the property value is an expression\n *\n * @param {string} propertyValue\n * @returns {boolean}\n */\nexport function isExpression(propertyValue = \"\"): boolean {\n\treturn propertyValue.startsWith(\"{\");\n}\n\n/**\n * This function checks if the property value is an i18n expression\n *\n * @param {string} propertyValue\n * @returns {boolean}\n */\nexport function isI18nExpression(propertyValue = \"\"): boolean {\n\treturn propertyValue.startsWith(\"{{\") && propertyValue.endsWith(\"}}\");\n}\n\n/**\n * The function checks if the property value has a formatter\n *\n * @param propertyValue\n * @returns\n */\nexport function hasFormatter(propertyValue = \"\"): boolean {\n\treturn (\n\t\tpropertyValue.startsWith(\"{=\") &&\n\t\tpropertyValue.endsWith(\"}\") &&\n\t\t(propertyValue.includes(\"format.\") || propertyValue.includes(\"extension.formatters.\"))\n\t);\n}\n\n/**\n * format the value based on the formatter configuration\n * @param {string} propertyName\n * @param {FormatterConfigurationMap} propertyValueFormatters\n * @returns\n */\nfunction formatValue(propertyName: string, propertyValueFormatters: FormatterConfigurationMap = []) {\n\tconst oMatchedFormatterDetail = propertyValueFormatters.find(function (oFormatterDetail: FormatterConfiguration) {\n\t\treturn oFormatterDetail.property === propertyName || \"{\" + oFormatterDetail.property + \"}\" === propertyName;\n\t});\n\n\tif (oMatchedFormatterDetail) {\n\t\treturn createFormatterExpression(oMatchedFormatterDetail);\n\t}\n\treturn propertyName;\n}\n\n/**\n * Apply text arrangement, UOM and formatter to the property\n * @param {string} propertyName\n * @param {PropertyFormattingOptions} options\n * @returns {string}\n */\nexport function getArrangements(propertyName: string, options: PropertyFormattingOptions) {\n\tconst model = getDialogModel() as JSONModel;\n\tconst isPropertyBoolean = isBooleanProperty(model, propertyName);\n\tconst { unitOfMeasures, textArrangements, propertyValueFormatters } = options;\n\tconst propertyHasBinding = propertyName.startsWith(\"{\");\n\tpropertyName = propertyName.replace(/[{}]/g, \"\");\n\n\tconst matchedUomObj = unitOfMeasures.find(function (arrangement: any) {\n\t\treturn arrangement.name === propertyName;\n\t});\n\tlet matchedUOMName = matchedUomObj?.value?.replace(/[{}]/g, \"\");\n\tconst matchedArrangementObj = textArrangements.find((arrangement) => {\n\t\tif (arrangement.value && arrangement.textArrangement) {\n\t\t\treturn arrangement.name === propertyName;\n\t\t}\n\t});\n\tlet matchedArrangementName = matchedArrangementObj?.value?.replace(/[{}]/g, \"\");\n\n\tlet propertyHasFormatter = false;\n\tlet matchedUOMHasFormatter = false;\n\tlet matchedArrangementHasFormatter = false;\n\tconst property = propertyName;\n\tpropertyName = propertyName && formatValue(propertyName, propertyValueFormatters);\n\tif (propertyName !== property) {\n\t\tpropertyHasFormatter = true;\n\t}\n\n\tconst matchedUOM = matchedUomObj && formatValue(matchedUOMName ?? \"\", propertyValueFormatters);\n\tif (matchedUOMName !== matchedUOM) {\n\t\tmatchedUOMHasFormatter = true;\n\t}\n\tconst matchedArrangement = matchedArrangementName && formatValue(matchedArrangementName, propertyValueFormatters);\n\tif (matchedArrangementName !== matchedArrangement) {\n\t\tmatchedArrangementHasFormatter = true;\n\t}\n\n\tlet updatedVal = \"\";\n\tconst isArrangementBoolean = isBooleanProperty(model, matchedArrangementName ?? \"\");\n\tconst isUoMBoolean = isBooleanProperty(model, matchedUOMName ?? \"\");\n\n\tif (matchedArrangementObj || (matchedUomObj && matchedUOMName)) {\n\t\tif (isPropertyBoolean) {\n\t\t\tpropertyName = getExpressionBindingForBooleanTypes(propertyName).slice(1, -1);\n\t\t}\n\t\tif (isArrangementBoolean) {\n\t\t\tmatchedArrangementName = getExpressionBindingForBooleanTypes(matchedArrangementName ?? \"\").slice(1, -1);\n\t\t}\n\t\tif (isUoMBoolean) {\n\t\t\tmatchedUOMName = getExpressionBindingForBooleanTypes(matchedUOMName ?? \"\").slice(1, -1);\n\t\t}\n\t}\n\n\tif (matchedUomObj && matchedArrangementObj) {\n\t\tswitch (matchedArrangementObj.textArrangement) {\n\t\t\tcase \"TextLast\":\n\t\t\t\tupdatedVal += propertyHasFormatter ? `{= ${propertyName}}` : `{${propertyName}}`;\n\t\t\t\tupdatedVal += matchedUOMHasFormatter ? ` {= ${matchedUOM}}` : ` {${matchedUOMName}}`;\n\t\t\t\tupdatedVal = getFormattedValue(updatedVal, propertyHasFormatter, matchedUOMHasFormatter, isUoMBoolean);\n\t\t\t\tupdatedVal += matchedArrangementHasFormatter ? ` ({= ${matchedArrangement}})` : ` ({${matchedArrangementName}})`;\n\t\t\t\tbreak;\n\t\t\tcase \"TextFirst\":\n\t\t\t\tupdatedVal = matchedArrangementHasFormatter ? `{= ${matchedArrangement}} (` : `{${matchedArrangementName}} (`;\n\t\t\t\tupdatedVal += propertyHasFormatter ? `{= ${propertyName}}` : `{${propertyName}}`;\n\t\t\t\tupdatedVal += matchedUOMHasFormatter ? ` {= ${matchedUOM}}` : ` {${matchedUOMName}}`;\n\t\t\t\tconst index = updatedVal.indexOf(\" (\");\n\t\t\t\tconst formattedValue = getFormattedValue(\n\t\t\t\t\tupdatedVal.slice(index + 2),\n\t\t\t\t\tpropertyHasFormatter,\n\t\t\t\t\tmatchedUOMHasFormatter,\n\t\t\t\t\tisUoMBoolean\n\t\t\t\t);\n\t\t\t\tupdatedVal = updatedVal.slice(0, index + 2) + formattedValue;\n\t\t\t\tupdatedVal += \")\";\n\t\t\t\tbreak;\n\t\t\tcase \"TextSeparate\":\n\t\t\t\tupdatedVal += propertyHasFormatter ? `{= ${propertyName}}` : `{${propertyName}}`;\n\t\t\t\tupdatedVal += matchedUOMHasFormatter ? ` {= ${matchedUOM}}` : ` {${matchedUOMName}}`;\n\t\t\t\tupdatedVal = getFormattedValue(updatedVal, propertyHasFormatter, matchedUOMHasFormatter, isUoMBoolean);\n\t\t\t\tbreak;\n\t\t\tcase \"TextOnly\":\n\t\t\t\tupdatedVal += matchedArrangementHasFormatter ? `{= ${matchedArrangement}}` : `{${matchedArrangementName}}`;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn updatedVal;\n\t} else if (matchedUomObj && matchedUOMName) {\n\t\tupdatedVal = propertyHasFormatter ? `{= ${propertyName}}` : `{${propertyName}}`;\n\t\tif (!matchedUOM?.startsWith(\"format.unit(\")) {\n\t\t\tupdatedVal += matchedUOMHasFormatter ? ` {= ${matchedUOM}}` : ` {${matchedUOMName}}`;\n\t\t}\n\t\treturn getFormattedValue(updatedVal, propertyHasFormatter, matchedUOMHasFormatter, isUoMBoolean);\n\t} else if (matchedArrangementObj) {\n\t\tswitch (matchedArrangementObj.textArrangement) {\n\t\t\tcase \"TextLast\":\n\t\t\t\tupdatedVal += propertyHasFormatter ? `{= ${propertyName}}` : `{${propertyName}}`;\n\t\t\t\tupdatedVal += matchedArrangementHasFormatter ? ` ({= ${matchedArrangement}})` : ` ({${matchedArrangementName}})`;\n\t\t\t\tbreak;\n\t\t\tcase \"TextFirst\":\n\t\t\t\tupdatedVal = matchedArrangementHasFormatter ? `{= ${matchedArrangement}}` : `{${matchedArrangementName}}`;\n\t\t\t\tupdatedVal += propertyHasFormatter ? ` ({= ${propertyName}})` : ` ({${propertyName}})`;\n\t\t\t\tbreak;\n\t\t\tcase \"TextSeparate\":\n\t\t\t\tupdatedVal += propertyHasFormatter ? `{= ${propertyName}}` : `{${propertyName}}`;\n\t\t\t\tbreak;\n\t\t\tcase \"TextOnly\":\n\t\t\t\tupdatedVal = matchedArrangementHasFormatter ? `{= ${matchedArrangement}}` : `{${matchedArrangementName}}`;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn updatedVal;\n\t}\n\tif (isPropertyBoolean) {\n\t\treturn getExpressionBindingForBooleanTypes(propertyName);\n\t}\n\n\treturn propertyHasBinding ? (propertyHasFormatter ? `{= ${propertyName}}` : `{${propertyName}}`) : propertyName;\n}\n\n/**\n * This function checks if the property is boolean type\n *\n * @param {JSONModel} model\n * @param {string} propertyName\n * @returns {boolean}\n */\n\nfunction isBooleanProperty(model: JSONModel, propertyName: string) {\n\tconst properties = model?.getProperty(\"/configuration/properties\");\n\tpropertyName = propertyName.replace(/[{}]/g, \"\");\n\tconst getProperty = (properties, name: string) => {\n\t\treturn properties?.find((property) => property.name === name);\n\t};\n\tconst property = getProperty(properties, propertyName);\n\tif (property) {\n\t\treturn property.type === \"Edm.Boolean\";\n\t}\n\n\tif (propertyName.includes(\"/\")) {\n\t\tconst propertyParts = propertyName.split(\"/\");\n\t\tconst selectedNavProperty = propertyParts[0];\n\t\tconst selectedProperty = propertyParts[1];\n\t\tconst navigationalProperties = model?.getProperty(\"/configuration/navigationProperty\");\n\t\tconst selectedNavPropertyObj = getProperty(navigationalProperties, selectedNavProperty);\n\t\tconst propertiesOfNavProperty = selectedNavPropertyObj?.properties;\n\n\t\tif (propertiesOfNavProperty && Array.isArray(propertiesOfNavProperty)) {\n\t\t\tconst selectedPropertyObj = getProperty(propertiesOfNavProperty, selectedProperty);\n\t\t\treturn selectedPropertyObj.type === \"Edm.Boolean\";\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * This function returns the binding expression for boolean type\n *\n * @param {string} propertyName\n * @returns {string}\n */\nexport function getExpressionBindingForBooleanTypes(propertyName: string) {\n\tconst expressionBinding = `{= \\${${propertyName}} === true ? '{{parameters._yesText}}' : '{{parameters._noText}}'}`;\n\treturn expressionBinding;\n}\n\n/**\n * Retrieves the formatted value based on the provided parameters.\n *\n * @param updatedVal - The updated value to be formatted.\n * @param propertyHasFormatter - A boolean indicating whether the property has a formatter.\n * @param matchedUOMHasFormatter - A boolean indicating whether the matched unit of measure has a formatter.\n * @param isUoMBoolean - A boolean indicating whether the Unit of Measure (UoM) is represented as a boolean expression.\n * @returns The formatted value as a binding string in the format '{= format.unit(${property}, ${uom})}'.\n *          1. When isUoMBoolean is true with formatter: '{= format.unit(${gross_amount}, ${Activation_ac} === true ? \\'Yes\\' : \\'No\\', {\"decimals\":1,\"style\":\"long\"})}'\n *          2. When isUoMBoolean is true without formatter: \"{= format.unit(${LanguageForEdit}, ${HasDraftEntity} === true ? 'Yes' : 'No')}\"\n */\n\nfunction getFormattedValue(updatedVal: string, propertyHasFormatter: boolean, matchedUOMHasFormatter: boolean, isUoMBoolean: boolean) {\n\tconst parts = isUoMBoolean ? updatedVal.split(\" {= \") : updatedVal.split(\" \");\n\tlet property = \"\",\n\t\tuom = \"\";\n\tif (parts.length === 2) {\n\t\tproperty = parts[0];\n\t\tuom = parts[1];\n\t}\n\n\tif (propertyHasFormatter) {\n\t\tconst formatFloat = updatedVal.startsWith(\"{= format.float(\");\n\t\tconst formatUnit = updatedVal.startsWith(\"{= format.unit(\");\n\n\t\tif ((formatFloat || formatUnit) && !matchedUOMHasFormatter) {\n\t\t\tconst index = updatedVal.indexOf(\"} {\");\n\t\t\tlet part1 = updatedVal.slice(0, index + 1);\n\t\t\tlet part2 = updatedVal.slice(index + 2);\n\t\t\tif (isUoMBoolean) {\n\t\t\t\tpart2 = part2.slice(4, -1);\n\t\t\t}\n\t\t\tpart1 = part1.replace(\"format.float(\", \"format.unit(\");\n\n\t\t\tconst parts = part1.split(\", \");\n\t\t\tif (parts.length === 2) {\n\t\t\t\treturn formatFloat ? part1.replace(\", {\", \", $\" + part2 + \", {\") : parts[0].concat(\", $\" + part2 + \")}\");\n\t\t\t} else if (parts.length === 3) {\n\t\t\t\treturn part2 ? parts[0].concat(\", $\" + part2 + \", \").concat(parts[2]) : part1;\n\t\t\t}\n\t\t\treturn updatedVal;\n\t\t}\n\t\treturn updatedVal;\n\t}\n\n\tif (isUoMBoolean) {\n\t\treturn \"{= format.unit($\" + property + \", \" + uom.slice(0, -1) + \")}\";\n\t} else {\n\t\treturn \"{= format.unit($\" + property + \", $\" + uom + \")}\";\n\t}\n}\n\n/**\n * Extracts the property path without unit of measure\n * \t - The property is in the format {propertyPath} {uomPath}\n *\n * @param property\n * @returns {string}\n */\nexport function extractPathWithoutUOM(property: string) {\n\treturn extractPathExpressionWithoutUOM(property).replace(/[{}]/g, \"\"); // Remove curly braces\n}\n\n/**\n * Extracts the property path expression without unit of measure\n * \t - The property is in the format {propertyPath} {uomPath}\n *\n * @param property\n * @returns {string}\n */\nexport function extractPathExpressionWithoutUOM(property: string) {\n\tconst hasUOM = property.includes(\"} {\");\n\treturn hasUOM ? property.substring(0, property.indexOf(\"} {\") + 1) : property;\n}\n\n/**\n * Extracts parts of an expression\n *\n * @param expression\n * @returns {string[]}\n */\nexport function getExpressionParts(expression: string) {\n\tconst startSymbols = [\"{=\", \"{\", \"(\", \"${\"];\n\tconst endSymbols = [\"}\", \")\"];\n\tconst parts = [];\n\tlet count = 0,\n\t\tpart = \"\",\n\t\tskipNext = false;\n\n\tfor (let i = 0; i < expression.length; i++) {\n\t\tif (skipNext) {\n\t\t\tskipNext = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (startSymbols.includes(expression[i])) {\n\t\t\tif (expression[i] === \"{\" && expression[i + 1] === \"=\") {\n\t\t\t\tpart += \"{=\";\n\t\t\t\tskipNext = true;\n\t\t\t} else {\n\t\t\t\tpart += expression[i];\n\t\t\t}\n\t\t\tcount++;\n\t\t} else if (endSymbols.includes(expression[i])) {\n\t\t\tpart += expression[i];\n\t\t\tcount--;\n\t\t} else {\n\t\t\tpart += expression[i];\n\t\t}\n\n\t\tif (count === 0) {\n\t\t\tif (part.trim().length !== 0) {\n\t\t\t\tparts.push(part);\n\t\t\t}\n\n\t\t\tpart = \"\";\n\t\t}\n\t}\n\treturn parts;\n}\n\n/**\n * Extracts the property path and formatter expression without text arrangement\n *\n * @param expression\n * @param mCardManifest\n *\n * @returns { propertyPath: string, formatterExpression: string[]}\n */\nexport function extractPropertyConfigurationWithoutTextArrangement(expression: string, mCardManifest: CardManifest) {\n\tconst textArrangementOptions: Array<ArrangementOptions> = getTextArrangementFromCardManifest(mCardManifest);\n\tconst parts = getExpressionParts(expression);\n\tlet textArrangementIndex = -1;\n\tconst propertyPaths: string[] = [];\n\tconst formatterExpression: string[] = [];\n\n\tparts.forEach((part, index) => {\n\t\tconst hasTextArrangement = part.trim().startsWith(\"(\") && part.trim().endsWith(\")\");\n\n\t\tif (hasTextArrangement) {\n\t\t\ttextArrangementIndex = index;\n\t\t\tconst hasFormatterBinding = hasFormatter(part.slice(1, -1));\n\n\t\t\tif (hasFormatterBinding) {\n\t\t\t\tformatterExpression.push(part.slice(1, -1));\n\t\t\t}\n\t\t\tpart = hasFormatterBinding ? parseFormatterExpression(part.slice(1, -1)).propertyPath : part.slice(1, -1);\n\t\t\tpart = \"({\" + part + \"})\";\n\t\t} else if (hasFormatter(part)) {\n\t\t\tformatterExpression.push(part);\n\t\t\tpart = \"{\" + parseFormatterExpression(part).propertyPath + \"}\";\n\t\t}\n\t\tpropertyPaths.push(part);\n\t});\n\n\tif (textArrangementIndex > -1) {\n\t\tlet remainingExpression = propertyPaths\n\t\t\t.slice(0, textArrangementIndex)\n\t\t\t.concat(propertyPaths.slice(textArrangementIndex + 1))\n\t\t\t.join(\" \");\n\t\tconst textArrangement = propertyPaths.slice(textArrangementIndex, textArrangementIndex + 1)[0];\n\t\tlet textArrangementProperty = \"\";\n\t\tif (hasBooleanBindingExpression(textArrangement)) {\n\t\t\ttextArrangementProperty = extractValueWithoutBooleanExprBinding(textArrangement);\n\t\t} else {\n\t\t\ttextArrangementProperty = textArrangement.trim().replace(/[({})]/g, \"\");\n\t\t}\n\t\tconst prop = textArrangementOptions.find((option) => textArrangementProperty === option.name);\n\t\tif (prop && prop.arrangementType === \"TextFirst\") {\n\t\t\tremainingExpression = remainingExpression.replace(prop.value, prop.name);\n\t\t}\n\t\treturn {\n\t\t\tpropertyPath: remainingExpression,\n\t\t\tformatterExpression\n\t\t};\n\t} else {\n\t\tconst propertyPathWithoutUOM = extractPathWithoutUOM(expression);\n\t\tconst matchedTextArrangement = textArrangementOptions.find((option) => propertyPathWithoutUOM === option.value);\n\t\tif (matchedTextArrangement && matchedTextArrangement.arrangementType === \"TextOnly\") {\n\t\t\treturn {\n\t\t\t\tpropertyPath: `{${matchedTextArrangement.name}}`,\n\t\t\t\tformatterExpression\n\t\t\t};\n\t\t}\n\t}\n\n\treturn {\n\t\tpropertyPath: expression,\n\t\tformatterExpression\n\t};\n}\n\n/**\n *  Resolves the property path with expression to simple property path\n * \t- If path is an expression, resolve the expression then return the path\n *  - If path is an expression with formatter, return the path after extracting the formatter\n * @param path\n * @param mCardManifest\n * @returns\n */\nexport function resolvePropertyPathFromExpression(path = \"\", mCardManifest: CardManifest) {\n\tlet { propertyPath } = extractPropertyConfigurationWithoutTextArrangement(path, mCardManifest);\n\tconst hasBinding = isExpression(path) || hasFormatter(path);\n\n\tif (hasBooleanBindingExpression(propertyPath)) {\n\t\tpropertyPath = extractValueWithoutBooleanExprBinding(propertyPath);\n\t}\n\n\tif (isExpression(propertyPath) && !hasFormatter(propertyPath)) {\n\t\tpropertyPath = extractPathWithoutUOM(propertyPath);\n\t}\n\n\tif (isExpression(propertyPath) && hasFormatter(propertyPath)) {\n\t\tconst formatterExpression = extractPathExpressionWithoutUOM(propertyPath);\n\t\tconst selectedFormatter = updateAndGetSelectedFormatters(formatterExpression);\n\t\tpropertyPath = selectedFormatter.property || \"\";\n\t}\n\n\treturn hasBinding ? `{${propertyPath}}` : propertyPath;\n}\n\nexport function getTextArrangementFromCardManifest(mManifest: CardManifest) {\n\tconst textArrangements = mManifest[\"sap.card\"].configuration?.parameters?._propertyFormatting as object | undefined;\n\n\tif (!textArrangements) {\n\t\treturn [];\n\t}\n\n\tconst textArrangementOptions: Array<ArrangementOptions> = [];\n\tObject.keys(textArrangements).forEach((property) => {\n\t\tconst arrangement = textArrangements[property].arrangements.text;\n\t\tconst arrangementType = Object.keys(arrangement).find((key) => arrangement[key]) || \"TextLast\";\n\t\tlet path = arrangement.path;\n\t\tlet isNavigationForId = false;\n\t\tlet isNavigationForDescription = false;\n\t\tlet propertyKeyForId = \"\";\n\t\tlet navigationKeyForId = \"\";\n\t\tlet navigationKeyForDescription = \"\";\n\t\tif (property.includes(\"/\")) {\n\t\t\tpropertyKeyForId = property.split(\"/\")[0];\n\t\t\tnavigationKeyForId = property.split(\"/\")[1];\n\t\t\tisNavigationForId = true;\n\t\t}\n\t\tif (path?.includes(\"/\")) {\n\t\t\tpath = arrangement.path.split(\"/\")[0];\n\t\t\tnavigationKeyForDescription = arrangement.path.split(\"/\")[1];\n\t\t\tisNavigationForDescription = true;\n\t\t}\n\t\ttextArrangementOptions.push({\n\t\t\tname: property,\n\t\t\tarrangementType,\n\t\t\tvalue: arrangement.path,\n\t\t\tpropertyKeyForDescription: path,\n\t\t\tpropertyKeyForId: property.includes(\"/\") ? propertyKeyForId : property,\n\t\t\ttextArrangement: arrangementType,\n\t\t\tisNavigationForId,\n\t\t\tisNavigationForDescription,\n\t\t\tnavigationKeyForId,\n\t\t\tnavigationKeyForDescription,\n\t\t\tnavigationalPropertiesForDescription: [],\n\t\t\tnavigationalPropertiesForId: []\n\t\t});\n\t});\n\treturn textArrangementOptions;\n}\n\n/**\n * Parses the formatter expression and returns the formatter name, property path and parameters\n *\n * @param path\n * @returns\n */\nexport function parseFormatterExpression(path = \"\"): ParsedFormatterExpression {\n\tconst formatterOptions = getFormatterConfiguration();\n\tconst formatterName = path.split(\"{=\")[1]?.split(\"(\")[0]?.trim();\n\n\tif (!formatterName) {\n\t\treturn {\n\t\t\tformatterName: \"\",\n\t\t\tpropertyPath: \"\",\n\t\t\tparameters: []\n\t\t};\n\t}\n\n\tconst selectedFormatter = formatterOptions.find((formatter) => formatter.formatterName === formatterName);\n\tconst bindingInfo = BindingParser.complexParser(path);\n\tconst propertyPath: string = bindingInfo?.parts[0].path;\n\tconst propertyExpression = \"${\" + propertyPath + \"}\";\n\tconst parameters: Array<FormatterConfigParameters> = [];\n\n\tlet bindingPartial = path;\n\tbindingPartial = path.trim().replace(\"{=\", \"\");\n\tbindingPartial = bindingPartial.substring(0, bindingPartial.lastIndexOf(\"}\"));\n\tbindingPartial = bindingPartial.replace(`${formatterName}(`, \"\");\n\tbindingPartial = bindingPartial.substring(0, bindingPartial.lastIndexOf(\")\"));\n\n\tlet parametersExpression = bindingPartial.replace(`${propertyExpression}`, \"\").trim();\n\tconst hasParameters = parametersExpression.length > 0;\n\n\tif (hasParameters) {\n\t\tconst formatterParameters = selectedFormatter?.parameters || [];\n\t\tfor (const parameter of formatterParameters) {\n\t\t\tif (parameter.type === \"object\") {\n\t\t\t\tconst startIndex = parametersExpression.indexOf(\"{\");\n\t\t\t\tconst endIndex = parametersExpression.indexOf(\"}\");\n\t\t\t\tconst options = parametersExpression.substring(startIndex, endIndex + 1);\n\t\t\t\tparametersExpression = parametersExpression.substring(endIndex + 1);\n\t\t\t\ttry {\n\t\t\t\t\tparameters.push(JSON.parse(options) as JSONObject);\n\t\t\t\t} catch {\n\t\t\t\t\tLog.error(\"Error in parsing the formatter options\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parameter.type === \"string\") {\n\t\t\t\tconst startIndex = parametersExpression.indexOf(\",\");\n\t\t\t\tparametersExpression = parametersExpression.substring(startIndex + 1);\n\t\t\t\tlet endIndex = parametersExpression.indexOf(\",\");\n\t\t\t\tlet options;\n\t\t\t\tif (endIndex !== -1) {\n\t\t\t\t\toptions = parametersExpression.substring(0, endIndex).trim();\n\t\t\t\t} else {\n\t\t\t\t\tendIndex = parametersExpression.indexOf(\"}\");\n\t\t\t\t\toptions = parametersExpression.substring(0, endIndex + 1).trim();\n\t\t\t\t}\n\t\t\t\tparametersExpression = parametersExpression.substring(endIndex + 1);\n\t\t\t\tparameters.push(options.replace(/['\"]+/g, \"\"));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tformatterName,\n\t\tpropertyPath,\n\t\tparameters\n\t};\n}\n\n/**\n * Updates the selected formatter with received parameters and returns the updated formatter\n *\n * @param propertyPath\n * @returns\n */\nexport function updateAndGetSelectedFormatters(propertyPath: string): FormatterConfiguration {\n\tconst formatterOptions = getFormatterConfiguration();\n\tconst formatterConfig = parseFormatterExpression(propertyPath);\n\tconst selectedFormatter = {\n\t\t...formatterOptions.find((options) => options.formatterName === formatterConfig.formatterName)\n\t} as FormatterConfiguration;\n\tselectedFormatter.property = formatterConfig.propertyPath;\n\n\tif (!selectedFormatter.parameters?.length) {\n\t\treturn selectedFormatter;\n\t}\n\n\tconst parametersLength = selectedFormatter.parameters.length;\n\tfor (let i = 0; i < parametersLength; i++) {\n\t\tconst formatterConfigParameters = formatterConfig.parameters;\n\t\tif (selectedFormatter.parameters[i].type === \"object\" && typeof formatterConfigParameters[i] === \"object\") {\n\t\t\tupdatePropertiesForObjectType(selectedFormatter, formatterConfigParameters, i);\n\t\t}\n\n\t\tif (selectedFormatter.parameters[i].type === \"string\" && typeof formatterConfigParameters[i] === \"string\") {\n\t\t\tselectedFormatter.parameters[i].value = formatterConfigParameters[i];\n\t\t}\n\t}\n\n\treturn selectedFormatter;\n}\n\n/**\n *  Updates the properties for the object type parameters\n *\n * @param selectedFormatter\n * @param formatterConfigParameters\n * @param index\n */\nfunction updatePropertiesForObjectType(\n\tselectedFormatter: FormatterConfiguration,\n\tformatterConfigParameters: Array<FormatterConfigParameters>,\n\tindex: number\n) {\n\tconst properties = selectedFormatter!.parameters![index].properties;\n\n\tproperties?.forEach((property) => {\n\t\tif (property.type === \"boolean\") {\n\t\t\tproperty[\"selected\"] = (formatterConfigParameters[index] as JSONObject)[property.name] as boolean;\n\t\t} else if (property.type === \"enum\") {\n\t\t\tproperty[\"selectedKey\"] = (formatterConfigParameters[index] as JSONObject)[property.name] as string;\n\t\t} else {\n\t\t\tproperty[\"value\"] =\n\t\t\t\ttypeof formatterConfigParameters === \"object\"\n\t\t\t\t\t? ((formatterConfigParameters[index] as JSONObject)[property.name] as string)\n\t\t\t\t\t: formatterConfigParameters[index];\n\t\t}\n\t});\n}\n"],"mappings":"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","ignoreList":[]}