{"version":3,"file":"PropertyExpression-dbg-dbg.js","names":["sap","ui","define","Log","BindingParser","___config_FormatterOptions","___utils_CommonUtils","___Formatter","getFormatterConfiguration","extractValueWithoutBooleanExprBinding","getDialogModel","hasBooleanBindingExpression","createFormatterExpression","isExpression","propertyValue","startsWith","isI18nExpression","endsWith","hasFormatter","includes","formatValue","propertyName","propertyValueFormatters","oMatchedFormatterDetail","find","oFormatterDetail","property","getArrangements","options","model","isPropertyBoolean","isBooleanProperty","unitOfMeasures","textArrangements","propertyHasBinding","replace","matchedUomObj","arrangement","name","matchedUOMName","value","matchedArrangementObj","textArrangement","matchedArrangementName","propertyHasFormatter","matchedUOMHasFormatter","matchedArrangementHasFormatter","matchedUOM","matchedArrangement","updatedVal","isArrangementBoolean","isUoMBoolean","getExpressionBindingForBooleanTypes","slice","getFormattedValue","index","indexOf","formattedValue","properties","getProperty","type","propertyParts","split","selectedNavProperty","selectedProperty","navigationalProperties","selectedNavPropertyObj","propertiesOfNavProperty","Array","isArray","selectedPropertyObj","expressionBinding","parts","uom","length","formatFloat","formatUnit","part1","part2","concat","extractPathWithoutUOM","extractPathExpressionWithoutUOM","hasUOM","substring","getExpressionParts","expression","startSymbols","endSymbols","count","part","skipNext","i","trim","push","extractPropertyConfigurationWithoutTextArrangement","mCardManifest","textArrangementOptions","getTextArrangementFromCardManifest","textArrangementIndex","propertyPaths","formatterExpression","forEach","hasTextArrangement","hasFormatterBinding","parseFormatterExpression","propertyPath","remainingExpression","join","textArrangementProperty","prop","option","arrangementType","propertyPathWithoutUOM","matchedTextArrangement","resolvePropertyPathFromExpression","path","hasBinding","selectedFormatter","updateAndGetSelectedFormatters","mManifest","configuration","parameters","_propertyFormatting","Object","keys","arrangements","text","key","isNavigationForId","isNavigationForDescription","propertyKeyForId","navigationKeyForId","navigationKeyForDescription","propertyKeyForDescription","navigationalPropertiesForDescription","navigationalPropertiesForId","formatterOptions","formatterName","formatter","bindingInfo","complexParser","propertyExpression","bindingPartial","lastIndexOf","parametersExpression","hasParameters","formatterParameters","parameter","startIndex","endIndex","JSON","parse","error","formatterConfig","parametersLength","formatterConfigParameters","updatePropertiesForObjectType","__exports","__esModule"],"sources":["PropertyExpression.ts"],"sourcesContent":["/*!\n * SAP UI development toolkit for HTML5 (SAPUI5)\n *  * (c) Copyright 2009-2025 SAP SE. All rights reserved\n */\nimport Log from \"sap/base/Log\";\nimport BindingParser from \"sap/ui/base/BindingParser\";\nimport { CardManifest } from \"sap/ui/integration/widgets/Card\";\nimport JSONModel from \"sap/ui/model/json/JSONModel\";\nimport { ArrangementOptions } from \"../app/controls/ArrangementsEditor\";\nimport { getFormatterConfiguration } from \"../config/FormatterOptions\";\nimport { extractValueWithoutBooleanExprBinding, getDialogModel, hasBooleanBindingExpression } from \"../utils/CommonUtils\";\nimport type { FormatterConfiguration, FormatterConfigurationMap } from \"./Formatter\";\nimport { createFormatterExpression } from \"./Formatter\";\n\ntype JSONObject = {\n\t[key: string]: string | boolean | number;\n};\n\ntype FormatterConfigParameters = string | JSONObject;\n\ntype ParsedFormatterExpression = {\n\tformatterName: string;\n\tpropertyPath: string;\n\tparameters: Array<FormatterConfigParameters>;\n};\n\ntype PropertyFormattingOptions = {\n\tunitOfMeasures: Array<{\n\t\t[key: string]: string;\n\t}>;\n\ttextArrangements: ArrangementOptions[];\n\tpropertyValueFormatters: FormatterConfigurationMap;\n};\n\n/**\n * This function checks if the property value is an expression\n *\n * @param {string} propertyValue\n * @returns {boolean}\n */\nexport function isExpression(propertyValue = \"\"): boolean {\n\treturn propertyValue.startsWith(\"{\");\n}\n\n/**\n * This function checks if the property value is an i18n expression\n *\n * @param {string} propertyValue\n * @returns {boolean}\n */\nexport function isI18nExpression(propertyValue = \"\"): boolean {\n\treturn propertyValue.startsWith(\"{{\") && propertyValue.endsWith(\"}}\");\n}\n\n/**\n * The function checks if the property value has a formatter\n *\n * @param propertyValue\n * @returns\n */\nexport function hasFormatter(propertyValue = \"\"): boolean {\n\treturn (\n\t\tpropertyValue.startsWith(\"{=\") &&\n\t\tpropertyValue.endsWith(\"}\") &&\n\t\t(propertyValue.includes(\"format.\") || propertyValue.includes(\"extension.formatters.\"))\n\t);\n}\n\n/**\n * format the value based on the formatter configuration\n * @param {string} propertyName\n * @param {FormatterConfigurationMap} propertyValueFormatters\n * @returns\n */\nfunction formatValue(propertyName: string, propertyValueFormatters: FormatterConfigurationMap = []) {\n\tconst oMatchedFormatterDetail = propertyValueFormatters.find(function (oFormatterDetail: FormatterConfiguration) {\n\t\treturn oFormatterDetail.property === propertyName || \"{\" + oFormatterDetail.property + \"}\" === propertyName;\n\t});\n\n\tif (oMatchedFormatterDetail) {\n\t\treturn createFormatterExpression(oMatchedFormatterDetail);\n\t}\n\treturn propertyName;\n}\n\n/**\n * Apply text arrangement, UOM and formatter to the property\n * @param {string} propertyName\n * @param {PropertyFormattingOptions} options\n * @returns {string}\n */\nexport function getArrangements(propertyName: string, options: PropertyFormattingOptions) {\n\tconst model = getDialogModel() as JSONModel;\n\tconst isPropertyBoolean = isBooleanProperty(model, propertyName);\n\tconst { unitOfMeasures, textArrangements, propertyValueFormatters } = options;\n\tconst propertyHasBinding = propertyName.startsWith(\"{\");\n\tpropertyName = propertyName.replace(/[{}]/g, \"\");\n\n\tconst matchedUomObj = unitOfMeasures.find(function (arrangement: any) {\n\t\treturn arrangement.name === propertyName;\n\t});\n\tlet matchedUOMName = matchedUomObj?.value?.replace(/[{}]/g, \"\");\n\tconst matchedArrangementObj = textArrangements.find((arrangement) => {\n\t\tif (arrangement.value && arrangement.textArrangement) {\n\t\t\treturn arrangement.name === propertyName;\n\t\t}\n\t});\n\tlet matchedArrangementName = matchedArrangementObj?.value?.replace(/[{}]/g, \"\");\n\n\tlet propertyHasFormatter = false;\n\tlet matchedUOMHasFormatter = false;\n\tlet matchedArrangementHasFormatter = false;\n\tconst property = propertyName;\n\tpropertyName = propertyName && formatValue(propertyName, propertyValueFormatters);\n\tif (propertyName !== property) {\n\t\tpropertyHasFormatter = true;\n\t}\n\n\tconst matchedUOM = matchedUomObj && formatValue(matchedUOMName ?? \"\", propertyValueFormatters);\n\tif (matchedUOMName !== matchedUOM) {\n\t\tmatchedUOMHasFormatter = true;\n\t}\n\tconst matchedArrangement = matchedArrangementName && formatValue(matchedArrangementName, propertyValueFormatters);\n\tif (matchedArrangementName !== matchedArrangement) {\n\t\tmatchedArrangementHasFormatter = true;\n\t}\n\n\tlet updatedVal = \"\";\n\tconst isArrangementBoolean = isBooleanProperty(model, matchedArrangementName ?? \"\");\n\tconst isUoMBoolean = isBooleanProperty(model, matchedUOMName ?? \"\");\n\n\tif (matchedArrangementObj || (matchedUomObj && matchedUOMName)) {\n\t\tif (isPropertyBoolean) {\n\t\t\tpropertyName = getExpressionBindingForBooleanTypes(propertyName).slice(1, -1);\n\t\t}\n\t\tif (isArrangementBoolean) {\n\t\t\tmatchedArrangementName = getExpressionBindingForBooleanTypes(matchedArrangementName ?? \"\").slice(1, -1);\n\t\t}\n\t\tif (isUoMBoolean) {\n\t\t\tmatchedUOMName = getExpressionBindingForBooleanTypes(matchedUOMName ?? \"\").slice(1, -1);\n\t\t}\n\t}\n\n\tif (matchedUomObj && matchedArrangementObj) {\n\t\tswitch (matchedArrangementObj.textArrangement) {\n\t\t\tcase \"TextLast\":\n\t\t\t\tupdatedVal += propertyHasFormatter ? `{= ${propertyName}}` : `{${propertyName}}`;\n\t\t\t\tupdatedVal += matchedUOMHasFormatter ? ` {= ${matchedUOM}}` : ` {${matchedUOMName}}`;\n\t\t\t\tupdatedVal = getFormattedValue(updatedVal, propertyHasFormatter, matchedUOMHasFormatter, isUoMBoolean);\n\t\t\t\tupdatedVal += matchedArrangementHasFormatter ? ` ({= ${matchedArrangement}})` : ` ({${matchedArrangementName}})`;\n\t\t\t\tbreak;\n\t\t\tcase \"TextFirst\":\n\t\t\t\tupdatedVal = matchedArrangementHasFormatter ? `{= ${matchedArrangement}} (` : `{${matchedArrangementName}} (`;\n\t\t\t\tupdatedVal += propertyHasFormatter ? `{= ${propertyName}}` : `{${propertyName}}`;\n\t\t\t\tupdatedVal += matchedUOMHasFormatter ? ` {= ${matchedUOM}}` : ` {${matchedUOMName}}`;\n\t\t\t\tconst index = updatedVal.indexOf(\" (\");\n\t\t\t\tconst formattedValue = getFormattedValue(\n\t\t\t\t\tupdatedVal.slice(index + 2),\n\t\t\t\t\tpropertyHasFormatter,\n\t\t\t\t\tmatchedUOMHasFormatter,\n\t\t\t\t\tisUoMBoolean\n\t\t\t\t);\n\t\t\t\tupdatedVal = updatedVal.slice(0, index + 2) + formattedValue;\n\t\t\t\tupdatedVal += \")\";\n\t\t\t\tbreak;\n\t\t\tcase \"TextSeparate\":\n\t\t\t\tupdatedVal += propertyHasFormatter ? `{= ${propertyName}}` : `{${propertyName}}`;\n\t\t\t\tupdatedVal += matchedUOMHasFormatter ? ` {= ${matchedUOM}}` : ` {${matchedUOMName}}`;\n\t\t\t\tupdatedVal = getFormattedValue(updatedVal, propertyHasFormatter, matchedUOMHasFormatter, isUoMBoolean);\n\t\t\t\tbreak;\n\t\t\tcase \"TextOnly\":\n\t\t\t\tupdatedVal += matchedArrangementHasFormatter ? `{= ${matchedArrangement}}` : `{${matchedArrangementName}}`;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn updatedVal;\n\t} else if (matchedUomObj && matchedUOMName) {\n\t\tupdatedVal = propertyHasFormatter ? `{= ${propertyName}}` : `{${propertyName}}`;\n\t\tif (!matchedUOM?.startsWith(\"format.unit(\")) {\n\t\t\tupdatedVal += matchedUOMHasFormatter ? ` {= ${matchedUOM}}` : ` {${matchedUOMName}}`;\n\t\t}\n\t\treturn getFormattedValue(updatedVal, propertyHasFormatter, matchedUOMHasFormatter, isUoMBoolean);\n\t} else if (matchedArrangementObj) {\n\t\tswitch (matchedArrangementObj.textArrangement) {\n\t\t\tcase \"TextLast\":\n\t\t\t\tupdatedVal += propertyHasFormatter ? `{= ${propertyName}}` : `{${propertyName}}`;\n\t\t\t\tupdatedVal += matchedArrangementHasFormatter ? ` ({= ${matchedArrangement}})` : ` ({${matchedArrangementName}})`;\n\t\t\t\tbreak;\n\t\t\tcase \"TextFirst\":\n\t\t\t\tupdatedVal = matchedArrangementHasFormatter ? `{= ${matchedArrangement}}` : `{${matchedArrangementName}}`;\n\t\t\t\tupdatedVal += propertyHasFormatter ? ` ({= ${propertyName}})` : ` ({${propertyName}})`;\n\t\t\t\tbreak;\n\t\t\tcase \"TextSeparate\":\n\t\t\t\tupdatedVal += propertyHasFormatter ? `{= ${propertyName}}` : `{${propertyName}}`;\n\t\t\t\tbreak;\n\t\t\tcase \"TextOnly\":\n\t\t\t\tupdatedVal = matchedArrangementHasFormatter ? `{= ${matchedArrangement}}` : `{${matchedArrangementName}}`;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn updatedVal;\n\t}\n\tif (isPropertyBoolean) {\n\t\treturn getExpressionBindingForBooleanTypes(propertyName);\n\t}\n\n\treturn propertyHasBinding ? (propertyHasFormatter ? `{= ${propertyName}}` : `{${propertyName}}`) : propertyName;\n}\n\n/**\n * This function checks if the property is boolean type\n *\n * @param {JSONModel} model\n * @param {string} propertyName\n * @returns {boolean}\n */\n\nfunction isBooleanProperty(model: JSONModel, propertyName: string) {\n\tconst properties = model?.getProperty(\"/configuration/properties\");\n\tpropertyName = propertyName.replace(/[{}]/g, \"\");\n\tconst getProperty = (properties, name: string) => {\n\t\treturn properties?.find((property) => property.name === name);\n\t};\n\tconst property = getProperty(properties, propertyName);\n\tif (property) {\n\t\treturn property.type === \"Edm.Boolean\";\n\t}\n\n\tif (propertyName.includes(\"/\")) {\n\t\tconst propertyParts = propertyName.split(\"/\");\n\t\tconst selectedNavProperty = propertyParts[0];\n\t\tconst selectedProperty = propertyParts[1];\n\t\tconst navigationalProperties = model?.getProperty(\"/configuration/navigationProperty\");\n\t\tconst selectedNavPropertyObj = getProperty(navigationalProperties, selectedNavProperty);\n\t\tconst propertiesOfNavProperty = selectedNavPropertyObj?.properties;\n\n\t\tif (propertiesOfNavProperty && Array.isArray(propertiesOfNavProperty)) {\n\t\t\tconst selectedPropertyObj = getProperty(propertiesOfNavProperty, selectedProperty);\n\t\t\treturn selectedPropertyObj.type === \"Edm.Boolean\";\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * This function returns the binding expression for boolean type\n *\n * @param {string} propertyName\n * @returns {string}\n */\nexport function getExpressionBindingForBooleanTypes(propertyName: string) {\n\tconst expressionBinding = `{= \\${${propertyName}} === true ? '{{parameters._yesText}}' : '{{parameters._noText}}'}`;\n\treturn expressionBinding;\n}\n\n/**\n * Retrieves the formatted value based on the provided parameters.\n *\n * @param updatedVal - The updated value to be formatted.\n * @param propertyHasFormatter - A boolean indicating whether the property has a formatter.\n * @param matchedUOMHasFormatter - A boolean indicating whether the matched unit of measure has a formatter.\n * @param isUoMBoolean - A boolean indicating whether the Unit of Measure (UoM) is represented as a boolean expression.\n * @returns The formatted value as a binding string in the format '{= format.unit(${property}, ${uom})}'.\n *          1. When isUoMBoolean is true with formatter: '{= format.unit(${gross_amount}, ${Activation_ac} === true ? \\'Yes\\' : \\'No\\', {\"decimals\":1,\"style\":\"long\"})}'\n *          2. When isUoMBoolean is true without formatter: \"{= format.unit(${LanguageForEdit}, ${HasDraftEntity} === true ? 'Yes' : 'No')}\"\n */\n\nfunction getFormattedValue(updatedVal: string, propertyHasFormatter: boolean, matchedUOMHasFormatter: boolean, isUoMBoolean: boolean) {\n\tconst parts = isUoMBoolean ? updatedVal.split(\" {= \") : updatedVal.split(\" \");\n\tlet property = \"\",\n\t\tuom = \"\";\n\tif (parts.length === 2) {\n\t\tproperty = parts[0];\n\t\tuom = parts[1];\n\t}\n\n\tif (propertyHasFormatter) {\n\t\tconst formatFloat = updatedVal.startsWith(\"{= format.float(\");\n\t\tconst formatUnit = updatedVal.startsWith(\"{= format.unit(\");\n\n\t\tif ((formatFloat || formatUnit) && !matchedUOMHasFormatter) {\n\t\t\tconst index = updatedVal.indexOf(\"} {\");\n\t\t\tlet part1 = updatedVal.slice(0, index + 1);\n\t\t\tlet part2 = updatedVal.slice(index + 2);\n\t\t\tif (isUoMBoolean) {\n\t\t\t\tpart2 = part2.slice(4, -1);\n\t\t\t}\n\t\t\tpart1 = part1.replace(\"format.float(\", \"format.unit(\");\n\n\t\t\tconst parts = part1.split(\", \");\n\t\t\tif (parts.length === 2) {\n\t\t\t\treturn formatFloat ? part1.replace(\", {\", \", $\" + part2 + \", {\") : parts[0].concat(\", $\" + part2 + \")}\");\n\t\t\t} else if (parts.length === 3) {\n\t\t\t\treturn part2 ? parts[0].concat(\", $\" + part2 + \", \").concat(parts[2]) : part1;\n\t\t\t}\n\t\t\treturn updatedVal;\n\t\t}\n\t\treturn updatedVal;\n\t}\n\n\tif (isUoMBoolean) {\n\t\treturn \"{= format.unit($\" + property + \", \" + uom.slice(0, -1) + \")}\";\n\t} else {\n\t\treturn \"{= format.unit($\" + property + \", $\" + uom + \")}\";\n\t}\n}\n\n/**\n * Extracts the property path without unit of measure\n * \t - The property is in the format {propertyPath} {uomPath}\n *\n * @param property\n * @returns {string}\n */\nexport function extractPathWithoutUOM(property: string) {\n\treturn extractPathExpressionWithoutUOM(property).replace(/[{}]/g, \"\"); // Remove curly braces\n}\n\n/**\n * Extracts the property path expression without unit of measure\n * \t - The property is in the format {propertyPath} {uomPath}\n *\n * @param property\n * @returns {string}\n */\nexport function extractPathExpressionWithoutUOM(property: string) {\n\tconst hasUOM = property.includes(\"} {\");\n\treturn hasUOM ? property.substring(0, property.indexOf(\"} {\") + 1) : property;\n}\n\n/**\n * Extracts parts of an expression\n *\n * @param expression\n * @returns {string[]}\n */\nexport function getExpressionParts(expression: string) {\n\tconst startSymbols = [\"{=\", \"{\", \"(\", \"${\"];\n\tconst endSymbols = [\"}\", \")\"];\n\tconst parts = [];\n\tlet count = 0,\n\t\tpart = \"\",\n\t\tskipNext = false;\n\n\tfor (let i = 0; i < expression.length; i++) {\n\t\tif (skipNext) {\n\t\t\tskipNext = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (startSymbols.includes(expression[i])) {\n\t\t\tif (expression[i] === \"{\" && expression[i + 1] === \"=\") {\n\t\t\t\tpart += \"{=\";\n\t\t\t\tskipNext = true;\n\t\t\t} else {\n\t\t\t\tpart += expression[i];\n\t\t\t}\n\t\t\tcount++;\n\t\t} else if (endSymbols.includes(expression[i])) {\n\t\t\tpart += expression[i];\n\t\t\tcount--;\n\t\t} else {\n\t\t\tpart += expression[i];\n\t\t}\n\n\t\tif (count === 0) {\n\t\t\tif (part.trim().length !== 0) {\n\t\t\t\tparts.push(part);\n\t\t\t}\n\n\t\t\tpart = \"\";\n\t\t}\n\t}\n\treturn parts;\n}\n\n/**\n * Extracts the property path and formatter expression without text arrangement\n *\n * @param expression\n * @param mCardManifest\n *\n * @returns { propertyPath: string, formatterExpression: string[]}\n */\nexport function extractPropertyConfigurationWithoutTextArrangement(expression: string, mCardManifest: CardManifest) {\n\tconst textArrangementOptions: Array<ArrangementOptions> = getTextArrangementFromCardManifest(mCardManifest);\n\tconst parts = getExpressionParts(expression);\n\tlet textArrangementIndex = -1;\n\tconst propertyPaths: string[] = [];\n\tconst formatterExpression: string[] = [];\n\n\tparts.forEach((part, index) => {\n\t\tconst hasTextArrangement = part.trim().startsWith(\"(\") && part.trim().endsWith(\")\");\n\n\t\tif (hasTextArrangement) {\n\t\t\ttextArrangementIndex = index;\n\t\t\tconst hasFormatterBinding = hasFormatter(part.slice(1, -1));\n\n\t\t\tif (hasFormatterBinding) {\n\t\t\t\tformatterExpression.push(part.slice(1, -1));\n\t\t\t}\n\t\t\tpart = hasFormatterBinding ? parseFormatterExpression(part.slice(1, -1)).propertyPath : part.slice(1, -1);\n\t\t\tpart = \"({\" + part + \"})\";\n\t\t} else if (hasFormatter(part)) {\n\t\t\tformatterExpression.push(part);\n\t\t\tpart = \"{\" + parseFormatterExpression(part).propertyPath + \"}\";\n\t\t}\n\t\tpropertyPaths.push(part);\n\t});\n\n\tif (textArrangementIndex > -1) {\n\t\tlet remainingExpression = propertyPaths\n\t\t\t.slice(0, textArrangementIndex)\n\t\t\t.concat(propertyPaths.slice(textArrangementIndex + 1))\n\t\t\t.join(\" \");\n\t\tconst textArrangement = propertyPaths.slice(textArrangementIndex, textArrangementIndex + 1)[0];\n\t\tlet textArrangementProperty = \"\";\n\t\tif (hasBooleanBindingExpression(textArrangement)) {\n\t\t\ttextArrangementProperty = extractValueWithoutBooleanExprBinding(textArrangement);\n\t\t} else {\n\t\t\ttextArrangementProperty = textArrangement.trim().replace(/[({})]/g, \"\");\n\t\t}\n\t\tconst prop = textArrangementOptions.find((option) => textArrangementProperty === option.name);\n\t\tif (prop && prop.arrangementType === \"TextFirst\") {\n\t\t\tremainingExpression = remainingExpression.replace(prop.value, prop.name);\n\t\t}\n\t\treturn {\n\t\t\tpropertyPath: remainingExpression,\n\t\t\tformatterExpression\n\t\t};\n\t} else {\n\t\tconst propertyPathWithoutUOM = extractPathWithoutUOM(expression);\n\t\tconst matchedTextArrangement = textArrangementOptions.find((option) => propertyPathWithoutUOM === option.value);\n\t\tif (matchedTextArrangement && matchedTextArrangement.arrangementType === \"TextOnly\") {\n\t\t\treturn {\n\t\t\t\tpropertyPath: `{${matchedTextArrangement.name}}`,\n\t\t\t\tformatterExpression\n\t\t\t};\n\t\t}\n\t}\n\n\treturn {\n\t\tpropertyPath: expression,\n\t\tformatterExpression\n\t};\n}\n\n/**\n *  Resolves the property path with expression to simple property path\n * \t- If path is an expression, resolve the expression then return the path\n *  - If path is an expression with formatter, return the path after extracting the formatter\n * @param path\n * @param mCardManifest\n * @returns\n */\nexport function resolvePropertyPathFromExpression(path = \"\", mCardManifest: CardManifest) {\n\tlet { propertyPath } = extractPropertyConfigurationWithoutTextArrangement(path, mCardManifest);\n\tconst hasBinding = isExpression(path) || hasFormatter(path);\n\n\tif (hasBooleanBindingExpression(propertyPath)) {\n\t\tpropertyPath = extractValueWithoutBooleanExprBinding(propertyPath);\n\t}\n\n\tif (isExpression(propertyPath) && !hasFormatter(propertyPath)) {\n\t\tpropertyPath = extractPathWithoutUOM(propertyPath);\n\t}\n\n\tif (isExpression(propertyPath) && hasFormatter(propertyPath)) {\n\t\tconst formatterExpression = extractPathExpressionWithoutUOM(propertyPath);\n\t\tconst selectedFormatter = updateAndGetSelectedFormatters(formatterExpression);\n\t\tpropertyPath = selectedFormatter.property || \"\";\n\t}\n\n\treturn hasBinding ? `{${propertyPath}}` : propertyPath;\n}\n\nexport function getTextArrangementFromCardManifest(mManifest: CardManifest) {\n\tconst textArrangements = mManifest[\"sap.card\"].configuration?.parameters?._propertyFormatting as object | undefined;\n\n\tif (!textArrangements) {\n\t\treturn [];\n\t}\n\n\tconst textArrangementOptions: Array<ArrangementOptions> = [];\n\tObject.keys(textArrangements).forEach((property) => {\n\t\tconst arrangement = textArrangements[property].arrangements.text;\n\t\tconst arrangementType = Object.keys(arrangement).find((key) => arrangement[key]) || \"TextLast\";\n\t\tlet path = arrangement.path;\n\t\tlet isNavigationForId = false;\n\t\tlet isNavigationForDescription = false;\n\t\tlet propertyKeyForId = \"\";\n\t\tlet navigationKeyForId = \"\";\n\t\tlet navigationKeyForDescription = \"\";\n\t\tif (property.includes(\"/\")) {\n\t\t\tpropertyKeyForId = property.split(\"/\")[0];\n\t\t\tnavigationKeyForId = property.split(\"/\")[1];\n\t\t\tisNavigationForId = true;\n\t\t}\n\t\tif (path?.includes(\"/\")) {\n\t\t\tpath = arrangement.path.split(\"/\")[0];\n\t\t\tnavigationKeyForDescription = arrangement.path.split(\"/\")[1];\n\t\t\tisNavigationForDescription = true;\n\t\t}\n\t\ttextArrangementOptions.push({\n\t\t\tname: property,\n\t\t\tarrangementType,\n\t\t\tvalue: arrangement.path,\n\t\t\tpropertyKeyForDescription: path,\n\t\t\tpropertyKeyForId: property.includes(\"/\") ? propertyKeyForId : property,\n\t\t\ttextArrangement: arrangementType,\n\t\t\tisNavigationForId,\n\t\t\tisNavigationForDescription,\n\t\t\tnavigationKeyForId,\n\t\t\tnavigationKeyForDescription,\n\t\t\tnavigationalPropertiesForDescription: [],\n\t\t\tnavigationalPropertiesForId: []\n\t\t});\n\t});\n\treturn textArrangementOptions;\n}\n\n/**\n * Parses the formatter expression and returns the formatter name, property path and parameters\n *\n * @param path\n * @returns\n */\nexport function parseFormatterExpression(path = \"\"): ParsedFormatterExpression {\n\tconst formatterOptions = getFormatterConfiguration();\n\tconst formatterName = path.split(\"{=\")[1]?.split(\"(\")[0]?.trim();\n\n\tif (!formatterName) {\n\t\treturn {\n\t\t\tformatterName: \"\",\n\t\t\tpropertyPath: \"\",\n\t\t\tparameters: []\n\t\t};\n\t}\n\n\tconst selectedFormatter = formatterOptions.find((formatter) => formatter.formatterName === formatterName);\n\tconst bindingInfo = BindingParser.complexParser(path);\n\tconst propertyPath: string = bindingInfo?.parts[0].path;\n\tconst propertyExpression = \"${\" + propertyPath + \"}\";\n\tconst parameters: Array<FormatterConfigParameters> = [];\n\n\tlet bindingPartial = path;\n\tbindingPartial = path.trim().replace(\"{=\", \"\");\n\tbindingPartial = bindingPartial.substring(0, bindingPartial.lastIndexOf(\"}\"));\n\tbindingPartial = bindingPartial.replace(`${formatterName}(`, \"\");\n\tbindingPartial = bindingPartial.substring(0, bindingPartial.lastIndexOf(\")\"));\n\n\tlet parametersExpression = bindingPartial.replace(`${propertyExpression}`, \"\").trim();\n\tconst hasParameters = parametersExpression.length > 0;\n\n\tif (hasParameters) {\n\t\tconst formatterParameters = selectedFormatter?.parameters || [];\n\t\tfor (const parameter of formatterParameters) {\n\t\t\tif (parameter.type === \"object\") {\n\t\t\t\tconst startIndex = parametersExpression.indexOf(\"{\");\n\t\t\t\tconst endIndex = parametersExpression.indexOf(\"}\");\n\t\t\t\tconst options = parametersExpression.substring(startIndex, endIndex + 1);\n\t\t\t\tparametersExpression = parametersExpression.substring(endIndex + 1);\n\t\t\t\ttry {\n\t\t\t\t\tparameters.push(JSON.parse(options) as JSONObject);\n\t\t\t\t} catch {\n\t\t\t\t\tLog.error(\"Error in parsing the formatter options\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parameter.type === \"string\") {\n\t\t\t\tconst startIndex = parametersExpression.indexOf(\",\");\n\t\t\t\tparametersExpression = parametersExpression.substring(startIndex + 1);\n\t\t\t\tlet endIndex = parametersExpression.indexOf(\",\");\n\t\t\t\tlet options;\n\t\t\t\tif (endIndex !== -1) {\n\t\t\t\t\toptions = parametersExpression.substring(0, endIndex).trim();\n\t\t\t\t} else {\n\t\t\t\t\tendIndex = parametersExpression.indexOf(\"}\");\n\t\t\t\t\toptions = parametersExpression.substring(0, endIndex + 1).trim();\n\t\t\t\t}\n\t\t\t\tparametersExpression = parametersExpression.substring(endIndex + 1);\n\t\t\t\tparameters.push(options.replace(/['\"]+/g, \"\"));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tformatterName,\n\t\tpropertyPath,\n\t\tparameters\n\t};\n}\n\n/**\n * Updates the selected formatter with received parameters and returns the updated formatter\n *\n * @param propertyPath\n * @returns\n */\nexport function updateAndGetSelectedFormatters(propertyPath: string): FormatterConfiguration {\n\tconst formatterOptions = getFormatterConfiguration();\n\tconst formatterConfig = parseFormatterExpression(propertyPath);\n\tconst selectedFormatter = {\n\t\t...formatterOptions.find((options) => options.formatterName === formatterConfig.formatterName)\n\t} as FormatterConfiguration;\n\tselectedFormatter.property = formatterConfig.propertyPath;\n\n\tif (!selectedFormatter.parameters?.length) {\n\t\treturn selectedFormatter;\n\t}\n\n\tconst parametersLength = selectedFormatter.parameters.length;\n\tfor (let i = 0; i < parametersLength; i++) {\n\t\tconst formatterConfigParameters = formatterConfig.parameters;\n\t\tif (selectedFormatter.parameters[i].type === \"object\" && typeof formatterConfigParameters[i] === \"object\") {\n\t\t\tupdatePropertiesForObjectType(selectedFormatter, formatterConfigParameters, i);\n\t\t}\n\n\t\tif (selectedFormatter.parameters[i].type === \"string\" && typeof formatterConfigParameters[i] === \"string\") {\n\t\t\tselectedFormatter.parameters[i].value = formatterConfigParameters[i];\n\t\t}\n\t}\n\n\treturn selectedFormatter;\n}\n\n/**\n *  Updates the properties for the object type parameters\n *\n * @param selectedFormatter\n * @param formatterConfigParameters\n * @param index\n */\nfunction updatePropertiesForObjectType(\n\tselectedFormatter: FormatterConfiguration,\n\tformatterConfigParameters: Array<FormatterConfigParameters>,\n\tindex: number\n) {\n\tconst properties = selectedFormatter!.parameters![index].properties;\n\n\tproperties?.forEach((property) => {\n\t\tif (property.type === \"boolean\") {\n\t\t\tproperty[\"selected\"] = (formatterConfigParameters[index] as JSONObject)[property.name] as boolean;\n\t\t} else if (property.type === \"enum\") {\n\t\t\tproperty[\"selectedKey\"] = (formatterConfigParameters[index] as JSONObject)[property.name] as string;\n\t\t} else {\n\t\t\tproperty[\"value\"] =\n\t\t\t\ttypeof formatterConfigParameters === \"object\"\n\t\t\t\t\t? ((formatterConfigParameters[index] as JSONObject)[property.name] as string)\n\t\t\t\t\t: formatterConfigParameters[index];\n\t\t}\n\t});\n}\n"],"mappings":"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","ignoreList":[]}