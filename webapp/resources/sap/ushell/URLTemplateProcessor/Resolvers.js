// Copyright (c) 2009-2025 SAP SE, All Rights Reserved
sap.ui.define(["sap/base/util/deepExtend","sap/ushell/URLTemplateProcessor/Functions","sap/ushell/URLTemplateProcessor/utils"],(e,n,t)=>{"use strict";let r;function o(e,n,t){let r=null;const o=[];let s=false;const a=n.join("/");r=e;if(typeof r==="undefined"){s=true}n.forEach((e,n)=>{if(s){return}o.push(e);if(!r.hasOwnProperty(e)){r=undefined;s=true;return}if(!r.hasOwnProperty(e)){throw new Error(`Cannot find path '${a}' in given structure: '${e}' seems to be missing in the object.`)}r=r[e]});return r}function s(e){return e.value}function a(e,n,t,o,s,a){const i=e.type;if(r[i]){return r[i](e,n,t,o,s,a)}throw new Error(`Cannot resolve unknown parameter type: '${i}'`)}function i(e,n,t,r,s,i){const u=e.value.map(e=>a(e,n,t,r,s,i));const c=e.pathType==="relative";const p=c?r:t;return o(p,u,n)}function u(t,r,o,s,i,u){const c=t.value;if(c[0].type!=="wildcard"){throw new Error("Leading wildcard expected in pipe expression")}if(c[0].value!=="*"){throw new Error(`Unsupported wildcard expression: ${c[0].value}`)}return c.slice(1).reduce((e,t)=>{if(t.type!=="function"){throw new Error("Invalid operation specified in pipe expression")}return n.applyFunctionInPipeContext(t.name,t.args.map(e=>a(e,r,o,s,i,u)),e)},e({},i[u]||{}))}function c(e,t,r,o,s,i){const u=e.name;const c=e.args.map(e=>a(e,t,r,o,s,i));const p=e.params.map(e=>a(e,t,r,o,s,i));return n.applyFunctionInValueContext(u,c,p)}function p(e,n,t,o,s,i){const u=e.value;if(r[u.type]){return a(u,n,t,o,s,i)}throw new Error(`unknown expression type: ${u.type}`)}function l(e,n,t,r,o,s){const a=e.value;if(!e.hasOwnProperty("namespace")){return n[a]}const i=e.namespace;const u=`The template attemps to take the value '${a}' from '${i}' namespace.`;if(!o.hasOwnProperty(i)){throw new Error(`${u} However this value was not defined at runtime. The template should reference only defined values.`)}const c=o[i];const p=a===".";if(p){return c}if(typeof c!=="object"){throw new Error(`${u} However the runtime did not define the namespace as an object. The template cannot access the desired value using the object notation in this case.`)}return c[a]}r={literal:s,expression:p,reference:l,function:c,path:i,pipe:u};function f(e,n,t,r,o,s){const i={};n.forEach(n=>{const u=e[n];const c=a(u,i,t,o,r,s);i[n]=c});return i}return{resolveLiteral:s,resolveExpression:p,resolveReference:l,resolveFunction:c,resolvePath:i,resolvePipe:u,resolveParameterValue:a,resolveAllParameters:f}});
//# sourceMappingURL=Resolvers.js.map