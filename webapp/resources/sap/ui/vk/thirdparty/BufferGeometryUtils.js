/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
sap.ui.define(["./three"],function(t){"use strict";var e=function(t,e){"use strict";function r(t,r,o=true){if(!r||!r.isReady){throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.")}if(!t.hasAttribute("position")||!t.hasAttribute("normal")||!t.hasAttribute("uv")){throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.')}function n(t){if(t.normalized||t.isInterleavedBufferAttribute){const e=new Float32Array(t.count*t.itemSize);for(let r=0,o=0;r<t.count;r++){e[o++]=t.getX(r);e[o++]=t.getY(r);if(t.itemSize>2){e[o++]=t.getZ(r)}}return e}if(t.array instanceof Float32Array){return t.array}return new Float32Array(t.array)}const s=t.index?t.toNonIndexed():t;const i=r.generateTangents(n(s.attributes.position),n(s.attributes.normal),n(s.attributes.uv));if(o){for(let t=3;t<i.length;t+=4){i[t]*=-1}}s.setAttribute("tangent",new e.BufferAttribute(i,4));if(t!==s){t.copy(s)}return t}function o(t,r=false){const o=t[0].index!==null;const s=new Set(Object.keys(t[0].attributes));const i=new Set(Object.keys(t[0].morphAttributes));const u={};const c={};const a=t[0].morphTargetsRelative;const f=new e.BufferGeometry;let l=0;for(let e=0;e<t.length;++e){const n=t[e];let m=0;if(o!==(n.index!==null)){console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");return null}for(const t in n.attributes){if(!s.has(t)){console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+'. All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.');return null}if(u[t]===undefined)u[t]=[];u[t].push(n.attributes[t]);m++}if(m!==s.size){console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". Make sure all geometries have the same number of attributes.");return null}if(a!==n.morphTargetsRelative){console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". .morphTargetsRelative must be consistent throughout all geometries.");return null}for(const t in n.morphAttributes){if(!i.has(t)){console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+".  .morphAttributes must be consistent throughout all geometries.");return null}if(c[t]===undefined)c[t]=[];c[t].push(n.morphAttributes[t])}if(r){let t;if(o){t=n.index.count}else if(n.attributes.position!==undefined){t=n.attributes.position.count}else{console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". The geometry must have either an index or a position attribute");return null}f.addGroup(l,t,e);l+=t}}if(o){let e=0;const r=[];for(let o=0;o<t.length;++o){const n=t[o].index;for(let t=0;t<n.count;++t){r.push(n.getX(t)+e)}e+=t[o].attributes.position.count}f.setIndex(r)}for(const t in u){const e=n(u[t]);if(!e){console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+t+" attribute.");return null}f.setAttribute(t,e)}for(const t in c){const e=c[t][0].length;if(e===0)break;f.morphAttributes=f.morphAttributes||{};f.morphAttributes[t]=[];for(let r=0;r<e;++r){const e=[];for(let o=0;o<c[t].length;++o){e.push(c[t][o][r])}const o=n(e);if(!o){console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+t+" morphAttribute.");return null}f.morphAttributes[t].push(o)}}return f}function n(t){let r;let o;let n;let s=-1;let i=0;for(let e=0;e<t.length;++e){const u=t[e];if(r===undefined)r=u.array.constructor;if(r!==u.array.constructor){console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");return null}if(o===undefined)o=u.itemSize;if(o!==u.itemSize){console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");return null}if(n===undefined)n=u.normalized;if(n!==u.normalized){console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");return null}if(s===-1)s=u.gpuType;if(s!==u.gpuType){console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.");return null}i+=u.count*o}const u=new r(i);const c=new e.BufferAttribute(u,o,n);let a=0;for(let e=0;e<t.length;++e){const r=t[e];if(r.isInterleavedBufferAttribute){const t=a/o;for(let e=0,n=r.count;e<n;e++){for(let n=0;n<o;n++){const o=r.getComponent(e,n);c.setComponent(e+t,n,o)}}}else{u.set(r.array,a)}a+=r.count*o}if(s!==undefined){c.gpuType=s}return c}function s(t){if(t.isInstancedInterleavedBufferAttribute||t.isInterleavedBufferAttribute){return u(t)}if(t.isInstancedBufferAttribute){return(new e.InstancedBufferAttribute).copy(t)}return(new e.BufferAttribute).copy(t)}function i(t){let r;let o=0;let n=0;for(let e=0,s=t.length;e<s;++e){const s=t[e];if(r===undefined)r=s.array.constructor;if(r!==s.array.constructor){console.error("AttributeBuffers of different types cannot be interleaved");return null}o+=s.array.length;n+=s.itemSize}const s=new e.InterleavedBuffer(new r(o),n);let i=0;const u=[];const c=["getX","getY","getZ","getW"];const a=["setX","setY","setZ","setW"];for(let r=0,o=t.length;r<o;r++){const o=t[r];const n=o.itemSize;const f=o.count;const l=new e.InterleavedBufferAttribute(s,n,i,o.normalized);u.push(l);i+=n;for(let t=0;t<f;t++){for(let e=0;e<n;e++){l[a[e]](t,o[c[e]](t))}}}return u}function u(t){const r=t.data.array.constructor;const o=t.count;const n=t.itemSize;const s=t.normalized;const i=new r(o*n);let u;if(t.isInstancedInterleavedBufferAttribute){u=new e.InstancedBufferAttribute(i,n,s,t.meshPerAttribute)}else{u=new e.BufferAttribute(i,n,s)}for(let e=0;e<o;e++){u.setX(e,t.getX(e));if(n>=2){u.setY(e,t.getY(e))}if(n>=3){u.setZ(e,t.getZ(e))}if(n>=4){u.setW(e,t.getW(e))}}return u}function c(t){const e=t.attributes;const r=t.morphTargets;const o=new Map;for(const t in e){const r=e[t];if(r.isInterleavedBufferAttribute){if(!o.has(r)){o.set(r,u(r))}e[t]=o.get(r)}}for(const t in r){const e=r[t];if(e.isInterleavedBufferAttribute){if(!o.has(e)){o.set(e,u(e))}r[t]=o.get(e)}}}function a(t){let e=0;for(const r in t.attributes){const o=t.getAttribute(r);e+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}const r=t.getIndex();e+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0;return e}function f(t,e=1e-4){e=Math.max(e,Number.EPSILON);const r={};const o=t.getIndex();const n=t.getAttribute("position");const s=o?o.count:n.count;let i=0;const u=Object.keys(t.attributes);const c={};const a={};const f=[];const l=["getX","getY","getZ","getW"];const m=["setX","setY","setZ","setW"];for(let e=0,r=u.length;e<r;e++){const r=u[e];const o=t.attributes[r];c[r]=new o.constructor(new o.array.constructor(o.count*o.itemSize),o.itemSize,o.normalized);const n=t.morphAttributes[r];if(n){if(!a[r])a[r]=[];n.forEach((t,e)=>{const o=new t.array.constructor(t.count*t.itemSize);a[r][e]=new t.constructor(o,t.itemSize,t.normalized)})}}const d=e*.5;const g=Math.log10(1/e);const b=Math.pow(10,g);const h=d*b;for(let e=0;e<s;e++){const n=o?o.getX(e):e;let s="";for(let e=0,r=u.length;e<r;e++){const r=u[e];const o=t.getAttribute(r);const i=o.itemSize;for(let t=0;t<i;t++){s+=`${~~(o[l[t]](n)*b+h)},`}}if(s in r){f.push(r[s])}else{for(let e=0,r=u.length;e<r;e++){const r=u[e];const o=t.getAttribute(r);const s=t.morphAttributes[r];const f=o.itemSize;const d=c[r];const g=a[r];for(let t=0;t<f;t++){const e=l[t];const r=m[t];d[r](i,o[e](n));if(s){for(let t=0,o=s.length;t<o;t++){g[t][r](i,s[t][e](n))}}}}r[s]=i;f.push(i);i++}}const p=t.clone();for(const e in t.attributes){const t=c[e];p.setAttribute(e,new t.constructor(t.array.slice(0,i*t.itemSize),t.itemSize,t.normalized));if(!(e in a))continue;for(let t=0;t<a[e].length;t++){const r=a[e][t];p.morphAttributes[e][t]=new r.constructor(r.array.slice(0,i*r.itemSize),r.itemSize,r.normalized)}}p.setIndex(f);return p}function l(t,r){if(r===e.TrianglesDrawMode){console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");return t}if(r===e.TriangleFanDrawMode||r===e.TriangleStripDrawMode){let o=t.getIndex();if(o===null){const e=[];const r=t.getAttribute("position");if(r!==undefined){for(let t=0;t<r.count;t++){e.push(t)}t.setIndex(e);o=t.getIndex()}else{console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");return t}}const n=o.count-2;const s=[];if(r===e.TriangleFanDrawMode){for(let t=1;t<=n;t++){s.push(o.getX(0));s.push(o.getX(t));s.push(o.getX(t+1))}}else{for(let t=0;t<n;t++){if(t%2===0){s.push(o.getX(t));s.push(o.getX(t+1));s.push(o.getX(t+2))}else{s.push(o.getX(t+2));s.push(o.getX(t+1));s.push(o.getX(t))}}}if(s.length/3!==n){console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.")}const i=t.clone();i.setIndex(s);i.clearGroups();return i}else{console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",r);return t}}function m(t){const r=new e.Vector3;const o=new e.Vector3;const n=new e.Vector3;const s=new e.Vector3;const i=new e.Vector3;const u=new e.Vector3;const c=new e.Vector3;const a=new e.Vector3;const f=new e.Vector3;function l(t,e,l,m,d,g,b,h){r.fromBufferAttribute(e,d);o.fromBufferAttribute(e,g);n.fromBufferAttribute(e,b);const p=t.morphTargetInfluences;if(l&&p){c.set(0,0,0);a.set(0,0,0);f.set(0,0,0);for(let t=0,e=l.length;t<e;t++){const e=p[t];const h=l[t];if(e===0)continue;s.fromBufferAttribute(h,d);i.fromBufferAttribute(h,g);u.fromBufferAttribute(h,b);if(m){c.addScaledVector(s,e);a.addScaledVector(i,e);f.addScaledVector(u,e)}else{c.addScaledVector(s.sub(r),e);a.addScaledVector(i.sub(o),e);f.addScaledVector(u.sub(n),e)}}r.add(c);o.add(a);n.add(f)}if(t.isSkinnedMesh){t.applyBoneTransform(d,r);t.applyBoneTransform(g,o);t.applyBoneTransform(b,n)}h[d*3+0]=r.x;h[d*3+1]=r.y;h[d*3+2]=r.z;h[g*3+0]=o.x;h[g*3+1]=o.y;h[g*3+2]=o.z;h[b*3+0]=n.x;h[b*3+1]=n.y;h[b*3+2]=n.z}const m=t.geometry;const d=t.material;let g,b,h;const p=m.index;const A=m.attributes.position;const y=m.morphAttributes.position;const w=m.morphTargetsRelative;const B=m.attributes.normal;const T=m.morphAttributes.position;const E=m.groups;const x=m.drawRange;let z,I,S,G;let M;let V,X;const v=new Float32Array(A.count*A.itemSize);const R=new Float32Array(B.count*B.itemSize);if(p!==null){if(Array.isArray(d)){for(z=0,S=E.length;z<S;z++){M=E[z];V=Math.max(M.start,x.start);X=Math.min(M.start+M.count,x.start+x.count);for(I=V,G=X;I<G;I+=3){g=p.getX(I);b=p.getX(I+1);h=p.getX(I+2);l(t,A,y,w,g,b,h,v);l(t,B,T,w,g,b,h,R)}}}else{V=Math.max(0,x.start);X=Math.min(p.count,x.start+x.count);for(z=V,S=X;z<S;z+=3){g=p.getX(z);b=p.getX(z+1);h=p.getX(z+2);l(t,A,y,w,g,b,h,v);l(t,B,T,w,g,b,h,R)}}}else{if(Array.isArray(d)){for(z=0,S=E.length;z<S;z++){M=E[z];V=Math.max(M.start,x.start);X=Math.min(M.start+M.count,x.start+x.count);for(I=V,G=X;I<G;I+=3){g=I;b=I+1;h=I+2;l(t,A,y,w,g,b,h,v);l(t,B,T,w,g,b,h,R)}}}else{V=Math.max(0,x.start);X=Math.min(A.count,x.start+x.count);for(z=V,S=X;z<S;z+=3){g=z;b=z+1;h=z+2;l(t,A,y,w,g,b,h,v);l(t,B,T,w,g,b,h,R)}}}const U=new e.Float32BufferAttribute(v,3);const H=new e.Float32BufferAttribute(R,3);return{positionAttribute:A,normalAttribute:B,morphedPositionAttribute:U,morphedNormalAttribute:H}}function d(t){if(t.groups.length===0){console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.");return t}let e=t.groups;e=e.sort((t,e)=>{if(t.materialIndex!==e.materialIndex)return t.materialIndex-e.materialIndex;return t.start-e.start});if(t.getIndex()===null){const e=t.getAttribute("position");const r=[];for(let t=0;t<e.count;t+=3){r.push(t,t+1,t+2)}t.setIndex(r)}const r=t.getIndex();const o=[];for(let t=0;t<e.length;t++){const n=e[t];const s=n.start;const i=s+n.count;for(let t=s;t<i;t++){o.push(r.getX(t))}}t.dispose();t.setIndex(o);let n=0;for(let t=0;t<e.length;t++){const r=e[t];r.start=n;n+=r.count}let s=e[0];t.groups=[s];for(let r=1;r<e.length;r++){const o=e[r];if(s.materialIndex===o.materialIndex){s.count+=o.count}else{s=o;t.groups.push(s)}}return t}function g(t,r=Math.PI/3){const o=Math.cos(r);const n=(1+1e-10)*100;const s=[new e.Vector3,new e.Vector3,new e.Vector3];const i=new e.Vector3;const u=new e.Vector3;const c=new e.Vector3;const a=new e.Vector3;function f(t){const e=~~(t.x*n);const r=~~(t.y*n);const o=~~(t.z*n);return`${e},${r},${o}`}const l=t.index?t.toNonIndexed():t;const m=l.attributes.position;const d={};for(let t=0,r=m.count/3;t<r;t++){const r=3*t;const o=s[0].fromBufferAttribute(m,r+0);const n=s[1].fromBufferAttribute(m,r+1);const c=s[2].fromBufferAttribute(m,r+2);i.subVectors(c,n);u.subVectors(o,n);const a=(new e.Vector3).crossVectors(i,u).normalize();for(let t=0;t<3;t++){const e=s[t];const r=f(e);if(!(r in d)){d[r]=[]}d[r].push(a)}}const g=new Float32Array(m.count*3);const b=new e.BufferAttribute(g,3,false);for(let t=0,e=m.count/3;t<e;t++){const e=3*t;const r=s[0].fromBufferAttribute(m,e+0);const n=s[1].fromBufferAttribute(m,e+1);const l=s[2].fromBufferAttribute(m,e+2);i.subVectors(l,n);u.subVectors(r,n);c.crossVectors(i,u).normalize();for(let t=0;t<3;t++){const r=s[t];const n=f(r);const i=d[n];a.set(0,0,0);for(let t=0,e=i.length;t<e;t++){const e=i[t];if(c.dot(e)>o){a.add(e)}}a.normalize();b.setXYZ(e+t,a.x,a.y,a.z)}}l.setAttribute("normal",b);return l}t.computeMikkTSpaceTangents=r;t.computeMorphedAttributes=m;t.deepCloneAttribute=s;t.deinterleaveAttribute=u;t.deinterleaveGeometry=c;t.estimateBytesUsed=a;t.interleaveAttributes=i;t.mergeAttributes=n;t.mergeGeometries=o;t.mergeGroups=d;t.mergeVertices=f;t.toCreasedNormals=g;t.toTrianglesDrawMode=l;return t}({},t);return e});
//# sourceMappingURL=BufferGeometryUtils.js.map