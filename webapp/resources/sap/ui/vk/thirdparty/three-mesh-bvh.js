sap.ui.define(["./three"],t=>{"use strict";const e={};const n=0;const o=1;const s=2;const i=0;const r=1;const c=2;const a=1.25;const l=1;const u=6*4+4+4;const f=65535;const d=Math.pow(2,-24);const h=Symbol("SKIP_GENERATION");function p(t){return t.index?t.index.count:t.attributes.position.count}function y(t){return p(t)/3}function m(t,e=ArrayBuffer){if(t>65535){return new Uint32Array(new e(4*t))}else{return new Uint16Array(new e(2*t))}}function x(e,n){if(!e.index){const o=e.attributes.position.count;const s=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;const i=m(o,s);e.setIndex(new t.BufferAttribute(i,1));for(let t=0;t<o;t++){i[t]=t}}}function g(t){const e=y(t);const n=t.drawRange;const o=n.start/3;const s=(n.start+n.count)/3;const i=Math.max(0,o);const r=Math.min(e,s)-i;return[{offset:Math.floor(i),count:Math.floor(r)}]}function b(t){if(!t.groups||!t.groups.length){return g(t)}const e=[];const n=new Set;const o=t.drawRange;const s=o.start/3;const i=(o.start+o.count)/3;for(const e of t.groups){const t=e.start/3;const o=(e.start+e.count)/3;n.add(Math.max(s,t));n.add(Math.min(i,o))}const r=Array.from(n.values()).sort((t,e)=>t-e);for(let t=0;t<r.length-1;t++){const n=r[t];const o=r[t+1];e.push({offset:Math.floor(n),count:Math.floor(o-n)})}return e}function v(t){if(t.groups.length===0){return false}const e=y(t);const n=b(t).sort((t,e)=>t.offset-e.offset);const o=n[n.length-1];o.count=Math.min(e-o.offset,o.count);let s=0;n.forEach(({count:t})=>s+=t);return e!==s}function w(t,e,n,o,s){let i=Infinity;let r=Infinity;let c=Infinity;let a=-Infinity;let l=-Infinity;let u=-Infinity;let f=Infinity;let d=Infinity;let h=Infinity;let p=-Infinity;let y=-Infinity;let m=-Infinity;for(let o=e*6,s=(e+n)*6;o<s;o+=6){const e=t[o+0];const n=t[o+1];const s=e-n;const x=e+n;if(s<i)i=s;if(x>a)a=x;if(e<f)f=e;if(e>p)p=e;const g=t[o+2];const b=t[o+3];const v=g-b;const w=g+b;if(v<r)r=v;if(w>l)l=w;if(g<d)d=g;if(g>y)y=g;const B=t[o+4];const A=t[o+5];const T=B-A;const I=B+A;if(T<c)c=T;if(I>u)u=I;if(B<h)h=B;if(B>m)m=B}o[0]=i;o[1]=r;o[2]=c;o[3]=a;o[4]=l;o[5]=u;s[0]=f;s[1]=d;s[2]=h;s[3]=p;s[4]=y;s[5]=m}function B(t,e=null,n=null,o=null){const s=t.attributes.position;const i=t.index?t.index.array:null;const r=y(t);const c=s.normalized;let a;if(e===null){a=new Float32Array(r*6*4);n=0;o=r}else{a=e;n=n||0;o=o||r}const l=s.array;const u=s.offset||0;let f=3;if(s.isInterleavedBufferAttribute){f=s.data.stride}const h=["getX","getY","getZ"];for(let t=n;t<n+o;t++){const e=t*3;const n=t*6;let o=e+0;let r=e+1;let p=e+2;if(i){o=i[o];r=i[r];p=i[p]}if(!c){o=o*f+u;r=r*f+u;p=p*f+u}for(let t=0;t<3;t++){let e,i,u;if(c){e=s[h[t]](o);i=s[h[t]](r);u=s[h[t]](p)}else{e=l[o+t];i=l[r+t];u=l[p+t]}let f=e;if(i<f)f=i;if(u<f)f=u;let y=e;if(i>y)y=i;if(u>y)y=u;const m=(y-f)/2;const x=t*2;a[n+x+0]=f+m;a[n+x+1]=m+(Math.abs(f)+m)*d}}return a}function A(t,e,n){n.min.x=e[t];n.min.y=e[t+1];n.min.z=e[t+2];n.max.x=e[t+3];n.max.y=e[t+4];n.max.z=e[t+5];return n}function T(t){t[0]=t[1]=t[2]=Infinity;t[3]=t[4]=t[5]=-Infinity}function I(t){let e=-1;let n=-Infinity;for(let o=0;o<3;o++){const s=t[o+3]-t[o];if(s>n){n=s;e=o}}return e}function M(t,e){e.set(t)}function P(t,e,n){let o,s;for(let i=0;i<3;i++){const r=i+3;o=t[i];s=e[i];n[i]=o<s?o:s;o=t[r];s=e[r];n[r]=o>s?o:s}}function S(t,e,n){for(let o=0;o<3;o++){const s=e[t+2*o];const i=e[t+2*o+1];const r=s-i;const c=s+i;if(r<n[o]){n[o]=r}if(c>n[o+3]){n[o+3]=c}}}function _(t){const e=t[3]-t[0];const n=t[4]-t[1];const o=t[5]-t[2];return 2*(e*n+n*o+o*e)}const V=32;const F=(t,e)=>t.candidate-e.candidate;const D=new Array(V).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}));const U=new Float32Array(6);function z(t,e,i,r,c,u){let f=-1;let d=0;if(u===n){f=I(e);if(f!==-1){d=(e[f]+e[f+3])/2}}else if(u===o){f=I(t);if(f!==-1){d=E(i,r,c,f)}}else if(u===s){const n=_(t);let o=a*c;const s=r*6;const u=(r+c)*6;for(let t=0;t<3;t++){const r=e[t];const h=e[t+3];const p=h-r;const y=p/V;if(c<V/4){const e=[...D];e.length=c;let r=0;for(let n=s;n<u;n+=6,r++){const o=e[r];o.candidate=i[n+2*t];o.count=0;const{bounds:s,leftCacheBounds:c,rightCacheBounds:a}=o;for(let t=0;t<3;t++){a[t]=Infinity;a[t+3]=-Infinity;c[t]=Infinity;c[t+3]=-Infinity;s[t]=Infinity;s[t+3]=-Infinity}S(n,i,s)}e.sort(F);let h=c;for(let t=0;t<h;t++){const n=e[t];while(t+1<h&&e[t+1].candidate===n.candidate){e.splice(t+1,1);h--}}for(let n=s;n<u;n+=6){const o=i[n+2*t];for(let t=0;t<h;t++){const s=e[t];if(o>=s.candidate){S(n,i,s.rightCacheBounds)}else{S(n,i,s.leftCacheBounds);s.count++}}}for(let s=0;s<h;s++){const i=e[s];const r=i.count;const u=c-i.count;const h=i.leftCacheBounds;const p=i.rightCacheBounds;let y=0;if(r!==0){y=_(h)/n}let m=0;if(u!==0){m=_(p)/n}const x=l+a*(y*r+m*u);if(x<o){f=t;o=x;d=i.candidate}}}else{for(let t=0;t<V;t++){const e=D[t];e.count=0;e.candidate=r+y+t*y;const n=e.bounds;for(let t=0;t<3;t++){n[t]=Infinity;n[t+3]=-Infinity}}for(let e=s;e<u;e+=6){const n=i[e+2*t];const o=n-r;let s=~~(o/y);if(s>=V)s=V-1;const c=D[s];c.count++;S(e,i,c.bounds)}const e=D[V-1];M(e.bounds,e.rightCacheBounds);for(let t=V-2;t>=0;t--){const e=D[t];const n=D[t+1];P(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let h=0;for(let e=0;e<V-1;e++){const s=D[e];const i=s.count;const r=s.bounds;const u=D[e+1];const p=u.rightCacheBounds;if(i!==0){if(h===0){M(r,U)}else{P(r,U,U)}}h+=i;let y=0;let m=0;if(h!==0){y=_(U)/n}const x=c-h;if(x!==0){m=_(p)/n}const g=l+a*(y*h+m*x);if(g<o){f=t;o=g;d=s.candidate}}}}}else{console.warn(`MeshBVH: Invalid build strategy value ${u} used.`)}return{axis:f,pos:d}}function E(t,e,n,o){let s=0;for(let i=e,r=e+n;i<r;i++){s+=t[i*6+o*2]}return s/n}class N{constructor(){this.boundingData=new Float32Array(6)}}function H(t,e,n,o,s,i){let r=o;let c=o+s-1;const a=i.pos;const l=i.axis*2;while(true){while(r<=c&&n[r*6+l]<a){r++}while(r<=c&&n[c*6+l]>=a){c--}if(r<c){for(let t=0;t<3;t++){let n=e[r*3+t];e[r*3+t]=e[c*3+t];e[c*3+t]=n}for(let t=0;t<6;t++){let e=n[r*6+t];n[r*6+t]=n[c*6+t];n[c*6+t]=e}r++;c--}else{return r}}}function k(t,e,n,o,s,i){let r=o;let c=o+s-1;const a=i.pos;const l=i.axis*2;while(true){while(r<=c&&n[r*6+l]<a){r++}while(r<=c&&n[c*6+l]>=a){c--}if(r<c){let e=t[r];t[r]=t[c];t[c]=e;for(let t=0;t<6;t++){let e=n[r*6+t];n[r*6+t]=n[c*6+t];n[c*6+t]=e}r++;c--}else{return r}}}function C(t,e){return e[t+15]===65535}function R(t,e){return e[t+6]}function G(t,e){return e[t+14]}function q(t){return t+8}function O(t,e){return e[t+6]}function L(t,e){return e[t+7]}function W(t){return t}let X,Y,Z,j;const K=Math.pow(2,32);function $(t){if("count"in t){return 1}else{return 1+$(t.left)+$(t.right)}}function J(t,e,n){X=new Float32Array(n);Y=new Uint32Array(n);Z=new Uint16Array(n);j=new Uint8Array(n);return Q(t,e)}function Q(t,e){const n=t/4;const o=t/2;const s="count"in e;const i=e.boundingData;for(let t=0;t<6;t++){X[n+t]=i[t]}if(s){if(e.buffer){const o=e.buffer;j.set(new Uint8Array(o),t);for(let e=t,s=t+o.byteLength;e<s;e+=u){const t=e/2;if(!C(t,Z)){Y[e/4+6]+=n}}return t+o.byteLength}else{const s=e.offset;const i=e.count;Y[n+6]=s;Z[o+14]=i;Z[o+15]=f;return t+u}}else{const o=e.left;const s=e.right;const i=e.splitAxis;let r;r=Q(t+u,o);if(r/4>K){throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.")}Y[n+6]=r/4;r=Q(r,s);Y[n+7]=i;return r}}function tt(t,e){const n=(t.index?t.index.count:t.attributes.position.count)/3;const o=n>2**16;const s=o?4:2;const i=e?new SharedArrayBuffer(n*s):new ArrayBuffer(n*s);const r=o?new Uint32Array(i):new Uint16Array(i);for(let t=0,e=r.length;t<e;t++){r[t]=t}return r}function et(t,e,n,o,s){const{maxDepth:i,verbose:r,maxLeafTris:c,strategy:a,onProgress:l,indirect:u}=s;const f=t._indirectBuffer;const d=t.geometry;const h=d.index?d.index.array:null;const p=u?k:H;const m=y(d);const x=new Float32Array(6);let g=false;const b=new N;w(e,n,o,b.boundingData,x);B(b,n,o,x);return b;function v(t){if(l){l(t/m)}}function B(t,n,o,s=null,l=0){if(!g&&l>=i){g=true;if(r){console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`);console.warn(d)}}if(o<=c||l>=i){v(n+o);t.offset=n;t.count=o;return t}const u=z(t.boundingData,s,e,n,o,a);if(u.axis===-1){v(n+o);t.offset=n;t.count=o;return t}const y=p(f,h,e,n,o,u);if(y===n||y===n+o){v(n+o);t.offset=n;t.count=o}else{t.splitAxis=u.axis;const s=new N;const i=n;const r=y-n;t.left=s;w(e,i,r,s.boundingData,x);B(s,i,r,x,l+1);const c=new N;const a=y;const f=o-r;t.right=c;w(e,a,f,c.boundingData,x);B(c,a,f,x,l+1)}return t}}function nt(t,e){const n=t.geometry;if(e.indirect){t._indirectBuffer=tt(n,e.useSharedArrayBuffer);if(v(n)&&!e.verbose){console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. '+"BVH may incorrectly report intersections on unrendered portions of the geometry.")}}if(!t._indirectBuffer){x(n,e)}const o=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;const s=B(n);const i=e.indirect?g(n):b(n);t._roots=i.map(n=>{const i=et(t,s,n.offset,n.count,e);const r=$(i);const c=new o(u*r);J(0,i,c);return c})}class ot{constructor(){this.min=Infinity;this.max=-Infinity}setFromPointsField(t,e){let n=Infinity;let o=-Infinity;for(let s=0,i=t.length;s<i;s++){const i=t[s];const r=i[e];n=r<n?r:n;o=r>o?r:o}this.min=n;this.max=o}setFromPoints(t,e){let n=Infinity;let o=-Infinity;for(let s=0,i=e.length;s<i;s++){const i=e[s];const r=t.dot(i);n=r<n?r:n;o=r>o?r:o}this.min=n;this.max=o}isSeparated(t){return this.min>t.max||t.min>this.max}}ot.prototype.setFromBox=function(){const e=new t.Vector3;return function t(n,o){const s=o.min;const i=o.max;let r=Infinity;let c=-Infinity;for(let t=0;t<=1;t++){for(let o=0;o<=1;o++){for(let a=0;a<=1;a++){e.x=s.x*t+i.x*(1-t);e.y=s.y*o+i.y*(1-o);e.z=s.z*a+i.z*(1-a);const l=n.dot(e);r=Math.min(l,r);c=Math.max(l,c)}}}this.min=r;this.max=c}}();const st=function(){const t=new ot;return function e(n,o){const s=n.points;const i=n.satAxes;const r=n.satBounds;const c=o.points;const a=o.satAxes;const l=o.satBounds;for(let e=0;e<3;e++){const n=r[e];const o=i[e];t.setFromPoints(o,c);if(n.isSeparated(t))return false}for(let e=0;e<3;e++){const n=l[e];const o=a[e];t.setFromPoints(o,s);if(n.isSeparated(t))return false}}}();const it=function(){const e=new t.Vector3;const n=new t.Vector3;const o=new t.Vector3;return function t(s,i,r){const c=s.start;const a=e;const l=i.start;const u=n;o.subVectors(c,l);e.subVectors(s.end,s.start);n.subVectors(i.end,i.start);const f=o.dot(u);const d=u.dot(a);const h=u.dot(u);const p=o.dot(a);const y=a.dot(a);const m=y*h-d*d;let x,g;if(m!==0){x=(f*d-p*h)/m}else{x=0}g=(f+x*d)/h;r.x=x;r.y=g}}();const rt=function(){const e=new t.Vector2;const n=new t.Vector3;const o=new t.Vector3;return function t(s,i,r,c){it(s,i,e);let a=e.x;let l=e.y;if(a>=0&&a<=1&&l>=0&&l<=1){s.at(a,r);i.at(l,c);return}else if(a>=0&&a<=1){if(l<0){i.at(0,c)}else{i.at(1,c)}s.closestPointToPoint(c,true,r);return}else if(l>=0&&l<=1){if(a<0){s.at(0,r)}else{s.at(1,r)}i.closestPointToPoint(r,true,c);return}else{let t;if(a<0){t=s.start}else{t=s.end}let e;if(l<0){e=i.start}else{e=i.end}const u=n;const f=o;s.closestPointToPoint(e,true,n);i.closestPointToPoint(t,true,o);if(u.distanceToSquared(e)<=f.distanceToSquared(t)){r.copy(u);c.copy(e);return}else{r.copy(t);c.copy(f);return}}}}();const ct=function(){const e=new t.Vector3;const n=new t.Vector3;const o=new t.Plane;const s=new t.Line3;return function t(i,r){const{radius:c,center:a}=i;const{a:l,b:u,c:f}=r;s.start=l;s.end=u;const d=s.closestPointToPoint(a,true,e);if(d.distanceTo(a)<=c)return true;s.start=l;s.end=f;const h=s.closestPointToPoint(a,true,e);if(h.distanceTo(a)<=c)return true;s.start=u;s.end=f;const p=s.closestPointToPoint(a,true,e);if(p.distanceTo(a)<=c)return true;const y=r.getPlane(o);const m=Math.abs(y.distanceToPoint(a));if(m<=c){const t=y.projectPoint(a,n);const e=r.containsPoint(t);if(e)return true}return false}}();const at=1e-15;function lt(t){return Math.abs(t)<at}class ut extends t.Triangle{constructor(...e){super(...e);this.isExtendedTriangle=true;this.satAxes=new Array(4).fill().map(()=>new t.Vector3);this.satBounds=new Array(4).fill().map(()=>new ot);this.points=[this.a,this.b,this.c];this.sphere=new t.Sphere;this.plane=new t.Plane;this.needsUpdate=true}intersectsSphere(t){return ct(t,this)}update(){const t=this.a;const e=this.b;const n=this.c;const o=this.points;const s=this.satAxes;const i=this.satBounds;const r=s[0];const c=i[0];this.getNormal(r);c.setFromPoints(r,o);const a=s[1];const l=i[1];a.subVectors(t,e);l.setFromPoints(a,o);const u=s[2];const f=i[2];u.subVectors(e,n);f.setFromPoints(u,o);const d=s[3];const h=i[3];d.subVectors(n,t);h.setFromPoints(d,o);this.sphere.setFromPoints(this.points);this.plane.setFromNormalAndCoplanarPoint(r,t);this.needsUpdate=false}}ut.prototype.closestPointToSegment=function(){const e=new t.Vector3;const n=new t.Vector3;const o=new t.Line3;return function t(s,i=null,r=null){const{start:c,end:a}=s;const l=this.points;let u;let f=Infinity;for(let t=0;t<3;t++){const c=(t+1)%3;o.start.copy(l[t]);o.end.copy(l[c]);rt(o,s,e,n);u=e.distanceToSquared(n);if(u<f){f=u;if(i)i.copy(e);if(r)r.copy(n)}}this.closestPointToPoint(c,e);u=c.distanceToSquared(e);if(u<f){f=u;if(i)i.copy(e);if(r)r.copy(c)}this.closestPointToPoint(a,e);u=a.distanceToSquared(e);if(u<f){f=u;if(i)i.copy(e);if(r)r.copy(a)}return Math.sqrt(f)}}();ut.prototype.intersectsTriangle=function(){const e=new ut;const n=new Array(3);const o=new Array(3);const s=new ot;const i=new ot;const r=new t.Vector3;const c=new t.Vector3;const a=new t.Vector3;const l=new t.Vector3;const u=new t.Vector3;const f=new t.Line3;const d=new t.Line3;const h=new t.Line3;const p=new t.Vector3;function y(t,e,n){const o=t.points;let s=0;let i=-1;for(let t=0;t<3;t++){const{start:r,end:a}=f;r.copy(o[t]);a.copy(o[(t+1)%3]);f.delta(c);const l=lt(e.distanceToPoint(r));if(lt(e.normal.dot(c))&&l){n.copy(f);s=2;break}const u=e.intersectLine(f,p);if(!u&&l){p.copy(r)}if((u||l)&&!lt(p.distanceTo(a))){if(s<=1){const t=s===1?n.start:n.end;t.copy(p);if(l){i=s}}else if(s>=2){const t=i===1?n.start:n.end;t.copy(p);s=2;break}s++;if(s===2&&i===-1){break}}}return s}return function t(c,f=null,p=false){if(this.needsUpdate){this.update()}if(!c.isExtendedTriangle){e.copy(c);e.update();c=e}else if(c.needsUpdate){c.update()}const m=this.plane;const x=c.plane;if(Math.abs(m.normal.dot(x.normal))>1-1e-10){const t=this.satBounds;const e=this.satAxes;o[0]=c.a;o[1]=c.b;o[2]=c.c;for(let n=0;n<4;n++){const i=t[n];const r=e[n];s.setFromPoints(r,o);if(i.isSeparated(s))return false}const a=c.satBounds;const l=c.satAxes;n[0]=this.a;n[1]=this.b;n[2]=this.c;for(let t=0;t<4;t++){const e=a[t];const o=l[t];s.setFromPoints(o,n);if(e.isSeparated(s))return false}for(let t=0;t<4;t++){const c=e[t];for(let t=0;t<4;t++){const e=l[t];r.crossVectors(c,e);s.setFromPoints(r,n);i.setFromPoints(r,o);if(s.isSeparated(i))return false}}if(f){if(!p){console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.")}f.start.set(0,0,0);f.end.set(0,0,0)}return true}else{const t=y(this,x,d);if(t===1&&c.containsPoint(d.end)){if(f){f.start.copy(d.end);f.end.copy(d.end)}return true}else if(t!==2){return false}const e=y(c,m,h);if(e===1&&this.containsPoint(h.end)){if(f){f.start.copy(h.end);f.end.copy(h.end)}return true}else if(e!==2){return false}d.delta(a);h.delta(l);if(a.dot(l)<0){let t=h.start;h.start=h.end;h.end=t}const n=d.start.dot(a);const o=d.end.dot(a);const s=h.start.dot(a);const i=h.end.dot(a);const r=o<s;const p=n<i;if(n!==i&&s!==o&&r===p){return false}if(f){u.subVectors(d.start,h.start);if(u.dot(a)>0){f.start.copy(d.start)}else{f.start.copy(h.start)}u.subVectors(d.end,h.end);if(u.dot(a)<0){f.end.copy(d.end)}else{f.end.copy(h.end)}}return true}}}();ut.prototype.distanceToPoint=function(){const e=new t.Vector3;return function t(n){this.closestPointToPoint(n,e);return n.distanceTo(e)}}();ut.prototype.distanceToTriangle=function(){const e=new t.Vector3;const n=new t.Vector3;const o=["a","b","c"];const s=new t.Line3;const i=new t.Line3;return function t(r,c=null,a=null){const l=c||a?s:null;if(this.intersectsTriangle(r,l)){if(c||a){if(c)l.getCenter(c);if(a)l.getCenter(a)}return 0}let u=Infinity;for(let t=0;t<3;t++){let n;const s=o[t];const i=r[s];this.closestPointToPoint(i,e);n=i.distanceToSquared(e);if(n<u){u=n;if(c)c.copy(e);if(a)a.copy(i)}const l=this[s];r.closestPointToPoint(l,e);n=l.distanceToSquared(e);if(n<u){u=n;if(c)c.copy(l);if(a)a.copy(e)}}for(let t=0;t<3;t++){const l=o[t];const f=o[(t+1)%3];s.set(this[l],this[f]);for(let t=0;t<3;t++){const l=o[t];const f=o[(t+1)%3];i.set(r[l],r[f]);rt(s,i,e,n);const d=e.distanceToSquared(n);if(d<u){u=d;if(c)c.copy(e);if(a)a.copy(n)}}}return Math.sqrt(u)}}();class ft{constructor(e,n,o){this.isOrientedBox=true;this.min=new t.Vector3;this.max=new t.Vector3;this.matrix=new t.Matrix4;this.invMatrix=new t.Matrix4;this.points=new Array(8).fill().map(()=>new t.Vector3);this.satAxes=new Array(3).fill().map(()=>new t.Vector3);this.satBounds=new Array(3).fill().map(()=>new ot);this.alignedSatBounds=new Array(3).fill().map(()=>new ot);this.needsUpdate=false;if(e)this.min.copy(e);if(n)this.max.copy(n);if(o)this.matrix.copy(o)}set(t,e,n){this.min.copy(t);this.max.copy(e);this.matrix.copy(n);this.needsUpdate=true}copy(t){this.min.copy(t.min);this.max.copy(t.max);this.matrix.copy(t.matrix);this.needsUpdate=true}}ft.prototype.update=function(){return function t(){const e=this.matrix;const n=this.min;const o=this.max;const s=this.points;for(let t=0;t<=1;t++){for(let i=0;i<=1;i++){for(let r=0;r<=1;r++){const c=(1<<0)*t|(1<<1)*i|(1<<2)*r;const a=s[c];a.x=t?o.x:n.x;a.y=i?o.y:n.y;a.z=r?o.z:n.z;a.applyMatrix4(e)}}}const i=this.satBounds;const r=this.satAxes;const c=s[0];for(let t=0;t<3;t++){const e=r[t];const n=i[t];const o=1<<t;const a=s[o];e.subVectors(c,a);n.setFromPoints(e,s)}const a=this.alignedSatBounds;a[0].setFromPointsField(s,"x");a[1].setFromPointsField(s,"y");a[2].setFromPointsField(s,"z");this.invMatrix.copy(this.matrix).invert();this.needsUpdate=false}}();ft.prototype.intersectsBox=function(){const t=new ot;return function e(n){if(this.needsUpdate){this.update()}const o=n.min;const s=n.max;const i=this.satBounds;const r=this.satAxes;const c=this.alignedSatBounds;t.min=o.x;t.max=s.x;if(c[0].isSeparated(t))return false;t.min=o.y;t.max=s.y;if(c[1].isSeparated(t))return false;t.min=o.z;t.max=s.z;if(c[2].isSeparated(t))return false;for(let e=0;e<3;e++){const o=r[e];const s=i[e];t.setFromBox(o,n);if(s.isSeparated(t))return false}return true}}();ft.prototype.intersectsTriangle=function(){const e=new ut;const n=new Array(3);const o=new ot;const s=new ot;const i=new t.Vector3;return function t(r){if(this.needsUpdate){this.update()}if(!r.isExtendedTriangle){e.copy(r);e.update();r=e}else if(r.needsUpdate){r.update()}const c=this.satBounds;const a=this.satAxes;n[0]=r.a;n[1]=r.b;n[2]=r.c;for(let t=0;t<3;t++){const e=c[t];const s=a[t];o.setFromPoints(s,n);if(e.isSeparated(o))return false}const l=r.satBounds;const u=r.satAxes;const f=this.points;for(let t=0;t<3;t++){const e=l[t];const n=u[t];o.setFromPoints(n,f);if(e.isSeparated(o))return false}for(let t=0;t<3;t++){const e=a[t];for(let t=0;t<4;t++){const r=u[t];i.crossVectors(e,r);o.setFromPoints(i,n);s.setFromPoints(i,f);if(o.isSeparated(s))return false}}return true}}();ft.prototype.closestPointToPoint=function(){return function t(e,n){if(this.needsUpdate){this.update()}n.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix);return n}}();ft.prototype.distanceToPoint=function(){const e=new t.Vector3;return function t(n){this.closestPointToPoint(n,e);return n.distanceTo(e)}}();ft.prototype.distanceToBox=function(){const e=["x","y","z"];const n=new Array(12).fill().map(()=>new t.Line3);const o=new Array(12).fill().map(()=>new t.Line3);const s=new t.Vector3;const i=new t.Vector3;return function t(r,c=0,a=null,l=null){if(this.needsUpdate){this.update()}if(this.intersectsBox(r)){if(a||l){r.getCenter(i);this.closestPointToPoint(i,s);r.closestPointToPoint(s,i);if(a)a.copy(s);if(l)l.copy(i)}return 0}const u=c*c;const f=r.min;const d=r.max;const h=this.points;let p=Infinity;for(let t=0;t<8;t++){const e=h[t];i.copy(e).clamp(f,d);const n=e.distanceToSquared(i);if(n<p){p=n;if(a)a.copy(e);if(l)l.copy(i);if(n<u)return Math.sqrt(n)}}let y=0;for(let t=0;t<3;t++){for(let s=0;s<=1;s++){for(let i=0;i<=1;i++){const r=(t+1)%3;const c=(t+2)%3;const a=s<<r|i<<c;const l=1<<t|s<<r|i<<c;const u=h[a];const p=h[l];const m=n[y];m.set(u,p);const x=e[t];const g=e[r];const b=e[c];const v=o[y];const w=v.start;const B=v.end;w[x]=f[x];w[g]=s?f[g]:d[g];w[b]=i?f[b]:d[g];B[x]=d[x];B[g]=s?f[g]:d[g];B[b]=i?f[b]:d[g];y++}}}for(let t=0;t<=1;t++){for(let e=0;e<=1;e++){for(let n=0;n<=1;n++){i.x=t?d.x:f.x;i.y=e?d.y:f.y;i.z=n?d.z:f.z;this.closestPointToPoint(i,s);const o=i.distanceToSquared(s);if(o<p){p=o;if(a)a.copy(s);if(l)l.copy(i);if(o<u)return Math.sqrt(o)}}}}for(let t=0;t<12;t++){const e=n[t];for(let t=0;t<12;t++){const n=o[t];rt(e,n,s,i);const r=s.distanceToSquared(i);if(r<p){p=r;if(a)a.copy(s);if(l)l.copy(i);if(r<u)return Math.sqrt(r)}}}return Math.sqrt(p)}}();class dt{constructor(t){this._getNewPrimitive=t;this._primitives=[]}getPrimitive(){const t=this._primitives;if(t.length===0){return this._getNewPrimitive()}else{return t.pop()}}releasePrimitive(t){this._primitives.push(t)}}class ht extends dt{constructor(){super(()=>new ut)}}const pt=new ht;class yt{constructor(){this.float32Array=null;this.uint16Array=null;this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{if(e){t.push(e)}e=n;this.float32Array=new Float32Array(n);this.uint16Array=new Uint16Array(n);this.uint32Array=new Uint32Array(n)};this.clearBuffer=()=>{e=null;this.float32Array=null;this.uint16Array=null;this.uint32Array=null;if(t.length!==0){this.setBuffer(t.pop())}}}}const mt=new yt;let xt,gt;const bt=[];const vt=new dt(()=>new t.Box3);function wt(t,e,n,o,s,i){xt=vt.getPrimitive();gt=vt.getPrimitive();bt.push(xt,gt);mt.setBuffer(t._roots[e]);const r=Bt(0,t.geometry,n,o,s,i);mt.clearBuffer();vt.releasePrimitive(xt);vt.releasePrimitive(gt);bt.pop();bt.pop();const c=bt.length;if(c>0){gt=bt[c-1];xt=bt[c-2]}return r}function Bt(t,e,n,o,s=null,i=0,r=0){const{float32Array:a,uint16Array:l,uint32Array:u}=mt;let f=t*2;const d=C(f,l);if(d){const h=R(t,u);const p=G(f,l);A(W(t),a,xt);return o(h,p,false,r,i+t,xt)}else{const y=q(t);const m=O(t,u);let x=y;let g=m;let b,v;let w,B;if(s){w=xt;B=gt;A(W(x),a,w);A(W(g),a,B);b=s(w);v=s(B);if(v<b){x=m;g=y;const D=b;b=v;v=D;w=B}}if(!w){w=xt;A(W(x),a,w)}const T=C(x*2,l);const I=n(w,T,b,r+1,i+x);let M;if(I===c){const U=V(x);const z=F(x);const E=z-U;M=o(U,E,true,r+1,i+x,w)}else{M=I&&Bt(x,e,n,o,s,i,r+1)}if(M)return true;B=gt;A(W(g),a,B);const P=C(g*2,l);const S=n(B,P,v,r+1,i+g);let _;if(S===c){const N=V(g);const H=F(g);const k=H-N;_=o(N,k,true,r+1,i+g,B)}else{_=S&&Bt(g,e,n,o,s,i,r+1)}if(_)return true;return false;function V(t){const{uint16Array:e,uint32Array:n}=mt;let o=t*2;while(!C(o,e)){t=q(t);o=t*2}return R(t,n)}function F(t){const{uint16Array:e,uint32Array:n}=mt;let o=t*2;while(!C(o,e)){t=O(t,n);o=t*2}return R(t,n)+G(o,e)}}}const At=new t.Vector3;const Tt=new t.Vector3;function It(t,e,n={},o=0,s=Infinity){const i=o*o;const r=s*s;let c=Infinity;let a=null;t.shapecast({boundsTraverseOrder:t=>{At.copy(e).clamp(t.min,t.max);return At.distanceToSquared(e)},intersectsBounds:(t,e,n)=>n<c&&n<r,intersectsTriangle:(t,n)=>{t.closestPointToPoint(e,At);const o=e.distanceToSquared(At);if(o<c){Tt.copy(At);c=o;a=n}if(o<i){return true}else{return false}}});if(c===Infinity)return null;const l=Math.sqrt(c);if(!n.point)n.point=Tt.clone();else n.point.copy(Tt);n.distance=l,n.faceIndex=a;return n}const Mt=new t.Vector3;const Pt=new t.Vector3;const St=new t.Vector3;const _t=new t.Vector2;const Vt=new t.Vector2;const Ft=new t.Vector2;const Dt=new t.Vector3;const Ut=new t.Vector3;const zt=new t.Vector3;const Et=new t.Vector3;function Nt(e,n,o,s,i,r,c,a){let l;if(r===t.BackSide){l=e.intersectTriangle(s,o,n,true,i)}else{l=e.intersectTriangle(n,o,s,r!==t.DoubleSide,i)}if(l===null)return null;const u=e.origin.distanceTo(i);if(u<c||u>a)return null;return{distance:u,point:i.clone()}}function Ht(e,n,o,s,i,r,c,a,l,u,f){Mt.fromBufferAttribute(n,r);Pt.fromBufferAttribute(n,c);St.fromBufferAttribute(n,a);const d=Nt(e,Mt,Pt,St,Et,l,u,f);if(d){if(s){_t.fromBufferAttribute(s,r);Vt.fromBufferAttribute(s,c);Ft.fromBufferAttribute(s,a);d.uv=t.Triangle.getInterpolation(Et,Mt,Pt,St,_t,Vt,Ft,new t.Vector2)}if(i){_t.fromBufferAttribute(i,r);Vt.fromBufferAttribute(i,c);Ft.fromBufferAttribute(i,a);d.uv1=t.Triangle.getInterpolation(Et,Mt,Pt,St,_t,Vt,Ft,new t.Vector2)}if(o){Dt.fromBufferAttribute(o,r);Ut.fromBufferAttribute(o,c);zt.fromBufferAttribute(o,a);d.normal=t.Triangle.getInterpolation(Et,Mt,Pt,St,Dt,Ut,zt,new t.Vector3);if(d.normal.dot(e.direction)>0){d.normal.multiplyScalar(-1)}}const n={a:r,b:c,c:a,normal:new t.Vector3,materialIndex:0};t.Triangle.getNormal(Mt,Pt,St,n.normal);d.face=n;d.faceIndex=r}return d}function kt(t,e,n,o,s,i,r){const c=o*3;let a=c+0;let l=c+1;let u=c+2;const f=t.index;if(t.index){a=f.getX(a);l=f.getX(l);u=f.getX(u)}const{position:d,normal:h,uv:p,uv1:y}=t.attributes;const m=Ht(n,d,h,p,y,a,l,u,e,i,r);if(m){m.faceIndex=o;if(s)s.push(m);return m}return null}function Ct(t,e,n,o){const s=t.a;const i=t.b;const r=t.c;let c=e;let a=e+1;let l=e+2;if(n){c=n.getX(c);a=n.getX(a);l=n.getX(l)}s.x=o.getX(c);s.y=o.getY(c);s.z=o.getZ(c);i.x=o.getX(a);i.y=o.getY(a);i.z=o.getZ(a);r.x=o.getX(l);r.y=o.getY(l);r.z=o.getZ(l)}const Rt=new t.Vector3;const Gt=new t.Vector3;const qt=new t.Vector3;const Ot=new t.Vector2;const Lt=new t.Vector2;const Wt=new t.Vector2;function Xt(e,n,o,s){const i=n.getIndex().array;const r=n.getAttribute("position");const c=n.getAttribute("uv");const a=i[o*3];const l=i[o*3+1];const u=i[o*3+2];Rt.fromBufferAttribute(r,a);Gt.fromBufferAttribute(r,l);qt.fromBufferAttribute(r,u);let f=0;const d=n.groups;const h=o*3;for(let t=0,e=d.length;t<e;t++){const e=d[t];const{start:n,count:o}=e;if(h>=n&&h<n+o){f=e.materialIndex;break}}let p=null;if(c){Ot.fromBufferAttribute(c,a);Lt.fromBufferAttribute(c,l);Wt.fromBufferAttribute(c,u);if(s&&s.uv)p=s.uv;else p=new t.Vector2;t.Triangle.getInterpolation(e,Rt,Gt,qt,Ot,Lt,Wt,p)}if(s){if(!s.face)s.face={};s.face.a=a;s.face.b=l;s.face.c=u;s.face.materialIndex=f;if(!s.face.normal)s.face.normal=new t.Vector3;t.Triangle.getNormal(Rt,Gt,qt,s.face.normal);if(p)s.uv=p;return s}else{return{face:{a:a,b:l,c:u,materialIndex:f,normal:t.Triangle.getNormal(Rt,Gt,qt,new t.Vector3)},uv:p}}}function Yt(t,e,n,o,s,i,r,c){const{geometry:a,_indirectBuffer:l}=t;for(let t=o,l=o+s;t<l;t++){kt(a,e,n,t,i,r,c)}}function Zt(t,e,n,o,s,i,r){const{geometry:c,_indirectBuffer:a}=t;let l=Infinity;let u=null;for(let t=o,a=o+s;t<a;t++){let o;o=kt(c,e,n,t,null,i,r);if(o&&o.distance<l){u=o;l=o.distance}}return u}function jt(t,e,n,o,s,i,r){const{geometry:c}=n;const{index:a}=c;const l=c.attributes.position;for(let n=t,c=e+t;n<c;n++){let t;t=n;Ct(r,t*3,a,l);r.needsUpdate=true;if(o(r,t,s,i)){return true}}return false}function Kt(t,e=null){if(e&&Array.isArray(e)){e=new Set(e)}const n=t.geometry;const o=n.index?n.index.array:null;const s=n.attributes.position;let i,r,c,a;let l=0;const u=t._roots;for(let t=0,e=u.length;t<e;t++){i=u[t];r=new Uint32Array(i);c=new Uint16Array(i);a=new Float32Array(i);d(0,l);l+=i.byteLength}function d(t,n,i=false){const l=t*2;const u=c[l+15]===f;if(u){const e=r[t+6];const n=c[l+14];let i=Infinity;let u=Infinity;let f=Infinity;let d=-Infinity;let h=-Infinity;let p=-Infinity;for(let t=3*e,r=3*(e+n);t<r;t++){let e=o[t];const n=s.getX(e);const r=s.getY(e);const c=s.getZ(e);if(n<i)i=n;if(n>d)d=n;if(r<u)u=r;if(r>h)h=r;if(c<f)f=c;if(c>p)p=c}if(a[t+0]!==i||a[t+1]!==u||a[t+2]!==f||a[t+3]!==d||a[t+4]!==h||a[t+5]!==p){a[t+0]=i;a[t+1]=u;a[t+2]=f;a[t+3]=d;a[t+4]=h;a[t+5]=p;return true}else{return false}}else{const o=t+8;const s=r[t+6];const c=o+n;const l=s+n;let u=i;let f=false;let h=false;if(e){if(!u){f=e.has(c);h=e.has(l);u=!f&&!h}}else{f=true;h=true}const p=u||f;const y=u||h;let m=false;if(p){m=d(o,n,u)}let x=false;if(y){x=d(s,n,u)}const g=m||x;if(g){for(let e=0;e<3;e++){const n=o+e;const i=s+e;const r=a[n];const c=a[n+3];const l=a[i];const u=a[i+3];a[t+e]=r<l?r:l;a[t+e+3]=c>u?c:u}}return g}}}function $t(t,e,n,o,s){let i,r,c,a,l,u;const f=1/n.direction.x,d=1/n.direction.y,h=1/n.direction.z;const p=n.origin.x;const y=n.origin.y;const m=n.origin.z;let x=e[t];let g=e[t+3];let b=e[t+1];let v=e[t+3+1];let w=e[t+2];let B=e[t+3+2];if(f>=0){i=(x-p)*f;r=(g-p)*f}else{i=(g-p)*f;r=(x-p)*f}if(d>=0){c=(b-y)*d;a=(v-y)*d}else{c=(v-y)*d;a=(b-y)*d}if(i>a||c>r)return false;if(c>i||isNaN(i))i=c;if(a<r||isNaN(r))r=a;if(h>=0){l=(w-m)*h;u=(B-m)*h}else{l=(B-m)*h;u=(w-m)*h}if(i>u||l>r)return false;if(l>i||i!==i)i=l;if(u<r||r!==r)r=u;return i<=s&&r>=o}function Jt(t,e,n,o,s,i,r,c){const{geometry:a,_indirectBuffer:l}=t;for(let t=o,u=o+s;t<u;t++){let o=l?l[t]:t;kt(a,e,n,o,i,r,c)}}function Qt(t,e,n,o,s,i,r){const{geometry:c,_indirectBuffer:a}=t;let l=Infinity;let u=null;for(let t=o,f=o+s;t<f;t++){let o;o=kt(c,e,n,a?a[t]:t,null,i,r);if(o&&o.distance<l){u=o;l=o.distance}}return u}function te(t,e,n,o,s,i,r){const{geometry:c}=n;const{index:a}=c;const l=c.attributes.position;for(let c=t,u=e+t;c<u;c++){let t;t=n.resolveTriangleIndex(c);Ct(r,t*3,a,l);r.needsUpdate=true;if(o(r,t,s,i)){return true}}return false}function ee(t,e,n,o,s,i,r){mt.setBuffer(t._roots[e]);ne(0,t,n,o,s,i,r);mt.clearBuffer()}function ne(t,e,n,o,s,i,r){const{float32Array:c,uint16Array:a,uint32Array:l}=mt;const u=t*2;const f=C(u,a);if(f){const c=R(t,l);const f=G(u,a);Yt(e,n,o,c,f,s,i,r)}else{const a=q(t);if($t(a,c,o,i,r)){ne(a,e,n,o,s,i,r)}const u=O(t,l);if($t(u,c,o,i,r)){ne(u,e,n,o,s,i,r)}}}const oe=["x","y","z"];function se(t,e,n,o,s,i){mt.setBuffer(t._roots[e]);const r=ie(0,t,n,o,s,i);mt.clearBuffer();return r}function ie(t,e,n,o,s,i){const{float32Array:r,uint16Array:c,uint32Array:a}=mt;let l=t*2;const u=C(l,c);if(u){const r=R(t,a);const u=G(l,c);return Zt(e,n,o,r,u,s,i)}else{const c=L(t,a);const l=oe[c];const u=o.direction[l];const f=u>=0;let d,h;if(f){d=q(t);h=O(t,a)}else{d=O(t,a);h=q(t)}const p=$t(d,r,o,s,i);const y=p?ie(d,e,n,o,s,i):null;if(y){const t=y.point[l];const e=f?t<=r[h+c]:t>=r[h+c+3];if(e){return y}}const m=$t(h,r,o,s,i);const x=m?ie(h,e,n,o,s,i):null;if(y&&x){return y.distance<=x.distance?y:x}else{return y||x||null}}}const re=new t.Box3;const ce=new ut;const ae=new ut;const le=new t.Matrix4;const ue=new ft;const fe=new ft;function de(t,e,n,o){mt.setBuffer(t._roots[e]);const s=he(0,t,n,o);mt.clearBuffer();return s}function he(t,e,n,o,s=null){const{float32Array:i,uint16Array:r,uint32Array:c}=mt;let a=t*2;if(s===null){if(!n.boundingBox){n.computeBoundingBox()}ue.set(n.boundingBox.min,n.boundingBox.max,o);s=ue}const l=C(a,r);if(l){const s=e.geometry;const l=s.index;const u=s.attributes.position;const f=n.index;const d=n.attributes.position;const h=R(t,c);const p=G(a,r);le.copy(o).invert();if(n.boundsTree){A(W(t),i,fe);fe.matrix.copy(le);fe.needsUpdate=true;const e=n.boundsTree.shapecast({intersectsBounds:t=>fe.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(o);t.b.applyMatrix4(o);t.c.applyMatrix4(o);t.needsUpdate=true;for(let e=h*3,n=(p+h)*3;e<n;e+=3){Ct(ae,e,l,u);ae.needsUpdate=true;if(t.intersectsTriangle(ae)){return true}}return false}});return e}else{for(let t=h*3,e=(p+h)*3;t<e;t+=3){Ct(ce,t,l,u);ce.a.applyMatrix4(le);ce.b.applyMatrix4(le);ce.c.applyMatrix4(le);ce.needsUpdate=true;for(let t=0,e=f.count;t<e;t+=3){Ct(ae,t,f,d);ae.needsUpdate=true;if(ce.intersectsTriangle(ae)){return true}}}}}else{const r=t+8;const a=c[t+6];A(W(r),i,re);const l=s.intersectsBox(re)&&he(r,e,n,o,s);if(l)return true;A(W(a),i,re);const u=s.intersectsBox(re)&&he(a,e,n,o,s);if(u)return true;return false}}const pe=new t.Matrix4;const ye=new ft;const me=new ft;const xe=new t.Vector3;const ge=new t.Vector3;const be=new t.Vector3;const ve=new t.Vector3;function we(t,e,n,o={},s={},i=0,r=Infinity){if(!e.boundingBox){e.computeBoundingBox()}ye.set(e.boundingBox.min,e.boundingBox.max,n);ye.needsUpdate=true;const c=t.geometry;const a=c.attributes.position;const l=c.index;const u=e.attributes.position;const f=e.index;const d=pt.getPrimitive();const h=pt.getPrimitive();let p=xe;let m=ge;let x=null;let g=null;if(s){x=be;g=ve}let b=Infinity;let v=null;let w=null;pe.copy(n).invert();me.matrix.copy(pe);t.shapecast({boundsTraverseOrder:t=>ye.distanceToBox(t),intersectsBounds:(t,e,n)=>{if(n<b&&n<r){if(e){me.min.copy(t.min);me.max.copy(t.max);me.needsUpdate=true}return true}return false},intersectsRange:(t,o)=>{if(e.boundsTree){const s=e.boundsTree;return s.shapecast({boundsTraverseOrder:t=>me.distanceToBox(t),intersectsBounds:(t,e,n)=>n<b&&n<r,intersectsRange:(e,s)=>{for(let r=e,c=e+s;r<c;r++){Ct(h,3*r,f,u);h.a.applyMatrix4(n);h.b.applyMatrix4(n);h.c.applyMatrix4(n);h.needsUpdate=true;for(let e=t,n=t+o;e<n;e++){Ct(d,3*e,l,a);d.needsUpdate=true;const t=d.distanceToTriangle(h,p,x);if(t<b){m.copy(p);if(g){g.copy(x)}b=t;v=e;w=r}if(t<i){return true}}}}})}else{const s=y(e);for(let e=0,r=s;e<r;e++){Ct(h,3*e,f,u);h.a.applyMatrix4(n);h.b.applyMatrix4(n);h.c.applyMatrix4(n);h.needsUpdate=true;for(let n=t,s=t+o;n<s;n++){Ct(d,3*n,l,a);d.needsUpdate=true;const t=d.distanceToTriangle(h,p,x);if(t<b){m.copy(p);if(g){g.copy(x)}b=t;v=n;w=e}if(t<i){return true}}}}}});pt.releasePrimitive(d);pt.releasePrimitive(h);if(b===Infinity){return null}if(!o.point){o.point=m.clone()}else{o.point.copy(m)}o.distance=b,o.faceIndex=v;if(s){if(!s.point)s.point=g.clone();else s.point.copy(g);s.point.applyMatrix4(pe);m.applyMatrix4(pe);s.distance=m.sub(s.point).length();s.faceIndex=w}return o}function Be(t,e=null){if(e&&Array.isArray(e)){e=new Set(e)}const n=t.geometry;const o=n.index?n.index.array:null;const s=n.attributes.position;let i,r,c,a;let l=0;const u=t._roots;for(let t=0,e=u.length;t<e;t++){i=u[t];r=new Uint32Array(i);c=new Uint16Array(i);a=new Float32Array(i);d(0,l);l+=i.byteLength}function d(n,i,l=false){const u=n*2;const h=c[u+15]===f;if(h){const e=r[n+6];const i=c[u+14];let l=Infinity;let f=Infinity;let d=Infinity;let h=-Infinity;let p=-Infinity;let y=-Infinity;for(let n=e,r=e+i;n<r;n++){const e=3*t.resolveTriangleIndex(n);for(let t=0;t<3;t++){let n=e+t;n=o?o[n]:n;const i=s.getX(n);const r=s.getY(n);const c=s.getZ(n);if(i<l)l=i;if(i>h)h=i;if(r<f)f=r;if(r>p)p=r;if(c<d)d=c;if(c>y)y=c}}if(a[n+0]!==l||a[n+1]!==f||a[n+2]!==d||a[n+3]!==h||a[n+4]!==p||a[n+5]!==y){a[n+0]=l;a[n+1]=f;a[n+2]=d;a[n+3]=h;a[n+4]=p;a[n+5]=y;return true}else{return false}}else{const t=n+8;const o=r[n+6];const s=t+i;const c=o+i;let u=l;let f=false;let h=false;if(e){if(!u){f=e.has(s);h=e.has(c);u=!f&&!h}}else{f=true;h=true}const p=u||f;const y=u||h;let m=false;if(p){m=d(t,i,u)}let x=false;if(y){x=d(o,i,u)}const g=m||x;if(g){for(let e=0;e<3;e++){const s=t+e;const i=o+e;const r=a[s];const c=a[s+3];const l=a[i];const u=a[i+3];a[n+e]=r<l?r:l;a[n+e+3]=c>u?c:u}}return g}}}function Ae(t,e,n,o,s,i,r){mt.setBuffer(t._roots[e]);Te(0,t,n,o,s,i,r);mt.clearBuffer()}function Te(t,e,n,o,s,i,r){const{float32Array:c,uint16Array:a,uint32Array:l}=mt;const u=t*2;const f=C(u,a);if(f){const c=R(t,l);const f=G(u,a);Jt(e,n,o,c,f,s,i,r)}else{const a=q(t);if($t(a,c,o,i,r)){Te(a,e,n,o,s,i,r)}const u=O(t,l);if($t(u,c,o,i,r)){Te(u,e,n,o,s,i,r)}}}const Ie=["x","y","z"];function Me(t,e,n,o,s,i){mt.setBuffer(t._roots[e]);const r=Pe(0,t,n,o,s,i);mt.clearBuffer();return r}function Pe(t,e,n,o,s,i){const{float32Array:r,uint16Array:c,uint32Array:a}=mt;let l=t*2;const u=C(l,c);if(u){const r=R(t,a);const u=G(l,c);return Qt(e,n,o,r,u,s,i)}else{const c=L(t,a);const l=Ie[c];const u=o.direction[l];const f=u>=0;let d,h;if(f){d=q(t);h=O(t,a)}else{d=O(t,a);h=q(t)}const p=$t(d,r,o,s,i);const y=p?Pe(d,e,n,o,s,i):null;if(y){const t=y.point[l];const e=f?t<=r[h+c]:t>=r[h+c+3];if(e){return y}}const m=$t(h,r,o,s,i);const x=m?Pe(h,e,n,o,s,i):null;if(y&&x){return y.distance<=x.distance?y:x}else{return y||x||null}}}const Se=new t.Box3;const _e=new ut;const Ve=new ut;const Fe=new t.Matrix4;const De=new ft;const Ue=new ft;function ze(t,e,n,o){mt.setBuffer(t._roots[e]);const s=Ee(0,t,n,o);mt.clearBuffer();return s}function Ee(t,e,n,o,s=null){const{float32Array:i,uint16Array:r,uint32Array:c}=mt;let a=t*2;if(s===null){if(!n.boundingBox){n.computeBoundingBox()}De.set(n.boundingBox.min,n.boundingBox.max,o);s=De}const l=C(a,r);if(l){const s=e.geometry;const l=s.index;const u=s.attributes.position;const f=n.index;const d=n.attributes.position;const h=R(t,c);const p=G(a,r);Fe.copy(o).invert();if(n.boundsTree){A(W(t),i,Ue);Ue.matrix.copy(Fe);Ue.needsUpdate=true;const s=n.boundsTree.shapecast({intersectsBounds:t=>Ue.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(o);t.b.applyMatrix4(o);t.c.applyMatrix4(o);t.needsUpdate=true;for(let n=h,o=p+h;n<o;n++){Ct(Ve,3*e.resolveTriangleIndex(n),l,u);Ve.needsUpdate=true;if(t.intersectsTriangle(Ve)){return true}}return false}});return s}else{for(let t=h,n=p+h;t<n;t++){const n=e.resolveTriangleIndex(t);Ct(_e,3*n,l,u);_e.a.applyMatrix4(Fe);_e.b.applyMatrix4(Fe);_e.c.applyMatrix4(Fe);_e.needsUpdate=true;for(let t=0,e=f.count;t<e;t+=3){Ct(Ve,t,f,d);Ve.needsUpdate=true;if(_e.intersectsTriangle(Ve)){return true}}}}}else{const r=t+8;const a=c[t+6];A(W(r),i,Se);const l=s.intersectsBox(Se)&&Ee(r,e,n,o,s);if(l)return true;A(W(a),i,Se);const u=s.intersectsBox(Se)&&Ee(a,e,n,o,s);if(u)return true;return false}}const Ne=new t.Matrix4;const He=new ft;const ke=new ft;const Ce=new t.Vector3;const Re=new t.Vector3;const Ge=new t.Vector3;const qe=new t.Vector3;function Oe(t,e,n,o={},s={},i=0,r=Infinity){if(!e.boundingBox){e.computeBoundingBox()}He.set(e.boundingBox.min,e.boundingBox.max,n);He.needsUpdate=true;const c=t.geometry;const a=c.attributes.position;const l=c.index;const u=e.attributes.position;const f=e.index;const d=pt.getPrimitive();const h=pt.getPrimitive();let p=Ce;let m=Re;let x=null;let g=null;if(s){x=Ge;g=qe}let b=Infinity;let v=null;let w=null;Ne.copy(n).invert();ke.matrix.copy(Ne);t.shapecast({boundsTraverseOrder:t=>He.distanceToBox(t),intersectsBounds:(t,e,n)=>{if(n<b&&n<r){if(e){ke.min.copy(t.min);ke.max.copy(t.max);ke.needsUpdate=true}return true}return false},intersectsRange:(o,s)=>{if(e.boundsTree){const c=e.boundsTree;return c.shapecast({boundsTraverseOrder:t=>ke.distanceToBox(t),intersectsBounds:(t,e,n)=>n<b&&n<r,intersectsRange:(e,r)=>{for(let y=e,B=e+r;y<B;y++){const e=c.resolveTriangleIndex(y);Ct(h,3*e,f,u);h.a.applyMatrix4(n);h.b.applyMatrix4(n);h.c.applyMatrix4(n);h.needsUpdate=true;for(let e=o,n=o+s;e<n;e++){const n=t.resolveTriangleIndex(e);Ct(d,3*n,l,a);d.needsUpdate=true;const o=d.distanceToTriangle(h,p,x);if(o<b){m.copy(p);if(g){g.copy(x)}b=o;v=e;w=y}if(o<i){return true}}}}})}else{const r=y(e);for(let e=0,c=r;e<c;e++){Ct(h,3*e,f,u);h.a.applyMatrix4(n);h.b.applyMatrix4(n);h.c.applyMatrix4(n);h.needsUpdate=true;for(let n=o,r=o+s;n<r;n++){const o=t.resolveTriangleIndex(n);Ct(d,3*o,l,a);d.needsUpdate=true;const s=d.distanceToTriangle(h,p,x);if(s<b){m.copy(p);if(g){g.copy(x)}b=s;v=n;w=e}if(s<i){return true}}}}}});pt.releasePrimitive(d);pt.releasePrimitive(h);if(b===Infinity){return null}if(!o.point){o.point=m.clone()}else{o.point.copy(m)}o.distance=b,o.faceIndex=v;if(s){if(!s.point)s.point=g.clone();else s.point.copy(g);s.point.applyMatrix4(Ne);m.applyMatrix4(Ne);s.distance=m.sub(s.point).length();s.faceIndex=w}return o}function Le(){return typeof SharedArrayBuffer!=="undefined"}function We(t,e){if(t===null){return t}else if(t.buffer){const n=t.buffer;if(n.constructor===e){return t}const o=t.constructor;const s=new o(new e(n.byteLength));s.set(t);return s}else{if(t.constructor===e){return t}const n=new e(t.byteLength);new Uint8Array(n).set(new Uint8Array(t));return n}}const Xe=new mt.constructor;const Ye=new mt.constructor;const Ze=new dt(()=>new t.Box3);const je=new t.Box3;const Ke=new t.Box3;const $e=new t.Box3;const Je=new t.Box3;let Qe=false;function tn(e,n,o,s){if(Qe){throw new Error("MeshBVH: Recursive calls to bvhcast not supported.")}Qe=true;const i=e._roots;const r=n._roots;let c;let a=0;let l=0;const u=(new t.Matrix4).copy(o).invert();for(let t=0,e=i.length;t<e;t++){Xe.setBuffer(i[t]);l=0;const e=Ze.getPrimitive();A(W(0),Xe.float32Array,e);e.applyMatrix4(u);for(let n=0,i=r.length;n<i;n++){Ye.setBuffer(r[t]);c=en(0,0,o,u,s,a,l,0,0,e);Ye.clearBuffer();l+=r[n].length;if(c){break}}Ze.releasePrimitive(e);Xe.clearBuffer();a+=i[t].length;if(c){break}}Qe=false;return c}function en(t,e,n,o,s,i=0,r=0,c=0,a=0,l=null,u=false){let f,d;if(u){f=Ye;d=Xe}else{f=Xe;d=Ye}const h=f.float32Array,p=f.uint32Array,y=f.uint16Array,m=d.float32Array,x=d.uint32Array,g=d.uint16Array;const b=t*2;const v=e*2;const w=C(b,y);const B=C(v,g);let T=false;if(B&&w){if(u){T=s(R(e,x),G(e*2,g),R(t,p),G(t*2,y),a,r+e,c,i+t)}else{T=s(R(t,p),G(t*2,y),R(e,x),G(e*2,g),c,i+t,a,r+e)}}else if(B){const l=Ze.getPrimitive();A(W(e),m,l);l.applyMatrix4(n);const f=q(t);const d=O(t,p);A(W(f),h,je);A(W(d),h,Ke);const y=l.intersectsBox(je);const x=l.intersectsBox(Ke);T=y&&en(e,f,o,n,s,r,i,a,c+1,l,!u)||x&&en(e,d,o,n,s,r,i,a,c+1,l,!u);Ze.releasePrimitive(l)}else{const f=q(e);const d=O(e,x);A(W(f),m,$e);A(W(d),m,Je);const y=l.intersectsBox($e);const g=l.intersectsBox(Je);if(y&&g){T=en(t,f,n,o,s,i,r,c,a+1,l,u)||en(t,d,n,o,s,i,r,c,a+1,l,u)}else if(y){if(w){T=en(t,f,n,o,s,i,r,c,a+1,l,u)}else{const e=Ze.getPrimitive();e.copy($e).applyMatrix4(n);const l=q(t);const d=O(t,p);A(W(l),h,je);A(W(d),h,Ke);const y=e.intersectsBox(je);const m=e.intersectsBox(Ke);T=y&&en(f,l,o,n,s,r,i,a,c+1,e,!u)||m&&en(f,d,o,n,s,r,i,a,c+1,e,!u);Ze.releasePrimitive(e)}}else if(g){if(w){T=en(t,d,n,o,s,i,r,c,a+1,l,u)}else{const e=Ze.getPrimitive();e.copy(Je).applyMatrix4(n);const l=q(t);const f=O(t,p);A(W(l),h,je);A(W(f),h,Ke);const y=e.intersectsBox(je);const m=e.intersectsBox(Ke);T=y&&en(d,l,o,n,s,r,i,a,c+1,e,!u)||m&&en(d,f,o,n,s,r,i,a,c+1,e,!u);Ze.releasePrimitive(e)}}}return T}const nn=new ft;const on=new t.Box3;const sn={strategy:n,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:false,setBoundingBox:true,onProgress:null,indirect:false,verbose:true};class rn{static serialize(t,e={}){e={cloneBuffers:true,...e};const n=t.geometry;const o=t._roots;const s=t._indirectBuffer;const i=n.getIndex();let r;if(e.cloneBuffers){r={roots:o.map(t=>t.slice()),index:i?i.array.slice():null,indirectBuffer:s?s.slice():null}}else{r={roots:o,index:i?i.array:null,indirectBuffer:s}}return r}static deserialize(e,n,o={}){o={setIndex:true,indirect:Boolean(e.indirectBuffer),...o};const{index:s,roots:i,indirectBuffer:r}=e;const c=new rn(n,{...o,[h]:true});c._roots=i;c._indirectBuffer=r||null;if(o.setIndex){const o=n.getIndex();if(o===null){const o=new t.BufferAttribute(e.index,1,false);n.setIndex(o)}else if(o.array!==s){o.array.set(s);o.needsUpdate=true}}return c}get indirect(){return!!this._indirectBuffer}constructor(e,n={}){if(!e.isBufferGeometry){throw new Error("MeshBVH: Only BufferGeometries are supported.")}else if(e.index&&e.index.isInterleavedBufferAttribute){throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}n=Object.assign({...sn,[h]:false},n);if(n.useSharedArrayBuffer&&!Le()){throw new Error("MeshBVH: SharedArrayBuffer is not available.")}this.geometry=e;this._roots=null;this._indirectBuffer=null;if(!n[h]){nt(this,n);if(!e.boundingBox&&n.setBoundingBox){e.boundingBox=this.getBoundingBox(new t.Box3)}}this.resolveTriangleIndex=n.indirect?t=>this._indirectBuffer[t]:t=>t}refit(t=null){const e=this.indirect?Be:Kt;return e(this,t)}traverse(t,e=0){const n=this._roots[e];const o=new Uint32Array(n);const s=new Uint16Array(n);i(0);function i(e,r=0){const c=e*2;const a=s[c+15]===f;if(a){const i=o[e+6];const l=s[c+14];t(r,a,new Float32Array(n,e*4,6),i,l)}else{const s=e+u/4;const c=o[e+6];const l=o[e+7];const f=t(r,a,new Float32Array(n,e*4,6),l);if(!f){i(s,r+1);i(c,r+1)}}}}raycast(e,n=t.FrontSide,o=0,s=Infinity){const i=this._roots;const r=this.geometry;const c=[];const a=n.isMaterial;const l=Array.isArray(n);const u=r.groups;const f=a?n.side:n;const d=this.indirect?Ae:ee;for(let t=0,r=i.length;t<r;t++){const i=l?n[u[t].materialIndex].side:f;const r=c.length;d(this,t,i,e,c,o,s);if(l){const e=u[t].materialIndex;for(let t=r,n=c.length;t<n;t++){c[t].face.materialIndex=e}}}return c}raycastFirst(e,n=t.FrontSide,o=0,s=Infinity){const i=this._roots;const r=this.geometry;const c=n.isMaterial;const a=Array.isArray(n);let l=null;const u=r.groups;const f=c?n.side:n;const d=this.indirect?Me:se;for(let t=0,r=i.length;t<r;t++){const i=a?n[u[t].materialIndex].side:f;const r=d(this,t,i,e,o,s);if(r!=null&&(l==null||r.distance<l.distance)){l=r;if(a){r.face.materialIndex=u[t].materialIndex}}}return l}intersectsGeometry(t,e){let n=false;const o=this._roots;const s=this.indirect?ze:de;for(let i=0,r=o.length;i<r;i++){n=s(this,i,t,e);if(n){break}}return n}shapecast(t){const e=pt.getPrimitive();const n=this.indirect?te:jt;let{boundsTraverseOrder:o,intersectsBounds:s,intersectsRange:i,intersectsTriangle:r}=t;if(i&&r){const t=i;i=(o,s,i,c,a)=>{if(!t(o,s,i,c,a)){return n(o,s,this,r,i,c,e)}return true}}else if(!i){if(r){i=(t,o,s,i)=>n(t,o,this,r,s,i,e)}else{i=(t,e,n)=>n}}let c=false;let a=0;const l=this._roots;for(let t=0,e=l.length;t<e;t++){const e=l[t];c=wt(this,t,s,i,o,a);if(c){break}a+=e.byteLength}pt.releasePrimitive(e);return c}bvhcast(t,e,n){let{intersectsRanges:o,intersectsTriangles:s}=n;const i=pt.getPrimitive();const r=this.geometry.index;const c=this.geometry.attributes.position;const a=this.indirect?t=>{const e=this.resolveTriangleIndex(t);Ct(i,e*3,r,c)}:t=>{Ct(i,t*3,r,c)};const l=pt.getPrimitive();const u=t.geometry.index;const f=t.geometry.attributes.position;const d=t.indirect?e=>{const n=t.resolveTriangleIndex(e);Ct(l,n*3,u,f)}:t=>{Ct(l,t*3,u,f)};if(s){const t=(t,n,o,r,c,u,f,h)=>{for(let p=o,y=o+r;p<y;p++){d(p);l.a.applyMatrix4(e);l.b.applyMatrix4(e);l.c.applyMatrix4(e);l.needsUpdate=true;for(let e=t,o=t+n;e<o;e++){a(e);i.needsUpdate=true;if(s(i,l,e,p,c,u,f,h)){return true}}}return false};if(o){const e=o;o=function(n,o,s,i,r,c,a,l){if(!e(n,o,s,i,r,c,a,l)){return t(n,o,s,i,r,c,a,l)}return true}}else{o=t}}return tn(this,t,e,o)}intersectsBox(t,e){nn.set(t.min,t.max,e);nn.needsUpdate=true;return this.shapecast({intersectsBounds:t=>nn.intersectsBox(t),intersectsTriangle:t=>nn.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},o={},s=0,i=Infinity){const r=this.indirect?Oe:we;return r(this,t,e,n,o,s,i)}closestPointToPoint(t,e={},n=0,o=Infinity){return It(this,t,e,n,o)}getBoundingBox(t){t.makeEmpty();const e=this._roots;e.forEach(e=>{A(0,new Float32Array(e),on);t.union(on)});return t}}const cn=new t.Box3;class an extends t.Object3D{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(e,n,o=10,s=0){super();this.material=n;this.geometry=new t.BufferGeometry;this.name="MeshBVHRootHelper";this.depth=o;this.displayParents=false;this.bvh=e;this.displayEdges=true;this._group=s}raycast(){}update(){const e=this.geometry;const n=this.bvh;const o=this._group;e.dispose();this.visible=false;if(n){const s=this.depth-1;const i=this.displayParents;let r=0;n.traverse((t,e)=>{if(t>=s||e){r++;return true}else if(i){r++}},o);let c=0;const a=new Float32Array(8*3*r);n.traverse((t,e,n)=>{const o=t>=s||e;if(o||i){A(0,n,cn);const{min:t,max:e}=cn;for(let n=-1;n<=1;n+=2){const o=n<0?t.x:e.x;for(let n=-1;n<=1;n+=2){const s=n<0?t.y:e.y;for(let n=-1;n<=1;n+=2){const i=n<0?t.z:e.z;a[c+0]=o;a[c+1]=s;a[c+2]=i;c+=3}}}return o}},o);let l;let u;if(this.displayEdges){u=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7])}else{u=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7])}if(a.length>65535){l=new Uint32Array(u.length*r)}else{l=new Uint16Array(u.length*r)}const f=u.length;for(let t=0;t<r;t++){const e=t*8;const n=t*f;for(let t=0;t<f;t++){l[n+t]=e+u[t]}}e.setIndex(new t.BufferAttribute(l,1,false));e.setAttribute("position",new t.BufferAttribute(a,3,false));this.visible=true}}}class ln extends t.Group{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t;this.meshMaterial.opacity=t}constructor(e=null,n=null,o=10){if(e instanceof rn){o=n||10;n=e;e=null}if(typeof n==="number"){o=n;n=null}super();this.name="MeshBVHHelper";this.depth=o;this.mesh=e;this.bvh=n;this.displayParents=false;this.displayEdges=true;this._roots=[];const s=new t.LineBasicMaterial({color:65416,transparent:true,opacity:.3,depthWrite:false});const i=new t.MeshBasicMaterial({color:65416,transparent:true,opacity:.3,depthWrite:false});i.color=s.color;this.edgeMaterial=s;this.meshMaterial=i;this.update()}update(){const t=this.bvh||this.mesh.geometry.boundsTree;const e=t?t._roots.length:0;while(this._roots.length>e){const t=this._roots.pop();t.geometry.dispose();this.remove(t)}for(let n=0;n<e;n++){const{depth:e,edgeMaterial:o,meshMaterial:s,displayParents:i,displayEdges:r}=this;if(n>=this._roots.length){const s=new an(t,o,e,n);this.add(s);this._roots.push(s)}const c=this._roots[n];c.bvh=t;c.depth=e;c.displayParents=i;c.displayEdges=r;c.material=r?o:s;c.update()}}updateMatrixWorld(...t){const e=this.mesh;const n=this.parent;if(e!==null){e.updateWorldMatrix(true,false);if(n){this.matrix.copy(n.matrixWorld).invert().multiply(e.matrixWorld)}else{this.matrix.copy(e.matrixWorld)}this.matrix.decompose(this.position,this.quaternion,this.scale)}super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth;this.mesh=t.mesh;this.bvh=t.bvh;this.opacity=t.opacity;this.color.copy(t.color)}clone(){return new ln(this.mesh,this.bvh,this.depth)}dispose(){this.edgeMaterial.dispose();this.meshMaterial.dispose();const t=this.children;for(let e=0,n=t.length;e<n;e++){t[e].geometry.dispose()}}}class un extends ln{constructor(...t){super(...t);console.warn("MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.")}}const fn=new t.Box3;const dn=new t.Box3;const hn=new t.Vector3;function pn(t){switch(typeof t){case"number":return 8;case"string":return t.length*2;case"boolean":return 4;default:return 0}}function yn(t){const e=/(Uint|Int|Float)(8|16|32)Array/;return e.test(t.constructor.name)}function mn(t,e){const n={nodeCount:0,leafNodeCount:0,depth:{min:Infinity,max:-Infinity},tris:{min:Infinity,max:-Infinity},splits:[0,0,0],surfaceAreaScore:0};t.traverse((t,e,o,s,i)=>{const r=o[0+3]-o[0];const c=o[1+3]-o[1];const u=o[2+3]-o[2];const f=2*(r*c+c*u+u*r);n.nodeCount++;if(e){n.leafNodeCount++;n.depth.min=Math.min(t,n.depth.min);n.depth.max=Math.max(t,n.depth.max);n.tris.min=Math.min(i,n.tris.min);n.tris.max=Math.max(i,n.tris.max);n.surfaceAreaScore+=f*a*i}else{n.splits[s]++;n.surfaceAreaScore+=f*l}},e);if(n.tris.min===Infinity){n.tris.min=0;n.tris.max=0}if(n.depth.min===Infinity){n.depth.min=0;n.depth.max=0}return n}function xn(t){return t._roots.map((e,n)=>mn(t,n))}function gn(t){const e=new Set;const n=[t];let o=0;while(n.length){const t=n.pop();if(e.has(t)){continue}e.add(t);for(let e in t){if(!Object.hasOwn(t,e)){continue}o+=pn(e);const s=t[e];if(s&&(typeof s==="object"||typeof s==="function")){if(yn(s)){o+=s.byteLength}else if(Le()&&s instanceof SharedArrayBuffer){o+=s.byteLength}else if(s instanceof ArrayBuffer){o+=s.byteLength}else{n.push(s)}}else{o+=pn(s)}}}return o}function bn(t){const e=t.geometry;const n=[];const o=e.index;const s=e.getAttribute("position");let i=true;t.traverse((e,r,c,a,l)=>{const u={depth:e,isLeaf:r,boundingData:c,offset:a,count:l};n[e]=u;A(0,c,fn);const f=n[e-1];if(r){for(let e=a,n=a+l;e<n;e++){const n=t.resolveTriangleIndex(e);let r=3*n;let c=3*n+1;let a=3*n+2;if(o){r=o.getX(r);c=o.getX(c);a=o.getX(a)}let l;hn.fromBufferAttribute(s,r);l=fn.containsPoint(hn);hn.fromBufferAttribute(s,c);l=l&&fn.containsPoint(hn);hn.fromBufferAttribute(s,a);l=l&&fn.containsPoint(hn);console.assert(l,"Leaf bounds does not fully contain triangle.");i=i&&l}}if(f){A(0,c,dn);const t=dn.containsBox(fn);console.assert(t,"Parent bounds does not fully contain child.");i=i&&t}});return i}function vn(e){const n=[];e.traverse((e,o,s,i,r)=>{const c={bounds:A(0,s,new t.Box3)};if(o){c.count=r;c.offset=i}else{c.left=null;c.right=null}n[e]=c;const a=n[e-1];if(a){if(a.left===null){a.left=c}else{a.right=c}}});return n[0]}function wn(t,e,n){if(t===null){return null}t.point.applyMatrix4(e.matrixWorld);t.distance=t.point.distanceTo(n.ray.origin);t.object=e;return t}const Bn=new t.Ray;const An=new t.Vector3;const Tn=new t.Matrix4;const In=t.Mesh.prototype.raycast;const Mn=new t.Vector3;function Pn(t,e){if(this.geometry.boundsTree){if(this.material===undefined)return;Tn.copy(this.matrixWorld).invert();Bn.copy(t.ray).applyMatrix4(Tn);Vn(this.matrixWorld,Mn);An.copy(Bn.direction).multiply(Mn);const n=An.length();const o=t.near/n;const s=t.far/n;const i=this.geometry.boundsTree;if(t.firstHitOnly===true){const n=wn(i.raycastFirst(Bn,this.material,o,s),this,t);if(n){e.push(n)}}else{const n=i.raycast(Bn,this.material,o,s);for(let o=0,s=n.length;o<s;o++){const s=wn(n[o],this,t);if(s){e.push(s)}}}}else{In.call(this,t,e)}}function Sn(t){this.boundsTree=new rn(this,t);return this.boundsTree}function _n(){this.boundsTree=null}function Vn(t,e){const n=t.elements;const o=e.set(n[0],n[1],n[2]).length();const s=e.set(n[4],n[5],n[6]).length();const i=e.set(n[8],n[9],n[10]).length();return e.set(o,s,i)}function Fn(t){switch(t){case 1:return"R";case 2:return"RG";case 3:return"RGBA";case 4:return"RGBA"}throw new Error}function Dn(e){switch(e){case 1:return t.RedFormat;case 2:return t.RGFormat;case 3:return t.RGBAFormat;case 4:return t.RGBAFormat}}function Un(e){switch(e){case 1:return t.RedIntegerFormat;case 2:return t.RGIntegerFormat;case 3:return t.RGBAIntegerFormat;case 4:return t.RGBAIntegerFormat}}class zn extends t.DataTexture{constructor(){super();this.minFilter=t.NearestFilter;this.magFilter=t.NearestFilter;this.generateMipmaps=false;this.overrideItemSize=null;this._forcedType=null}updateFrom(e){const n=this.overrideItemSize;const o=e.itemSize;const s=e.count;if(n!==null){if(o*s%n!==0){throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.")}e.itemSize=n;e.count=s*o/n}const i=e.itemSize;const r=e.count;const c=e.normalized;const a=e.array.constructor;const l=a.BYTES_PER_ELEMENT;let u=this._forcedType;let f=i;if(u===null){switch(a){case Float32Array:u=t.FloatType;break;case Uint8Array:case Uint16Array:case Uint32Array:u=t.UnsignedIntType;break;case Int8Array:case Int16Array:case Int32Array:u=t.IntType;break}}let d,h,p,y;let m=Fn(i);switch(u){case t.FloatType:p=1;h=Dn(i);if(c&&l===1){y=a;m+="8";if(a===Uint8Array){d=t.UnsignedByteType}else{d=t.ByteType;m+="_SNORM"}}else{y=Float32Array;m+="32F";d=t.FloatType}break;case t.IntType:m+=l*8+"I";p=c?Math.pow(2,a.BYTES_PER_ELEMENT*8-1):1;h=Un(i);if(l===1){y=Int8Array;d=t.ByteType}else if(l===2){y=Int16Array;d=t.ShortType}else{y=Int32Array;d=t.IntType}break;case t.UnsignedIntType:m+=l*8+"UI";p=c?Math.pow(2,a.BYTES_PER_ELEMENT*8-1):1;h=Un(i);if(l===1){y=Uint8Array;d=t.UnsignedByteType}else if(l===2){y=Uint16Array;d=t.UnsignedShortType}else{y=Uint32Array;d=t.UnsignedIntType}break}if(f===3&&(h===t.RGBAFormat||h===t.RGBAIntegerFormat)){f=4}const x=Math.ceil(Math.sqrt(r))||1;const g=f*x*x;const b=new y(g);const v=e.normalized;e.normalized=false;for(let t=0;t<r;t++){const n=f*t;b[n]=e.getX(t)/p;if(i>=2){b[n+1]=e.getY(t)/p}if(i>=3){b[n+2]=e.getZ(t)/p;if(f===4){b[n+3]=1}}if(i>=4){b[n+3]=e.getW(t)/p}}e.normalized=v;this.internalFormat=m;this.format=h;this.type=d;this.image.width=x;this.image.height=x;this.image.data=b;this.needsUpdate=true;this.dispose();e.itemSize=o;e.count=s}}class En extends zn{constructor(){super();this._forcedType=t.UnsignedIntType}}class Nn extends zn{constructor(){super();this._forcedType=t.IntType}}class Hn extends zn{constructor(){super();this._forcedType=t.FloatType}}class kn{constructor(){this.index=new En;this.position=new Hn;this.bvhBounds=new t.DataTexture;this.bvhContents=new t.DataTexture;this._cachedIndexAttr=null;this.index.overrideItemSize=3}updateFrom(e){const{geometry:n}=e;Rn(e,this.bvhBounds,this.bvhContents);this.position.updateFrom(n.attributes.position);if(e.indirect){const o=e._indirectBuffer;if(this._cachedIndexAttr===null||this._cachedIndexAttr.count!==o.length){if(n.index){this._cachedIndexAttr=n.index.clone()}else{const e=m(p(n));this._cachedIndexAttr=new t.BufferAttribute(e,1,false)}}Cn(n,o,this._cachedIndexAttr);this.index.updateFrom(this._cachedIndexAttr)}else{this.index.updateFrom(n.index)}}dispose(){const{index:t,position:e,bvhBounds:n,bvhContents:o}=this;if(t)t.dispose();if(e)e.dispose();if(n)n.dispose();if(o)o.dispose()}}function Cn(t,e,n){const o=n.array;const s=t.index?t.index.array:null;for(let t=0,n=e.length;t<n;t++){const n=3*t;const i=3*e[t];for(let t=0;t<3;t++){o[n+t]=s?s[i+t]:i+t}}}function Rn(e,n,o){const s=e._roots;if(s.length!==1){throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.")}const i=s[0];const r=new Uint16Array(i);const c=new Uint32Array(i);const a=new Float32Array(i);const l=i.byteLength/u;const f=2*Math.ceil(Math.sqrt(l/2));const d=new Float32Array(4*f*f);const h=Math.ceil(Math.sqrt(l));const p=new Uint32Array(2*h*h);for(let t=0;t<l;t++){const e=t*u/4;const n=e*2;const o=W(e);for(let e=0;e<3;e++){d[8*t+0+e]=a[o+0+e];d[8*t+4+e]=a[o+3+e]}if(C(n,r)){const o=G(n,r);const s=R(e,c);const i=4294901760|o;p[t*2+0]=i;p[t*2+1]=s}else{const n=4*O(e,c)/u;const o=L(e,c);p[t*2+0]=o;p[t*2+1]=n}}n.image.data=d;n.image.width=f;n.image.height=f;n.format=t.RGBAFormat;n.type=t.FloatType;n.internalFormat="RGBA32F";n.minFilter=t.NearestFilter;n.magFilter=t.NearestFilter;n.generateMipmaps=false;n.needsUpdate=true;n.dispose();o.image.data=p;o.image.width=h;o.image.height=h;o.format=t.RGIntegerFormat;o.type=t.UnsignedIntType;o.internalFormat="RG32UI";o.minFilter=t.NearestFilter;o.magFilter=t.NearestFilter;o.generateMipmaps=false;o.needsUpdate=true;o.dispose()}const Gn=new t.Vector3;const qn=new t.Vector3;const On=new t.Vector3;const Ln=new t.Vector4;const Wn=new t.Vector3;const Xn=new t.Vector3;const Yn=new t.Vector4;const Zn=new t.Vector4;const jn=new t.Matrix4;const Kn=new t.Matrix4;function $n(t,e){if(!t&&!e){return}const n=t.count===e.count;const o=t.normalized===e.normalized;const s=t.array.constructor===e.array.constructor;const i=t.itemSize===e.itemSize;if(!n||!o||!s||!i){throw new Error}}function Jn(e,n=null){const o=e.array.constructor;const s=e.normalized;const i=e.itemSize;const r=n===null?e.count:n;return new t.BufferAttribute(new o(i*r),i,s)}function Qn(t,e,n=0){if(t.isInterleavedBufferAttribute){const o=t.itemSize;for(let s=0,i=t.count;s<i;s++){const i=s+n;e.setX(i,t.getX(s));if(o>=2)e.setY(i,t.getY(s));if(o>=3)e.setZ(i,t.getZ(s));if(o>=4)e.setW(i,t.getW(s))}}else{const o=e.array;const s=o.constructor;const i=o.BYTES_PER_ELEMENT*t.itemSize*n;const r=new s(o.buffer,i,t.array.length);r.set(t.array)}}function to(t,e,n){const o=t.elements;const s=e.elements;for(let t=0,e=s.length;t<e;t++){o[t]+=s[t]*n}}function eo(t,e,n){const o=t.skeleton;const s=t.geometry;const i=o.bones;const r=o.boneInverses;Yn.fromBufferAttribute(s.attributes.skinIndex,e);Zn.fromBufferAttribute(s.attributes.skinWeight,e);jn.elements.fill(0);for(let t=0;t<4;t++){const e=Zn.getComponent(t);if(e!==0){const n=Yn.getComponent(t);Kn.multiplyMatrices(i[n].matrixWorld,r[n]);to(jn,Kn,e)}}jn.multiply(t.bindMatrix).premultiply(t.bindMatrixInverse);n.transformDirection(jn);return n}function no(t,e,n,o,s){Wn.set(0,0,0);for(let i=0,r=t.length;i<r;i++){const r=e[i];const c=t[i];if(r===0)continue;Xn.fromBufferAttribute(c,o);if(n){Wn.addScaledVector(Xn,r)}else{Wn.addScaledVector(Xn.sub(s),r)}}s.add(Wn)}function oo(e,n={useGroups:false,updateIndex:false,skipAttributes:[]},o=new t.BufferGeometry){const s=e[0].index!==null;const{useGroups:i=false,updateIndex:r=false,skipAttributes:c=[]}=n;const a=new Set(Object.keys(e[0].attributes));const l={};let u=0;o.clearGroups();for(let t=0;t<e.length;++t){const n=e[t];let r=0;if(s!==(n.index!==null)){throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.")}for(const t in n.attributes){if(!a.has(t)){throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.')}if(l[t]===undefined){l[t]=[]}l[t].push(n.attributes[t]);r++}if(r!==a.size){throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.")}if(i){let e;if(s){e=n.index.count}else if(n.attributes.position!==undefined){e=n.attributes.position.count}else{throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute")}o.addGroup(u,e,t);u+=e}}if(s){let n=false;if(!o.index){let s=0;for(let t=0;t<e.length;++t){s+=e[t].index.count}o.setIndex(new t.BufferAttribute(new Uint32Array(s),1,false));n=true}if(r||n){const t=o.index;let n=0;let s=0;for(let o=0;o<e.length;++o){const i=e[o];const r=i.index;if(c[o]!==true){for(let e=0;e<r.count;++e){t.setX(n,r.getX(e)+s);n++}}s+=i.attributes.position.count}}}for(const t in l){const e=l[t];if(!(t in o.attributes)){let n=0;for(const t in e){n+=e[t].count}o.setAttribute(t,Jn(l[t][0],n))}const n=o.attributes[t];let s=0;for(let t=0,o=e.length;t<o;t++){const o=e[t];if(c[t]!==true){Qn(o,n,s)}s+=o.count}}return o}function so(t,e){if(t===null||e===null){return t===e}if(t.length!==e.length){return false}for(let n=0,o=t.length;n<o;n++){if(t[n]!==e[n]){return false}}return true}function io(t){const{index:e,attributes:n}=t;if(e){for(let t=0,n=e.count;t<n;t+=3){const n=e.getX(t);const o=e.getX(t+2);e.setX(t,o);e.setX(t+2,n)}}else{for(const t in n){const e=n[t];const o=e.itemSize;for(let t=0,n=e.count;t<n;t+=3){for(let n=0;n<o;n++){const o=e.getComponent(t,n);const s=e.getComponent(t+2,n);e.setComponent(t,n,s);e.setComponent(t+2,n,o)}}}}return t}class ro{constructor(e){this.matrixWorld=new t.Matrix4;this.geometryHash=null;this.boneMatrices=null;this.primitiveCount=-1;this.mesh=e;this.update()}update(){const t=this.mesh;const e=t.geometry;const n=t.skeleton;const o=(e.index?e.index.count:e.attributes.position.count)/3;this.matrixWorld.copy(t.matrixWorld);this.geometryHash=e.attributes.position.version;this.primitiveCount=o;if(n){if(!n.boneTexture){n.computeBoneTexture()}n.update();const t=n.boneMatrices;if(!this.boneMatrices||this.boneMatrices.length!==t.length){this.boneMatrices=t.slice()}else{this.boneMatrices.set(t)}}else{this.boneMatrices=null}}didChange(){const t=this.mesh;const e=t.geometry;const n=(e.index?e.index.count:e.attributes.position.count)/3;const o=this.matrixWorld.equals(t.matrixWorld)&&this.geometryHash===e.attributes.position.version&&so(t.skeleton&&t.skeleton.boneMatrices||null,this.boneMatrices)&&this.primitiveCount===n;return!o}}class co{constructor(e){if(!Array.isArray(e)){e=[e]}const n=[];e.forEach(t=>{t.traverseVisible(t=>{if(t.isMesh){n.push(t)}})});this.meshes=n;this.useGroups=true;this.applyWorldTransforms=true;this.attributes=["position","normal","color","tangent","uv","uv2"];this._intermediateGeometry=new Array(n.length).fill().map(()=>new t.BufferGeometry);this._diffMap=new WeakMap}getMaterials(){const t=[];this.meshes.forEach(e=>{if(Array.isArray(e.material)){t.push(...e.material)}else{t.push(e.material)}});return t}generate(e=new t.BufferGeometry){let n=[];const{meshes:o,useGroups:s,_intermediateGeometry:i,_diffMap:r}=this;for(let t=0,e=o.length;t<e;t++){const e=o[t];const s=i[t];const c=r.get(e);if(!c||c.didChange(e)){this._convertToStaticGeometry(e,s);n.push(false);if(!c){r.set(e,new ro(e))}else{c.update()}}else{n.push(true)}}if(i.length===0){e.setIndex(null);const n=e.attributes;for(const t in n){e.deleteAttribute(t)}for(const n in this.attributes){e.setAttribute(this.attributes[n],new t.BufferAttribute(new Float32Array(0),4,false))}}else{oo(i,{useGroups:s,skipAttributes:n},e)}for(const t in e.attributes){e.attributes[t].needsUpdate=true}return e}_convertToStaticGeometry(e,n=new t.BufferGeometry){const o=e.geometry;const s=this.applyWorldTransforms;const i=this.attributes.includes("normal");const r=this.attributes.includes("tangent");const c=o.attributes;const a=n.attributes;if(!n.index&&o.index){n.index=o.index.clone()}if(!a.position){n.setAttribute("position",Jn(c.position))}if(i&&!a.normal&&c.normal){n.setAttribute("normal",Jn(c.normal))}if(r&&!a.tangent&&c.tangent){n.setAttribute("tangent",Jn(c.tangent))}$n(o.index,n.index);$n(c.position,a.position);if(i){$n(c.normal,a.normal)}if(r){$n(c.tangent,a.tangent)}const l=c.position;const u=i?c.normal:null;const f=r?c.tangent:null;const d=o.morphAttributes.position;const h=o.morphAttributes.normal;const p=o.morphAttributes.tangent;const y=o.morphTargetsRelative;const m=e.morphTargetInfluences;const x=new t.Matrix3;x.getNormalMatrix(e.matrixWorld);if(o.index){n.index.array.set(o.index.array)}for(let t=0,n=c.position.count;t<n;t++){Gn.fromBufferAttribute(l,t);if(u){qn.fromBufferAttribute(u,t)}if(f){Ln.fromBufferAttribute(f,t);On.fromBufferAttribute(f,t)}if(m){if(d){no(d,m,y,t,Gn)}if(h){no(h,m,y,t,qn)}if(p){no(p,m,y,t,On)}}if(e.isSkinnedMesh){e.applyBoneTransform(t,Gn);if(u){eo(e,t,qn)}if(f){eo(e,t,On)}}if(s){Gn.applyMatrix4(e.matrixWorld)}a.position.setXYZ(t,Gn.x,Gn.y,Gn.z);if(u){if(s){qn.applyNormalMatrix(x)}a.normal.setXYZ(t,qn.x,qn.y,qn.z)}if(f){if(s){On.transformDirection(e.matrixWorld)}a.tangent.setXYZW(t,On.x,On.y,On.z,Ln.w)}}for(const t in this.attributes){const e=this.attributes[t];if(e==="position"||e==="tangent"||e==="normal"||!(e in c)){continue}if(!a[e]){n.setAttribute(e,Jn(c[e]))}$n(c[e],a[e]);Qn(c[e],a[e])}if(e.matrixWorld.determinant()<0){io(n)}return n}}const ao=`\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n`;const lo=`\n\nfloat dot2( vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// point and cut off range\n\tvec3 point, float closestDistanceSquared,\n\n\t// outputs\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\tbvhClosestPointToPoint(\t\tbvh,\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\t)\t_bvhClosestPointToPoint(\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\t)\n\nfloat _bvhClosestPointToPoint(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// point to check\n\tvec3 point,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat closestDistanceSquared = pow( 100000.0, 2.0 );\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count, point, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;const uo=`\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\tbvhIntersectFirstHit(\t\tbvh,\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\t)\t_bvhIntersectFirstHit(\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;const fo=`\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;var ho=Object.freeze({__proto__:null,bvh_distance_functions:lo,bvh_ray_functions:uo,bvh_struct_definitions:fo,common_functions:ao});const po=fo;const yo=lo;const mo=`\n\t${ao}\n\t${uo}\n`;e.AVERAGE=o;e.BVHShaderGLSL=ho;e.CENTER=n;e.CONTAINED=c;e.ExtendedTriangle=ut;e.FloatVertexAttributeTexture=Hn;e.INTERSECTED=r;e.IntVertexAttributeTexture=Nn;e.MeshBVH=rn;e.MeshBVHHelper=ln;e.MeshBVHUniformStruct=kn;e.NOT_INTERSECTED=i;e.OrientedBox=ft;e.SAH=s;e.StaticGeometryGenerator=co;e.UIntVertexAttributeTexture=En;e.VertexAttributeTexture=zn;e.acceleratedRaycast=Pn;e.computeBoundsTree=Sn;e.disposeBoundsTree=_n;e.estimateMemoryInBytes=gn;e.getBVHExtremes=xn;e.getJSONStructure=vn;e.getTriangleHitPointInfo=Xt;e.shaderDistanceFunction=yo;e.shaderIntersectFunction=mo;e.shaderStructs=po;e.validateBounds=bn;return e});
//# sourceMappingURL=three-mesh-bvh.js.map