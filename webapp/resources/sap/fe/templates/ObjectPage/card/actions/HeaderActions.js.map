{"version":3,"file":"HeaderActions.js","names":["ACStyle","_exports","ACAction","ACInput","ACTION_OK","HeaderActions","_BaseCardContentProvi","convertedTypes","config","_this","call","this","actions","contextInfo","getCardConfigurationByKey","contextPath","entityType","getEntityType","Log","error","_assertThisInitialized","getAnnotatedHeaderActions","length","configuredActions","getConfiguredActions","reduce","getActionInAdaptiveCardFormat","bind","err","message","Error","String","_inheritsLoose","_proto","prototype","getCardActions","getAdaptiveCardActionType","edmAction","isBound","isFunction","parameters","needUserInputParameters","ShowCard","Execute","getActionCardBodyWithParameterFields","actionTarget","elements","parameter","index","inputElement","labelTerm","annotations","Common","Label","type","Date","id","name","label","toString","isRequired","getRequired","undefined","push","Text","isMultiline","isMultiLineText","getActionWithParameters","actionDetails","body","verb","title","style","data","actionWithParameters","Positive","card","getAction","dataFieldForAction","ActionTarget","getActionDetails","actionType","retAction","getActionData","bindingContextPath","bindingContextPathRelativeToService","startsWith","substring","serviceURI","contextURL","isConfirmationRequired","getIsCriticalForAdaptiveCardAction","actionToTrigger","Action","replace","getActionStyle","adaptiveCardActions","actionElement","action","titleOverride","isActionVisible","isVisible","getVisibleForAdaptiveCardAction","isEnabled","getEnabledForAdaptiveCardAction","whenValue","test","isStaticAction","isCopyAction","visualUpdates","$when","identificationAnnotation","UI","Identification","filter","dataField","$Type","Determining","annotatedActions","actionConfigs","annotatedActionElements","map","key","getStableIdPartFromDataField","Object","keys","customConfigActionNames","customActionConfigElements","customActionElements","customConfigActionKey","relevantActionElement","find","position","placement","Placement","After","actionOverwriteConfig","OverrideType","overwrite","insertCustomElements","visibilityExp","updatePathsAndGetCompiledExpression","Default","criticality","Criticality","Destructive","isActionCritical","getIsActionCriticalExpression","enabledExpression","getActionEnabledExpression","isCollection","IsCopyAction","valueOf","fieldControlExpression","isActionParameterRequiredExpression","BaseCardContentProvider"],"sources":["./HeaderActions.ts"],"sourcesContent":["import type { Action, ActionParameter, ConvertedMetadata, EntityType } from \"@sap-ux/vocabularies-types\";\nimport { UIAnnotationTypes, type DataFieldForAction } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport Log from \"sap/base/Log\";\nimport {\n\tOverrideType,\n\tPlacement,\n\tinsertCustomElements,\n\ttype ConfigurableObjectKey,\n\ttype CustomElement,\n\ttype Positionable\n} from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport type { CompiledAdaptiveCardExpression } from \"sap/fe/core/helpers/AdaptiveCardExpressionCompiler\";\nimport { getStableIdPartFromDataField } from \"sap/fe/core/helpers/StableIdHelper\";\nimport { getIsActionCriticalExpression } from \"sap/fe/core/templating/ActionHelper\";\nimport { isActionParameterRequiredExpression } from \"sap/fe/core/templating/FieldControlHelper\";\nimport { isMultiLineText } from \"sap/fe/core/templating/PropertyHelper\";\nimport { getActionEnabledExpression, isVisible } from \"sap/fe/core/templating/UIFormatters\";\nimport BaseCardContentProvider, { type CardConfig } from \"sap/fe/templates/ObjectPage/card/BaseCardContentProvider\";\nimport type { ActionData, CardElement, IACAction, IInputDate, IInputText } from \"types/adaptiveCard_types\";\n\nexport type ActionConfig = Positionable & {\n\ttitle?: string;\n\tisVisible?: boolean;\n};\n\nexport type CustomActionConfigs = Record<ConfigurableObjectKey, ActionConfig>;\n\nexport type ActionConfigurable = {\n\tactions?: CustomActionConfigs;\n};\n\nexport type HeaderActionsConfig = ActionConfigurable & CardConfig;\n\ntype ActionConfigElement = Positionable &\n\tActionConfig & {\n\t\tkey: ConfigurableObjectKey;\n\t\taction: DataFieldForAction;\n\t};\n\ntype InternalCustomActionElements = Record<ConfigurableObjectKey, CustomElement<ActionConfigElement>>;\n\nexport enum ACStyle {\n\tDefault = \"default\",\n\tPositive = \"positive\",\n\tDestructive = \"destructive\"\n}\n\nexport enum ACAction {\n\tExecute = \"Action.Execute\",\n\tShowCard = \"Action.ShowCard\"\n}\n\nexport enum ACInput {\n\tText = \"Input.Text\",\n\tChoiceSet = \"Input.ChoiceSet\",\n\tDate = \"Input.Date\"\n}\n\nconst ACTION_OK = \"OK\";\n\nexport default class HeaderActions extends BaseCardContentProvider<HeaderActionsConfig> {\n\tprivate actions: IACAction[] = [];\n\n\t/**\n\t * Get the card actions.\n\t * @returns Card actions.\n\t */\n\tpublic getCardActions(): IACAction[] {\n\t\treturn this.actions;\n\t}\n\n\tconstructor(convertedTypes: ConvertedMetadata, config: HeaderActionsConfig) {\n\t\tsuper(convertedTypes, config);\n\t\ttry {\n\t\t\tconst contextInfo = this.getCardConfigurationByKey(\"contextInfo\");\n\t\t\tconst { contextPath } = contextInfo;\n\t\t\tconst entityType = this.getEntityType();\n\t\t\tif (!entityType) {\n\t\t\t\tLog.error(`FE : V4 : Adaptive Card header actions : no EntityType found at context path: ${contextPath}`);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tconst actions = this.getAnnotatedHeaderActions(entityType);\n\t\t\tif (actions.length > 0) {\n\t\t\t\tconst configuredActions = this.getConfiguredActions(actions);\n\t\t\t\tthis.actions = configuredActions.reduce(this.getActionInAdaptiveCardFormat.bind(this), [] as IACAction[]);\n\t\t\t}\n\t\t} catch (err: unknown) {\n\t\t\tconst message = err instanceof Error ? err.message : String(err);\n\t\t\tLog.error(\"Error while creating the card defintion\", message);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get action type based on the need for user inputs for action parameters.\n\t * @param edmAction Converted metadata action.\n\t * @returns Action type to use\n\t */\n\tprivate getAdaptiveCardActionType(edmAction: Action): ACAction | undefined {\n\t\tconst { isBound, isFunction, parameters } = edmAction;\n\t\tif (isFunction) {\n\t\t\t// functions are ignored\n\t\t\treturn;\n\t\t}\n\t\tconst needUserInputParameters = parameters.length > (isBound ? 1 : 0);\n\n\t\treturn needUserInputParameters ? ACAction.ShowCard : ACAction.Execute;\n\t}\n\n\t/**\n\t * Get Action parameter elements to add to the action card body.\n\t * @param actionTarget Converted metadata action.\n\t * @returns Input elements for action parameters\n\t */\n\tprivate getActionCardBodyWithParameterFields(actionTarget: Action): CardElement[] {\n\t\tconst { isBound } = actionTarget;\n\t\treturn actionTarget.parameters.reduce((elements, parameter, index) => {\n\t\t\tif (isBound && index === 0) {\n\t\t\t\treturn elements;\n\t\t\t}\n\t\t\tlet inputElement: IInputText | IInputDate;\n\t\t\tconst labelTerm = parameter.annotations.Common?.Label;\n\t\t\tif (parameter.type === \"Edm.Date\" || parameter.type === \"Edm.DateTimeOffset\" || parameter.type === \"Edm.DateTime\") {\n\t\t\t\tinputElement = {\n\t\t\t\t\ttype: ACInput.Date,\n\t\t\t\t\tid: parameter.name,\n\t\t\t\t\tlabel: labelTerm?.toString() ?? parameter.name,\n\t\t\t\t\tisRequired: this.getRequired(parameter, actionTarget) ?? undefined\n\t\t\t\t};\n\t\t\t\telements.push(inputElement);\n\t\t\t} else {\n\t\t\t\tinputElement = {\n\t\t\t\t\ttype: ACInput.Text,\n\t\t\t\t\tid: parameter.name,\n\t\t\t\t\tlabel: labelTerm?.toString() ?? parameter.name,\n\t\t\t\t\tisRequired: this.getRequired(parameter, actionTarget) ?? undefined,\n\t\t\t\t\tisMultiline: isMultiLineText(parameter) ?? undefined\n\t\t\t\t};\n\t\t\t\telements.push(inputElement);\n\t\t\t}\n\t\t\treturn elements;\n\t\t}, [] as CardElement[]);\n\t}\n\n\t/**\n\t * Get action object with parameter elements.\n\t * @param actionTarget Converted metadata action.\n\t * @param actionDetails Action properties.\n\t * @returns Action object with parameters.\n\t */\n\tprivate getActionWithParameters(actionTarget: Action, actionDetails: Partial<IACAction>): IACAction {\n\t\tconst body = this.getActionCardBodyWithParameterFields(actionTarget);\n\t\tconst { verb, title, style, data } = actionDetails;\n\t\tconst actionWithParameters: IACAction = {\n\t\t\ttype: ACAction.Execute,\n\t\t\tverb,\n\t\t\tdata,\n\t\t\ttitle: ACTION_OK,\n\t\t\tstyle: ACStyle.Positive\n\t\t};\n\n\t\treturn {\n\t\t\ttype: ACAction.ShowCard,\n\t\t\ttitle,\n\t\t\tstyle,\n\t\t\tcard: {\n\t\t\t\ttype: \"AdaptiveCard\",\n\t\t\t\tbody,\n\t\t\t\tactions: [actionWithParameters]\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Get action for adaptive card.\n\t * @param dataFieldForAction DataFieldForAction annotation\n\t * @returns Action to add.\n\t */\n\tprivate getAction(dataFieldForAction: DataFieldForAction): IACAction | undefined {\n\t\tconst { ActionTarget: actionTarget } = dataFieldForAction;\n\n\t\tconst actionDetails = this.getActionDetails(dataFieldForAction);\n\t\tif (!actionTarget || !actionDetails) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst actionType = this.getAdaptiveCardActionType(actionTarget);\n\n\t\tlet retAction: IACAction | undefined;\n\t\tif (actionType === ACAction.Execute) {\n\t\t\t// Actions without parameters\n\t\t\tretAction = { type: actionType, ...actionDetails };\n\t\t} else if (actionType === ACAction.ShowCard) {\n\t\t\t// Action with parameters\n\t\t\tretAction = this.getActionWithParameters(actionTarget, actionDetails);\n\t\t}\n\t\treturn retAction;\n\t}\n\n\t/**\n\t * Get data that needs to be part of action.\n\t * @param actionTarget Converted metadata action.\n\t * @returns Action data that needs to be passed with the action.\n\t */\n\tprivate getActionData(actionTarget: Action): ActionData {\n\t\tconst { isBound } = actionTarget;\n\t\tconst contextInfo = this.getCardConfigurationByKey(\"contextInfo\");\n\t\tconst { bindingContextPath } = contextInfo;\n\t\tconst bindingContextPathRelativeToService = bindingContextPath.startsWith(\"/\")\n\t\t\t? bindingContextPath.substring(1)\n\t\t\t: bindingContextPath;\n\t\tconst serviceURI = this.getCardConfigurationByKey(\"serviceURI\");\n\t\tconst contextURL = `${serviceURI}${bindingContextPathRelativeToService}`;\n\t\treturn {\n\t\t\tcontextURL,\n\t\t\tserviceURI: isBound ? undefined : serviceURI,\n\t\t\tisConfirmationRequired: this.getIsCriticalForAdaptiveCardAction(actionTarget) ?? undefined\n\t\t};\n\t}\n\n\t/**\n\t * Get action for adaptive card.\n\t * @param dataFieldForAction DataFieldForAction annotation\n\t * @returns Action to add.\n\t */\n\tprivate getActionDetails(dataFieldForAction: DataFieldForAction): Partial<IACAction> | undefined {\n\t\tconst { ActionTarget: actionTarget } = dataFieldForAction;\n\t\tif (!actionTarget) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Verb creation for actions:\n\t\t//\n\t\t// 1. Bound action:\n\t\t//    Verb needs to be relative to contextURL. format: '<metadata namespace>.<action name>'\n\t\t//    Example:\n\t\t//        Metadata namespace: 'com.c_som_sd'\n\t\t//        Action name: 'boundAction'\n\t\t//        Verb: 'com.c_som_sd.boundAction'\n\t\t//        ContextURL: /SOM(1)\n\t\t//        URL to trigger POST call(this will be created by the BOT, <serviceURI + contextURL + verb>): 'https://<serviceURI>/SOM('1')/com.c_som_sd.boundAction'\n\t\t//\n\t\t// 2. Unbound action:\n\t\t//    Verb needs to be relative to serviceURI. format: '<action name>'\n\t\t//    Example:\n\t\t//        Action name: 'unboundAction'\n\t\t//        Verb: 'unboundAction'\n\t\t//        ContextURL: undefined\n\t\t//        URL to trigger POST call(this will be created by the BOT, <serviceURI + verb>): 'https://<serviceURI>/unboundAction'\n\t\tconst actionToTrigger = actionTarget.isBound ? dataFieldForAction.Action.toString() : actionTarget.name,\n\t\t\t// We remove the overload part from the action. like 'com.c_som_sd.boundAction(com.c_som_sd.returnType)', we need only 'com.c_som_sd.boundAction' as verb.\n\t\t\tverb = actionToTrigger.replace(/\\((.*)\\)$/, \"\"),\n\t\t\ttitle = dataFieldForAction.Label?.toString() ?? actionTarget.name,\n\t\t\tstyle = this.getActionStyle(dataFieldForAction),\n\t\t\tdata = this.getActionData(actionTarget);\n\n\t\treturn { verb, title, style, data };\n\t}\n\n\t/**\n\t * Generates action sets for adaptive card.\n\t *\n\t * As of now, only considering 'Annotated Actions'.\n\t * Not supported:\n\t * 1. Standard actions\n\t * 2. Manifest actions\n\t *\n\t * Presently, only first two actions shall be passed to the adaptive card.\n\t *\n\t * This function can be used by Array.reduce.\n\t * @param adaptiveCardActions Actions array to be returned.\n\t * @param actionElement DataFieldForAction that needs to be converted.\n\t * @returns An Array of Actions that need to be concatenated to card body.\n\t */\n\tprivate getActionInAdaptiveCardFormat(adaptiveCardActions: IACAction[], actionElement: ActionConfigElement): IACAction[] {\n\t\tif (adaptiveCardActions.length > 1) {\n\t\t\t// Note: We only expect first 2 actions in MS teams adaptive cards. This might change in the future.\n\t\t\treturn adaptiveCardActions;\n\t\t}\n\n\t\tconst { action: dataFieldForAction, title: titleOverride } = actionElement;\n\t\tconst { ActionTarget: actionTarget } = dataFieldForAction;\n\n\t\t// No Action in case:\n\t\t// 1. actionTarget not available.\n\t\t// 1. statically not visible.\n\t\t// 2. statically disabled.\n\t\t// 3. action is static action.\n\t\tif (!actionTarget) {\n\t\t\treturn adaptiveCardActions;\n\t\t}\n\n\t\tconst isActionVisible = actionElement.isVisible ?? this.getVisibleForAdaptiveCardAction(dataFieldForAction) ?? undefined;\n\t\tconst isEnabled = this.getEnabledForAdaptiveCardAction(actionTarget) ?? undefined;\n\n\t\t// NOTE: '$when' is used to control visibility of actions. Looks like the value needs to always be an expression of format '${<exp>}'.\n\t\t// So, direct strings like 'true' and 'false' which are expected to work for normal card properties don't work for $when.\n\t\t// We would need to handle such cases independently.\n\t\tlet whenValue: string | undefined;\n\t\tif (typeof isActionVisible === \"boolean\" && isActionVisible === false) {\n\t\t\treturn adaptiveCardActions;\n\t\t} else if (typeof isActionVisible === \"string\" && isActionVisible && /^\\$\\{.*\\}/i.test(isActionVisible)) {\n\t\t\t// visible is an expression of format '${<exp>}'.\n\t\t\twhenValue = isActionVisible;\n\t\t} else if (isActionVisible === \"true\") {\n\t\t\t// statically visible\n\t\t\twhenValue = undefined;\n\t\t} else if (isActionVisible === \"false\") {\n\t\t\t// statically not visible\n\t\t\treturn adaptiveCardActions;\n\t\t}\n\n\t\tif (isEnabled === \"false\" || this.isStaticAction(actionTarget) || this.isCopyAction(dataFieldForAction)) {\n\t\t\treturn adaptiveCardActions;\n\t\t}\n\n\t\tconst action = this.getAction(dataFieldForAction);\n\t\tif (action) {\n\t\t\tconst visualUpdates = {\n\t\t\t\tisEnabled,\n\t\t\t\t$when: whenValue,\n\t\t\t\ttitle: titleOverride ?? action.title\n\t\t\t};\n\t\t\tadaptiveCardActions.push({ ...action, ...visualUpdates });\n\t\t}\n\n\t\treturn adaptiveCardActions;\n\t}\n\n\t/**\n\t * Get the DataFieldForActions for adaptive card.\n\t * @param entityType EntityType.\n\t * @returns DataFieldForActions that are applicable to be shown in the adaptive card.\n\t */\n\tprivate getAnnotatedHeaderActions(entityType: EntityType): DataFieldForAction[] {\n\t\tconst identificationAnnotation = entityType.annotations.UI?.Identification;\n\t\treturn identificationAnnotation\n\t\t\t? (identificationAnnotation.filter(\n\t\t\t\t\t(dataField) => dataField.$Type === UIAnnotationTypes.DataFieldForAction && !dataField.Determining\n\t\t\t  ) as DataFieldForAction[])\n\t\t\t: [];\n\t}\n\n\t/**\n\t * Get configured actions.\n\t * @param annotatedActions Annotated actions from the converted metadata.\n\t * @returns ActionConfigElements to create actions for card definition.\n\t */\n\tprivate getConfiguredActions(annotatedActions: DataFieldForAction[]): ActionConfigElement[] {\n\t\t// Actions from annotations.\n\t\tconst actionConfigs = this.getCardConfigurationByKey(\"actions\");\n\t\tconst annotatedActionElements = annotatedActions.map(\n\t\t\t(action) => ({ key: action && getStableIdPartFromDataField(action), action }) as ActionConfigElement\n\t\t);\n\t\tif (!actionConfigs || Object.keys(actionConfigs).length === 0) {\n\t\t\treturn annotatedActionElements;\n\t\t}\n\n\t\t// Custom Action configs.\n\t\tconst customConfigActionNames = Object.keys(actionConfigs);\n\t\tconst customActionConfigElements = customConfigActionNames.reduce((customActionElements, customConfigActionKey) => {\n\t\t\tconst relevantActionElement = annotatedActionElements.find((actionElement) => actionElement.key === customConfigActionKey);\n\n\t\t\tif (relevantActionElement) {\n\t\t\t\tcustomActionElements[customConfigActionKey] = {\n\t\t\t\t\tkey: customConfigActionKey,\n\t\t\t\t\taction: relevantActionElement.action,\n\t\t\t\t\tposition: {\n\t\t\t\t\t\tplacement: Placement.After\n\t\t\t\t\t},\n\t\t\t\t\t...actionConfigs[customConfigActionKey]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn customActionElements;\n\t\t}, {} as InternalCustomActionElements);\n\n\t\t// Final action elements\n\t\tconst actionOverwriteConfig = {\n\t\t\ttitle: OverrideType.overwrite,\n\t\t\tposition: OverrideType.overwrite,\n\t\t\tisVisible: OverrideType.overwrite\n\t\t};\n\t\treturn insertCustomElements(annotatedActionElements, customActionConfigElements, actionOverwriteConfig);\n\t}\n\n\t/**************************************************************************/\n\t/* Functions for creating template bindings and getting action properties */\n\t/**************************************************************************/\n\n\t/**\n\t * Get action visibility.\n\t * @param dataFieldForAction DataFieldForAction annotation\n\t * @returns Boolean\n\t */\n\tprivate getVisibleForAdaptiveCardAction(dataFieldForAction: DataFieldForAction): CompiledAdaptiveCardExpression {\n\t\tconst visibilityExp = isVisible(dataFieldForAction);\n\t\treturn this.updatePathsAndGetCompiledExpression(visibilityExp);\n\t}\n\n\t/**\n\t * Get action style for the action button.\n\t * @param dataFieldForAction DataFieldForAction annotation\n\t * @returns Style of the action button\n\t */\n\tprivate getActionStyle(dataFieldForAction: DataFieldForAction): ACStyle {\n\t\t// TODO: compile to adaptive card binding string for dynamic annotation.\n\t\tlet style = ACStyle.Default;\n\t\tconst criticality = dataFieldForAction.Criticality;\n\t\tif (criticality && typeof criticality === \"string\") {\n\t\t\tswitch (criticality) {\n\t\t\t\tcase \"UI.CriticalityType/Positive\":\n\t\t\t\t\tstyle = ACStyle.Positive;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"UI.CriticalityType/Negative\":\n\t\t\t\t\tstyle = ACStyle.Destructive;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstyle = ACStyle.Default;\n\t\t\t}\n\t\t}\n\t\treturn style;\n\t}\n\n\t/**\n\t * Check if action is critical.\n\t * @param actionTarget Action definition.\n\t * @returns Boolean\n\t */\n\tprivate getIsCriticalForAdaptiveCardAction(actionTarget: Action): CompiledAdaptiveCardExpression {\n\t\tconst isActionCritical = getIsActionCriticalExpression(actionTarget, this.convertedTypes);\n\t\treturn this.updatePathsAndGetCompiledExpression(isActionCritical);\n\t}\n\n\t/**\n\t * Get action enablement.\n\t * @param actionTarget Action definition.\n\t * @returns Boolean\n\t */\n\tprivate getEnabledForAdaptiveCardAction(actionTarget: Action): CompiledAdaptiveCardExpression {\n\t\tconst enabledExpression = getActionEnabledExpression(actionTarget, this.convertedTypes);\n\t\treturn this.updatePathsAndGetCompiledExpression(enabledExpression);\n\t}\n\n\t/**\n\t * Check for static action.\n\t * @param actionTarget Action definition.\n\t * @returns Boolean.\n\t */\n\tprivate isStaticAction(actionTarget: Action): boolean {\n\t\tconst { isBound, parameters } = actionTarget;\n\t\treturn isBound && parameters[0] && parameters[0].isCollection;\n\t}\n\n\t/**\n\t * Check for copy action.\n\t * @param dataField Action definition.\n\t * @returns Boolean.\n\t */\n\tprivate isCopyAction(dataField: DataFieldForAction): boolean {\n\t\treturn dataField.annotations?.UI?.IsCopyAction?.valueOf() === true;\n\t}\n\n\t/**\n\t * Check if parameter input is required for action execution.\n\t * @param parameter Action parameter.\n\t * @param actionTarget\n\t * @returns Boolean\n\t */\n\tprivate getRequired(parameter: ActionParameter, actionTarget: Action): CompiledAdaptiveCardExpression {\n\t\tconst fieldControlExpression = isActionParameterRequiredExpression(parameter, actionTarget, this.convertedTypes);\n\t\treturn this.updatePathsAndGetCompiledExpression(fieldControlExpression);\n\t}\n}\n"],"mappings":"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","ignoreList":[]}