{"version":3,"file":"HeaderContent.js","names":["MAX_COLUMNS","HeaderContent","_BaseCardContentProvi","convertedTypes","config","_this","call","this","cardElements","headerFacetsForAdaptiveCard","contextPath","getCardConfigurationByKey","headerFacet","MetaPath","customConfigHeaderFacets","getCustomConfigHeaderFacets","createHeaderForms","error","Log","_assertThisInitialized","_exports","_inheritsLoose","_proto","prototype","getHeaderContent","getFieldGroupProperties","referenceFacetTargetMetaPath","dataField","formElementConfig","property","textProperty","textpropertyAnnotation","label","labelText","navigationPath","color","$Type","isPathAnnotationExpression","Value","getMetaPathForObject","getNavigationPathForExpression","getTarget","annotations","Common","Text","Label","$target","valueOf","getCriticalityForDataPoints","dataFieldTargetPath","Target","dataFieldTarget","isAnnotationOfType","contactObject","fn","getVisibleDataFields","dataFields","reduce","visibledataFields","isReferencePropertyStaticallyHidden","isPotentiallySensitive","push","getColumnForDataField","properties","dataPointTitle","items","columns","getColumn","visible","getVisibleForDataField","uom","getTextBlock","size","weight","text","maxLines","wrap","spacing","isSubtle","textBinding","getValueBinding","additionalValue","dateFieldVisibleExp","getTextBlockVisiblityForDateField","undefined","$when","compileToAdaptiveExpression","equal","constant","getFieldGroupContent","formHeader","formElementsConfig","fieldGroup","maxColumns","forms","formTitle","fieldItems","Data","iTotalColums","Math","ceil","length","i","iLoopEnd","iLoopStart","dataFieldcolumnset","getColumnSet","j","key","getStableIdPartFromDataField","dataProperties","dataFieldNext","dataFieldColumns","dataPoint","exp","criticalityProperty","Criticality","criticalityExpression","getExpressionFromAnnotation","getCriticalityExpressionForCards","updatePathsAndGetCompiledExpression","getUomPathBinding","propertyTargetObject","Measures","ISOCurrency","Unit","uomMetaPath","targetPath","targetIsProperty","getDataPointProperties","getDataPointContent","Visualization","dataPointForms","getCustomHeaderFacetConfigElements","headerFacetConfigs","annotatedReferenceFacets","customConfigHeaderFacetNames","Object","keys","customHeaderFacetElements","customConfigHeaderFacetKey","relevantFacetElement","find","headerFacetElement","position","placement","Placement","After","headerFacetMetaPath","referenceFacets","getReferenceFacetFromAnnotations","map","generate","value","customHeaderFacetConfigElements","headerFacetOverwriteConfig","isVisible","OverrideType","overwrite","title","insertCustomElements","configHeaderFacets","previousCardElementIsDataPoint","headerForms","configHeaderFacet","currentIdx","allConfigHeaderFacets","FacetItem","UI","Hidden","facetDefinition","getVisibleForReferenceFacet","toString","term","addEmptyColumns","dataPointColumns","dataPointColumnSet","getAddressContent","bind","cardColumnSet","numColumns","numColumnsToAdd","addressContent","address","addressColumnSet","headerFacets","filter","facet","element","visibilityExp","generateVisibleExpression","getDataModelObjectPath","metaPathObject","navigationProperties","getNavigationProperties","navigatedPaths","forEach","isNavigationProperty","name","replaceAll","BaseCardContentProvider"],"sources":["./HeaderContent.ts"],"sourcesContent":["import type { ConvertedMetadata, NavigationProperty, PrimitiveType, Property } from \"@sap-ux/vocabularies-types\";\nimport { type PropertyAnnotationsBase_Common } from \"@sap-ux/vocabularies-types/vocabularies/Common_Edm\";\nimport {\n\tCommunicationAnnotationTerms,\n\tCommunicationAnnotationTypes,\n\ttype Address,\n\ttype Contact\n} from \"@sap-ux/vocabularies-types/vocabularies/Communication\";\nimport type {\n\tDataFieldAbstractTypes,\n\tDataPoint,\n\tDataPointType,\n\tFieldGroup,\n\tHeaderFacets,\n\tReferenceFacet\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTerms, UIAnnotationTypes, VisualizationType } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport Log from \"sap/base/Log\";\nimport type { BindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport { constant, equal, getExpressionFromAnnotation } from \"sap/fe/base/BindingToolkit\";\nimport type { ConfigurableObjectKey, CustomElement, Positionable } from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport { OverrideType, Placement, insertCustomElements } from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport { isPotentiallySensitive, isReferencePropertyStaticallyHidden } from \"sap/fe/core/converters/helpers/DataFieldHelper\";\nimport { compileToAdaptiveExpression, type CompiledAdaptiveCardExpression } from \"sap/fe/core/helpers/AdaptiveCardExpressionCompiler\";\nimport MetaPath from \"sap/fe/core/helpers/MetaPath\";\nimport { generate, getStableIdPartFromDataField } from \"sap/fe/core/helpers/StableIdHelper\";\nimport { isAnnotationOfType, isNavigationProperty, isPathAnnotationExpression } from \"sap/fe/core/helpers/TypeGuards\";\nimport { getCriticalityExpressionForCards } from \"sap/fe/core/templating/CriticalityFormatters\";\nimport { generateVisibleExpression } from \"sap/fe/core/templating/DataFieldFormatters\";\nimport { isVisible } from \"sap/fe/core/templating/UIFormatters\";\nimport { getColumn, getColumnSet, getTextBlock } from \"sap/fe/templates/ObjectPage/card/AdaptiveCardContent\";\nimport BaseCardContentProvider, { type CardConfig } from \"sap/fe/templates/ObjectPage/card/BaseCardContentProvider\";\nimport type { CardColumn, CardColumnSet, CardElement, CardTextBlock } from \"types/adaptiveCard_types\";\n\ntype DataProperties = {\n\tcolor?: CompiledAdaptiveCardExpression;\n\tuom?: string;\n\tlabel?: string;\n\tproperty?: MetaPath<string>;\n\ttextProperty?: MetaPath<string>;\n\tnavigationPath?: string;\n};\n\n// External types for header facet configuration\nexport type FormElementConfig = {\n\tlabelText: string;\n};\nexport type CustomFormElementsConfig = Record<ConfigurableObjectKey, FormElementConfig>;\n\nexport type HeaderFacetConfig = Positionable & {\n\tisVisible?: string | boolean;\n\ttitle?: string;\n\tformElementsConfig?: CustomFormElementsConfig;\n};\n\nexport type CustomHeaderFacetConfigs = Record<ConfigurableObjectKey, HeaderFacetConfig>;\n\nexport type HeaderFacetConfigurable = {\n\theaderFacets?: CustomHeaderFacetConfigs;\n};\n\nexport type CardHeaderFacetsConfig = HeaderFacetConfigurable & CardConfig;\n\n// Internal types for header facet configuration\ntype HeaderFacetConfigElement = HeaderFacetConfig & {\n\tkey: ConfigurableObjectKey;\n\theaderFacet: ReferenceFacet;\n};\n\ntype InternalCustomHeaderFacetElements = Record<ConfigurableObjectKey, CustomElement<HeaderFacetConfigElement>>;\n\nconst MAX_COLUMNS = 3;\n/**\n * Get image and title for card.\n * @param convertedTypes Converted Metadata.\n * @param config Card Configuration.\n */\nexport default class HeaderContent extends BaseCardContentProvider<CardHeaderFacetsConfig> {\n\tprivate cardElements: CardElement[] = [];\n\n\t/**\n\t * Get image and title in column set.\n\t * @returns Column set.\n\t */\n\tpublic getHeaderContent(): CardElement[] {\n\t\treturn this.cardElements;\n\t}\n\n\tconstructor(convertedTypes: ConvertedMetadata, config: CardConfig) {\n\t\tsuper(convertedTypes, config);\n\t\tlet headerFacetsForAdaptiveCard: CardElement[] = [];\n\t\tconst { contextPath } = this.getCardConfigurationByKey(\"contextInfo\");\n\t\ttry {\n\t\t\tconst headerFacet = new MetaPath<HeaderFacets>(convertedTypes, `${contextPath}@${UIAnnotationTerms.HeaderFacets}`, contextPath);\n\t\t\tconst customConfigHeaderFacets = this.getCustomConfigHeaderFacets(headerFacet);\n\t\t\theaderFacetsForAdaptiveCard = this.createHeaderForms(headerFacet, customConfigHeaderFacets);\n\t\t} catch (error) {\n\t\t\tLog.error(`FE : V4 : Adaptive Card header facets : no EntityType found at context path: ${contextPath}`);\n\t\t}\n\t\tthis.cardElements = headerFacetsForAdaptiveCard;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the DataPoint Information from ReferenceFacet.\n\t * @param referenceFacetTargetMetaPath MetaPath pointing to FieldGroup\n\t * @param dataField DataFieldAbstract types\n\t * @param formElementConfig Field configurations\n\t * @returns Properties applicable for the dataPoint annotation\n\t */\n\tprivate getFieldGroupProperties(\n\t\treferenceFacetTargetMetaPath: MetaPath<FieldGroup>,\n\t\tdataField: DataFieldAbstractTypes,\n\t\tformElementConfig?: FormElementConfig\n\t): DataProperties {\n\t\tlet property,\n\t\t\ttextProperty,\n\t\t\ttextpropertyAnnotation,\n\t\t\tlabel = formElementConfig?.labelText,\n\t\t\tnavigationPath,\n\t\t\tcolor;\n\t\tswitch (dataField?.$Type) {\n\t\t\tcase UIAnnotationTypes.DataField:\n\t\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\t\t\tif (isPathAnnotationExpression(dataField.Value)) {\n\t\t\t\t\tproperty = referenceFacetTargetMetaPath.getMetaPathForObject(dataField.Value);\n\t\t\t\t\tnavigationPath = this.getNavigationPathForExpression(referenceFacetTargetMetaPath);\n\t\t\t\t\ttextpropertyAnnotation = ((property?.getTarget() as Property)?.annotations?.Common as PropertyAnnotationsBase_Common)\n\t\t\t\t\t\t?.Text;\n\t\t\t\t\ttextProperty = textpropertyAnnotation && referenceFacetTargetMetaPath.getMetaPathForObject(textpropertyAnnotation);\n\t\t\t\t} else {\n\t\t\t\t\tproperty = dataField.Value;\n\t\t\t\t}\n\t\t\t\tlabel = label ?? dataField.Label ?? dataField.Value?.$target?.annotations?.Common?.Label.valueOf() ?? \"\";\n\t\t\t\tcolor = this.getCriticalityForDataPoints(dataField);\n\t\t\t\tbreak;\n\t\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\t\t\tlabel =\n\t\t\t\t\tlabel ?? dataField.Label ?? (dataField as PrimitiveType)?.Value?.$target?.annotations?.Common?.Label.valueOf() ?? \"\";\n\t\t\t\tconst dataFieldTargetPath = referenceFacetTargetMetaPath.getMetaPathForObject(dataField.Target);\n\t\t\t\tconst dataFieldTarget = dataFieldTargetPath?.getTarget();\n\t\t\t\tnavigationPath = this.getNavigationPathForExpression(dataFieldTargetPath as MetaPath<DataPointType>);\n\t\t\t\tif (isAnnotationOfType<DataPoint>(dataFieldTarget, UIAnnotationTypes.DataPointType)) {\n\t\t\t\t\tif (isPathAnnotationExpression(dataFieldTarget.Value)) {\n\t\t\t\t\t\tproperty = dataFieldTargetPath?.getMetaPathForObject((dataFieldTarget as DataPointType)?.Value);\n\t\t\t\t\t\ttextpropertyAnnotation = property?.getTarget()?.annotations?.Common?.Text;\n\t\t\t\t\t\ttextProperty = textpropertyAnnotation && referenceFacetTargetMetaPath.getMetaPathForObject(textpropertyAnnotation);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tproperty = dataFieldTarget.Value;\n\t\t\t\t\t}\n\t\t\t\t\tcolor = this.getCriticalityForDataPoints(dataFieldTarget);\n\t\t\t\t} else if (isAnnotationOfType<Contact>(dataFieldTarget, CommunicationAnnotationTypes.ContactType)) {\n\t\t\t\t\tconst contactObject = dataFieldTarget.fn;\n\t\t\t\t\tif (isPathAnnotationExpression(contactObject)) {\n\t\t\t\t\t\tproperty = dataFieldTargetPath?.getMetaPathForObject(contactObject);\n\t\t\t\t\t\ttextpropertyAnnotation = (property as PrimitiveType)?.getTarget()?.annotations?.Common?.Text;\n\t\t\t\t\t\ttextProperty = textpropertyAnnotation && referenceFacetTargetMetaPath.getMetaPathForObject(textpropertyAnnotation);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\treturn { property, label, navigationPath, textProperty, color };\n\t}\n\n\t/**\n\t * Returns the visible dataFields from fieldGroup.\n\t * @param dataFields DataFieldAbstractTypes.\n\t * @returns Visible DataFields.\n\t */\n\tprivate getVisibleDataFields(dataFields: DataFieldAbstractTypes[]): DataFieldAbstractTypes[] {\n\t\treturn dataFields.reduce((visibledataFields, dataField) => {\n\t\t\tif (!isReferencePropertyStaticallyHidden(dataField) && !isPotentiallySensitive(dataField)) {\n\t\t\t\tvisibledataFields.push(dataField);\n\t\t\t}\n\t\t\treturn visibledataFields;\n\t\t}, [] as DataFieldAbstractTypes[]);\n\t}\n\n\t/**\n\t * Update the columnSets for each dataFields.\n\t * @param dataField DataFieldAbstractTypes\n\t * @param properties Properties of the DataField required for adaptive card\n\t * @param dataPointTitle\n\t * @returns ColumnSets containing header facet information which is required for adaptive card\n\t */\n\tprivate getColumnForDataField(\n\t\tdataField?: MetaPath<DataFieldAbstractTypes | DataPointType>,\n\t\tproperties?: DataProperties,\n\t\tdataPointTitle?: boolean\n\t): CardColumn[] {\n\t\tconst items = [];\n\t\tconst columns = [];\n\t\tif (!dataField) {\n\t\t\tcolumns.push(getColumn());\n\t\t} else {\n\t\t\tconst visible = this.getVisibleForDataField(dataField);\n\t\t\tconst { property, label, color, uom, textProperty } = properties || {};\n\t\t\tif (property) {\n\t\t\t\tif (label) {\n\t\t\t\t\tif (dataPointTitle === true) {\n\t\t\t\t\t\titems.push(\n\t\t\t\t\t\t\tgetTextBlock({\n\t\t\t\t\t\t\t\tsize: \"Small\",\n\t\t\t\t\t\t\t\tweight: \"Bolder\",\n\t\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\t\tmaxLines: 2,\n\t\t\t\t\t\t\t\twrap: true,\n\t\t\t\t\t\t\t\tspacing: \"Medium\",\n\t\t\t\t\t\t\t\tvisible: visible\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\titems.push(getTextBlock({ size: \"Small\", text: `${label}:`, maxLines: 1, isSubtle: true }));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst textBinding = this.getValueBinding(property, textProperty);\n\t\t\t\tconst additionalValue = uom ?? textProperty;\n\t\t\t\tconst dateFieldVisibleExp = this.getTextBlockVisiblityForDateField(\n\t\t\t\t\tproperty,\n\t\t\t\t\ttypeof additionalValue !== \"string\" ? additionalValue : undefined\n\t\t\t\t);\n\t\t\t\titems.push(\n\t\t\t\t\tgetTextBlock({\n\t\t\t\t\t\tsize: \"Small\",\n\t\t\t\t\t\t$when: compileToAdaptiveExpression(dateFieldVisibleExp),\n\t\t\t\t\t\ttext: uom ? `${textBinding} ${uom}` : textBinding,\n\t\t\t\t\t\tmaxLines: 2,\n\t\t\t\t\t\tcolor: color\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\titems.push(\n\t\t\t\t\tgetTextBlock({\n\t\t\t\t\t\tsize: \"Small\",\n\t\t\t\t\t\t$when: compileToAdaptiveExpression(equal(dateFieldVisibleExp, constant(false))),\n\t\t\t\t\t\ttext: \"\\\\-\"\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tcolumns.push(getColumn({ items: items, visible: visible ?? undefined }));\n\t\t\t}\n\t\t}\n\t\treturn columns;\n\t}\n\n\t/**\n\t * Updates the column sets and gets the fieldgroup content.\n\t * @param referenceFacetTargetMetaPath Metapath of the reference facet fieldgroup\n\t * @param formHeader Form Header\n\t * @param visible Visible expression for the FacetHeader\n\t * @param formElementsConfig Fields' configurations\n\t * @returns ColumnSets containing header facet information which is required for adaptive card\n\t */\n\tprivate getFieldGroupContent(\n\t\treferenceFacetTargetMetaPath: MetaPath<FieldGroup>,\n\t\tformHeader: string | undefined,\n\t\tvisible: CompiledAdaptiveCardExpression | boolean,\n\t\tformElementsConfig?: CustomFormElementsConfig\n\t): CardElement[] {\n\t\tconst fieldGroup = referenceFacetTargetMetaPath.getTarget();\n\t\tconst maxColumns = MAX_COLUMNS;\n\t\tconst forms: CardElement[] = [];\n\t\tif (formHeader) {\n\t\t\tconst formTitle: CardTextBlock = getTextBlock({\n\t\t\t\tsize: \"Small\",\n\t\t\t\tweight: \"Bolder\",\n\t\t\t\ttext: formHeader,\n\t\t\t\tmaxLines: 2,\n\t\t\t\tspacing: \"Medium\",\n\t\t\t\twrap: true,\n\t\t\t\tvisible: visible ?? undefined\n\t\t\t});\n\t\t\tforms.push(formTitle);\n\t\t}\n\t\tconst fieldItems = this.getVisibleDataFields(fieldGroup?.Data);\n\t\t/* Column set should contain maximum of three columns\n\t\thence check the number of datafields and decide the columns for each column set */\n\t\tconst iTotalColums = Math.ceil(fieldItems.length / maxColumns);\n\t\tfor (let i = 1; i <= iTotalColums; i++) {\n\t\t\tconst iLoopEnd = i * maxColumns;\n\t\t\tconst iLoopStart = iLoopEnd - maxColumns;\n\t\t\tconst dataFieldcolumnset = getColumnSet([] as CardColumn[], visible ?? undefined);\n\t\t\tfor (let j = iLoopStart; j < iLoopEnd; j++) {\n\t\t\t\tconst dataField: DataFieldAbstractTypes = fieldItems[j];\n\t\t\t\tconst key = dataField && getStableIdPartFromDataField(dataField);\n\t\t\t\tconst formElementConfig = key ? formElementsConfig?.[key] : undefined;\n\t\t\t\tconst dataProperties = this.getFieldGroupProperties(referenceFacetTargetMetaPath, dataField, formElementConfig);\n\t\t\t\tconst dataFieldNext = dataField && referenceFacetTargetMetaPath.getMetaPathForObject(dataField);\n\t\t\t\tconst dataFieldColumns = this.getColumnForDataField(dataFieldNext, dataProperties);\n\t\t\t\tif (dataFieldColumns) {\n\t\t\t\t\tdataFieldcolumnset.columns.push(...dataFieldColumns);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dataFieldcolumnset) {\n\t\t\t\tforms.push(dataFieldcolumnset);\n\t\t\t}\n\t\t}\n\t\treturn forms;\n\t}\n\n\t/**\n\t * Get the text color for the dataPoint.\n\t * @param dataPoint DataPoint annotation\n\t * @returns Color of the Text\n\t */\n\tpublic getCriticalityForDataPoints(dataPoint: DataPoint | DataFieldAbstractTypes): CompiledAdaptiveCardExpression {\n\t\tlet exp;\n\t\tconst criticalityProperty = dataPoint.Criticality;\n\t\tif (criticalityProperty) {\n\t\t\tconst criticalityExpression: BindingToolkitExpression<string | number> = getExpressionFromAnnotation(criticalityProperty);\n\t\t\texp = getCriticalityExpressionForCards(criticalityExpression, false);\n\t\t} else {\n\t\t\texp = constant(\"default\");\n\t\t}\n\t\treturn this.updatePathsAndGetCompiledExpression(exp);\n\t}\n\n\t/**\n\t * Get the uom path for the dataPoint.\n\t * @param referenceFacetTargetMetaPath MetaPath pointing to datapoints\n\t * @param propertyTargetObject DataPoint property\n\t * @returns Path binding for UOM\n\t */\n\tprivate getUomPathBinding(\n\t\treferenceFacetTargetMetaPath: MetaPath<DataPointType | DataFieldAbstractTypes>,\n\t\tpropertyTargetObject: Property | undefined\n\t): string | undefined {\n\t\tconst uom = propertyTargetObject?.annotations.Measures?.ISOCurrency || propertyTargetObject?.annotations.Measures?.Unit;\n\t\tif (!uom) {\n\t\t\treturn;\n\t\t} else if (isPathAnnotationExpression(uom)) {\n\t\t\tconst uomMetaPath = referenceFacetTargetMetaPath.getMetaPathForObject(uom);\n\t\t\tconst targetPath = uomMetaPath?.getTarget();\n\t\t\treturn targetPath && this.targetIsProperty(uomMetaPath) ? this.getValueBinding(uomMetaPath) : undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Get the DataPoint Information from ReferenceFacet.\n\t * @param referenceFacetTargetMetaPath MetaPath pointing to datapoints\n\t * @param dataPoint DataPoint\n\t * @returns Properties applicable for the dataPoint annotation\n\t */\n\tprivate getDataPointProperties(referenceFacetTargetMetaPath: MetaPath<DataPoint>, dataPoint: DataPoint): DataProperties {\n\t\tconst property = referenceFacetTargetMetaPath.getMetaPathForObject(dataPoint?.Value);\n\t\tconst uom = this.getUomPathBinding(\n\t\t\treferenceFacetTargetMetaPath,\n\t\t\treferenceFacetTargetMetaPath.getMetaPathForObject(dataPoint?.Value)?.getTarget()\n\t\t);\n\t\tconst textpropertyAnnotation = property?.getTarget()?.annotations?.Common?.Text;\n\t\tconst textProperty = textpropertyAnnotation && referenceFacetTargetMetaPath.getMetaPathForObject(textpropertyAnnotation);\n\t\tconst color = this.getCriticalityForDataPoints(dataPoint);\n\t\tconst navigationPath = this.getNavigationPathForExpression(referenceFacetTargetMetaPath);\n\t\treturn { property, color, uom, navigationPath, textProperty };\n\t}\n\n\t/**\n\t * Get the Datapoint content from the facet.\n\t * @param referenceFacetTargetMetaPath MetaPath pointing to Datapoints\n\t * @param formHeader Title of the form header\n\t * @returns Title and content of the datapoint\n\t */\n\tprivate getDataPointContent(referenceFacetTargetMetaPath: MetaPath<DataPoint>, formHeader: string | undefined): CardColumn[] {\n\t\tconst columns = [];\n\t\tconst dataPoint = referenceFacetTargetMetaPath.getTarget();\n\t\tif (dataPoint?.Visualization !== VisualizationType.Rating && dataPoint?.Visualization !== VisualizationType.Progress) {\n\t\t\tconst properties = this.getDataPointProperties(referenceFacetTargetMetaPath, dataPoint);\n\t\t\tproperties.label = formHeader;\n\t\t\tconst dataPointForms = this.getColumnForDataField(referenceFacetTargetMetaPath, properties, true);\n\t\t\tif (dataPointForms) {\n\t\t\t\tcolumns.push(...dataPointForms);\n\t\t\t}\n\t\t}\n\t\treturn columns;\n\t}\n\n\t/**\n\t * Get the custom configured header facet elements.\n\t * @param headerFacetConfigs\n\t * @param annotatedReferenceFacets\n\t * @returns The custom configured header facet elements\n\t */\n\tprivate getCustomHeaderFacetConfigElements(\n\t\theaderFacetConfigs: CustomHeaderFacetConfigs,\n\t\tannotatedReferenceFacets: HeaderFacetConfigElement[]\n\t): InternalCustomHeaderFacetElements {\n\t\tconst customConfigHeaderFacetNames = Object.keys(headerFacetConfigs);\n\t\treturn customConfigHeaderFacetNames.reduce((customHeaderFacetElements, customConfigHeaderFacetKey) => {\n\t\t\tconst relevantFacetElement = annotatedReferenceFacets.find(\n\t\t\t\t(headerFacetElement) => headerFacetElement.key === customConfigHeaderFacetKey\n\t\t\t);\n\n\t\t\tif (relevantFacetElement) {\n\t\t\t\tcustomHeaderFacetElements[customConfigHeaderFacetKey] = {\n\t\t\t\t\tkey: customConfigHeaderFacetKey,\n\t\t\t\t\theaderFacet: relevantFacetElement.headerFacet,\n\t\t\t\t\tposition: {\n\t\t\t\t\t\tplacement: Placement.After\n\t\t\t\t\t},\n\t\t\t\t\t...headerFacetConfigs[customConfigHeaderFacetKey]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn customHeaderFacetElements;\n\t\t}, {} as InternalCustomHeaderFacetElements);\n\t}\n\n\t/**\n\t * Get the custom configured header facets.\n\t * @param headerFacetMetaPath MetaPath object of the annotated header facets\n\t * @returns Reference facets with overridden custom configurations\n\t */\n\tprivate getCustomConfigHeaderFacets(headerFacetMetaPath: MetaPath<HeaderFacets>): HeaderFacetConfigElement[] {\n\t\tconst referenceFacets: ReferenceFacet[] = this.getReferenceFacetFromAnnotations(headerFacetMetaPath.getTarget());\n\t\tlet annotatedReferenceFacets: HeaderFacetConfigElement[] = referenceFacets.map(function (headerFacet) {\n\t\t\treturn { key: generate([headerFacet.Target.value]), headerFacet };\n\t\t});\n\t\t// Get the UI overrides for header facets, if any\n\t\tconst headerFacetConfigs = this.getCardConfigurationByKey(\"headerFacets\");\n\t\tif (headerFacetConfigs && Object.keys(headerFacetConfigs).length > 0) {\n\t\t\tconst customHeaderFacetConfigElements = this.getCustomHeaderFacetConfigElements(headerFacetConfigs, annotatedReferenceFacets);\n\n\t\t\tconst headerFacetOverwriteConfig = {\n\t\t\t\tisVisible: OverrideType.overwrite,\n\t\t\t\ttitle: OverrideType.overwrite,\n\t\t\t\tposition: OverrideType.overwrite,\n\t\t\t\tformElementsConfig: OverrideType.overwrite\n\t\t\t};\n\n\t\t\t// override the annotated header facets to reflect the UI changes on OP\n\t\t\tannotatedReferenceFacets = insertCustomElements(\n\t\t\t\tannotatedReferenceFacets,\n\t\t\t\tcustomHeaderFacetConfigElements,\n\t\t\t\theaderFacetOverwriteConfig\n\t\t\t);\n\t\t}\n\n\t\treturn annotatedReferenceFacets;\n\t}\n\n\t/**\n\t * Get Header Data ColumnSets.\n\t * @param headerFacetMetaPath Array of header Facets\n\t * @param configHeaderFacets Header facets configurations\n\t * @returns ColumnSets containing header facet information which is required for adaptive card\n\t */\n\tprivate createHeaderForms(headerFacetMetaPath: MetaPath<HeaderFacets>, configHeaderFacets: HeaderFacetConfigElement[]): CardElement[] {\n\t\tlet previousCardElementIsDataPoint = false;\n\t\treturn configHeaderFacets.reduce(\n\t\t\tfunction (\n\t\t\t\tthis: HeaderContent,\n\t\t\t\theaderForms: CardElement[],\n\t\t\t\tconfigHeaderFacet: HeaderFacetConfigElement,\n\t\t\t\tcurrentIdx: number,\n\t\t\t\tallConfigHeaderFacets: HeaderFacetConfigElement[]\n\t\t\t): CardElement[] {\n\t\t\t\tconst FacetItem = configHeaderFacet.headerFacet;\n\t\t\t\tif (FacetItem.$Type === UIAnnotationTypes.ReferenceFacet && FacetItem.annotations?.UI?.Hidden?.valueOf() !== true) {\n\t\t\t\t\tconst referenceFacetTargetMetaPath = headerFacetMetaPath.getMetaPathForObject(FacetItem.Target);\n\t\t\t\t\tconst facetDefinition = referenceFacetTargetMetaPath?.getTarget();\n\t\t\t\t\tconst navigationPath = this.getNavigationPathForExpression(\n\t\t\t\t\t\treferenceFacetTargetMetaPath as MetaPath<FieldGroup | DataPointType>\n\t\t\t\t\t);\n\t\t\t\t\tconst visible = configHeaderFacet.isVisible ?? this.getVisibleForReferenceFacet(FacetItem, navigationPath);\n\t\t\t\t\tconst formHeader = configHeaderFacet.title ?? FacetItem.Label?.toString();\n\t\t\t\t\tconst formElementsConfig = configHeaderFacet.formElementsConfig;\n\t\t\t\t\tswitch (facetDefinition?.term) {\n\t\t\t\t\t\tcase UIAnnotationTerms.FieldGroup:\n\t\t\t\t\t\t\tif (previousCardElementIsDataPoint === true) {\n\t\t\t\t\t\t\t\t// If previous header form content was a DataPoint, we add dummy columns.\n\t\t\t\t\t\t\t\tthis.addEmptyColumns(headerForms[headerForms.length - 1] as CardColumnSet);\n\t\t\t\t\t\t\t\tpreviousCardElementIsDataPoint = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\theaderForms.push(\n\t\t\t\t\t\t\t\t...this.getFieldGroupContent(\n\t\t\t\t\t\t\t\t\treferenceFacetTargetMetaPath as MetaPath<FieldGroup>,\n\t\t\t\t\t\t\t\t\tformHeader,\n\t\t\t\t\t\t\t\t\tvisible,\n\t\t\t\t\t\t\t\t\tformElementsConfig\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase UIAnnotationTerms.DataPoint:\n\t\t\t\t\t\t\tif (!isPotentiallySensitive(facetDefinition)) {\n\t\t\t\t\t\t\t\tconst dataPointColumns = this.getDataPointContent(\n\t\t\t\t\t\t\t\t\treferenceFacetTargetMetaPath as MetaPath<DataPoint>,\n\t\t\t\t\t\t\t\t\tconfigHeaderFacet.title ?? formHeader\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst dataPointColumnSet = getColumnSet([] as CardColumn[], visible ?? undefined);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tpreviousCardElementIsDataPoint &&\n\t\t\t\t\t\t\t\t\t(headerForms[headerForms.length - 1] as CardColumnSet).columns.length !== MAX_COLUMNS\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t(headerForms[headerForms.length - 1] as CardColumnSet).columns.push(...dataPointColumns);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdataPointColumnSet.columns.push(...dataPointColumns);\n\t\t\t\t\t\t\t\t\theaderForms.push(dataPointColumnSet);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpreviousCardElementIsDataPoint = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CommunicationAnnotationTerms.Address:\n\t\t\t\t\t\t\tif (previousCardElementIsDataPoint) {\n\t\t\t\t\t\t\t\t// If previous header form content was a DataPoint, we add dummy columns.\n\t\t\t\t\t\t\t\tthis.addEmptyColumns(headerForms[headerForms.length - 1] as CardColumnSet);\n\t\t\t\t\t\t\t\tpreviousCardElementIsDataPoint = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\theaderForms.push(\n\t\t\t\t\t\t\t\t...this.getAddressContent(\n\t\t\t\t\t\t\t\t\treferenceFacetTargetMetaPath as MetaPath<Address>,\n\t\t\t\t\t\t\t\t\tconfigHeaderFacet.title ?? formHeader,\n\t\t\t\t\t\t\t\t\tvisible\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentIdx === allConfigHeaderFacets.length - 1 && previousCardElementIsDataPoint) {\n\t\t\t\t\t// This is the last recursion of the reduce loop.\n\t\t\t\t\t// If previous header form content was a DataPoint, we add dummy columns.\n\t\t\t\t\tthis.addEmptyColumns(headerForms[headerForms.length - 1] as CardColumnSet);\n\t\t\t\t}\n\n\t\t\t\treturn headerForms;\n\t\t\t}.bind(this),\n\t\t\t[] as CardElement[]\n\t\t);\n\t}\n\n\t/**\n\t * Add empty columns to the end of the column set.\n\t *\n\t * Header form with less than the maximum columns need to be added with empty columns to have the consistent layout equal to MAX_COLUMNS.\n\t * This is needs in case of a header form contains DataPoints side by side. We fill the empty space in the layout with a dummy empty column.\n\t * @param cardColumnSet Equivalent of a Header Form\n\t */\n\tprivate addEmptyColumns(cardColumnSet: CardColumnSet): void {\n\t\tconst numColumns = cardColumnSet.columns.length;\n\t\tif (numColumns < MAX_COLUMNS && numColumns > 1) {\n\t\t\t// If only one column exists then we don't have problem as it can freely occupy the whole width of the row.\n\t\t\tconst numColumnsToAdd = MAX_COLUMNS - numColumns;\n\t\t\tfor (let i = 0; i < numColumnsToAdd; i++) {\n\t\t\t\tcardColumnSet.columns.push(...this.getColumnForDataField());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the Address content from the facet.\n\t * @param referenceFacetTargetMetaPath Meta\n\t * @param formHeader Title of the form header\n\t * @param visible Visible expression for the FacetHeader\n\t * @returns Title and content of the address\n\t */\n\tprivate getAddressContent(\n\t\treferenceFacetTargetMetaPath: MetaPath<Address>,\n\t\tformHeader: string | undefined,\n\t\tvisible: CompiledAdaptiveCardExpression | boolean\n\t): CardElement[] {\n\t\tconst addressContent: CardElement[] = [];\n\t\tconst address = referenceFacetTargetMetaPath.getTarget();\n\t\tif (formHeader) {\n\t\t\taddressContent.push(\n\t\t\t\tgetTextBlock({\n\t\t\t\t\tsize: \"Small\",\n\t\t\t\t\tweight: \"Bolder\",\n\t\t\t\t\ttext: formHeader,\n\t\t\t\t\tmaxLines: 2,\n\t\t\t\t\twrap: true,\n\t\t\t\t\tspacing: \"Medium\",\n\t\t\t\t\tvisible: visible\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\tconst addressColumnSet = getColumnSet([] as CardColumn[], visible ?? undefined);\n\t\tconst items = [];\n\t\tconst columns = [];\n\t\tif (address?.label) {\n\t\t\titems.push(\n\t\t\t\tgetTextBlock({\n\t\t\t\t\tsize: \"Small\",\n\t\t\t\t\ttext: `${address?.label}`,\n\t\t\t\t\tmaxLines: 2\n\t\t\t\t})\n\t\t\t);\n\t\t\tcolumns.push(getColumn({ items: items, visible: visible ?? undefined }));\n\t\t}\n\t\tif (columns.length > 0) {\n\t\t\taddressColumnSet.columns.push(...columns);\n\t\t}\n\t\taddressContent.push(addressColumnSet);\n\t\treturn addressContent;\n\t}\n\n\t/**\n\t * Gets Reference facets configured in the header facet.\n\t * @param headerFacets HeaderFacets containing referncefacets.\n\t * @returns An Array of ReferenceFacets.\n\t */\n\tprivate getReferenceFacetFromAnnotations(headerFacets: HeaderFacets): ReferenceFacet[] {\n\t\treturn headerFacets ? (headerFacets.filter((facet) => facet.$Type === UIAnnotationTypes.ReferenceFacet) as ReferenceFacet[]) : [];\n\t}\n\n\t/**\n\t * Get referencefacet  visibility.\n\t * @param element Reference facet\n\t * @param navigationPath Visited navigation paths\n\t * @returns Boolean\n\t */\n\tprivate getVisibleForReferenceFacet(element: ReferenceFacet, navigationPath?: string): CompiledAdaptiveCardExpression {\n\t\tconst visibilityExp = isVisible(element);\n\t\treturn this.updatePathsAndGetCompiledExpression(visibilityExp, navigationPath);\n\t}\n\n\t/**\n\t * Get datafield visibility.\n\t * @param dataField DataFieldAbstract\n\t * @param navigationPath Visited navigation paths\n\t * @returns Boolean\n\t */\n\tprivate getVisibleForDataField(\n\t\tdataField: MetaPath<DataFieldAbstractTypes | DataPointType>,\n\t\tnavigationPath?: string\n\t): CompiledAdaptiveCardExpression {\n\t\tconst visibilityExp = generateVisibleExpression(dataField.getDataModelObjectPath());\n\t\treturn this.updatePathsAndGetCompiledExpression(visibilityExp, navigationPath);\n\t}\n\n\t/**\n\t * Get the navigation paths of the properties.\n\t * @param metaPathObject MetaPath of the object\n\t * @returns Navigation paths\n\t */\n\tprivate getNavigationPathForExpression(\n\t\tmetaPathObject: MetaPath<FieldGroup | DataFieldAbstractTypes | DataPointType>\n\t): string | undefined {\n\t\tconst navigationProperties = metaPathObject.getNavigationProperties();\n\t\tconst navigatedPaths: string[] = [];\n\t\tif (navigationProperties.length > 0) {\n\t\t\tnavigationProperties.forEach(function (property: NavigationProperty) {\n\t\t\t\tif (isNavigationProperty(property)) {\n\t\t\t\t\tnavigatedPaths.push(property.name);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn navigatedPaths?.toString()?.replaceAll(\",\", \"/\");\n\t}\n}\n"],"mappings":"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","ignoreList":[]}