{"version":3,"file":"CommonHelper.js","names":["_getRestrictions","aDefaultOps","aExpressionOps","filter","sElement","includes","_getDefaultOperators","sPropertyType","oDataClass","TypeMap","getDataTypeClassName","oBaseType","getBaseType","FilterOperatorUtil","getOperatorsForType","_isOperatorExcludedByManifest","operatorName","oSettings","operatorConfiguration","some","config","path","equals","exclude","_getEmptyOps","sType","result","notEmptyExcluded","emptyExcluded","push","ValueColor","mLibrary","CommonHelper","getPathToKey","oCtx","getObject","getParameterEditMode","target","oInterface","oModel","context","getModel","sPropertyPath","getPath","oAnnotations","fieldControl","immutable","computed","sEditMode","FieldEditMode","Editable","ReadOnly","$EnumMember","Disabled","$Path","getMetaPath","undefined","getMetaModelId","convertTypes","getId","isDesktop","Device","system","desktop","getTargetCollectionPath","navCollection","sPath","model","metaModel","isA","getMetaModel","aParts","split","sPart","entitySet","length","navigationCollection","slice","join","isPropertyFilterable","oDataField","skipHiddenFilters","sPropertyLocationPath","getLocationForPropertyPath","sProperty","replace","$Type","iLength","sCollectionPath","lastIndexOf","indexOf","gotoActionParameter","oContext","sPropertyName","CommonUtils","getParameterPath","getEntitySetName","oMetaModel","sEntityType","oEntityContainer","key","getActionPath","oAction","bReturnOnlyPath","sActionName","bCheckStaticValue","sContextPath","sEntityTypeName","sEntityName","this","sBindingParameter","getNavigationContext","ODataModelAnnotationHelper","getNavigationPath","bKeepProperty","bStartsWithEntityType","startsWith","part","shift","pop","getActionContext","getPathToBoundActionOverload","addSingleQuotes","sValue","bEscape","escapeSingleQuotes","generateFunction","sFuncName","sParams","i","arguments","sFunction","getHeaderDataPointLinkVisibility","isClickable","compileExpression","ifElse","constant","equal","pathInModel","notEqual","objectToString","oParams","iNumberOfKeys","Object","keys","sKey","removeEscapeCharacters","sExpression","stringifyObject","sStringified","oObject","JSON","parse","Array","isArray","oUI5Object","ui5object","assign","stringify","Log","error","Error","stringifyCustomData","vData","Context","parseCustomData","hasOwnProperty","getContextPath","oValue","getSortConditions","oPresentationVariant","sPresentationVariantPath","_isPresentationVariantAnnotation","SortOrder","aSortConditions","sorters","sEntityPath","forEach","oCondition","oSortProperty","oSorter","DynamicProperty","$AnnotationPath","Name","Property","$PropertyPath","name","descending","Descending","annotationPath","createPresentationPathContext","oPresentationContext","aPaths","createBindingContext","getPressHandlerForDataFieldForIBN","sContext","bNavigateWithConfirmationDialog","forContextMenu","mNavigationParameters","navigationContexts","RequiresContext","Inline","applicableProperty","notApplicableProperty","applicableContexts","SemanticObject","Action","notApplicableContexts","label","Label","Mapping","semanticObjectMapping","getEntitySet","ModelHelper","getEntitySetPath","getCriticalityCalculationBinding","sImprovementDirection","sDeviationLow","sToleranceLow","sAcceptanceLow","sAcceptanceHigh","sToleranceHigh","sDeviationHigh","sCriticalityExpression","Neutral","Infinity","Good","Critical","warning","getMeasureAttributeIndex","iMeasure","oChartAnnotations","isMicroChart","aMeasures","sMeasurePropertyPath","Measures","value","DynamicMeasures","bMeasureAttributeExists","aMeasureAttributes","MeasureAttributes","iMeasureAttribute","fnCheckMeasure","sMeasurePath","oMeasureAttribute","index","Measure","DynamicMeasure","bind","getMeasureAttribute","async","sChartAnnotationPath","requestObject","then","sMeasureAttributePath","DataPoint","getMeasureAttributeForMeasure","substring","isDraftParentEntityForContainment","oTargetCollectionContainsTarget","oTableMetadata","parentEntitySet","sParentEntitySetPath","oDraftRoot","oDraftNode","getDataFromTemplate","dataElement","splitPath","dataKey","connectedDataPath","connectedObject","template","Template","splitTemp","tempArray","trim","Data","notLastIndex","element","isLastIndex","templateInfo","lastIndex","getDelimiter","setMetaModel","getParameters","oParameterInfo","getParameterInfo","parameterProperties","buildActionWrapper","oThis","aParams","ref","handlerModule","handlerMethod","id","internalModelPath","oAdditionalParams","contexts","fn","getHiddenPathExpression","dataFieldAnnotations","hidden","getOperatorsForProperty","sEntitySetPath","bUseSemanticDateRange","settings","oFilterRestrictions","getFilterRestrictionsByPath","aEqualsOps","aSingleRangeOps","aSingleRangeDTBasicOps","aMultiRangeOps","aSearchExpressionOps","aBasicSemanticDateOps","SemanticDateOperators","getBasicSemanticDateOperations","bSemanticDateRange","aSemanticDateOps","customData","emptyOps","getFilterOperations","DefaultSemanticDateOperators","getSemanticDateOperations","aDefaultOperators","supportedOperators","extendedSemanticDateOperators","ExtendedSemanticDateOperators","restrictions","FilterAllowedExpressions","sAllowedExpression","getSpecificAllowedExpression","singleValueDateOps","getSingleValueDateOperations","aSingleValueOps","multiValueOperators","multiRangeOps","concat","getOperatorsForDateProperty","propertyType","getAIIcon","aiIcon","requiresIContext"],"sources":["./CommonHelper.ts"],"sourcesContent":["import type {\n\tChart,\n\tChartMeasureAttributeType,\n\tDataFieldForIntentBasedNavigation,\n\tDataFieldTypes,\n\tPresentationVariant\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport Log from \"sap/base/Log\";\nimport type { CompiledBindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport { compileExpression, constant, equal, fn, ifElse, notEqual, pathInModel, ref } from \"sap/fe/base/BindingToolkit\";\nimport CommonUtils from \"sap/fe/core/CommonUtils\";\nimport type { FilterSettings } from \"sap/fe/core/converters/ManifestSettings\";\n\nimport type { PropertyPath } from \"@sap-ux/vocabularies-types\";\nimport { aiIcon, type CustomAction } from \"sap/fe/core/converters/controls/Common/Action\";\nimport { convertTypes } from \"sap/fe/core/converters/MetaModelConverter\";\nimport { isPropertyFilterable } from \"sap/fe/core/helpers/MetaModelFunction\";\nimport ModelHelper from \"sap/fe/core/helpers/ModelHelper\";\nimport type { ComputedAnnotationInterface } from \"sap/fe/core/templating/UIFormatters\";\nimport * as DefaultSemanticDateOperators from \"sap/fe/macros/filterBar/DefaultSemanticDateOperators\";\nimport ExtendedSemanticDateOperators from \"sap/fe/macros/filterBar/ExtendedSemanticDateOperators\";\nimport SemanticDateOperators from \"sap/fe/macros/filterBar/SemanticDateOperators\";\nimport mLibrary from \"sap/m/library\";\nimport Device from \"sap/ui/Device\";\nimport FilterOperatorUtil from \"sap/ui/mdc/condition/FilterOperatorUtil\";\nimport FieldEditMode from \"sap/ui/mdc/enums/FieldEditMode\";\nimport TypeMap from \"sap/ui/mdc/odata/v4/TypeMap\";\nimport Context from \"sap/ui/model/Context\";\nimport ODataModelAnnotationHelper from \"sap/ui/model/odata/v4/AnnotationHelper\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\nimport type ODataModel from \"sap/ui/model/odata/v4/ODataModel\";\nimport type { MetaModelType } from \"../../../../../../types/metamodel_types\";\n\ntype MetaModelMeasure = {\n\t$PropertyPath: string;\n};\n\nfunction _getRestrictions(aDefaultOps: string[], aExpressionOps: string[]): string[] {\n\t// From the default set of Operators for the Base Type, select those that are defined in the Allowed Value.\n\t// In case that no operators are found, return undefined so that the default set is used.\n\treturn aDefaultOps.filter(function (sElement) {\n\t\treturn aExpressionOps.includes(sElement);\n\t});\n}\n\nfunction _getDefaultOperators(sPropertyType?: string): string[] {\n\t// mdc defines the full set of operations that are meaningful for each Edm Type\n\t// TODO Replace with model / internal way of retrieving the actual model type used for the property\n\tconst oDataClass = TypeMap.getDataTypeClassName(sPropertyType);\n\t// TODO need to pass proper formatOptions, constraints here\n\tconst oBaseType = TypeMap.getBaseType(oDataClass, {}, {});\n\treturn FilterOperatorUtil.getOperatorsForType(oBaseType);\n}\n\n/**\n * Helper function to check if an operator is excluded by manifest configuration.\n * @param operatorName The operator name to check\n * @param oSettings The settings object containing operator configuration\n * @returns True if the operator is excluded, false otherwise\n */\nfunction _isOperatorExcludedByManifest(operatorName: string, oSettings: FilterSettings | undefined): boolean {\n\tif (!oSettings?.operatorConfiguration) return false;\n\n\treturn oSettings.operatorConfiguration.some(\n\t\t(config) => config.path === \"key\" && config.equals === operatorName && config.exclude === true\n\t);\n}\n\n/**\n * Helper function to get Empty/NotEmpty operators with manifest configuration support.\n * @param sType The field type\n * @param oSettings The settings object containing operator configuration\n * @returns Array of Empty/NotEmpty operators if not excluded by manifest\n */\nfunction _getEmptyOps(sType: string, oSettings: FilterSettings | undefined): string[] {\n\t// Only return Empty/NotEmpty for date types\n\tif (sType !== \"Edm.Date\" && sType !== \"Edm.DateTimeOffset\") {\n\t\treturn [];\n\t}\n\n\tconst result: string[] = [];\n\n\t// Check manifest configuration and add operators in correct order (NotEmpty first to match test expectations)\n\tconst notEmptyExcluded = _isOperatorExcludedByManifest(\"NotEmpty\", oSettings);\n\tconst emptyExcluded = _isOperatorExcludedByManifest(\"Empty\", oSettings);\n\n\tif (!notEmptyExcluded) {\n\t\tresult.push(\"NotEmpty\");\n\t}\n\tif (!emptyExcluded) {\n\t\tresult.push(\"Empty\");\n\t}\n\n\treturn result;\n}\n\nconst ValueColor = mLibrary.ValueColor;\nconst CommonHelper = {\n\tgetPathToKey: function (oCtx: Context): object {\n\t\treturn oCtx.getObject();\n\t},\n\n\t/**\n\t * Determine if field is editable.\n\t * @param target Target instance\n\t * @param oInterface Interface instance\n\t * @returns A Binding Expression to determine if a field should be editable or not.\n\t */\n\tgetParameterEditMode: function (target: object, oInterface: ComputedAnnotationInterface): string {\n\t\tconst oModel = oInterface.context.getModel(),\n\t\t\tsPropertyPath = oInterface.context.getPath(),\n\t\t\toAnnotations = oModel.getObject(`${sPropertyPath}@`),\n\t\t\tfieldControl = oAnnotations[\"@com.sap.vocabularies.Common.v1.FieldControl\"],\n\t\t\timmutable = oAnnotations[\"@Org.OData.Core.V1.Immutable\"],\n\t\t\tcomputed = oAnnotations[\"@Org.OData.Core.V1.Computed\"];\n\n\t\tlet sEditMode: FieldEditMode | string = FieldEditMode.Editable;\n\n\t\tif (immutable || computed) {\n\t\t\tsEditMode = FieldEditMode.ReadOnly;\n\t\t} else if (fieldControl) {\n\t\t\tif (fieldControl.$EnumMember) {\n\t\t\t\tif (fieldControl.$EnumMember === \"com.sap.vocabularies.Common.v1.FieldControlType/ReadOnly\") {\n\t\t\t\t\tsEditMode = FieldEditMode.ReadOnly;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tfieldControl.$EnumMember === \"com.sap.vocabularies.Common.v1.FieldControlType/Inapplicable\" ||\n\t\t\t\t\tfieldControl.$EnumMember === \"com.sap.vocabularies.Common.v1.FieldControlType/Hidden\"\n\t\t\t\t) {\n\t\t\t\t\tsEditMode = FieldEditMode.Disabled;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fieldControl.$Path) {\n\t\t\t\tsEditMode =\n\t\t\t\t\t\"{= %{\" +\n\t\t\t\t\tfieldControl.$Path +\n\t\t\t\t\t\"} < 3 ? (%{\" +\n\t\t\t\t\tfieldControl.$Path +\n\t\t\t\t\t\"} === 0 ? '\" +\n\t\t\t\t\tFieldEditMode.Disabled +\n\t\t\t\t\t\"' : '\" +\n\t\t\t\t\tFieldEditMode.ReadOnly +\n\t\t\t\t\t\"') : '\" +\n\t\t\t\t\tFieldEditMode.Editable +\n\t\t\t\t\t\"'}\";\n\t\t\t}\n\t\t}\n\n\t\treturn sEditMode;\n\t},\n\t/**\n\t * Get the complete metapath to the target.\n\t * @param target\n\t * @param oInterface\n\t * @returns The metapath\n\t */\n\tgetMetaPath: function (target: unknown, oInterface: ComputedAnnotationInterface): string | undefined {\n\t\treturn (oInterface && oInterface.context && oInterface.context.getPath()) || undefined;\n\t},\n\tgetMetaModelId: function (target: Context, oInterface: ComputedAnnotationInterface): string {\n\t\tconvertTypes(oInterface.context.getModel());\n\t\treturn oInterface.context.getModel().getId();\n\t},\n\tisDesktop: function (): boolean {\n\t\treturn Device.system.desktop === true;\n\t},\n\tgetTargetCollectionPath: function (context: Context, navCollection?: string): string {\n\t\tlet sPath = context.getPath();\n\t\tif (\n\t\t\t(context.getObject(\"$kind\") as unknown as string) === \"EntitySet\" ||\n\t\t\t(context.getObject(\"$ContainsTarget\") as unknown as boolean) === true\n\t\t) {\n\t\t\treturn sPath;\n\t\t}\n\n\t\tconst model = context.getModel() as ODataModel | ODataMetaModel;\n\t\tconst metaModel = model.isA<ODataMetaModel>(\"sap.ui.model.odata.v4.ODataMetaModel\") ? model : model.getMetaModel();\n\t\tsPath = metaModel.getMetaPath(sPath);\n\n\t\t//Supporting sPath of any format, either '/<entitySet>/<navigationCollection>' <OR> '/<entitySet>/$Type/<navigationCollection>'\n\t\tconst aParts = sPath.split(\"/\").filter(function (sPart: string): boolean {\n\t\t\treturn !!sPart && sPart != \"$Type\";\n\t\t}); //filter out empty strings and parts referring to '$Type'\n\t\tconst entitySet = `/${aParts[0]}`;\n\t\tif (aParts.length === 1) {\n\t\t\treturn entitySet;\n\t\t}\n\t\tconst navigationCollection = navCollection === undefined ? aParts.slice(1).join(\"/$NavigationPropertyBinding/\") : navCollection;\n\t\treturn `${entitySet}/$NavigationPropertyBinding/${navigationCollection}`; // used in gotoTargetEntitySet method in the same file\n\t},\n\n\tisPropertyFilterable: function (\n\t\tcontext: Context,\n\t\toDataField?: MetaModelType<DataFieldTypes>,\n\t\tskipHiddenFilters?: boolean\n\t): boolean | CompiledBindingToolkitExpression {\n\t\tconst oModel = context.getModel() as ODataMetaModel,\n\t\t\tsPropertyPath = context.getPath(),\n\t\t\t// LoacationPath would be the prefix of sPropertyPath, example: sPropertyPath = '/Customer/Set/Name' -> sPropertyLocationPath = '/Customer/Set'\n\t\t\tsPropertyLocationPath = CommonHelper.getLocationForPropertyPath(oModel, sPropertyPath),\n\t\t\tsProperty = sPropertyPath.replace(`${sPropertyLocationPath}/`, \"\");\n\n\t\tif (\n\t\t\toDataField &&\n\t\t\t(oDataField.$Type === \"com.sap.vocabularies.UI.v1.DataFieldForAction\" ||\n\t\t\t\toDataField.$Type === \"com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation\")\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn isPropertyFilterable(oModel, sPropertyLocationPath, sProperty, skipHiddenFilters);\n\t},\n\n\tgetLocationForPropertyPath: function (oModel: ODataMetaModel, sPropertyPath: string): string {\n\t\tlet iLength;\n\t\tlet sCollectionPath = sPropertyPath.slice(0, sPropertyPath.lastIndexOf(\"/\"));\n\t\tif (oModel.getObject(`${sCollectionPath}/$kind`) === \"EntityContainer\") {\n\t\t\tiLength = sCollectionPath.length + 1;\n\t\t\tsCollectionPath = sPropertyPath.slice(iLength, sPropertyPath.indexOf(\"/\", iLength));\n\t\t}\n\t\treturn sCollectionPath;\n\t},\n\tgotoActionParameter: function (oContext: Context): string {\n\t\tconst sPath = oContext.getPath(),\n\t\t\tsPropertyName = oContext.getObject(`${sPath}/$Name`);\n\n\t\treturn CommonUtils.getParameterPath(sPath, sPropertyName);\n\t},\n\t/**\n\t * Returns the entity set name from the entity type name.\n\t * @param oMetaModel OData v4 metamodel instance\n\t * @param sEntityType EntityType of the actiom\n\t * @returns The EntitySet of the bound action\n\t * @private\n\t */\n\tgetEntitySetName: function (oMetaModel: ODataMetaModel, sEntityType: string): string | undefined {\n\t\tconst oEntityContainer = oMetaModel.getObject(\"/\");\n\t\tfor (const key in oEntityContainer) {\n\t\t\tif (typeof oEntityContainer[key] === \"object\" && oEntityContainer[key].$Type === sEntityType) {\n\t\t\t\treturn key;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t},\n\t/**\n\t * Returns the metamodel path correctly for bound actions if used with bReturnOnlyPath as true,\n\t * else returns an object which has 3 properties related to the action. They are the entity set name,\n\t * the $Path value of the OperationAvailable annotation and the binding parameter name. If\n\t * bCheckStaticValue is true, returns the static value of OperationAvailable annotation, if present.\n\t * e.g. for bound action someNameSpace.SomeBoundAction\n\t * of entity set SomeEntitySet, the string \"/SomeEntitySet/someNameSpace.SomeBoundAction\" is returned.\n\t * @param oAction The context object of the action\n\t * @param bReturnOnlyPath If false, additional info is returned along with metamodel path to the bound action\n\t * @param sActionName The name of the bound action of the form someNameSpace.SomeBoundAction\n\t * @param bCheckStaticValue If true, the static value of OperationAvailable is returned, if present\n\t * @returns The string or object as specified by bReturnOnlyPath\n\t * @private\n\t */\n\tgetActionPath: function (\n\t\toAction: Context,\n\t\tbReturnOnlyPath: boolean,\n\t\tsActionName?: string,\n\t\tbCheckStaticValue?: boolean\n\t):\n\t\t| string\n\t\t| {\n\t\t\t\tsContextPath: string;\n\t\t\t\tsProperty: string;\n\t\t\t\tsBindingParameter: string;\n\t\t  } {\n\t\tlet sContextPath = oAction.getPath().split(\"/@\")[0];\n\n\t\tsActionName = !sActionName ? oAction.getObject(oAction.getPath()) : sActionName;\n\n\t\tif (sActionName && sActionName.includes(\"(\")) {\n\t\t\t// action bound to another entity type\n\t\t\tsActionName = sActionName.split(\"(\")[0];\n\t\t} else if (oAction.getObject(sContextPath)) {\n\t\t\t// TODO: this logic sounds wrong, to be corrected\n\t\t\tconst sEntityTypeName = oAction.getObject(sContextPath).$Type;\n\t\t\tconst sEntityName = this.getEntitySetName(oAction.getModel(), sEntityTypeName);\n\t\t\tif (sEntityName) {\n\t\t\t\tsContextPath = `/${sEntityName}`;\n\t\t\t}\n\t\t} else {\n\t\t\treturn sContextPath;\n\t\t}\n\n\t\tif (bCheckStaticValue) {\n\t\t\treturn oAction.getObject(`${sContextPath}/${sActionName}@Org.OData.Core.V1.OperationAvailable`);\n\t\t}\n\t\tif (bReturnOnlyPath) {\n\t\t\treturn `${sContextPath}/${sActionName}`;\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tsContextPath: sContextPath,\n\t\t\t\tsProperty: oAction.getObject(`${sContextPath}/${sActionName}@Org.OData.Core.V1.OperationAvailable/$Path`),\n\t\t\t\tsBindingParameter: oAction.getObject(`${sContextPath}/${sActionName}/@$ui5.overload/0/$Parameter/0/$Name`)\n\t\t\t};\n\t\t}\n\t},\n\n\tgetNavigationContext: function (oContext: Context): string {\n\t\treturn ODataModelAnnotationHelper.getNavigationPath(oContext.getPath());\n\t},\n\n\t/**\n\t * Returns the path without the entity type (potentially first) and property (last) part (optional).\n\t * The result can be an empty string if it is a simple direct property.\n\t *\n\t * If and only if the given property path starts with a slash (/), it is considered that the entity type\n\t * is part of the path and will be stripped away.\n\t * @param sPropertyPath\n\t * @param bKeepProperty\n\t * @returns The navigation path\n\t */\n\tgetNavigationPath: function (sPropertyPath: string, bKeepProperty?: boolean): string {\n\t\tconst bStartsWithEntityType = sPropertyPath.startsWith(\"/\");\n\t\tconst aParts = sPropertyPath.split(\"/\").filter(function (part: string) {\n\t\t\treturn !!part;\n\t\t});\n\t\tif (bStartsWithEntityType) {\n\t\t\taParts.shift();\n\t\t}\n\t\tif (!bKeepProperty) {\n\t\t\taParts.pop();\n\t\t}\n\t\treturn aParts.join(\"/\");\n\t},\n\n\t/**\n\t * Returns the correct metamodel path for bound actions.\n\t *\n\t * Since this method is called irrespective of the action type, this will be applied to unbound actions.\n\t * In such a case, if an incorrect path is returned, it is ignored during templating.\n\t *\n\t * Example: for the bound action someNameSpace.SomeBoundAction of entity set SomeEntitySet,\n\t * the string \"/SomeEntitySet/someNameSpace.SomeBoundAction\" is returned.\n\t * @param oAction Context object for the action\n\t * @returns Correct metamodel path for bound and incorrect path for unbound actions\n\t * @private\n\t */\n\tgetActionContext: function (oAction: Context): string {\n\t\treturn CommonHelper.getActionPath(oAction, true) as string;\n\t},\n\t/**\n\t * Returns the metamodel path correctly for overloaded bound actions. For unbound actions,\n\t * the incorrect path is returned, but ignored during templating.\n\t * e.g. for bound action someNameSpace.SomeBoundAction of entity set SomeEntitySet,\n\t * the string \"/SomeEntitySet/someNameSpace.SomeBoundAction/@$ui5.overload/0\" is returned.\n\t * @param oAction The context object for the action\n\t * @returns The correct metamodel path for bound action overload and incorrect path for unbound actions\n\t * @private\n\t */\n\tgetPathToBoundActionOverload: function (oAction: Context): string {\n\t\tconst sPath = CommonHelper.getActionPath(oAction, true);\n\t\treturn `${sPath}/@$ui5.overload/0`;\n\t},\n\n\t/**\n\t * Returns the string with single quotes.\n\t * @param sValue Some string that needs to be converted into single quotes\n\t * @param [bEscape] Should the string be escaped beforehand\n\t * @returns - String with single quotes\n\t */\n\taddSingleQuotes: function (sValue: string, bEscape?: boolean): string {\n\t\tif (bEscape && sValue) {\n\t\t\tsValue = this.escapeSingleQuotes(sValue);\n\t\t}\n\t\treturn `'${sValue}'`;\n\t},\n\n\t/**\n\t * Returns the string with escaped single quotes.\n\t * @param sValue Some string that needs escaping of single quotes\n\t * @returns - String with escaped single quotes\n\t */\n\tescapeSingleQuotes: function (sValue: string): string {\n\t\treturn sValue.replace(/[']/g, \"\\\\'\");\n\t},\n\n\t/**\n\t * Returns the function string\n\t * The first argument of generateFunction is name of the generated function string.\n\t * Remaining arguments of generateFunction are arguments of the newly generated function string.\n\t * @param sFuncName Some string for the function name\n\t * @param args The remaining arguments\n\t * @returns - Function string depends on arguments passed\n\t */\n\tgenerateFunction: function (sFuncName: string, ...args: string[]): string {\n\t\tlet sParams = \"\";\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tsParams += args[i];\n\t\t\tif (i < args.length - 1) {\n\t\t\t\tsParams += \", \";\n\t\t\t}\n\t\t}\n\n\t\tlet sFunction = `${sFuncName}()`;\n\t\tif (sParams) {\n\t\t\tsFunction = `${sFuncName}(${sParams})`;\n\t\t}\n\t\treturn sFunction;\n\t},\n\t/*\n\t * Returns the visibility expression for datapoint title/link\n\t *\n\t * @function\n\t * @param {string} [path] annotation path of data point or Microchart\n\t * @param {boolean} [isClickable] true if link is visible\n\t * @returns {CompiledBindingToolkitExpression} visibilityExp Used to get the visibility binding for DataPoints title in the Header.\n\t *\n\t */\n\n\tgetHeaderDataPointLinkVisibility: function (path: string, isClickable: boolean): CompiledBindingToolkitExpression {\n\t\treturn compileExpression(\n\t\t\tifElse(\n\t\t\t\tconstant(isClickable),\n\t\t\t\tequal(pathInModel(`isHeaderDPLinkVisible/${path}`, \"internal\"), true),\n\t\t\t\tnotEqual(pathInModel(`isHeaderDPLinkVisible/${path}`, \"internal\"), true)\n\t\t\t)\n\t\t);\n\t},\n\n\t/**\n\t * Converts object to string(different from JSON.stringify or.toString).\n\t * @param oParams Some object\n\t * @returns - Object string\n\t */\n\tobjectToString: function (oParams: Record<string, unknown>): string {\n\t\tlet iNumberOfKeys = Object.keys(oParams).length,\n\t\t\tsParams = \"\";\n\n\t\tfor (const sKey in oParams) {\n\t\t\tlet sValue = oParams[sKey];\n\t\t\tif (sValue && typeof sValue === \"object\") {\n\t\t\t\tsValue = this.objectToString(sValue as Record<string, unknown>);\n\t\t\t}\n\t\t\tsParams += `${sKey}: ${sValue}`;\n\t\t\tif (iNumberOfKeys > 1) {\n\t\t\t\t--iNumberOfKeys;\n\t\t\t\tsParams += \", \";\n\t\t\t}\n\t\t}\n\n\t\treturn `{ ${sParams}}`;\n\t},\n\n\t/**\n\t * Removes escape characters (\\) from an expression.\n\t * @param sExpression An expression with escape characters\n\t * @returns Expression string without escape characters or undefined\n\t */\n\tremoveEscapeCharacters: function (sExpression?: string): string | undefined {\n\t\treturn sExpression ? sExpression.replace(/\\\\?\\\\([{}])/g, \"$1\") : undefined;\n\t},\n\n\t/**\n\t * Makes updates to a stringified object so that it works properly in a template by adding ui5Object:true.\n\t * @param sStringified\n\t * @returns The updated string representation of the object\n\t */\n\tstringifyObject: function (sStringified: string): string | undefined {\n\t\tif (!sStringified || sStringified === \"{}\") {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst oObject = JSON.parse(sStringified);\n\t\t\tif (typeof oObject === \"object\" && !Array.isArray(oObject)) {\n\t\t\t\tconst oUI5Object = {\n\t\t\t\t\tui5object: true\n\t\t\t\t};\n\t\t\t\tObject.assign(oUI5Object, oObject);\n\t\t\t\treturn JSON.stringify(oUI5Object);\n\t\t\t} else {\n\t\t\t\tconst sType = Array.isArray(oObject) ? \"Array\" : typeof oObject;\n\t\t\t\tLog.error(`Unexpected object type in stringifyObject (${sType}) - only works with object`);\n\t\t\t\tthrow new Error(\"stringifyObject only works with objects!\");\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Create a string representation of the given data, taking care that it is not treated as a binding expression.\n\t * @param vData The data to stringify\n\t * @returns The string representation of the data.\n\t */\n\tstringifyCustomData: function (vData: object | string | undefined): string {\n\t\tconst oObject: { ui5object: true; customData?: unknown } = {\n\t\t\tui5object: true\n\t\t};\n\t\toObject[\"customData\"] = vData instanceof Context ? vData.getObject() : vData;\n\t\treturn JSON.stringify(oObject);\n\t},\n\n\t/**\n\t * Parses the given data, potentially unwraps the data.\n\t * @param vData The data to parse\n\t * @param vData.ui5object\n\t * @param vData.customData\n\t * @returns The result of the data parsing\n\t */\n\tparseCustomData: function (vData?: string | { ui5object: true; customData?: unknown }): unknown {\n\t\tvData = typeof vData === \"string\" ? JSON.parse(vData) : vData;\n\t\tif (vData && vData.hasOwnProperty(\"customData\")) {\n\t\t\treturn (vData as { ui5object: true; customData?: unknown })[\"customData\"];\n\t\t}\n\t\treturn vData;\n\t},\n\tgetContextPath: function (oValue: unknown, oInterface: ComputedAnnotationInterface): string {\n\t\tconst sPath = oInterface && oInterface.context && oInterface.context.getPath();\n\t\treturn sPath[sPath.length - 1] === \"/\" ? sPath.slice(0, -1) : sPath;\n\t},\n\t/**\n\t * Returns a stringified JSON object containing  Presentation Variant sort conditions.\n\t * @param oContext\n\t * @param oContext.getPath\n\t * @param oContext.getModel\n\t * @param oPresentationVariant Presentation variant Annotation\n\t * @param sPresentationVariantPath\n\t * @returns Stringified JSON object\n\t */\n\tgetSortConditions: function (\n\t\toContext: { getPath(num: number): string; getModel(num: number): ODataMetaModel },\n\t\toPresentationVariant: MetaModelType<PresentationVariant>,\n\t\tsPresentationVariantPath: string\n\t): string | undefined {\n\t\tif (\n\t\t\toPresentationVariant &&\n\t\t\tCommonHelper._isPresentationVariantAnnotation(sPresentationVariantPath) &&\n\t\t\toPresentationVariant.SortOrder\n\t\t) {\n\t\t\tconst aSortConditions: { sorters: { name?: string; descending?: boolean }[] } = {\n\t\t\t\tsorters: []\n\t\t\t};\n\n\t\t\tconst sEntityPath = oContext.getPath(0).split(\"@\")[0];\n\t\t\toPresentationVariant.SortOrder.forEach(function (oCondition = {}) {\n\t\t\t\tlet oSortProperty: string | undefined;\n\t\t\t\tconst oSorter: { name?: string; descending?: boolean } = {};\n\t\t\t\tif (oCondition.DynamicProperty) {\n\t\t\t\t\toSortProperty = oContext.getModel(0).getObject(sEntityPath + oCondition.DynamicProperty.$AnnotationPath)?.Name;\n\t\t\t\t} else if (oCondition.Property) {\n\t\t\t\t\toSortProperty = oCondition.Property.$PropertyPath;\n\t\t\t\t}\n\t\t\t\tif (oSortProperty) {\n\t\t\t\t\toSorter.name = oSortProperty;\n\t\t\t\t\toSorter.descending = !!oCondition.Descending;\n\t\t\t\t\taSortConditions.sorters.push(oSorter);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Please define the right path to the sort property\");\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn JSON.stringify(aSortConditions);\n\t\t}\n\t\treturn undefined;\n\t},\n\t_isPresentationVariantAnnotation: function (annotationPath: string): boolean {\n\t\treturn (\n\t\t\tannotationPath.includes(`@${UIAnnotationTerms.PresentationVariant}`) ||\n\t\t\tannotationPath.includes(`@${UIAnnotationTerms.SelectionPresentationVariant}`)\n\t\t);\n\t},\n\tcreatePresentationPathContext: function (oPresentationContext: Context): Context {\n\t\tconst aPaths = oPresentationContext.getPath().split(\"@\") || [];\n\t\tconst oModel = oPresentationContext.getModel();\n\t\tif (aPaths.length && aPaths[aPaths.length - 1].includes(\"com.sap.vocabularies.UI.v1.SelectionPresentationVariant\")) {\n\t\t\tconst sPath = oPresentationContext.getPath().split(\"/PresentationVariant\")[0];\n\t\t\treturn oModel.createBindingContext(`${sPath}@sapui.name`);\n\t\t}\n\t\treturn oModel.createBindingContext(`${oPresentationContext.getPath()}@sapui.name`);\n\t},\n\tgetPressHandlerForDataFieldForIBN: function (\n\t\toDataField: DataFieldForIntentBasedNavigation,\n\t\tsContext?: string,\n\t\tbNavigateWithConfirmationDialog?: boolean,\n\t\tforContextMenu = false\n\t): string | undefined {\n\t\tif (!oDataField) return undefined;\n\t\tconst mNavigationParameters: {\n\t\t\tnavigationContexts?: string;\n\t\t\tlabel?: string;\n\t\t\tapplicableContexts?: string;\n\t\t\tnotApplicableContexts?: string;\n\t\t\tsemanticObjectMapping?: string;\n\t\t} = {\n\t\t\tnavigationContexts: sContext ? sContext : \"${$source>/}.getBindingContext()\"\n\t\t};\n\t\tif (oDataField.RequiresContext && !oDataField.Inline && bNavigateWithConfirmationDialog) {\n\t\t\tconst applicableProperty = !forContextMenu ? \"aApplicable\" : \"aApplicableForContextMenu\";\n\t\t\tconst notApplicableProperty = !forContextMenu ? \"aNotApplicable\" : \"aNotApplicableForContextMenu\";\n\t\t\tmNavigationParameters.applicableContexts = `\\${internal>ibn/${oDataField.SemanticObject}-${oDataField.Action}/${applicableProperty}/}`;\n\t\t\tmNavigationParameters.notApplicableContexts = `\\${internal>ibn/${oDataField.SemanticObject}-${oDataField.Action}/${notApplicableProperty}/}`;\n\t\t\tmNavigationParameters.label = this.addSingleQuotes(oDataField.Label as string, true);\n\t\t}\n\t\tif (oDataField.Mapping) {\n\t\t\tmNavigationParameters.semanticObjectMapping = this.addSingleQuotes(JSON.stringify(oDataField.Mapping));\n\t\t}\n\t\treturn this.generateFunction(\n\t\t\tbNavigateWithConfirmationDialog ? \"._intentBasedNavigation.navigateWithConfirmationDialog\" : \"._intentBasedNavigation.navigate\",\n\t\t\tthis.addSingleQuotes(oDataField.SemanticObject as unknown as string),\n\t\t\tthis.addSingleQuotes(oDataField.Action as unknown as string),\n\t\t\tthis.objectToString(mNavigationParameters),\n\t\t\t\"${$source>/}\"\n\t\t);\n\t},\n\tgetEntitySet: function (oContext: Context): string {\n\t\tconst sPath = oContext.getPath();\n\t\treturn ModelHelper.getEntitySetPath(sPath);\n\t},\n\n\t/**\n\t * Method to do the calculation of criticality in case CriticalityCalculation present in the annotation\n\t *\n\t * The calculation is done by comparing a value to the threshold values relevant for the specified improvement direction.\n\t * For improvement direction Target, the criticality is calculated using both low and high threshold values. It will be\n\t *\n\t * - Positive if the value is greater than or equal to AcceptanceRangeLowValue and lower than or equal to AcceptanceRangeHighValue\n\t * - Neutral if the value is greater than or equal to ToleranceRangeLowValue and lower than AcceptanceRangeLowValue OR greater than AcceptanceRangeHighValue and lower than or equal to ToleranceRangeHighValue\n\t * - Critical if the value is greater than or equal to DeviationRangeLowValue and lower than ToleranceRangeLowValue OR greater than ToleranceRangeHighValue and lower than or equal to DeviationRangeHighValue\n\t * - Negative if the value is lower than DeviationRangeLowValue or greater than DeviationRangeHighValue\n\t *\n\t * For improvement direction Minimize, the criticality is calculated using the high threshold values. It is\n\t * - Positive if the value is lower than or equal to AcceptanceRangeHighValue\n\t * - Neutral if the value is greater than AcceptanceRangeHighValue and lower than or equal to ToleranceRangeHighValue\n\t * - Critical if the value is greater than ToleranceRangeHighValue and lower than or equal to DeviationRangeHighValue\n\t * - Negative if the value is greater than DeviationRangeHighValue\n\t *\n\t * For improvement direction Maximize, the criticality is calculated using the low threshold values. It is\n\t *\n\t * - Positive if the value is greater than or equal to AcceptanceRangeLowValue\n\t * - Neutral if the value is less than AcceptanceRangeLowValue and greater than or equal to ToleranceRangeLowValue\n\t * - Critical if the value is lower than ToleranceRangeLowValue and greater than or equal to DeviationRangeLowValue\n\t * - Negative if the value is lower than DeviationRangeLowValue\n\t *\n\t * Thresholds are optional. For unassigned values, defaults are determined in this order:\n\t *\n\t * - For DeviationRange, an omitted LowValue translates into the smallest possible number (-INF), an omitted HighValue translates into the largest possible number (+INF)\n\t * - For ToleranceRange, an omitted LowValue will be initialized with DeviationRangeLowValue, an omitted HighValue will be initialized with DeviationRangeHighValue\n\t * - For AcceptanceRange, an omitted LowValue will be initialized with ToleranceRangeLowValue, an omitted HighValue will be initialized with ToleranceRangeHighValue.\n\t * @param sImprovementDirection ImprovementDirection to be used for creating the criticality binding\n\t * @param sValue Value from Datapoint to be measured\n\t * @param sDeviationLow ExpressionBinding for Lower Deviation level\n\t * @param sToleranceLow ExpressionBinding for Lower Tolerance level\n\t * @param sAcceptanceLow ExpressionBinding for Lower Acceptance level\n\t * @param sAcceptanceHigh ExpressionBinding for Higher Acceptance level\n\t * @param sToleranceHigh ExpressionBinding for Higher Tolerance level\n\t * @param sDeviationHigh ExpressionBinding for Higher Deviation level\n\t * @returns Returns criticality calculation as expression binding\n\t */\n\tgetCriticalityCalculationBinding: function (\n\t\tsImprovementDirection: string,\n\t\tsValue: string,\n\t\tsDeviationLow: string | number,\n\t\tsToleranceLow: string | number,\n\t\tsAcceptanceLow: string | number,\n\t\tsAcceptanceHigh: string | number,\n\t\tsToleranceHigh: string | number,\n\t\tsDeviationHigh: string | number\n\t): string {\n\t\tlet sCriticalityExpression: typeof ValueColor | string = ValueColor.Neutral; // Default Criticality State\n\n\t\tsValue = `%${sValue}`;\n\n\t\t// Setting Unassigned Values\n\t\tsDeviationLow = sDeviationLow || -Infinity;\n\t\tsToleranceLow = sToleranceLow || sDeviationLow;\n\t\tsAcceptanceLow = sAcceptanceLow || sToleranceLow;\n\t\tsDeviationHigh = sDeviationHigh || Infinity;\n\t\tsToleranceHigh = sToleranceHigh || sDeviationHigh;\n\t\tsAcceptanceHigh = sAcceptanceHigh || sToleranceHigh;\n\n\t\t// Dealing with Decimal and Path based bingdings\n\t\tsDeviationLow = sDeviationLow && (+sDeviationLow ? +sDeviationLow : `%${sDeviationLow}`);\n\t\tsToleranceLow = sToleranceLow && (+sToleranceLow ? +sToleranceLow : `%${sToleranceLow}`);\n\t\tsAcceptanceLow = sAcceptanceLow && (+sAcceptanceLow ? +sAcceptanceLow : `%${sAcceptanceLow}`);\n\t\tsAcceptanceHigh = sAcceptanceHigh && (+sAcceptanceHigh ? +sAcceptanceHigh : `%${sAcceptanceHigh}`);\n\t\tsToleranceHigh = sToleranceHigh && (+sToleranceHigh ? +sToleranceHigh : `%${sToleranceHigh}`);\n\t\tsDeviationHigh = sDeviationHigh && (+sDeviationHigh ? +sDeviationHigh : `%${sDeviationHigh}`);\n\n\t\t// Creating runtime expression binding from criticality calculation for Criticality State\n\t\tif (sImprovementDirection.includes(\"Minimize\")) {\n\t\t\tsCriticalityExpression =\n\t\t\t\t\"{= \" +\n\t\t\t\tsValue +\n\t\t\t\t\" <= \" +\n\t\t\t\tsAcceptanceHigh +\n\t\t\t\t\" ? '\" +\n\t\t\t\tValueColor.Good +\n\t\t\t\t\"' : \" +\n\t\t\t\tsValue +\n\t\t\t\t\" <= \" +\n\t\t\t\tsToleranceHigh +\n\t\t\t\t\" ? '\" +\n\t\t\t\tValueColor.Neutral +\n\t\t\t\t\"' : \" +\n\t\t\t\t\"(\" +\n\t\t\t\tsDeviationHigh +\n\t\t\t\t\" && \" +\n\t\t\t\tsValue +\n\t\t\t\t\" <= \" +\n\t\t\t\tsDeviationHigh +\n\t\t\t\t\") ? '\" +\n\t\t\t\tValueColor.Critical +\n\t\t\t\t\"' : '\" +\n\t\t\t\tValueColor.Error +\n\t\t\t\t\"' }\";\n\t\t} else if (sImprovementDirection.includes(\"Maximize\")) {\n\t\t\tsCriticalityExpression =\n\t\t\t\t\"{= \" +\n\t\t\t\tsValue +\n\t\t\t\t\" >= \" +\n\t\t\t\tsAcceptanceLow +\n\t\t\t\t\" ? '\" +\n\t\t\t\tValueColor.Good +\n\t\t\t\t\"' : \" +\n\t\t\t\tsValue +\n\t\t\t\t\" >= \" +\n\t\t\t\tsToleranceLow +\n\t\t\t\t\" ? '\" +\n\t\t\t\tValueColor.Neutral +\n\t\t\t\t\"' : \" +\n\t\t\t\t\"(\" +\n\t\t\t\tsDeviationLow +\n\t\t\t\t\" && \" +\n\t\t\t\tsValue +\n\t\t\t\t\" >= \" +\n\t\t\t\tsDeviationLow +\n\t\t\t\t\") ? '\" +\n\t\t\t\tValueColor.Critical +\n\t\t\t\t\"' : '\" +\n\t\t\t\tValueColor.Error +\n\t\t\t\t\"' }\";\n\t\t} else if (sImprovementDirection.includes(\"Target\")) {\n\t\t\tsCriticalityExpression =\n\t\t\t\t\"{= (\" +\n\t\t\t\tsValue +\n\t\t\t\t\" <= \" +\n\t\t\t\tsAcceptanceHigh +\n\t\t\t\t\" && \" +\n\t\t\t\tsValue +\n\t\t\t\t\" >= \" +\n\t\t\t\tsAcceptanceLow +\n\t\t\t\t\") ? '\" +\n\t\t\t\tValueColor.Good +\n\t\t\t\t\"' : \" +\n\t\t\t\t\"((\" +\n\t\t\t\tsValue +\n\t\t\t\t\" >= \" +\n\t\t\t\tsToleranceLow +\n\t\t\t\t\" && \" +\n\t\t\t\tsValue +\n\t\t\t\t\" < \" +\n\t\t\t\tsAcceptanceLow +\n\t\t\t\t\") || (\" +\n\t\t\t\tsValue +\n\t\t\t\t\" > \" +\n\t\t\t\tsAcceptanceHigh +\n\t\t\t\t\" && \" +\n\t\t\t\tsValue +\n\t\t\t\t\" <= \" +\n\t\t\t\tsToleranceHigh +\n\t\t\t\t\")) ? '\" +\n\t\t\t\tValueColor.Neutral +\n\t\t\t\t\"' : \" +\n\t\t\t\t\"((\" +\n\t\t\t\tsDeviationLow +\n\t\t\t\t\" && (\" +\n\t\t\t\tsValue +\n\t\t\t\t\" >= \" +\n\t\t\t\tsDeviationLow +\n\t\t\t\t\") && (\" +\n\t\t\t\tsValue +\n\t\t\t\t\" < \" +\n\t\t\t\tsToleranceLow +\n\t\t\t\t\")) || ((\" +\n\t\t\t\tsValue +\n\t\t\t\t\" > \" +\n\t\t\t\tsToleranceHigh +\n\t\t\t\t\") && \" +\n\t\t\t\tsDeviationHigh +\n\t\t\t\t\" && (\" +\n\t\t\t\tsValue +\n\t\t\t\t\" <= \" +\n\t\t\t\tsDeviationHigh +\n\t\t\t\t\"))) ? '\" +\n\t\t\t\tValueColor.Critical +\n\t\t\t\t\"' : '\" +\n\t\t\t\tValueColor.Error +\n\t\t\t\t\"' }\";\n\t\t} else {\n\t\t\tLog.warning(\"Case not supported, returning the default Value Neutral\");\n\t\t}\n\n\t\treturn sCriticalityExpression;\n\t},\n\t/**\n\t * To fetch measure attribute index.\n\t * @param iMeasure Chart Annotations\n\t * @param oChartAnnotations Chart Annotations\n\t * @param isMicroChart Whether this is a micro chart\n\t * @returns MeasureAttribute index.\n\t * @private\n\t */\n\tgetMeasureAttributeIndex: function (iMeasure: number, oChartAnnotations: MetaModelType<Chart> | Chart, isMicroChart?: boolean): number {\n\t\tlet aMeasures, sMeasurePropertyPath;\n\t\tif (oChartAnnotations?.Measures?.length && oChartAnnotations?.Measures?.length > 0) {\n\t\t\taMeasures = oChartAnnotations.Measures;\n\t\t\tsMeasurePropertyPath = isMicroChart\n\t\t\t\t? (aMeasures[iMeasure] as PropertyPath).value\n\t\t\t\t: (aMeasures[iMeasure] as MetaModelMeasure).$PropertyPath;\n\t\t} else if (oChartAnnotations?.DynamicMeasures?.length && oChartAnnotations?.DynamicMeasures?.length > 0) {\n\t\t\taMeasures = (oChartAnnotations as MetaModelType<Chart>).DynamicMeasures;\n\t\t\tsMeasurePropertyPath = aMeasures?.[iMeasure].$AnnotationPath;\n\t\t}\n\t\tlet bMeasureAttributeExists;\n\t\tconst aMeasureAttributes = oChartAnnotations.MeasureAttributes;\n\t\tlet iMeasureAttribute = -1;\n\t\tconst fnCheckMeasure = function (\n\t\t\tsMeasurePath: string | undefined,\n\t\t\toMeasureAttribute: MetaModelType<ChartMeasureAttributeType> | ChartMeasureAttributeType,\n\t\t\tindex: number\n\t\t): boolean {\n\t\t\tif (oMeasureAttribute) {\n\t\t\t\tconst path = isMicroChart\n\t\t\t\t\t? (oMeasureAttribute as ChartMeasureAttributeType).Measure?.value\n\t\t\t\t\t: (oMeasureAttribute as MetaModelType<ChartMeasureAttributeType>).Measure?.$PropertyPath;\n\t\t\t\tif (oMeasureAttribute.Measure && path === sMeasurePath) {\n\t\t\t\t\tiMeasureAttribute = index;\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (\n\t\t\t\t\toMeasureAttribute.DynamicMeasure &&\n\t\t\t\t\t(oMeasureAttribute as MetaModelType<ChartMeasureAttributeType>)?.DynamicMeasure?.$AnnotationPath === sMeasurePath\n\t\t\t\t) {\n\t\t\t\t\tiMeasureAttribute = index;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tif (aMeasureAttributes) {\n\t\t\tbMeasureAttributeExists = aMeasureAttributes.some(fnCheckMeasure.bind(null, sMeasurePropertyPath));\n\t\t}\n\t\treturn bMeasureAttributeExists && iMeasureAttribute > -1 ? iMeasureAttribute : -1;\n\t},\n\n\tgetMeasureAttribute: async function (oContext: Context): Promise<string | undefined> {\n\t\tconst oMetaModel = oContext.getModel() as ODataMetaModel,\n\t\t\tsChartAnnotationPath = oContext.getPath();\n\t\treturn oMetaModel.requestObject(sChartAnnotationPath).then(function (oChartAnnotations: MetaModelType<Chart>) {\n\t\t\tconst aMeasureAttributes = oChartAnnotations.MeasureAttributes,\n\t\t\t\tiMeasureAttribute = CommonHelper.getMeasureAttributeIndex(0, oChartAnnotations);\n\t\t\tconst sMeasureAttributePath =\n\t\t\t\tiMeasureAttribute > -1 && aMeasureAttributes?.[iMeasureAttribute] && aMeasureAttributes[iMeasureAttribute].DataPoint\n\t\t\t\t\t? `${sChartAnnotationPath}/MeasureAttributes/${iMeasureAttribute}/`\n\t\t\t\t\t: undefined;\n\t\t\tif (sMeasureAttributePath === undefined) {\n\t\t\t\tLog.warning(\"DataPoint missing for the measure\");\n\t\t\t}\n\t\t\treturn sMeasureAttributePath ? `${sMeasureAttributePath}DataPoint/$AnnotationPath/` : sMeasureAttributePath;\n\t\t});\n\t},\n\t/**\n\t * This function returns the measureAttribute for the measure.\n\t * @param oContext Context to the measure annotation\n\t * @returns Path to the measureAttribute of the measure\n\t */\n\tgetMeasureAttributeForMeasure: function (oContext: Context): string | undefined {\n\t\tconst oMetaModel = oContext.getModel() as ODataMetaModel,\n\t\t\tsMeasurePath = oContext.getPath(),\n\t\t\tsChartAnnotationPath = sMeasurePath.substring(0, sMeasurePath.lastIndexOf(\"Measure\")),\n\t\t\tiMeasure = sMeasurePath.replace(/.*\\//, \"\");\n\n\t\tconst oChartAnnotations = oMetaModel.getObject(sChartAnnotationPath);\n\t\tconst aMeasureAttributes = oChartAnnotations.MeasureAttributes,\n\t\t\tiMeasureAttribute = CommonHelper.getMeasureAttributeIndex(iMeasure as unknown as number, oChartAnnotations);\n\t\tconst sMeasureAttributePath =\n\t\t\tiMeasureAttribute > -1 && aMeasureAttributes[iMeasureAttribute] && aMeasureAttributes[iMeasureAttribute].DataPoint\n\t\t\t\t? `${sChartAnnotationPath}MeasureAttributes/${iMeasureAttribute}/`\n\t\t\t\t: undefined;\n\t\tif (sMeasureAttributePath === undefined) {\n\t\t\tLog.warning(\"DataPoint missing for the measure\");\n\t\t}\n\t\treturn sMeasureAttributePath ? `${sMeasureAttributePath}DataPoint/$AnnotationPath/` : sMeasureAttributePath;\n\t},\n\t/**\n\t * Method to determine if the contained navigation property has a draft root/node parent entitySet.\n\t * @param oTargetCollectionContainsTarget Target collection has ContainsTarget property\n\t * @param oTableMetadata Table metadata for which draft support shall be checked\n\t * @param oTableMetadata.parentEntitySet\n\t * @param oTableMetadata.parentEntitySet.oModel\n\t * @param oTableMetadata.parentEntitySet.sPath\n\t * @returns Returns true if draft\n\t */\n\tisDraftParentEntityForContainment: function (\n\t\toTargetCollectionContainsTarget: object,\n\t\toTableMetadata: {\n\t\t\tparentEntitySet?: {\n\t\t\t\toModel: ODataMetaModel;\n\t\t\t\tsPath?: string;\n\t\t\t};\n\t\t}\n\t): boolean {\n\t\tif (oTargetCollectionContainsTarget) {\n\t\t\tif (oTableMetadata && oTableMetadata.parentEntitySet && oTableMetadata.parentEntitySet.sPath) {\n\t\t\t\tconst sParentEntitySetPath = oTableMetadata.parentEntitySet.sPath;\n\t\t\t\tconst oDraftRoot = oTableMetadata.parentEntitySet.oModel.getObject(\n\t\t\t\t\t`${sParentEntitySetPath}@com.sap.vocabularies.Common.v1.DraftRoot`\n\t\t\t\t);\n\t\t\t\tconst oDraftNode = oTableMetadata.parentEntitySet.oModel.getObject(\n\t\t\t\t\t`${sParentEntitySetPath}@com.sap.vocabularies.Common.v1.DraftNode`\n\t\t\t\t);\n\t\t\t\tif (oDraftRoot || oDraftNode) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\t/**\n\t * Ensures the data is processed as defined in the template.\n\t * Since the property Data is of the type 'object', it may not be in the same order as required by the template.\n\t * @param dataElement The data that is currently being processed.\n\t * @returns The correct path according to the template.\n\t */\n\tgetDataFromTemplate: function (dataElement: Context): string {\n\t\tconst splitPath = dataElement.getPath().split(\"/\");\n\t\tconst dataKey = splitPath[splitPath.length - 1];\n\t\tconst connectedDataPath = `/${splitPath.slice(1, -2).join(\"/\")}/@`;\n\t\tconst connectedObject = dataElement.getObject(connectedDataPath);\n\t\tconst template = connectedObject.Template;\n\t\tconst splitTemp = template.split(\"}\");\n\t\tconst tempArray = [];\n\t\tfor (let i = 0; i < splitTemp.length - 1; i++) {\n\t\t\tconst key = splitTemp[i].split(\"{\")[1].trim();\n\t\t\ttempArray.push(key);\n\t\t}\n\t\tObject.keys(connectedObject.Data).forEach(function (sKey: string) {\n\t\t\tif (sKey.startsWith(\"$\")) {\n\t\t\t\tdelete connectedObject.Data[sKey];\n\t\t\t}\n\t\t});\n\t\tconst index = Object.keys(connectedObject.Data).indexOf(dataKey);\n\t\treturn `/${splitPath.slice(1, -2).join(\"/\")}/Data/${tempArray[index]}`;\n\t},\n\n\t/**\n\t * Checks if the end of the template has been reached.\n\t * @param target The target of the connected fields.\n\t * @param target.Template\n\t * @param target.Data\n\t * @param element The element that is currently being processed.\n\t * @returns True or False (depending on the template index).\n\t */\n\tnotLastIndex: function (target: { Template: string; Data: Record<string, unknown> }, element: object): boolean {\n\t\tconst template = target.Template;\n\t\tconst splitTemp = template.split(\"}\");\n\t\tconst tempArray: string[] = [];\n\t\tlet isLastIndex = false;\n\t\tfor (let i = 0; i < splitTemp.length - 1; i++) {\n\t\t\tconst dataKey = splitTemp[i].split(\"{\")[1].trim();\n\t\t\ttempArray.push(dataKey);\n\t\t}\n\n\t\ttempArray.forEach(function (templateInfo: string) {\n\t\t\tconst lastIndex = tempArray.length - 1;\n\t\t\tif (target.Data[templateInfo] === element && tempArray.indexOf(templateInfo) < lastIndex) {\n\t\t\t\tisLastIndex = true;\n\t\t\t}\n\t\t});\n\t\treturn isLastIndex;\n\t},\n\n\t/**\n\t * Determines the delimiter from the template.\n\t * @param template The template string.\n\t * @returns The delimiter in the template string.\n\t */\n\tgetDelimiter: function (template: string): string {\n\t\treturn template.split(\"}\")[1].split(\"{\")[0].trim();\n\t},\n\n\toMetaModel: undefined as ODataMetaModel | undefined,\n\tsetMetaModel: function (oMetaModel: ODataMetaModel): void {\n\t\tthis.oMetaModel = oMetaModel;\n\t},\n\n\tgetMetaModel: function (): ODataMetaModel {\n\t\treturn this.oMetaModel!;\n\t},\n\n\tgetParameters: function (sPath: string, metaModel?: ODataMetaModel): string[] {\n\t\tif (metaModel) {\n\t\t\tconst oParameterInfo = CommonUtils.getParameterInfo(metaModel, sPath);\n\t\t\tif (oParameterInfo.parameterProperties) {\n\t\t\t\treturn Object.keys(oParameterInfo.parameterProperties);\n\t\t\t}\n\t\t}\n\t\treturn [];\n\t},\n\n\t/**\n\t * Build an expression calling an action handler via the FPM helper's actionWrapper function\n\t *\n\t * This function assumes that the 'FPM.actionWrapper()' function is available at runtime.\n\t * @param oAction Action metadata\n\t * @param oAction.handlerModule Module containing the action handler method\n\t * @param oAction.handlerMethod Action handler method name\n\t * @param [oThis] `this` (if the function is called from a macro)\n\t * @param oThis.id The table's ID\n\t * @param forContextMenu Indicates if the action appears in the context menu. If false, the action appears in the table toolbar\n\t * @returns The action wrapper binding\texpression\n\t */\n\tbuildActionWrapper: function (\n\t\toAction: CustomAction,\n\t\toThis: { id?: string } | undefined,\n\t\tforContextMenu = false\n\t): CompiledBindingToolkitExpression {\n\t\tconst aParams: unknown[] = [ref(\"$event\"), oAction.handlerModule, oAction.handlerMethod];\n\n\t\tif (oThis && oThis.id) {\n\t\t\tconst internalModelPath = !forContextMenu ? \"${internal>selectedContexts}\" : \"${internal>contextmenu/selectedContexts}\";\n\t\t\tconst oAdditionalParams = { contexts: ref(internalModelPath) };\n\t\t\taParams.push(oAdditionalParams);\n\t\t}\n\t\treturn compileExpression(fn(\"FPM.actionWrapper\", aParams));\n\t},\n\t/**\n\t * Returns the value whether or not the element should be visible depending on the Hidden annotation.\n\t * It is inverted as the UI elements have a visible property instead of a hidden one.\n\t * @param dataFieldAnnotations The dataField object\n\t * @returns A path or a Boolean\n\t */\n\tgetHiddenPathExpression: function (dataFieldAnnotations: Record<string, { $Path?: string }>): string | boolean {\n\t\tif (dataFieldAnnotations[\"@com.sap.vocabularies.UI.v1.Hidden\"] !== null) {\n\t\t\tconst hidden = dataFieldAnnotations[\"@com.sap.vocabularies.UI.v1.Hidden\"];\n\t\t\treturn typeof hidden === \"object\" ? \"{= !${\" + hidden.$Path + \"} }\" : !hidden;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t * Method to fetch the correct operators based on the filter restrictions that can be annotated on an entity set or a navigation property.\n\t * We return the correct operators based on the specified restriction and also check for the operators defined in the manifest to include or exclude them.\n\t * @param sProperty String name of the property\n\t * @param sEntitySetPath String path to the entity set\n\t * @param oContext Context used during templating\n\t * @param sType String data type od the property, for example edm.Date\n\t * @param bUseSemanticDateRange Boolean passed from the manifest for semantic date range\n\t * @param settings Stringified object of the property settings or property settings as a whole\n\t * @returns An array of strings representing operators for filtering\n\t */\n\tgetOperatorsForProperty: function (\n\t\tsProperty: string,\n\t\tsEntitySetPath: string,\n\t\toContext: ODataMetaModel,\n\t\tsType?: string,\n\t\tbUseSemanticDateRange?: boolean | string,\n\t\tsettings?: FilterSettings | string\n\t): string[] {\n\t\tconst oFilterRestrictions = CommonUtils.getFilterRestrictionsByPath(sEntitySetPath, oContext);\n\t\tconst aEqualsOps = [\"EQ\"];\n\t\tconst aSingleRangeOps = [\"EQ\", \"GE\", \"LE\", \"LT\", \"GT\", \"BT\", \"NE\", \"NOTBT\", \"NOTLE\", \"NOTLT\", \"NOTGE\", \"NOTGT\"];\n\t\tconst aSingleRangeDTBasicOps = [\"EQ\", \"BT\"];\n\t\tconst aMultiRangeOps = [\"EQ\", \"GE\", \"LE\", \"LT\", \"GT\", \"BT\", \"NE\", \"NOTBT\", \"NOTLE\", \"NOTLT\", \"NOTGE\", \"NOTGT\"];\n\t\tconst aSearchExpressionOps = [\"Contains\", \"NotContains\", \"StartsWith\", \"NotStartsWith\", \"EndsWith\", \"NotEndsWith\"];\n\t\tconst aBasicSemanticDateOps = SemanticDateOperators.getBasicSemanticDateOperations();\n\t\tconst bSemanticDateRange = bUseSemanticDateRange === \"true\" || bUseSemanticDateRange === true;\n\t\tlet aSemanticDateOps: string[] = [];\n\t\tconst oSettings = settings && typeof settings === \"string\" ? JSON.parse(settings).customData : settings;\n\n\t\t// Initialize Empty/NotEmpty operators based on field type and manifest settings\n\t\tconst emptyOps = _getEmptyOps(sType || \"\", oSettings);\n\n\t\tif ((oContext.getObject(`${sEntitySetPath}/@com.sap.vocabularies.Common.v1.ResultContext`) as unknown) === true) {\n\t\t\treturn aEqualsOps;\n\t\t}\n\n\t\tif (oSettings && oSettings.operatorConfiguration && oSettings.operatorConfiguration.length > 0) {\n\t\t\taSemanticDateOps = SemanticDateOperators.getFilterOperations(oSettings.operatorConfiguration, sType);\n\t\t} else {\n\t\t\taSemanticDateOps = DefaultSemanticDateOperators.getSemanticDateOperations(sType);\n\t\t}\n\t\t// Get the default Operators for this Property Type\n\t\tconst aDefaultOperators = _getDefaultOperators(sType);\n\t\tlet supportedOperators = aDefaultOperators;\n\t\tif (bSemanticDateRange) {\n\t\t\tconst extendedSemanticDateOperators = ExtendedSemanticDateOperators.getSemanticDateOperations();\n\t\t\tsupportedOperators = [...aBasicSemanticDateOps, ...aDefaultOperators, ...extendedSemanticDateOperators];\n\t\t}\n\n\t\tlet restrictions: string[] = [];\n\n\t\t// Is there a Filter Restriction defined for this property?\n\t\tif (\n\t\t\toFilterRestrictions &&\n\t\t\toFilterRestrictions.FilterAllowedExpressions &&\n\t\t\toFilterRestrictions.FilterAllowedExpressions[sProperty]\n\t\t) {\n\t\t\t// Extending the default operators list with Semantic Date options DATERANGE, DATE, FROM and TO\n\t\t\tconst sAllowedExpression = CommonUtils.getSpecificAllowedExpression(oFilterRestrictions.FilterAllowedExpressions[sProperty]);\n\t\t\t// In case more than one Allowed Expressions has been defined for a property\n\t\t\t// choose the most restrictive Allowed Expression\n\n\t\t\t// MultiValue has same Operator as SingleValue, but there can be more than one (maxConditions)\n\t\t\tswitch (sAllowedExpression) {\n\t\t\t\tcase \"SingleValue\":\n\t\t\t\t\tconst singleValueDateOps = DefaultSemanticDateOperators.getSingleValueDateOperations();\n\t\t\t\t\tlet aSingleValueOps: string[];\n\t\t\t\t\tif (sType === \"Edm.Date\" && bSemanticDateRange) {\n\t\t\t\t\t\taSingleValueOps = [...singleValueDateOps, ...emptyOps];\n\t\t\t\t\t} else if (sType === \"Edm.Date\" || sType === \"Edm.DateTimeOffset\") {\n\t\t\t\t\t\taSingleValueOps = [...aEqualsOps, ...emptyOps]; // [\"EQ\", \"Empty\", \"NotEmpty\"]\n\t\t\t\t\t} else {\n\t\t\t\t\t\taSingleValueOps = aEqualsOps; // [\"EQ\"]\n\t\t\t\t\t}\n\t\t\t\t\trestrictions = _getRestrictions(supportedOperators, aSingleValueOps);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"MultiValue\":\n\t\t\t\t\tconst multiValueOperators = [...aEqualsOps, \"Empty\", \"NotEmpty\"];\n\t\t\t\t\trestrictions = _getRestrictions(supportedOperators, multiValueOperators);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SingleRange\":\n\t\t\t\t\tlet aExpressionOps: string[];\n\t\t\t\t\tif (bSemanticDateRange && (sType === \"Edm.Date\" || sType === \"Edm.DateTimeOffset\")) {\n\t\t\t\t\t\t// Only Edm.Date and Edm.DateTimeOffset get semantic operators\n\t\t\t\t\t\taExpressionOps = [...aSemanticDateOps, ...emptyOps];\n\t\t\t\t\t} else if (sType === \"Edm.DateTimeOffset\") {\n\t\t\t\t\t\taExpressionOps = [...aSingleRangeDTBasicOps, ...emptyOps];\n\t\t\t\t\t} else if (sType === \"Edm.Date\") {\n\t\t\t\t\t\taExpressionOps = [...aSingleRangeOps, ...emptyOps];\n\t\t\t\t\t} else {\n\t\t\t\t\t\taExpressionOps = aSingleRangeOps;\n\t\t\t\t\t}\n\t\t\t\t\trestrictions = _getRestrictions(supportedOperators, aExpressionOps);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"MultiRange\":\n\t\t\t\t\tconst multiRangeOps =\n\t\t\t\t\t\tsType === \"Edm.Date\" || sType === \"Edm.DateTimeOffset\" ? [...aMultiRangeOps, ...emptyOps] : aMultiRangeOps;\n\t\t\t\t\trestrictions = _getRestrictions(supportedOperators, multiRangeOps);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"SearchExpression\":\n\t\t\t\t\trestrictions = _getRestrictions(supportedOperators, aSearchExpressionOps);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"MultiRangeOrSearchExpression\":\n\t\t\t\t\trestrictions = _getRestrictions(supportedOperators, aSearchExpressionOps.concat(aMultiRangeOps));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// In case AllowedExpressions is not recognised, undefined in return results in the default set of\n\t\t\t// operators for the type.\n\t\t}\n\t\treturn restrictions;\n\t},\n\tgetOperatorsForDateProperty: function (propertyType: string): string[] {\n\t\t// In case AllowedExpressions is not provided for type Edm.Date then all the default\n\t\t// operators for the type should be returned excluding semantic operators from the list.\n\t\tconst aDefaultOperators = _getDefaultOperators(propertyType);\n\t\tconst aMultiRangeOps = [\"EQ\", \"GE\", \"LE\", \"LT\", \"GT\", \"BT\", \"NE\", \"NOTBT\", \"NOTLE\", \"NOTLT\", \"NOTGE\", \"NOTGT\", \"Empty\", \"NotEmpty\"];\n\t\treturn _getRestrictions(aDefaultOperators, aMultiRangeOps);\n\t},\n\tgetAIIcon: function (): string {\n\t\treturn aiIcon;\n\t}\n};\n(CommonHelper.getSortConditions as { requiresIContext?: boolean }).requiresIContext = true;\n\nexport default CommonHelper;\n"],"mappings":"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","ignoreList":[]}