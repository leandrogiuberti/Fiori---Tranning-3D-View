{"version":3,"file":"FilterFieldHelper.js","names":["isRequiredInFilter","path","annotationInterface","model","context","getModel","propertyPath","getPath","propertyLocationPath","CommonHelper","getLocationForPropertyPath","property","required","getObject","oFR","CommonUtils","getFilterRestrictionsByPath","RequiredProperties","includes","_exports","maxConditions","max","filterRestrictions","propertyInfo","$Type","FilterAllowedExpressions","allowedExpression","getSpecificAllowedExpression","getConditionsBinding","dataModelObjectPath","relativePropertyPath","getContextRelativeTargetObjectPath","compileExpression","pathInModel","constraints","value","AnnotationHelper","format","matches","match","propertyConstraints","JSTokenizer","parseJS","V4","nullable","Object","keys","length","undefined","JSON","stringify","replaceAll","formatOptions","hasOwnProperty","$Nullable","arguments","parseKeepsEmptyString","fiscalType","getFiscalType","getProperty","getDataType","type","typeMapping","EDM_TYPE_MAPPING","getPlaceholder","FiscalDate","getPattern"],"sources":["./FilterFieldHelper.ts"],"sourcesContent":["import type { Property } from \"@sap-ux/vocabularies-types\";\nimport JSTokenizer from \"sap/base/util/JSTokenizer\";\nimport type { CompiledBindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport { compileExpression, EDM_TYPE_MAPPING, getFiscalType, pathInModel } from \"sap/fe/base/BindingToolkit\";\nimport CommonUtils from \"sap/fe/core/CommonUtils\";\nimport type { DataModelObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport { getContextRelativeTargetObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport { getProperty } from \"sap/fe/core/templating/PropertyFormatters\";\nimport type { ComputedAnnotationInterface, MetaModelContext } from \"sap/fe/core/templating/UIFormatters\";\nimport FiscalDate from \"sap/fe/core/type/FiscalDate\";\nimport CommonHelper from \"sap/fe/macros/CommonHelper\";\nimport AnnotationHelper from \"sap/ui/model/odata/v4/AnnotationHelper\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\n\n/**\n * Checks whether the property with the given path is required in the filter for the given annotation interface.\n * @param path Property path - ignored when provided as string\n * @param annotationInterface Structure returned by the ODataMetaModel when using the @@ operator in XML templates\n * @returns The value true if the given input is requird for filtering\n */\nexport function isRequiredInFilter(path: string | unknown, annotationInterface: ComputedAnnotationInterface): boolean {\n\tconst model = annotationInterface.context.getModel() as ODataMetaModel;\n\tconst propertyPath = annotationInterface.context.getPath();\n\tconst propertyLocationPath = CommonHelper.getLocationForPropertyPath(model, propertyPath);\n\n\tlet property: string;\n\tlet required = model.getObject(`${propertyLocationPath}/@com.sap.vocabularies.Common.v1.ResultContext`);\n\n\tif (!required) {\n\t\tif (typeof path === \"string\") {\n\t\t\tproperty = path;\n\t\t} else {\n\t\t\tproperty = model.getObject(`${propertyPath}@sapui.name`);\n\t\t}\n\t\tconst oFR = CommonUtils.getFilterRestrictionsByPath(propertyLocationPath, model);\n\t\trequired = oFR?.RequiredProperties?.includes(property);\n\t}\n\treturn required;\n}\n\n/**\n * Checks the maximum number of conditions for the given path and given annotation interface.\n * @param path Property path - ignored when provided as string\n * @param annotationInterface Structure returned by the ODataMetaModel when using the @@ operator in XML templates\n * @returns The number of maximum allowed conditions or -1 if there is no limit.\n */\nexport function maxConditions(path: string | unknown, annotationInterface: ComputedAnnotationInterface): number {\n\tconst model = annotationInterface.context.getModel() as ODataMetaModel;\n\tconst propertyPath = annotationInterface.context.getPath();\n\tconst propertyLocationPath = CommonHelper.getLocationForPropertyPath(model, propertyPath);\n\n\tlet property: string;\n\tlet max = -1;\n\n\tif (model.getObject(`${propertyLocationPath}/@com.sap.vocabularies.Common.v1.ResultContext`) === true) {\n\t\treturn 1;\n\t}\n\n\tif (typeof path === \"string\") {\n\t\tproperty = path;\n\t} else {\n\t\tproperty = model.getObject(`${propertyPath}@sapui.name`);\n\t}\n\tconst filterRestrictions = CommonUtils.getFilterRestrictionsByPath(propertyLocationPath, model);\n\tlet propertyInfo = model.getObject(`${propertyLocationPath}/${property}`);\n\tif (!propertyInfo) {\n\t\tpropertyInfo = model.getObject(propertyPath);\n\t}\n\tif (propertyInfo.$Type === \"Edm.Boolean\") {\n\t\tmax = 1;\n\t} else if (filterRestrictions?.FilterAllowedExpressions?.[property]) {\n\t\tconst allowedExpression = CommonUtils.getSpecificAllowedExpression(filterRestrictions.FilterAllowedExpressions[property]);\n\t\tif (allowedExpression === \"SingleValue\" || allowedExpression === \"SingleRange\") {\n\t\t\tmax = 1;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * To Create binding for mdc:filterfield conditions.\n * @param dataModelObjectPath Data Model Object path to filter field property\n * @returns Expression binding for conditions for the field\n */\nexport function getConditionsBinding(dataModelObjectPath: DataModelObjectPath<Property>): CompiledBindingToolkitExpression {\n\tconst relativePropertyPath = getContextRelativeTargetObjectPath(dataModelObjectPath, false, true);\n\treturn compileExpression(pathInModel(`/conditions/${relativePropertyPath}`, \"$filters\"));\n}\n\n/**\n * Get the contraints string for the given property and interface.\n * @param context\n * @param annotationInterface Structure returned by the ODataMetaModel when using the @@ operator in XML templates\n * @returns Constraints as string if available otherwise undefined\n */\nexport function constraints(context: MetaModelContext, annotationInterface: ComputedAnnotationInterface): string | undefined {\n\tconst value = (AnnotationHelper.format(context, annotationInterface) as string) || \"\";\n\tconst matches = value.match(/constraints:.*?({.*?})/);\n\tconst propertyConstraints = JSTokenizer.parseJS(matches?.[1] || \"{}\");\n\t// Workaround. Add \"V4: true\" to DateTimeOffset constraints. AnnotationHelper is not aware of this flag.\n\tif (value.includes(\"sap.ui.model.odata.type.DateTimeOffset\")) {\n\t\t// Ensure that V4:true is  there. With the openUI5 BLI: CPOUI5ODATAV4-2131 the constraints are already include 'V4':true\n\t\tpropertyConstraints.V4 = true;\n\t}\n\t// Remove {nullable:false} from the constraints as it prevents from having an empty filter field\n\t// in the case of a single-value filter\n\tif (propertyConstraints.nullable === false) {\n\t\tdelete propertyConstraints.nullable;\n\t}\n\t// Unfortunately, JSTokenizer does not provide a method to stringify (reversing parseJS).\n\t// Using JSON.stringify and replacing double quotes with single quotes works at least in the known simple cases (flat objects not containing quotes in property names or values).\n\t// If special cases should occur in future, this might need some adoption (depending on the required string format in that case).\n\treturn Object.keys(propertyConstraints).length === 0 ? undefined : JSON.stringify(propertyConstraints).replaceAll('\"', \"'\");\n}\n\n/**\n * Get the format options as string for the given path and given annotation interface.\n * @param context\n * @param annotationInterface Structure returned by the ODataMetaModel when using the @@ operator in XML templates\n * @returns Format options as string if available otherwise undefined\n */\nexport function formatOptions(context: MetaModelContext, annotationInterface: ComputedAnnotationInterface): string | undefined {\n\t// as the Annotation helper always returns \"parseKeepsEmptyString: true\" we need to prevent this in case a property (of type string) is nullable\n\t// Filling annotationInterface.arguments with an array where the first parameter is null, and the second contains the \"expected\"\n\t// parseKeepsEmptyString value follows a proposal from the model colleagues to \"overrule\" the behavior of the AnnotationHelper\n\tif (context.$Type === \"Edm.String\") {\n\t\tif (!context.hasOwnProperty(\"$Nullable\") || context.$Nullable === true) {\n\t\t\tannotationInterface.arguments = [null, { parseKeepsEmptyString: false }];\n\t\t}\n\t\tconst fiscalType = getFiscalType(getProperty(context, annotationInterface));\n\t\tif (fiscalType) {\n\t\t\tif (!annotationInterface.arguments) {\n\t\t\t\tannotationInterface.arguments = [null, {}];\n\t\t\t}\n\t\t\t(annotationInterface.arguments[1] as { fiscalType?: string }).fiscalType = fiscalType;\n\t\t}\n\t}\n\tconst value = (AnnotationHelper.format(context, annotationInterface) as string) || \"\";\n\treturn value.match(/formatOptions:.*?({.*?})/)?.[1] || undefined;\n}\n\n/**\n * Get the data type for a given property.\n * @param property Property information\n * @returns Type as string\n */\nexport function getDataType(property: Property): string {\n\tif (property.type === \"Edm.String\") {\n\t\tconst fiscalType = getFiscalType(property);\n\t\tif (fiscalType) {\n\t\t\treturn \"sap.fe.core.type.FiscalDate\";\n\t\t}\n\t}\n\tconst typeMapping = EDM_TYPE_MAPPING[property.type];\n\treturn typeMapping ? typeMapping.type : property.type;\n}\n\n/**\n * Get the placeholder of properties of type Edm.String.\n * @param property Property information\n * @returns Placeholder as string if available otherwise undefined\n */\nexport function getPlaceholder(property: Property): string | undefined {\n\tif (property.type === \"Edm.String\") {\n\t\tconst fiscalType = getFiscalType(property);\n\t\tif (fiscalType) {\n\t\t\treturn new FiscalDate({ fiscalType }, {}).getPattern();\n\t\t}\n\t}\n\treturn undefined;\n}\n"],"mappings":"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","ignoreList":[]}