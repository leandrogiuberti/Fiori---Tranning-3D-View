{"version":3,"file":"FilterUtils.js","names":["PropertyInfoKeys","CONDITION_PATH_TO_PROPERTY_PATH_REGEX","oFilterUtils","getFilter","vIFilter","aFilters","getFilterInfo","filters","length","Filter","undefined","getFilterField","propertyPath","converterContext","entityType","FilterBarConverter","buildProperyInfo","propertyInfoField","oPropertyInfo","aTypeConfig","propertyConvertyContext","getConverterContextFor","annotationPath","propertyTargetObject","getDataModelObjectPath","targetObject","oTypeConfig","fetchTypeConfig","fetchPropertyInfo","key","assignDataTypeToPropertyInfo","createConverterContext","oFilterControl","sEntityTypePath","metaModel","appComponent","sFilterEntityTypePath","DelegateUtil","getCustomData","contextPath","oView","isA","CommonUtils","getTargetView","oMetaModel","getModel","getMetaModel","oAppComponent","getAppComponent","oVisualizationObjectPath","MetaModelConverter","getInvolvedDataModelObjects","createBindingContext","manifestSettings","getViewData","ConverterContext","createConverterContextForMacro","startingEntitySet","name","getDiagnostics","merge","contextLocation","ManifestWrapper","getConvertedFilterFields","includeHidden","oModifier","lineItemTerm","this","_getFilterMetaModel","lrTables","_getFieldsForTable","oConverterContext","_getSelectionFields","getBindingPathForParameters","oIFilter","mConditions","aFilterPropertiesMetadata","aParameters","aParams","setTypeConfigToProperties","sFieldPath","oConditionInternal","oProperty","FilterUtil","getPropertyByKey","typeConfig","TypeMap","getTypeConfig","dataType","formatOptions","constraints","mInternalParameterCondition","ConditionConverter","toType","getTypeMap","sEdmType","ODATA_TYPE_MAPPING","className","push","encodeURIComponent","ODataUtils","formatLiteral","values","data","sEntitySetPath","substring","sParameterEntitySet","slice","lastIndexOf","sTargetNavigation","toString","getEditStateIsHideDraft","bIsHideDraft","$editState","oCondition","find","condition","operator","includes","mProperties","mFilterConditions","aIgnoreProperties","ignoredProperties","oTargetControl","targetControl","sTargetEntityPath","mParameters","sSearch","sBindingPath","aPropertiesMetadata","propertiesMetadata","Element","getElementById","_getSearchField","_getFilterConditions","getFilterPropertyInfo","getPropertyInfoSet","_getFilterPropertiesMetadata","Object","keys","forEach","sKey","JSON","parse","param","requiredParam","mParametersValue","aTargetPropertiesMetadata","getControlDelegate","fetchPropertiesForEntity","_aIgnoreProperties","_getIgnoredProperties","concat","getEditStateAndFilter","parameters","search","bindingPath","_ref","oFilter","hasEditStateMetadata","filter","property","editStateFilter","hasOwnProperty","editStateValue","EDITSTATE","getFilterForEditState","view","isHiddenDraftEnabled","getEnvironmentCapabilities","getCapabilities","HiddenDraft","enabled","getProperty","_transformDateTimeOffsetFilters","hasEditStateFilter","hasEditStateFilterRecursively","exchangeEditStateFilterRecursively","and","oFilterBar","Array","isArray","actualFilters","firstFilter","oPropertyHelper","getPropertyHelper","dateTimeOffsetPaths","Set","sConditionPath","propertyInfo","isDateTimeOffset","typeInstance","getName","precision","add","_transformDateTimeOffSetFilterValueRecursively","i","filterWithNestedFilters","filterPath","getPath","filterOperator","getOperator","filterValue1","getValue1","Log","warning","has","transformedFilter","_transformDateTimeOffSetFilterValue","nestedFilter","getCondition","nestedFilterWithMultipleConditions","hasTransformation","j","subFilter","subFilterWithNesting","subFilterPath","subFilterOperator","subFilterValue1","matchingConditionPath","from","pathParts","split","navigationPart","replace","propertyPart","Boolean","endsWith","transformedSubFilter","path","variable","getVariable","bAnd","nestedFilterPath","nestedFilterOperator","nestedFilterValue1","transformedNestedFilter","originalValue","dateTimeMatch","match","dateTimePart","timezone","startValue","endValue","FilterOperator","BT","value1","value2","some","getFilters","map","isAnd","aProperties","oIFilterProperty","getConstraints","Function","getNotApplicableFilters","oControl","sTargetEntityTypePath","oFilterBarEntityPath","oFilterBarEntitySetAnnotations","getObject","aNotApplicable","getConditions","bIsFilterBarEntityType","bIsChart","bIsAnalyticalTable","getParent","getTableDefinition","enableAnalytics","bIsTreeTable","control","type","bEnableSearch","CommonHelper","parseCustomData","enableSearch","enableBasicSearch","aTargetProperties","mTargetProperties","reduce","mProp","oProp","mAggregatedProperties","chartEntityTypeAnnotations","oEntitySetAnnotations","mChartCustomAggregates","getAllCustomAggregates","sAggregateName","oAggregate","sProperty","aConditionProperty","typeCheck","isCustomFilter","getSearch","_getValueListInfo","filterBar","propertyName","valueListInfos","requestValueListInfo","catch","_propertyInfo","_getConditionValidated","async","valueListInfo","value","ConditionValidated","NotValidated","valueListProperties","Parameters","parameter","valueOf","$Type","LocalDataProperty","$PropertyPath","ValueListProperty","valueListPropertyPath","EQ","listBinding","$model","bindList","CollectionPath","$select","valueExists","requestContexts","Validated","error","_clearFilterValue","conditionPath","oState","StateUtil","retrieveExternalState","filtered","applyExternalState","setFilterValues","_len","arguments","args","_key","_setFilterValues","addFilterValues","_len2","_key2","getPropertyPathFromConditionPath","getFilterBarForAdaptationControl","potentialFilterBar","getDataModelObjectPathForProperty","entityTypePath","append","_len3","_key3","sOperator","vValues","SemanticDateOperators","getSemanticDateOperations","supportedValueTypes","Error","mainFilterBarControl","propertyTargetObjectPath","getContextRelativeTargetObjectPath","Condition","createCondition","Promise","all","conditionValidatedStatus","conditionToModelPath","_getEntitySetPath","ModelHelper","getEntitySetPath","tableControls","getController","_getControls","oTable","filterFields","getSelectionFields","selectionFields","propertyInfos","sPropertyInfo","getControlType","oPageContext","aFilterBarSelectionFieldsAnnotation","getEntityTypeAnnotation","annotation","mapSelectionFields","oSelectionField","oFilterBarSelectionFieldAnnotation","sPath","oFilterField","fieldNames","oField","_getSelectionFieldsFromPropertyInfos","selField","indexOf","group","groupLabel","settings","visualFilter","label","getPropertyInfo","filterPropertiesMetadata","entityProperties","ignoreProperties","filterProperty","filterPropertyName","entityPropertiesCurrent","entity","isInitialized","formatPropertyInfo","propInfo","propInfos","_formatPropertyInfo","propertyInfoForFilterBar","stringify","hiddenFilter","required","tooltip","visible","maxConditions","caseSensitive"],"sources":["./FilterUtils.ts"],"sourcesContent":["import type { EntityType,Property } from \"@sap-ux/vocabularies-types\";\nimport type { PropertyPath } from \"@sap-ux/vocabularies-types/Edm\";\nimport { CommonAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport type { SelectionFields } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport Log from \"sap/base/Log\";\nimport merge from \"sap/base/util/merge\";\nimport type AppComponent from \"sap/fe/core/AppComponent\";\nimport type { BaseTreeModifier } from \"sap/fe/core/CommonUtils\";\nimport CommonUtils from \"sap/fe/core/CommonUtils\";\nimport ConverterContext from \"sap/fe/core/converters/ConverterContext\";\nimport type { BaseManifestSettings,HiddenDraft } from \"sap/fe/core/converters/ManifestSettings\";\nimport ManifestWrapper from \"sap/fe/core/converters/ManifestWrapper\";\nimport * as MetaModelConverter from \"sap/fe/core/converters/MetaModelConverter\";\nimport type { IDiagnostics } from \"sap/fe/core/converters/TemplateConverter\";\nimport type { TableVisualization } from \"sap/fe/core/converters/controls/Common/Table\";\nimport type { PropertyTypeConfig } from \"sap/fe/core/converters/controls/Common/table/Columns\";\nimport type { FilterField,PropertyInfo,PropertyInfoExternal } from \"sap/fe/core/converters/controls/ListReport/FilterBar\";\nimport * as FilterBarConverter from \"sap/fe/core/converters/controls/ListReport/FilterBar\";\nimport { getAllCustomAggregates } from \"sap/fe/core/helpers/MetaModelFunction\";\nimport ModelHelper from \"sap/fe/core/helpers/ModelHelper\";\nimport type { DataModelObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport { getContextRelativeTargetObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport { ODATA_TYPE_MAPPING } from \"sap/fe/core/templating/DisplayModeFormatter\";\nimport CommonHelper from \"sap/fe/macros/CommonHelper\";\nimport DelegateUtil from \"sap/fe/macros/DelegateUtil\";\nimport SemanticDateOperators from \"sap/fe/macros/filterBar/SemanticDateOperators\";\nimport type { AnnotationValueListType } from \"sap/fe/macros/internal/valuehelp/ValueListHelper\";\nimport type TableAPI from \"sap/fe/macros/table/TableAPI\";\nimport type { InternalBindingInfo } from \"sap/fe/macros/table/Utils\";\nimport type ListReportController from \"sap/fe/templates/ListReport/ListReportController.controller\";\nimport type ManagedObject from \"sap/ui/base/ManagedObject\";\nimport type Control from \"sap/ui/core/Control\";\nimport Element from \"sap/ui/core/Element\";\nimport type Chart from \"sap/ui/mdc/Chart\";\nimport type FilterBar from \"sap/ui/mdc/FilterBar\";\nimport type { ConditionObject } from \"sap/ui/mdc/condition/Condition\";\nimport Condition from \"sap/ui/mdc/condition/Condition\";\nimport ConditionConverter from \"sap/ui/mdc/condition/ConditionConverter\";\nimport ConditionValidated from \"sap/ui/mdc/enums/ConditionValidated\";\nimport type { IFilter } from \"sap/ui/mdc/library\";\nimport TypeMap from \"sap/ui/mdc/odata/v4/TypeMap\";\nimport StateUtil from \"sap/ui/mdc/p13n/StateUtil\";\nimport FilterUtil from \"sap/ui/mdc/util/FilterUtil\";\nimport Filter from \"sap/ui/model/Filter\";\nimport FilterOperator from \"sap/ui/model/FilterOperator\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\nimport ODataUtils from \"sap/ui/model/odata/v4/ODataUtils\";\nimport EDITSTATE from \"../filterBar/DraftEditState\";\n\nexport type IFilterControl = Control & {\n\tgetSearch?: () => string;\n\tgetPropertyInfoSet?: () => PropertyInfo[];\n\tgetPropertyInfo?: () => PropertyInfo[];\n\tgetTypeMap: () => TypeMap;\n\tgetControlDelegate?: () => {\n\t\tfetchPropertiesForEntity: (sEntitySetPath: string, oMetaModel: ODataMetaModel, oControl: Control) => PropertyInfo[];\n\t};\n\tisInitialized?: () => boolean;\n\tgetCurrentState?: () => { items?: { key: string }[] };\n} & IFilter;\nenum PropertyInfoKeys {\n\thiddenFilter = \"hiddenFilter\",\n\trequired = \"required\",\n\tpath = \"path\",\n\ttooltip = \"tooltip\",\n\tvisible = \"visible\",\n\tmaxConditions = \"maxConditions\",\n\tformatOptions = \"formatOptions\",\n\tconstraints = \"constraints\",\n\tgroup = \"group\",\n\tgroupLabel = \"groupLabel\",\n\tcaseSensitive = \"caseSensitive\"\n}\n\nconst CONDITION_PATH_TO_PROPERTY_PATH_REGEX = /[+*]/g;\n\nconst oFilterUtils = {\n\tgetFilter: function (vIFilter: string | IFilterControl | null): Filter | undefined {\n\t\tconst aFilters = oFilterUtils.getFilterInfo(vIFilter).filters;\n\t\treturn aFilters?.length ? new Filter(aFilters, false) : undefined;\n\t},\n\tgetFilterField: function (propertyPath: string, converterContext: ConverterContext, entityType: EntityType): FilterField | undefined {\n\t\treturn FilterBarConverter.getFilterField(propertyPath, converterContext, entityType);\n\t},\n\tbuildProperyInfo: function (propertyInfoField: FilterField, converterContext: ConverterContext): PropertyInfo {\n\t\tlet oPropertyInfo;\n\t\tconst aTypeConfig: Record<string, PropertyTypeConfig> = {};\n\t\tconst propertyConvertyContext = converterContext.getConverterContextFor<Property>(propertyInfoField.annotationPath);\n\t\tconst propertyTargetObject = propertyConvertyContext.getDataModelObjectPath().targetObject;\n\t\tconst oTypeConfig = FilterBarConverter.fetchTypeConfig(propertyTargetObject);\n\t\toPropertyInfo = FilterBarConverter.fetchPropertyInfo(converterContext, propertyInfoField, oTypeConfig);\n\t\taTypeConfig[propertyInfoField.key] = oTypeConfig;\n\t\toPropertyInfo = FilterBarConverter.assignDataTypeToPropertyInfo(oPropertyInfo, converterContext, [], aTypeConfig);\n\t\treturn oPropertyInfo;\n\t},\n\tcreateConverterContext: function (\n\t\toFilterControl: IFilterControl,\n\t\tsEntityTypePath: string | undefined,\n\t\tmetaModel?: ODataMetaModel,\n\t\tappComponent?: AppComponent\n\t): ConverterContext {\n\t\tconst sFilterEntityTypePath = DelegateUtil.getCustomData<string>(oFilterControl, \"entityType\"),\n\t\t\tcontextPath = sEntityTypePath || sFilterEntityTypePath;\n\n\t\tconst oView = (oFilterControl as Partial<IFilterControl>).isA ? CommonUtils.getTargetView(oFilterControl) : null;\n\t\tconst oMetaModel = (metaModel || oFilterControl.getModel()!.getMetaModel()) as ODataMetaModel;\n\t\tconst oAppComponent = appComponent || (oView && CommonUtils.getAppComponent(oView));\n\t\tconst oVisualizationObjectPath = MetaModelConverter.getInvolvedDataModelObjects(oMetaModel.createBindingContext(contextPath!)!);\n\t\tlet manifestSettings: BaseManifestSettings | undefined;\n\t\tif (oFilterControl.isA && !oFilterControl.isA(\"sap.ui.mdc.valuehelp.FilterBar\")) {\n\t\t\tmanifestSettings = ((oView && oView.getViewData()) || {}) as BaseManifestSettings;\n\t\t}\n\t\treturn ConverterContext.createConverterContextForMacro(\n\t\t\toVisualizationObjectPath.startingEntitySet.name,\n\t\t\toMetaModel,\n\t\t\toAppComponent?.getDiagnostics() as unknown as IDiagnostics,\n\t\t\tmerge,\n\t\t\toVisualizationObjectPath.contextLocation,\n\t\t\tnew ManifestWrapper((manifestSettings ?? {}) as BaseManifestSettings)\n\t\t);\n\t},\n\tgetConvertedFilterFields: function (\n\t\toFilterControl: IFilterControl,\n\t\tsEntityTypePath: string | undefined,\n\t\tincludeHidden?: boolean,\n\t\tmetaModel?: ODataMetaModel,\n\t\tappComponent?: AppComponent,\n\t\toModifier?: BaseTreeModifier,\n\t\tlineItemTerm?: string\n\t): FilterField[] {\n\t\tconst oMetaModel = this._getFilterMetaModel(oFilterControl, metaModel);\n\t\tconst sFilterEntityTypePath = DelegateUtil.getCustomData<string>(oFilterControl, \"entityType\");\n\t\tconst annotationPath = DelegateUtil.getCustomData<string>(oFilterControl, \"annotationPath\"),\n\t\t\tcontextPath = sEntityTypePath || sFilterEntityTypePath;\n\n\t\tconst lrTables: TableVisualization[] = this._getFieldsForTable(oFilterControl, sEntityTypePath);\n\n\t\tconst oConverterContext = this.createConverterContext(oFilterControl, sEntityTypePath, metaModel ?? oMetaModel, appComponent);\n\n\t\t//aSelectionFields = FilterBarConverter.getSelectionFields(oConverterContext);\n\t\treturn this._getSelectionFields(\n\t\t\toFilterControl,\n\t\t\tsEntityTypePath,\n\t\t\tsFilterEntityTypePath!,\n\t\t\tcontextPath!,\n\t\t\tlrTables,\n\t\t\toMetaModel,\n\t\t\toConverterContext,\n\t\t\tincludeHidden,\n\t\t\toModifier,\n\t\t\tlineItemTerm,\n\t\t\tannotationPath\n\t\t);\n\t},\n\n\tgetBindingPathForParameters: function (\n\t\toIFilter: IFilterControl,\n\t\tmConditions: Record<string, ConditionObject[]>,\n\t\taFilterPropertiesMetadata: PropertyInfo[] | null,\n\t\taParameters: string[]\n\t): string {\n\t\tconst aParams: string[] = [];\n\t\taFilterPropertiesMetadata = oFilterUtils.setTypeConfigToProperties(aFilterPropertiesMetadata)!;\n\t\t// Collecting all parameter values from conditions\n\t\tfor (const sFieldPath of aParameters) {\n\t\t\tif (mConditions[sFieldPath] && mConditions[sFieldPath].length > 0) {\n\t\t\t\t// We would be using only the first condition for parameter value.\n\t\t\t\tconst oConditionInternal = merge({}, mConditions[sFieldPath][0]) as ConditionObject;\n\t\t\t\tconst oProperty = FilterUtil.getPropertyByKey(aFilterPropertiesMetadata, sFieldPath) as PropertyInfo;\n\t\t\t\tconst oTypeConfig =\n\t\t\t\t\toProperty.typeConfig || TypeMap.getTypeConfig(oProperty.dataType, oProperty.formatOptions, oProperty.constraints);\n\t\t\t\tconst mInternalParameterCondition = ConditionConverter.toType(oConditionInternal, oTypeConfig, oIFilter.getTypeMap());\n\t\t\t\tconst sEdmType = ODATA_TYPE_MAPPING[oTypeConfig.className];\n\t\t\t\taParams.push(\n\t\t\t\t\t`${sFieldPath}=${encodeURIComponent(ODataUtils.formatLiteral(mInternalParameterCondition.values[0], sEdmType))}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Binding path from EntityType\n\t\tconst sEntityTypePath = oIFilter.data(\"entityType\");\n\t\tconst sEntitySetPath = sEntityTypePath.substring(0, sEntityTypePath.length - 1);\n\t\tconst sParameterEntitySet = sEntitySetPath.slice(0, sEntitySetPath.lastIndexOf(\"/\"));\n\t\tconst sTargetNavigation = sEntitySetPath.substring(sEntitySetPath.lastIndexOf(\"/\") + 1);\n\t\t// create parameter context\n\t\treturn `${sParameterEntitySet}(${aParams.toString()})/${sTargetNavigation}`;\n\t},\n\n\tgetEditStateIsHideDraft: function (mConditions?: Record<string, ConditionObject[]>): boolean {\n\t\tlet bIsHideDraft = false;\n\t\tif (mConditions && mConditions.$editState) {\n\t\t\tconst oCondition = mConditions.$editState.find(function (condition: ConditionObject) {\n\t\t\t\treturn condition.operator === \"DRAFT_EDIT_STATE\";\n\t\t\t});\n\t\t\tif (oCondition && (oCondition.values.includes(\"ALL_HIDING_DRAFTS\") || oCondition.values.includes(\"SAVED_ONLY\"))) {\n\t\t\t\tbIsHideDraft = true;\n\t\t\t}\n\t\t}\n\t\treturn bIsHideDraft;\n\t},\n\t/**\n\t * Gets all filters that originate from the MDC FilterBar.\n\t * @param vIFilter String or object instance related to MDC_FilterBar/Table/Chart\n\t * @param mProperties Properties on filters that are to be retrieved. Available parameters:\n\t * @param mProperties.ignoredProperties Array of property names which should be not considered for filtering\n\t * @param mProperties.propertiesMetadata Array with all the property metadata. If not provided, properties will be retrieved from vIFilter.\n\t * @param mProperties.targetControl MDC_table or chart. If provided, property names which are not relevant for the target control entitySet are not considered.\n\t * @param mFilterConditions Map with externalized filter conditions.\n\t * @returns FilterBar filters and basic search\n\t * @private\n\t */\n\tgetFilterInfo: function (\n\t\tvIFilter: string | IFilterControl | null,\n\t\tmProperties?: { ignoredProperties?: string[]; propertiesMetadata?: PropertyInfo[]; targetControl?: Control },\n\t\tmFilterConditions?: Record<string, ConditionObject[]>\n\t): InternalBindingInfo {\n\t\tlet aIgnoreProperties = (mProperties && mProperties.ignoredProperties) || [];\n\t\tconst oTargetControl = mProperties && mProperties.targetControl,\n\t\t\tsTargetEntityPath = oTargetControl ? oTargetControl.data(\"entityType\") : undefined;\n\t\tconst mParameters: Record<string, string> = {};\n\t\tlet oIFilter: IFilterControl = vIFilter as IFilterControl,\n\t\t\tsSearch,\n\t\t\taFilters: Filter[] = [],\n\t\t\tsBindingPath,\n\t\t\taPropertiesMetadata = mProperties && mProperties.propertiesMetadata;\n\t\tif (typeof vIFilter === \"string\") {\n\t\t\toIFilter = Element.getElementById(vIFilter) as unknown as IFilterControl;\n\t\t}\n\t\tif (oIFilter) {\n\t\t\tsSearch = this._getSearchField(oIFilter, aIgnoreProperties);\n\t\t\tconst mConditions = this._getFilterConditions(mProperties, mFilterConditions!, oIFilter);\n\t\t\tlet aFilterPropertiesMetadata: PropertyInfo[] | null;\n\t\t\tif (oIFilter.isA<FilterBar>(\"sap.ui.mdc.FilterBar\")) {\n\t\t\t\taFilterPropertiesMetadata = this.getFilterPropertyInfo(oIFilter);\n\t\t\t} else {\n\t\t\t\taFilterPropertiesMetadata = oIFilter.getPropertyInfoSet ? oIFilter.getPropertyInfoSet() : null;\n\t\t\t}\n\t\t\taFilterPropertiesMetadata = this._getFilterPropertiesMetadata(aFilterPropertiesMetadata, oIFilter);\n\t\t\tif (mProperties && mProperties.targetControl && mProperties.targetControl.isA(\"sap.ui.mdc.Chart\")) {\n\t\t\t\tObject.keys(mConditions).forEach(function (sKey: string) {\n\t\t\t\t\tif (sKey === \"$editState\") {\n\t\t\t\t\t\tdelete mConditions[\"$editState\"];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tlet aParameters = oIFilter.data(\"parameters\") || [];\n\t\t\taParameters = typeof aParameters === \"string\" ? JSON.parse(aParameters) : aParameters;\n\t\t\tif (aParameters && aParameters.length > 0) {\n\t\t\t\t// Binding path changes in case of parameters.\n\t\t\t\tsBindingPath = oFilterUtils.getBindingPathForParameters(oIFilter, mConditions, aFilterPropertiesMetadata, aParameters);\n\t\t\t\tif (Object.keys(mConditions).length) {\n\t\t\t\t\tObject.keys(mConditions).forEach((param) => {\n\t\t\t\t\t\taParameters.forEach((requiredParam: string) => {\n\t\t\t\t\t\t\tif (param === requiredParam) {\n\t\t\t\t\t\t\t\tconst mParametersValue = mConditions[param][0].values;\n\t\t\t\t\t\t\t\tmParameters[requiredParam] = mParametersValue[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mConditions) {\n\t\t\t\t//Exclude Interface Filter properties that are not relevant for the Target control entitySet\n\t\t\t\tif (sTargetEntityPath && oIFilter.data(\"entityType\") && oIFilter.data(\"entityType\") !== sTargetEntityPath) {\n\t\t\t\t\tconst oMetaModel = oIFilter.getModel()!.getMetaModel() as ODataMetaModel;\n\t\t\t\t\tconst aTargetPropertiesMetadata = oIFilter\n\t\t\t\t\t\t.getControlDelegate?.()\n\t\t\t\t\t\t.fetchPropertiesForEntity(sTargetEntityPath, oMetaModel, oIFilter) as PropertyInfo[];\n\t\t\t\t\taPropertiesMetadata = aTargetPropertiesMetadata;\n\n\t\t\t\t\tconst _aIgnoreProperties = this._getIgnoredProperties(\n\t\t\t\t\t\taFilterPropertiesMetadata as PropertyInfo[],\n\t\t\t\t\t\taTargetPropertiesMetadata\n\t\t\t\t\t);\n\t\t\t\t\tif (_aIgnoreProperties.length > 0) {\n\t\t\t\t\t\taIgnoreProperties = aIgnoreProperties.concat(_aIgnoreProperties);\n\t\t\t\t\t}\n\t\t\t\t} else if (!aPropertiesMetadata && aFilterPropertiesMetadata) {\n\t\t\t\t\taPropertiesMetadata = aFilterPropertiesMetadata;\n\t\t\t\t}\n\t\t\t\t// var aParamKeys = [];\n\t\t\t\t// aParameters.forEach(function (oParam) {\n\t\t\t\t// \taParamKeys.push(oParam.key);\n\t\t\t\t// });\n\t\t\t\taFilters = this.getEditStateAndFilter({\n\t\t\t\t\toIFilter,\n\t\t\t\t\tmConditions,\n\t\t\t\t\taPropertiesMetadata,\n\t\t\t\t\taIgnoreProperties,\n\t\t\t\t\taParameters\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn { parameters: mParameters, filters: aFilters, search: sSearch || undefined, bindingPath: sBindingPath };\n\t},\n\t/**\n\t * Gets the Filter params taking in consideration the Editing Status field,\n\t * merges/overrides the data that's coming from FilterUtil.getFilterInfo, and,\n\t * returns a mapped data to be sent to the backend.\n\t * @param param Object\n\t * @param param.oIFilter Object FilterBar instance\n\t * @param param.mConditions Object Conditions that comes from the Filter Fields\n\t * @param param.aPropertiesMetadata Array Filter metadata\n\t * @param param.aIgnoreProperties Array of strings with the field keys which need to be ignored\n\t * @param param.aParameters Array URL params that also need to be ignore and are merged into the aIgnoreProperties\n\t * @returns FilterBar filters array\n\t */\n\tgetEditStateAndFilter: function ({\n\t\toIFilter,\n\t\tmConditions,\n\t\taPropertiesMetadata,\n\t\taIgnoreProperties,\n\t\taParameters\n\t}: {\n\t\toIFilter: IFilterControl;\n\t\tmConditions: Record<string, ConditionObject[]>;\n\t\taPropertiesMetadata: PropertyInfo[] | undefined;\n\t\taIgnoreProperties: string[];\n\t\taParameters: ConcatArray<string>;\n\t}): Filter[] {\n\t\tconst oFilter = (\n\t\t\tFilterUtil.getFilterInfo(\n\t\t\t\toIFilter,\n\t\t\t\tmConditions,\n\t\t\t\toFilterUtils.setTypeConfigToProperties(aPropertiesMetadata)!,\n\t\t\t\taIgnoreProperties.concat(aParameters)\n\t\t\t) as { filters: Filter }\n\t\t).filters;\n\t\tconst hasEditStateMetadata = aPropertiesMetadata?.filter((property) => property.name === \"$editState\");\n\t\tlet editStateFilter: Filter | undefined;\n\t\tif (!aIgnoreProperties.includes(\"$editState\") && hasEditStateMetadata && hasEditStateMetadata.length > 0) {\n\t\t\tif (mConditions.hasOwnProperty(\"$editState\")) {\n\t\t\t\tconst editStateValue = mConditions[\"$editState\"];\n\t\t\t\teditStateFilter = EDITSTATE.getFilterForEditState(editStateValue?.[0]?.values?.[0]);\n\t\t\t} else {\n\t\t\t\teditStateFilter = EDITSTATE.getFilterForEditState(\"\");\n\t\t\t}\n\t\t} else {\n\t\t\tconst view = CommonUtils.getTargetView(oIFilter);\n\t\t\tconst appComponent = CommonUtils.getAppComponent(view);\n\t\t\tconst isHiddenDraftEnabled = (appComponent.getEnvironmentCapabilities()?.getCapabilities()?.HiddenDraft as HiddenDraft)\n\t\t\t\t?.enabled;\n\t\t\tif (\n\t\t\t\tisHiddenDraftEnabled &&\n\t\t\t\toIFilter.hasOwnProperty(\"disableDraftEditStateFilter\") &&\n\t\t\t\toIFilter.getProperty(\"disableDraftEditStateFilter\")\n\t\t\t) {\n\t\t\t\teditStateFilter = EDITSTATE.getFilterForEditState(\"ALL\");\n\t\t\t}\n\t\t}\n\t\tlet aFilters = oFilter ? [oFilter] : [];\n\n\t\t//( Transform DateTimeOffset precision 7 filters\n\t\tif (oIFilter.isA<FilterBar>(\"sap.ui.mdc.FilterBar\")) {\n\t\t\tthis._transformDateTimeOffsetFilters(aFilters, mConditions, oIFilter as FilterBar);\n\t\t}\n\n\t\tif (editStateFilter) {\n\t\t\tconst hasEditStateFilter = this.hasEditStateFilterRecursively(aFilters);\n\t\t\tif (hasEditStateFilter) {\n\t\t\t\taFilters = this.exchangeEditStateFilterRecursively(editStateFilter, aFilters);\n\t\t\t} else {\n\t\t\t\taFilters = [\n\t\t\t\t\tnew Filter({\n\t\t\t\t\t\tfilters: [...aFilters, editStateFilter],\n\t\t\t\t\t\tand: true\n\t\t\t\t\t})\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\t\treturn aFilters;\n\t},\n\n\t/**\n\t * Transforms DateTimeOffset precision 7 filters by converting EQ operators to BT operators\n\t * with microsecond precision range from .0000000 to .9990000.\n\t * @param aFilters Array of filter objects to transform\n\t * @param mConditions Filter conditions from the filter bar\n\t * @param oFilterBar The filter bar instance to access property information\n\t */\n\t_transformDateTimeOffsetFilters: function (\n\t\taFilters: Filter[],\n\t\tmConditions: Record<string, ConditionObject[]>,\n\t\toFilterBar: FilterBar\n\t): void {\n\t\tif (!aFilters || !Array.isArray(aFilters) || !mConditions) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Handle nested filter structure - when multiple filters are defined,\n\t\t// they may be contained within aFilters[0].aFilters\n\t\tlet actualFilters: Filter[] = aFilters;\n\t\tconst firstFilter = aFilters[0] as Filter & { aFilters?: Filter[] };\n\t\tif (firstFilter?.aFilters && firstFilter.aFilters.length > 0) {\n\t\t\tactualFilters = firstFilter.aFilters;\n\t\t}\n\n\t\t// Get property helper to access property metadata\n\t\tconst oPropertyHelper = oFilterBar.getPropertyHelper();\n\t\tif (!oPropertyHelper) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create a set of condition paths that are DateTimeOffset precision 7\n\t\tconst dateTimeOffsetPaths: Set<string> = new Set<string>();\n\n\t\tObject.keys(mConditions).forEach(function (sConditionPath: string): void {\n\t\t\tif (mConditions[sConditionPath] && mConditions[sConditionPath].length > 0) {\n\t\t\t\t// Use the full condition path for property helper\n\t\t\t\tconst propertyInfo = oPropertyHelper.getProperty(sConditionPath) as\n\t\t\t\t\t| {\n\t\t\t\t\t\t\tdataType?: string;\n\t\t\t\t\t\t\tconstraints?: { precision?: number };\n\t\t\t\t\t\t\ttypeConfig?: {\n\t\t\t\t\t\t\t\ttypeInstance?: {\n\t\t\t\t\t\t\t\t\tconstraints?: { precision?: number };\n\t\t\t\t\t\t\t\t\tgetName(): string;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t};\n\t\t\t\t\t  }\n\t\t\t\t\t| undefined;\n\n\t\t\t\t// Check if property is DateTimeOffset with precision 7\n\t\t\t\tconst isDateTimeOffset: boolean =\n\t\t\t\t\t(propertyInfo?.dataType?.includes(\"DateTimeOffset\") ?? false) ||\n\t\t\t\t\t(propertyInfo?.typeConfig?.typeInstance?.getName().includes(\"DateTimeOffset\") ?? false);\n\t\t\t\tconst precision: number | undefined =\n\t\t\t\t\tpropertyInfo?.constraints?.precision ?? propertyInfo?.typeConfig?.typeInstance?.constraints?.precision;\n\n\t\t\t\tif (isDateTimeOffset && precision === 7) {\n\t\t\t\t\tdateTimeOffsetPaths.add(sConditionPath);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Transform filters recursively to handle all nested structures\n\t\tthis._transformDateTimeOffSetFilterValueRecursively(actualFilters, dateTimeOffsetPaths);\n\t},\n\n\t/**\n\t * Recursively transforms filters to handle all possible nested aFilters structures.\n\t * @param aFilters Array of filter objects to transform\n\t * @param dateTimeOffsetPaths Set of condition paths that are DateTimeOffset precision 7\n\t */\n\t_transformDateTimeOffSetFilterValueRecursively: function (aFilters: Filter[], dateTimeOffsetPaths: Set<string>): void {\n\t\tfor (let i = 0; i < aFilters.length; i++) {\n\t\t\tconst filter: Filter = aFilters[i];\n\n\t\t\t// Check if this filter has nested aFilters (multiple conditions for same field)\n\t\t\tconst filterWithNestedFilters = filter as Filter & { aFilters?: Filter[]; bAnd?: boolean };\n\t\t\tif (filterWithNestedFilters.aFilters && filterWithNestedFilters.aFilters.length > 0) {\n\t\t\t\t// Recursively transform nested filters for deeper nesting levels\n\t\t\t\tthis._transformDateTimeOffSetFilterValueRecursively(filterWithNestedFilters.aFilters, dateTimeOffsetPaths);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst filterPath: string | undefined = filter.getPath();\n\t\t\tconst filterOperator: FilterOperator | undefined = filter.getOperator() as FilterOperator | undefined;\n\t\t\tconst filterValue1: unknown = filter.getValue1();\n\n\t\t\t// Handle undefined filterOperator gracefully\n\t\t\tif (filterOperator === undefined) {\n\t\t\t\tLog.warning(\n\t\t\t\t\t\"FilterUtils._transformDateTimeOffsetFilters: Filter operator is undefined, skipping filter transformation\",\n\t\t\t\t\t`filterPath: ${filterPath}, filterValue1: ${filterValue1}`\n\t\t\t\t);\n\t\t\t\tcontinue; // Skip this filter and continue with next one\n\t\t\t}\n\n\t\t\tif (filterOperator === \"EQ\" && filterValue1 !== undefined && filterValue1 !== null) {\n\t\t\t\t// For direct properties - check if the path matches any condition path\n\t\t\t\tif (filterPath && dateTimeOffsetPaths.has(filterPath)) {\n\t\t\t\t\tconst transformedFilter: Filter | null = this._transformDateTimeOffSetFilterValue(filter);\n\t\t\t\t\tif (transformedFilter) {\n\t\t\t\t\t\taFilters[i] = transformedFilter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (filterOperator === \"Any\") {\n\t\t\t\tconst nestedFilter = filter.getCondition();\n\t\t\t\tif (!nestedFilter) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Check if the nested filter has multiple conditions (aFilters array)\n\t\t\t\tconst nestedFilterWithMultipleConditions = nestedFilter as Filter & { aFilters?: Filter[]; bAnd?: boolean };\n\t\t\t\tif (nestedFilterWithMultipleConditions.aFilters && nestedFilterWithMultipleConditions.aFilters.length > 0) {\n\t\t\t\t\t// Handle multiple conditions within navigation property\n\t\t\t\t\tlet hasTransformation = false;\n\n\t\t\t\t\tfor (let j = 0; j < nestedFilterWithMultipleConditions.aFilters.length; j++) {\n\t\t\t\t\t\tconst subFilter: Filter = nestedFilterWithMultipleConditions.aFilters[j];\n\n\t\t\t\t\t\t// Check for further nesting within sub-filters\n\t\t\t\t\t\tconst subFilterWithNesting = subFilter as Filter & { aFilters?: Filter[] };\n\t\t\t\t\t\tif (subFilterWithNesting.aFilters && subFilterWithNesting.aFilters.length > 0) {\n\t\t\t\t\t\t\t// Recursively handle deeper nesting levels\n\t\t\t\t\t\t\tthis._transformDateTimeOffSetFilterValueRecursively(subFilterWithNesting.aFilters, dateTimeOffsetPaths);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst subFilterPath: string | undefined = subFilter.getPath();\n\t\t\t\t\t\tconst subFilterOperator: FilterOperator | undefined = subFilter.getOperator() as FilterOperator | undefined;\n\t\t\t\t\t\tconst subFilterValue1: unknown = subFilter.getValue1();\n\n\t\t\t\t\t\t// Handle undefined subFilterOperator gracefully\n\t\t\t\t\t\tif (subFilterOperator === undefined) {\n\t\t\t\t\t\t\tLog.warning(\n\t\t\t\t\t\t\t\t\"FilterUtils._transformDateTimeOffsetFilters: Filter operator is undefined, skipping filter transformation\",\n\t\t\t\t\t\t\t\t`filterPath: ${subFilterPath}, filterValue1: ${subFilterValue1}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue; // Skip this sub-filter\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (subFilterOperator === \"EQ\" && subFilterValue1 !== undefined && subFilterValue1 !== null) {\n\t\t\t\t\t\t\t// Check if any condition path matches the navigation pattern\n\t\t\t\t\t\t\tconst matchingConditionPath: string | undefined = Array.from(dateTimeOffsetPaths).find(function (\n\t\t\t\t\t\t\t\tsConditionPath: string\n\t\t\t\t\t\t\t): boolean {\n\t\t\t\t\t\t\t\t// Extract navigation and property parts from condition path\n\t\t\t\t\t\t\t\tconst pathParts: string[] = sConditionPath.split(\"/\");\n\t\t\t\t\t\t\t\tif (pathParts.length === 2) {\n\t\t\t\t\t\t\t\t\tconst navigationPart: string = pathParts[0].replace(\"*\", \"\"); // \"_Item*\" -> \"_Item\"\n\t\t\t\t\t\t\t\t\tconst propertyPart: string = pathParts[1]; // \"BillingDocumentDate\"\n\n\t\t\t\t\t\t\t\t\t// Check if filter navigation matches and sub filter ends with property\n\t\t\t\t\t\t\t\t\treturn filterPath === navigationPart && Boolean(subFilterPath?.endsWith(propertyPart));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tif (matchingConditionPath) {\n\t\t\t\t\t\t\t\tconst transformedSubFilter: Filter | null = this._transformDateTimeOffSetFilterValue(subFilter);\n\t\t\t\t\t\t\t\tif (transformedSubFilter) {\n\t\t\t\t\t\t\t\t\tnestedFilterWithMultipleConditions.aFilters[j] = transformedSubFilter;\n\t\t\t\t\t\t\t\t\thasTransformation = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// If any transformation occurred, recreate the Any filter with updated nested conditions\n\t\t\t\t\tif (hasTransformation) {\n\t\t\t\t\t\taFilters[i] = new Filter({\n\t\t\t\t\t\t\tpath: filterPath,\n\t\t\t\t\t\t\toperator: \"Any\",\n\t\t\t\t\t\t\tvariable: filter.getVariable(),\n\t\t\t\t\t\t\tcondition: new Filter({\n\t\t\t\t\t\t\t\tfilters: nestedFilterWithMultipleConditions.aFilters,\n\t\t\t\t\t\t\t\tand: nestedFilterWithMultipleConditions.bAnd ?? true\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Handle single condition within navigation property\n\t\t\t\t\tconst nestedFilterPath: string | undefined = nestedFilter.getPath();\n\t\t\t\t\tconst nestedFilterOperator: FilterOperator | undefined = nestedFilter.getOperator() as FilterOperator | undefined;\n\n\t\t\t\t\tconst nestedFilterValue1: unknown = nestedFilter.getValue1();\n\n\t\t\t\t\t// Handle undefined nestedFilterOperator gracefully\n\n\t\t\t\t\tif (nestedFilterOperator === undefined) {\n\t\t\t\t\t\tLog.warning(\n\t\t\t\t\t\t\t\"FilterUtils._transformDateTimeOffsetFilters: Filter operator is undefined, skipping filter transformation\",\n\t\t\t\t\t\t\t`filterPath: ${nestedFilterPath}, filterValue1: ${nestedFilterValue1}`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontinue; // Skip this nested filter\n\t\t\t\t\t}\n\n\t\t\t\t\tif (nestedFilterOperator === \"EQ\" && nestedFilterValue1 !== undefined && nestedFilterValue1 !== null) {\n\t\t\t\t\t\t// Check if any condition path matches the navigation pattern\n\t\t\t\t\t\tconst matchingConditionPath: string | undefined = Array.from(dateTimeOffsetPaths).find(function (\n\t\t\t\t\t\t\tsConditionPath: string\n\t\t\t\t\t\t): boolean {\n\t\t\t\t\t\t\t// Extract navigation and property parts from condition path\n\t\t\t\t\t\t\tconst pathParts: string[] = sConditionPath.split(\"/\");\n\t\t\t\t\t\t\tif (pathParts.length === 2) {\n\t\t\t\t\t\t\t\tconst navigationPart: string = pathParts[0].replace(\"*\", \"\"); // \"_Item*\" -> \"_Item\"\n\t\t\t\t\t\t\t\tconst propertyPart: string = pathParts[1]; // \"RequestedDeliveryDate\"\n\n\t\t\t\t\t\t\t\t// Check if filter navigation matches and nested filter ends with property\n\t\t\t\t\t\t\t\treturn filterPath === navigationPart && Boolean(nestedFilterPath?.endsWith(propertyPart));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (matchingConditionPath) {\n\t\t\t\t\t\t\tconst transformedNestedFilter: Filter | null = this._transformDateTimeOffSetFilterValue(nestedFilter);\n\t\t\t\t\t\t\tif (transformedNestedFilter) {\n\t\t\t\t\t\t\t\t// Create new Any filter with transformed nested filter\n\t\t\t\t\t\t\t\taFilters[i] = new Filter({\n\t\t\t\t\t\t\t\t\tpath: filterPath,\n\t\t\t\t\t\t\t\t\toperator: \"Any\",\n\t\t\t\t\t\t\t\t\tvariable: filter.getVariable(),\n\t\t\t\t\t\t\t\t\tcondition: transformedNestedFilter\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Transforms a single filter value from EQ to BT with microsecond precision.\n\t * @param filter The filter object to transform\n\t * @returns The transformed filter or null if no transformation needed\n\t */\n\t_transformDateTimeOffSetFilterValue: function (filter: Filter): Filter | null {\n\t\tconst originalValue: string | undefined = filter.getValue1()?.toString();\n\n\t\tif (!originalValue) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Parse the datetime value: 2025-08-13T15:19:15.0000000+02:00 or 2025-08-13T15:19:15.0000000Z\n\t\tconst dateTimeMatch: RegExpMatchArray | null = originalValue.match(\n\t\t\t/^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2})(?:\\.(\\d{0,7}))?([+-]\\d{2}:\\d{2}|Z)$/\n\t\t);\n\n\t\tif (dateTimeMatch) {\n\t\t\tconst dateTimePart: string = dateTimeMatch[1];\n\t\t\tconst timezone: string = dateTimeMatch[3];\n\n\t\t\t// Create microsecond range values\n\t\t\tconst startValue = `${dateTimePart}.0000000${timezone}`;\n\t\t\tconst endValue = `${dateTimePart}.9990000${timezone}`;\n\n\t\t\t// Return new BT filter with microsecond range\n\t\t\treturn new Filter({\n\t\t\t\tpath: filter.getPath(),\n\t\t\t\toperator: FilterOperator.BT,\n\t\t\t\tvalue1: startValue,\n\t\t\t\tvalue2: endValue\n\t\t\t});\n\t\t}\n\n\t\treturn null;\n\t},\n\thasEditStateFilterRecursively: function (filters: Filter[]): boolean {\n\t\treturn filters.some((filter): boolean => {\n\t\t\tif (filter.getPath() === \"$editState\") {\n\t\t\t\treturn true;\n\t\t\t} else if (filter.getFilters() !== undefined) {\n\t\t\t\treturn this.hasEditStateFilterRecursively(filter.getFilters()!);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t},\n\texchangeEditStateFilterRecursively: function (editStateFilter: Filter, filters: Filter[]): Filter[] {\n\t\treturn filters.map((filter): Filter => {\n\t\t\tif (filter.getPath() === \"$editState\") {\n\t\t\t\treturn editStateFilter;\n\t\t\t} else if (filter.getFilters() !== undefined) {\n\t\t\t\tfilter = new Filter({\n\t\t\t\t\tfilters: this.exchangeEditStateFilterRecursively(editStateFilter, filter.getFilters()!),\n\t\t\t\t\tand: filter.isAnd()\n\t\t\t\t});\n\t\t\t\treturn filter;\n\t\t\t}\n\t\t\treturn filter;\n\t\t});\n\t},\n\tsetTypeConfigToProperties: function (aProperties: PropertyInfo[] | null | undefined): PropertyInfo[] | null | undefined {\n\t\tif (aProperties && aProperties.length) {\n\t\t\taProperties.forEach(function (oIFilterProperty: PropertyInfo) {\n\t\t\t\tif (\n\t\t\t\t\toIFilterProperty.typeConfig &&\n\t\t\t\t\toIFilterProperty.typeConfig.typeInstance &&\n\t\t\t\t\t(oIFilterProperty.typeConfig.typeInstance as { getConstraints?: Function }).getConstraints instanceof Function\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (oIFilterProperty.path === \"$editState\") {\n\t\t\t\t\toIFilterProperty.typeConfig = TypeMap.getTypeConfig(\"sap.ui.model.odata.type.String\", {}, {});\n\t\t\t\t} else if (oIFilterProperty.path === \"$search\") {\n\t\t\t\t\toIFilterProperty.typeConfig = TypeMap.getTypeConfig(\"sap.ui.model.odata.type.String\", {}, {});\n\t\t\t\t} else if (oIFilterProperty.dataType || (oIFilterProperty.typeConfig && oIFilterProperty.typeConfig.className)) {\n\t\t\t\t\toIFilterProperty.typeConfig = TypeMap.getTypeConfig(\n\t\t\t\t\t\toIFilterProperty.dataType || oIFilterProperty.typeConfig?.className,\n\t\t\t\t\t\toIFilterProperty.formatOptions,\n\t\t\t\t\t\toIFilterProperty.constraints\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn aProperties;\n\t},\n\tgetNotApplicableFilters: function (oFilterBar: FilterBar, oControl: Control): string[] {\n\t\tconst sTargetEntityTypePath = oControl.data(\"entityType\"),\n\t\t\toFilterBarEntityPath = oFilterBar.data(\"entityType\"),\n\t\t\toMetaModel = oFilterBar.getModel()!.getMetaModel()!,\n\t\t\toFilterBarEntitySetAnnotations = oMetaModel.getObject(oFilterBarEntityPath),\n\t\t\taNotApplicable = [],\n\t\t\tmConditions = oFilterBar.getConditions(),\n\t\t\tbIsFilterBarEntityType = sTargetEntityTypePath === oFilterBarEntityPath,\n\t\t\tbIsChart = oControl.isA<Chart>(\"sap.ui.mdc.Chart\"),\n\t\t\tbIsAnalyticalTable = !bIsChart && (oControl.getParent() as TableAPI).getTableDefinition().enableAnalytics,\n\t\t\tbIsTreeTable = !bIsChart && (oControl.getParent() as TableAPI).getTableDefinition().control.type === \"TreeTable\",\n\t\t\tbEnableSearch = bIsChart\n\t\t\t\t? (CommonHelper.parseCustomData(DelegateUtil.getCustomData(oControl, \"applySupported\")) as { enableSearch?: boolean })\n\t\t\t\t\t\t.enableSearch\n\t\t\t\t: !(bIsAnalyticalTable || bIsTreeTable) || (oControl.getParent() as TableAPI).getTableDefinition().enableBasicSearch;\n\n\t\tif (mConditions && (!bIsFilterBarEntityType || bIsAnalyticalTable || bIsChart || bIsTreeTable)) {\n\t\t\t// We don't need to calculate the difference on property Level if entity sets are identical\n\t\t\tconst aTargetProperties = bIsFilterBarEntityType\n\t\t\t\t\t? []\n\t\t\t\t\t: (oFilterBar\n\t\t\t\t\t\t\t.getControlDelegate()\n\t\t\t\t\t\t\t.fetchPropertiesForEntity(sTargetEntityTypePath, oMetaModel, oFilterBar) as PropertyInfo[]),\n\t\t\t\tmTargetProperties = aTargetProperties.reduce(function (mProp: { [key: string]: PropertyInfo }, oProp: PropertyInfo) {\n\t\t\t\t\tmProp[oProp.name] = oProp;\n\t\t\t\t\treturn mProp;\n\t\t\t\t}, {}),\n\t\t\t\tmAggregatedProperties: Record<string, unknown> = {};\n\t\t\tconst chartEntityTypeAnnotations = oControl\n\t\t\t\t.getModel()!\n\t\t\t\t.getMetaModel()!\n\t\t\t\t.getObject(oControl.data(\"targetCollectionPath\") + \"/\");\n\t\t\tif (oControl.isA(\"sap.ui.mdc.Chart\")) {\n\t\t\t\tconst oEntitySetAnnotations = oControl\n\t\t\t\t\t\t.getModel()!\n\t\t\t\t\t\t.getMetaModel()!\n\t\t\t\t\t\t.getObject(`${oControl.data(\"targetCollectionPath\")}@`),\n\t\t\t\t\tmChartCustomAggregates = getAllCustomAggregates(oEntitySetAnnotations);\n\t\t\t\tObject.keys(mChartCustomAggregates).forEach(function (sAggregateName: string) {\n\t\t\t\t\tif (!mAggregatedProperties[sAggregateName]) {\n\t\t\t\t\t\tconst oAggregate = mChartCustomAggregates[sAggregateName];\n\t\t\t\t\t\tmAggregatedProperties[sAggregateName] = oAggregate;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfor (const sProperty in mConditions) {\n\t\t\t\t// Need to check the length of mConditions[sProperty] since previous filtered properties are kept into mConditions with empty array as definition\n\t\t\t\tconst aConditionProperty = mConditions[sProperty];\n\t\t\t\tlet typeCheck = true;\n\t\t\t\tif (chartEntityTypeAnnotations[sProperty] && oFilterBarEntitySetAnnotations[sProperty]) {\n\t\t\t\t\ttypeCheck = chartEntityTypeAnnotations[sProperty][\"$Type\"] === oFilterBarEntitySetAnnotations[sProperty][\"$Type\"];\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tArray.isArray(aConditionProperty) &&\n\t\t\t\t\taConditionProperty.length > 0 && //has a filter value\n\t\t\t\t\t(((!mTargetProperties[sProperty] || // no target property found by property name\n\t\t\t\t\t\t(mTargetProperties[sProperty].isCustomFilter && mTargetProperties[sProperty].annotationPath == undefined) || // custom filter that is not part of the current entitySet\n\t\t\t\t\t\t(mTargetProperties[sProperty] && !typeCheck)) &&\n\t\t\t\t\t\t(!bIsFilterBarEntityType || (sProperty === \"$editState\" && (bIsChart || bIsTreeTable || bIsAnalyticalTable)))) || //type does not match OR $editState on secondary entity set\n\t\t\t\t\t\tmAggregatedProperties[sProperty])\n\t\t\t\t) {\n\t\t\t\t\taNotApplicable.push(sProperty.replace(/[+|*]/g, \"\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!bEnableSearch && oFilterBar.getSearch()) {\n\t\t\taNotApplicable.push(\"$search\");\n\t\t}\n\t\treturn aNotApplicable;\n\t},\n\n\t/**\n\t * Gets the value list information of a property as defined for a given filter bar.\n\t * @param filterBar The filter bar to get the value list information for\n\t * @param propertyName The property to get the value list information for\n\t * @returns The value list information\n\t */\n\tasync _getValueListInfo(filterBar: FilterBar, propertyName: string): Promise<AnnotationValueListType | undefined> {\n\t\tconst metaModel = filterBar.getModel()?.getMetaModel() as ODataMetaModel;\n\n\t\tif (!metaModel) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst entityType = filterBar.data(\"entityType\") ?? \"\";\n\t\tconst valueListInfos = await metaModel.requestValueListInfo(entityType + propertyName, true).catch(() => null);\n\t\treturn valueListInfos?.[\"\"];\n\t},\n\n\t/**\n\t * Gets the value list of all the filter properties.\n\t * @param filterBar Instance of FilterBar\n\t * @returns Array of filter properties for FilterBar\n\t */\n\tgetFilterPropertyInfo(filterBar: IFilterControl): PropertyInfo[] {\n\t\tlet _propertyInfo = filterBar.data(\"feFilterInfo\");\n\t\tif (typeof _propertyInfo === \"string\") {\n\t\t\t_propertyInfo = JSON.parse(_propertyInfo);\n\t\t}\n\t\treturn _propertyInfo || [];\n\t},\n\n\t/**\n\t * Gets the {@link ConditionValidated} state for a single value. This decides whether the value is treated as a selected value\n\t * in a value help, meaning that its description is loaded and displayed if existing, or whether it is displayed as a\n\t * condition (e.g. \"=1\").\n\t *\n\t * Values for properties without value list info are always treated as {@link ConditionValidated.NotValidated}.\n\t * @param valueListInfo The value list info from the {@link MetaModel}\n\t * @param propertyName The name of the property\n\t * @param value The single value to get the state for\n\t * @returns The {@link ConditionValidated} state for the value\n\t */\n\t_getConditionValidated: async function (\n\t\tvalueListInfo: AnnotationValueListType | undefined,\n\t\tpropertyName: string,\n\t\tvalue: string | number | boolean | null | undefined\n\t): Promise<ConditionValidated> {\n\t\tif (!valueListInfo) {\n\t\t\treturn ConditionValidated.NotValidated;\n\t\t}\n\n\t\ttry {\n\t\t\tconst valueListProperties = valueListInfo.Parameters.filter((parameter) =>\n\t\t\t\t[CommonAnnotationTypes.ValueListParameterInOut.valueOf(), CommonAnnotationTypes.ValueListParameterOut.valueOf()].includes(\n\t\t\t\t\tparameter.$Type\n\t\t\t\t)\n\t\t\t)\n\t\t\t\t.filter((parameter) => parameter.LocalDataProperty?.$PropertyPath === propertyName)\n\t\t\t\t.map((parameter) => parameter.ValueListProperty);\n\n\t\t\tconst valueListPropertyPath = valueListProperties[0] ?? propertyName;\n\n\t\t\tconst filter = new Filter({\n\t\t\t\tpath: valueListPropertyPath,\n\t\t\t\toperator: FilterOperator.EQ,\n\t\t\t\tvalue1: value\n\t\t\t});\n\t\t\tconst listBinding = valueListInfo.$model.bindList(`/${valueListInfo.CollectionPath}`, undefined, undefined, filter, {\n\t\t\t\t$select: valueListPropertyPath\n\t\t\t});\n\n\t\t\tconst valueExists = (await listBinding.requestContexts()).length > 0;\n\t\t\tif (valueExists) {\n\t\t\t\treturn ConditionValidated.Validated;\n\t\t\t} else {\n\t\t\t\treturn ConditionValidated.NotValidated;\n\t\t\t}\n\t\t} catch (error: unknown) {\n\t\t\tLog.error(\"FilterUtils: Error while retrieving ConditionValidated\", error as Error | string);\n\t\t\treturn ConditionValidated.NotValidated;\n\t\t}\n\t},\n\t/**\n\t * Clear the filter value for a specific property in the filter bar.\n\t * This is a prerequisite before new values can be set cleanly.\n\t * @param filterBar The filter bar that contains the filter field\n\t * @param conditionPath The path to the property as a condition path\n\t */\n\tasync _clearFilterValue(filterBar: FilterBar, conditionPath: string): Promise<void> {\n\t\tconst oState = await StateUtil.retrieveExternalState(filterBar);\n\t\tif (oState.filter[conditionPath]) {\n\t\t\toState.filter[conditionPath].forEach((oCondition: ConditionObject) => {\n\t\t\t\toCondition.filtered = false;\n\t\t\t});\n\t\t\tawait StateUtil.applyExternalState(filterBar, { filter: { [conditionPath]: oState.filter[conditionPath] } });\n\t\t}\n\t},\n\n\t/**\n\t * Set the filter values for the given property in the filter bar.\n\t * The filter values can be either a single value or an array of values.\n\t * Each filter value must be represented as a primitive value.\n\t * @param oFilterBar The filter bar that contains the filter field\n\t * @param sConditionPath The path to the property as a condition path\n\t * @param args List of optional parameters\n\t *  [sOperator] The operator to be used - if not set, the default operator (EQ) will be used\n\t *  [vValues] The values to be applied - if sOperator is missing, vValues is used as 3rd parameter\n\t */\n\tsetFilterValues: async function (oFilterBar: FilterBar | undefined, sConditionPath: string, ...args: unknown[]): Promise<void> {\n\t\tawait this._setFilterValues(oFilterBar, false, sConditionPath, ...args);\n\t},\n\n\t/**\n\t * Add the filter values for the given property in the filter bar.\n\t *\n\t * The filter values can be either a single value or an array of values.\n\t * Each filter value must be represented as a primitive value.\n\t * @param filterBar The filter bar that contains the filter field\n\t * @param conditionPath The path to the property as a condition path\n\t * @param args List of optional parameters\n\t */\n\taddFilterValues: async function (filterBar: FilterBar | undefined, conditionPath: string, ...args: unknown[]): Promise<void> {\n\t\tawait this._setFilterValues(filterBar, true, conditionPath, ...args);\n\t},\n\n\t/**\n\t * Get property path from condition path.\n\t *\n\t * It removes the condition path specific characters like \"+\" and \"*\".\n\t * @param conditionPath The path to the property as a condition path\n\t * @returns The property path derived from the condition path\n\t */\n\tgetPropertyPathFromConditionPath(conditionPath: string): string {\n\t\treturn conditionPath.replace(CONDITION_PATH_TO_PROPERTY_PATH_REGEX, \"\");\n\t},\n\n\t/**\n\t * Get main filter bar for the given p13n adaptation filter control.\n\t * @param potentialFilterBar Expected instance of FilterBar or AdaptationFilterBar.\n\t * @returns The main filter bar instance if found, otherwise undefined.\n\t */\n\tgetFilterBarForAdaptationControl(potentialFilterBar: ManagedObject | null): FilterBar | null {\n\t\twhile (potentialFilterBar && !potentialFilterBar.isA<FilterBar>(\"sap.ui.mdc.FilterBar\")) {\n\t\t\tpotentialFilterBar = potentialFilterBar.getParent();\n\t\t}\n\t\treturn potentialFilterBar;\n\t},\n\n\t/**\n\t * Get the data model object path for a property in the filter bar.\n\t *\n\t * This is used to retrieve the data model object path for a specific property in the filter bar.\n\t * @param filterBar The filter bar that contains the property\n\t * @param propertyPath The path to the property\n\t * @returns The data model object path for the property\n\t */\n\tgetDataModelObjectPathForProperty(filterBar: FilterBar, propertyPath: string): DataModelObjectPath<Property> | undefined {\n\t\tconst entityTypePath = DelegateUtil.getCustomData<string>(filterBar, \"entityType\");\n\t\tconst metaModel = filterBar.getModel()?.getMetaModel() as ODataMetaModel;\n\t\treturn MetaModelConverter.getInvolvedDataModelObjects<Property>(\n\t\t\tmetaModel.createBindingContext(`${entityTypePath}${propertyPath}`)!,\n\t\t\tmetaModel.createBindingContext(`${entityTypePath}`)!\n\t\t);\n\t},\n\n\t_setFilterValues: async function (\n\t\toFilterBar: FilterBar | undefined,\n\t\tappend: boolean,\n\t\tsConditionPath: string,\n\t\t...args: unknown[]\n\t): Promise<void> {\n\t\tlet sOperator = args?.[0] as string | undefined;\n\t\tlet vValues = args?.[1] as undefined | string | number | boolean | string[] | number[] | boolean[];\n\n\t\t// Do nothing when the filter bar is hidden\n\t\tif (!oFilterBar) {\n\t\t\treturn;\n\t\t}\n\n\t\t// common filter Operators need a value. Do nothing if this value is undefined\n\t\t// BCP: 2270135274\n\t\tif (\n\t\t\targs.length === 2 &&\n\t\t\t(vValues === undefined || vValues === null || vValues === \"\") &&\n\t\t\tsOperator &&\n\t\t\tObject.keys(FilterOperator).includes(sOperator)\n\t\t) {\n\t\t\tLog.warning(`An empty filter value cannot be applied with the ${sOperator} operator`);\n\t\t\treturn;\n\t\t}\n\n\t\t// The 4th parameter is optional; if sOperator is missing, vValues is used as 3rd parameter\n\t\t// This does not apply for semantic dates, as these do not require vValues (exception: \"LASTDAYS\", 3)\n\t\tif (vValues === undefined && !SemanticDateOperators.getSemanticDateOperations().includes(sOperator || \"\")) {\n\t\t\tvValues = sOperator ?? [];\n\t\t\tsOperator = undefined;\n\t\t}\n\n\t\t// If sOperator is not set, use EQ as default\n\t\tif (!sOperator) {\n\t\t\tsOperator = FilterOperator.EQ;\n\t\t}\n\n\t\t// Supported array types:\n\t\t//  - Single Values:\t\"2\" | [\"2\"]\n\t\t//  - Multiple Values:\t[\"2\", \"3\"]\n\t\t//  - Ranges:\t\t\t[\"2\",\"3\"]\n\t\t// Unsupported array types:\n\t\t//  - Multiple Ranges:\t[[\"2\",\"3\"]] | [[\"2\",\"3\"],[\"4\",\"5\"]]\n\t\tconst supportedValueTypes = [\"string\", \"number\", \"boolean\"];\n\t\tif (\n\t\t\tvValues !== undefined &&\n\t\t\t((!Array.isArray(vValues) && !supportedValueTypes.includes(typeof vValues)) ||\n\t\t\t\t(Array.isArray(vValues) && vValues.length > 0 && !supportedValueTypes.includes(typeof vValues[0])))\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t\"FilterUtils.js#_setFilterValues: Filter value not supported; only primitive values or an array thereof can be used.\"\n\t\t\t);\n\t\t}\n\t\tlet values: (string | number | boolean | null)[] | undefined;\n\t\tif (vValues !== undefined) {\n\t\t\tvalues = Array.isArray(vValues) ? vValues : [vValues];\n\t\t}\n\n\t\tconst filter: { [key: string]: ConditionObject[] } = {};\n\t\tif (sConditionPath) {\n\t\t\t// We recreate conditionPath to ensure it is in right format\n\t\t\t// e.g. If \"_Item/Material\" is sent as condition path where _Item is 1:n multiplicity -> \"_Item*/Material\"\n\t\t\tconst propertyPath = oFilterUtils.getPropertyPathFromConditionPath(sConditionPath);\n\t\t\tconst mainFilterBarControl = oFilterUtils.getFilterBarForAdaptationControl(oFilterBar) ?? oFilterBar;\n\t\t\tconst propertyTargetObjectPath = oFilterUtils.getDataModelObjectPathForProperty(mainFilterBarControl, propertyPath);\n\t\t\tconst propertyName = propertyTargetObjectPath?.targetObject?.name ?? propertyPath;\n\t\t\tsConditionPath =\n\t\t\t\t(propertyTargetObjectPath ? getContextRelativeTargetObjectPath(propertyTargetObjectPath, false, true) : undefined) ??\n\t\t\t\tsConditionPath;\n\t\t\t// Get the value list info of the property to later check whether the values exist\n\t\t\tconst valueListInfo = await this._getValueListInfo(mainFilterBarControl, propertyPath);\n\t\t\tif (values && values.length) {\n\t\t\t\tif (sOperator === FilterOperator.BT) {\n\t\t\t\t\t// The operator BT requires one condition with both thresholds\n\t\t\t\t\tfilter[sConditionPath] = [Condition.createCondition(sOperator, values, null, null, ConditionValidated.NotValidated)];\n\t\t\t\t} else {\n\t\t\t\t\t// Regular single and multi value conditions, if there are no values, we do not want any conditions\n\t\t\t\t\tfilter[sConditionPath] = await Promise.all(\n\t\t\t\t\t\tvalues.map(async (value) => {\n\t\t\t\t\t\t\t// For the EQ case, tell MDC to validate the value (e.g. display the description), if it exists in the associated entity, otherwise never validate\n\t\t\t\t\t\t\tconst conditionValidatedStatus =\n\t\t\t\t\t\t\t\tsOperator === FilterOperator.EQ\n\t\t\t\t\t\t\t\t\t? await this._getConditionValidated(valueListInfo, propertyName, value)\n\t\t\t\t\t\t\t\t\t: ConditionValidated.NotValidated;\n\n\t\t\t\t\t\t\treturn Condition.createCondition(sOperator!, [value], null, null, conditionValidatedStatus);\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (SemanticDateOperators.getSemanticDateOperations().includes(sOperator || \"\")) {\n\t\t\t\t// vValues is undefined, so the operator is a semantic date that does not need values (see above)\n\t\t\t\tfilter[sConditionPath] = [Condition.createCondition(sOperator, [], null, null, ConditionValidated.NotValidated)];\n\t\t\t}\n\t\t}\n\n\t\tif (!append) {\n\t\t\t// Clear the current value as we do not want to add filter values but replace them\n\t\t\tawait this._clearFilterValue(oFilterBar, sConditionPath);\n\t\t}\n\n\t\tif (filter[sConditionPath]) {\n\t\t\t// This is not called in the reset case, i.e. setFilterValue(\"Property\")\n\t\t\tawait StateUtil.applyExternalState(oFilterBar, { filter });\n\t\t}\n\t},\n\tconditionToModelPath: function (sConditionPath: string): string {\n\t\t// make the path usable as model property, therefore slashes become backslashes\n\t\treturn sConditionPath.replace(/\\//g, \"\\\\\");\n\t},\n\t_getFilterMetaModel: function (oFilterControl: IFilterControl, metaModel?: ODataMetaModel): ODataMetaModel {\n\t\treturn metaModel || (oFilterControl.getModel()!.getMetaModel() as ODataMetaModel);\n\t},\n\t_getEntitySetPath: function (sEntityTypePath: string): string {\n\t\treturn sEntityTypePath && ModelHelper.getEntitySetPath(sEntityTypePath);\n\t},\n\n\t_getFieldsForTable: function (oFilterControl: IFilterControl, sEntityTypePath?: string): TableVisualization[] {\n\t\tconst lrTables: TableVisualization[] = [];\n\t\t/**\n\t\t * Gets fields from\n\t\t * \t- direct entity properties,\n\t\t * \t- navigateProperties key in the manifest if these properties are known by the entity\n\t\t *  - annotation \"SelectionFields\"\n\t\t */\n\t\tif (sEntityTypePath) {\n\t\t\tconst oView = CommonUtils.getTargetView(oFilterControl);\n\t\t\tconst tableControls =\n\t\t\t\toView &&\n\t\t\t\toView.getController() &&\n\t\t\t\t(oView.getController() as ListReportController)._getControls &&\n\t\t\t\t(oView.getController() as ListReportController)._getControls(\"table\");\n\t\t\tif (tableControls) {\n\t\t\t\ttableControls.forEach(function (oTable: Control) {\n\t\t\t\t\tlrTables.push((oTable.getParent() as TableAPI).getTableDefinition());\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn lrTables;\n\t\t}\n\t\treturn [];\n\t},\n\t_getSelectionFields: function (\n\t\toFilterControl: IFilterControl,\n\t\tsEntityTypePath: string | undefined,\n\t\tsFilterEntityTypePath: string,\n\t\tcontextPath: string,\n\t\tlrTables: TableVisualization[],\n\t\toMetaModel: ODataMetaModel,\n\t\toConverterContext: ConverterContext,\n\t\tincludeHidden?: boolean,\n\t\toModifier?: BaseTreeModifier,\n\t\tlineItemTerm?: string,\n\t\tannotationPath?: string\n\t): FilterField[] {\n\t\tconst filterFields = FilterBarConverter.getSelectionFields(\n\t\t\toConverterContext,\n\t\t\tlrTables,\n\t\t\tannotationPath,\n\t\t\tincludeHidden,\n\t\t\tlineItemTerm\n\t\t);\n\t\tlet selectionFields: FilterField[] = filterFields.selectionFields;\n\t\tconst propertyInfos = (oFilterControl as Partial<IFilterControl>).data\n\t\t\t? this.getFilterPropertyInfo(oFilterControl)\n\t\t\t: JSON.parse(filterFields.sPropertyInfo.replace(/\\\\\\{/g, \"{\").replace(/\\\\\\}/g, \"}\")); // propertyInfo string is returned from the getSelectionFields\n\t\tif (\n\t\t\t(oModifier\n\t\t\t\t? oModifier.getControlType(oFilterControl) === \"sap.ui.mdc.FilterBar\"\n\t\t\t\t: oFilterControl.isA(\"sap.ui.mdc.FilterBar\")) &&\n\t\t\tsEntityTypePath !== sFilterEntityTypePath\n\t\t) {\n\t\t\t/**\n\t\t\t * We are in a multi-entity set scenario so we add annotation \"SelectionFields\"\n\t\t\t * from FilterBar entity if these properties are known by the entity\n\t\t\t */\n\t\t\tconst oVisualizationObjectPath = MetaModelConverter.getInvolvedDataModelObjects(oMetaModel.createBindingContext(contextPath)!);\n\t\t\tconst oPageContext = oConverterContext.getConverterContextFor(sFilterEntityTypePath);\n\t\t\tconst aFilterBarSelectionFieldsAnnotation: SelectionFields =\n\t\t\t\toPageContext.getEntityTypeAnnotation<SelectionFields>(\"@com.sap.vocabularies.UI.v1.SelectionFields\").annotation ||\n\t\t\t\t([] as unknown as SelectionFields);\n\t\t\tconst mapSelectionFields: Record<string, boolean> = {};\n\t\t\tselectionFields.forEach(function (oSelectionField: FilterField) {\n\t\t\t\tmapSelectionFields[oSelectionField.conditionPath] = true;\n\t\t\t});\n\n\t\t\taFilterBarSelectionFieldsAnnotation.forEach(function (oFilterBarSelectionFieldAnnotation: PropertyPath) {\n\t\t\t\tconst sPath = oFilterBarSelectionFieldAnnotation.value;\n\t\t\t\tif (!mapSelectionFields[sPath]) {\n\t\t\t\t\tconst oFilterField = FilterBarConverter.getFilterField(\n\t\t\t\t\t\tsPath,\n\t\t\t\t\t\toConverterContext,\n\t\t\t\t\t\toVisualizationObjectPath.startingEntitySet.entityType\n\t\t\t\t\t);\n\t\t\t\t\tif (oFilterField) {\n\t\t\t\t\t\tselectionFields.push(oFilterField);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (selectionFields) {\n\t\t\tconst fieldNames: string[] = [];\n\t\t\tselectionFields.forEach(function (oField: FilterField) {\n\t\t\t\tfieldNames.push(oField.key);\n\t\t\t});\n\t\t\tselectionFields = this._getSelectionFieldsFromPropertyInfos(fieldNames, selectionFields, propertyInfos);\n\t\t}\n\t\treturn selectionFields;\n\t},\n\n\t/**\n\t * Adds the properties from propertyInfos for the filter field.\n\t * @param fieldNames The names of fields present in the selectionField array.\n\t * @param selectionFields Selection field array of all the possible fields that can be in the selection field.\n\t * @param propertyInfo PropertyInfos filters that are available or present in selection field annotation.\n\t * @returns FilterField array of all the possible filter fields after adding properties from propertyInfos\n\t */\n\t_getSelectionFieldsFromPropertyInfos: function (\n\t\tfieldNames: string[],\n\t\tselectionFields: FilterField[],\n\t\tpropertyInfo: PropertyInfo[]\n\t): FilterField[] {\n\t\tpropertyInfo.forEach(function (oProp: PropertyInfo) {\n\t\t\tif (oProp.name === \"$search\" || oProp.name === \"$editState\" || oProp.key === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selField = selectionFields[fieldNames.indexOf(oProp.key)];\n\t\t\tif (fieldNames.includes(oProp.key) && selField.annotationPath) {\n\t\t\t\toProp.group = selField.group;\n\t\t\t\toProp.groupLabel = selField.groupLabel;\n\t\t\t\toProp.settings = selField.settings;\n\t\t\t\toProp.visualFilter = selField.visualFilter;\n\t\t\t\toProp.label = oProp.label ? oProp.label : selField.label; // if a label is coming for the manifest we need to take that as priority.\n\t\t\t\toProp.annotationPath = oProp.annotationPath ?? selField.annotationPath;\n\t\t\t\tselectionFields[fieldNames.indexOf(oProp.key)] = oProp as FilterField;\n\t\t\t}\n\n\t\t\tif (!fieldNames.includes(oProp.key) && !oProp.annotationPath) {\n\t\t\t\tselectionFields.push(oProp as FilterField);\n\t\t\t}\n\t\t});\n\t\treturn selectionFields;\n\t},\n\t_getSearchField: function (oIFilter: Partial<IFilterControl>, aIgnoreProperties: string[]): string | null {\n\t\treturn oIFilter.getSearch && !aIgnoreProperties.includes(\"search\") ? oIFilter.getSearch() : null;\n\t},\n\t_getFilterConditions: function (\n\t\tmProperties: { ignoredProperties?: string[]; propertiesMetadata?: PropertyInfo[]; targetControl?: Control } | undefined,\n\t\tmFilterConditions: Record<string, ConditionObject[]>,\n\t\toIFilter: IFilterControl\n\t): Record<string, ConditionObject[]> {\n\t\tconst mConditions = mFilterConditions || oIFilter.getConditions();\n\t\tif (mProperties && mProperties.targetControl && mProperties.targetControl.isA(\"sap.ui.mdc.Chart\")) {\n\t\t\tObject.keys(mConditions).forEach(function (sKey: string) {\n\t\t\t\tif (sKey === \"$editState\") {\n\t\t\t\t\tdelete mConditions[\"$editState\"];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn mConditions;\n\t},\n\t_getFilterPropertiesMetadata: function (\n\t\taFilterPropertiesMetadata: PropertyInfo[] | null,\n\t\toIFilter: IFilterControl\n\t): PropertyInfo[] | null {\n\t\tif (!(aFilterPropertiesMetadata && aFilterPropertiesMetadata.length)) {\n\t\t\tif (oIFilter.getPropertyInfo) {\n\t\t\t\taFilterPropertiesMetadata = oIFilter.getPropertyInfo();\n\t\t\t} else {\n\t\t\t\taFilterPropertiesMetadata = null;\n\t\t\t}\n\t\t}\n\t\treturn aFilterPropertiesMetadata;\n\t},\n\t_getIgnoredProperties: function (filterPropertiesMetadata: PropertyInfo[], entityProperties: PropertyInfo[]): string[] {\n\t\tconst ignoreProperties: string[] = [];\n\t\tfilterPropertiesMetadata.forEach(function (filterProperty) {\n\t\t\tconst filterPropertyName = filterProperty.name;\n\t\t\tconst entityPropertiesCurrent = entityProperties.find((entity) => entity.name === filterPropertyName);\n\t\t\tif (\n\t\t\t\tentityPropertiesCurrent &&\n\t\t\t\t((!filterProperty.isCustomFilter && filterProperty.dataType !== entityPropertiesCurrent.dataType) ||\n\t\t\t\t\t// custom filters will have an annotation path applied in the converter when there is a matching property found\n\t\t\t\t\t(filterProperty.isCustomFilter && entityPropertiesCurrent.annotationPath === undefined))\n\t\t\t) {\n\t\t\t\tignoreProperties.push(filterPropertyName);\n\t\t\t}\n\t\t});\n\t\treturn ignoreProperties;\n\t},\n\tgetFilters: function (filterBar?: IFilterControl): InternalBindingInfo | undefined {\n\t\tif (!filterBar || typeof filterBar.isInitialized !== \"function\" || !filterBar.isInitialized()) {\n\t\t\treturn;\n\t\t}\n\t\tconst { parameters, filters, search } = this.getFilterInfo(filterBar);\n\t\treturn { parameters, filters, search };\n\t},\n\t/**\n\t * Prepares propertyInfo for sharing it outside FE, removes unwanted property.\n\t * @param propertyInfos Array of propertyInfo\n\t * @returns Array or String (for FilterBar templating) of PropertyInfos after removing the unwanted properties\n\t */\n\tformatPropertyInfo: function (propertyInfos: PropertyInfo[] | string): PropertyInfoExternal[] | string {\n\t\tif (typeof propertyInfos === \"string\") {\n\t\t\tlet propInfo = propertyInfos.replace(/\\\\\\{/g, \"{\");\n\t\t\tpropInfo = propInfo.replace(/\\\\\\}/g, \"}\");\n\t\t\tlet propInfos = JSON.parse(propInfo);\n\t\t\tpropInfos = this._formatPropertyInfo(propInfos);\n\t\t\tlet propertyInfoForFilterBar = JSON.stringify(propInfos);\n\t\t\tpropertyInfoForFilterBar = propertyInfoForFilterBar.replace(/\\{/g, \"\\\\{\");\n\t\t\tpropertyInfoForFilterBar = propertyInfoForFilterBar.replace(/\\}/g, \"\\\\}\");\n\t\t\treturn propertyInfoForFilterBar;\n\t\t} else {\n\t\t\treturn this._formatPropertyInfo(propertyInfos);\n\t\t}\n\t},\n\t/**\n\t * Removes unwanted property from PropertyInfos.\n\t * @param propertyInfos Array of propertyInfo\n\t * @returns Array of PropertyInfos after removing the unwanted properties\n\t */\n\t_formatPropertyInfo: function (propertyInfos: PropertyInfo[]): PropertyInfoExternal[] {\n\t\treturn propertyInfos.map((property) => {\n\t\t\tconst _propertyInfo: PropertyInfoExternal = {\n\t\t\t\tkey: property.key || property.name,\n\t\t\t\tdataType: \"\",\n\t\t\t\tlabel: \"\"\n\t\t\t};\n\t\t\tfor (const key in PropertyInfoKeys) {\n\t\t\t\tif (property.hasOwnProperty(key)) {\n\t\t\t\t\tswitch (key) {\n\t\t\t\t\t\tcase \"hiddenFilter\":\n\t\t\t\t\t\t\t_propertyInfo.hiddenFilter = property.hiddenFilter;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"required\":\n\t\t\t\t\t\t\t_propertyInfo.required = property.required;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"path\":\n\t\t\t\t\t\t\t_propertyInfo.path = property.path;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"tooltip\":\n\t\t\t\t\t\t\t_propertyInfo.tooltip = property.tooltip;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"visible\":\n\t\t\t\t\t\t\t_propertyInfo.visible = property.visible;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"maxConditions\":\n\t\t\t\t\t\t\t_propertyInfo.maxConditions = property.maxConditions;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"formatOptions\":\n\t\t\t\t\t\t\t_propertyInfo.formatOptions = property.formatOptions;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"constraints\":\n\t\t\t\t\t\t\t_propertyInfo.constraints = property.constraints;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"group\":\n\t\t\t\t\t\t\t_propertyInfo.group = property.group;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"groupLabel\":\n\t\t\t\t\t\t\t_propertyInfo.groupLabel = property.groupLabel;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"caseSensitive\":\n\t\t\t\t\t\t\t_propertyInfo.caseSensitive = property.caseSensitive;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (property.dataType) {\n\t\t\t\t_propertyInfo.dataType = property.dataType;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Missing mandatory property dataType for filter-bar filter field: ${property}`);\n\t\t\t}\n\t\t\tif (property.label) {\n\t\t\t\t_propertyInfo.label = property.label;\n\t\t\t}\n\t\t\treturn _propertyInfo;\n\t\t});\n\t}\n};\n\nexport default oFilterUtils;\n"],"mappings":";;;;yhCA4DKA,EAAgB,SAAhBA,KAAgB,+BAAhBA,EAAgB,uBAAhBA,EAAgB,eAAhBA,EAAgB,qBAAhBA,EAAgB,qBAAhBA,EAAgB,iCAAhBA,EAAgB,iCAAhBA,EAAgB,6BAAhBA,EAAgB,iBAAhBA,EAAgB,2BAAhBA,EAAgB,wCAAhBA,CAAgB,EAAhBA,GAAgB,IAcrB,MAAMC,EAAwC,QAE9C,MAAMC,EAAe,CACpBC,UAAW,SAAUC,GACpB,MAAMC,EAAWH,EAAaI,cAAcF,GAAUG,QACtD,OAAOF,GAAUG,OAAS,IAAIC,EAAOJ,EAAU,OAASK,SACzD,EACAC,eAAgB,SAAUC,EAAsBC,EAAoCC,GACnF,OAAOC,EAAmBJ,eAAeC,EAAcC,EAAkBC,EAC1E,EACAE,iBAAkB,SAAUC,EAAgCJ,GAC3D,IAAIK,EACJ,MAAMC,EAAkD,CAAC,EACzD,MAAMC,EAA0BP,EAAiBQ,uBAAiCJ,EAAkBK,gBACpG,MAAMC,EAAuBH,EAAwBI,yBAAyBC,aAC9E,MAAMC,EAAcX,EAAmBY,gBAAgBJ,GACvDL,EAAgBH,EAAmBa,kBAAkBf,EAAkBI,EAAmBS,GAC1FP,EAAYF,EAAkBY,KAAOH,EACrCR,EAAgBH,EAAmBe,6BAA6BZ,EAAeL,EAAkB,GAAIM,GACrG,OAAOD,CACR,EACAa,uBAAwB,SACvBC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAwBC,EAAaC,cAAsBN,EAAgB,cAChFO,EAAcN,GAAmBG,EAElC,MAAMI,EAASR,EAA2CS,IAAMC,EAAYC,cAAcX,GAAkB,KAC5G,MAAMY,EAAcV,GAAaF,EAAea,WAAYC,eAC5D,MAAMC,EAAgBZ,GAAiBK,GAASE,EAAYM,gBAAgBR,GAC5E,MAAMS,EAA2BC,EAAmBC,4BAA4BP,EAAWQ,qBAAqBb,IAChH,IAAIc,EACJ,GAAIrB,EAAeS,MAAQT,EAAeS,IAAI,kCAAmC,CAChFY,EAAqBb,GAASA,EAAMc,eAAkB,CAAC,CACxD,CACA,OAAOC,EAAiBC,+BACvBP,EAAyBQ,kBAAkBC,KAC3Cd,EACAG,GAAeY,iBACfC,EACAX,EAAyBY,gBACzB,IAAIC,EAAiBT,GAAoB,CAAC,GAE5C,EACAU,yBAA0B,SACzB/B,EACAC,EACA+B,EACA9B,EACAC,EACA8B,EACAC,GAEA,MAAMtB,EAAauB,KAAKC,oBAAoBpC,EAAgBE,GAC5D,MAAME,EAAwBC,EAAaC,cAAsBN,EAAgB,cACjF,MAAMV,EAAiBe,EAAaC,cAAsBN,EAAgB,kBACzEO,EAAcN,GAAmBG,EAElC,MAAMiC,EAAiCF,KAAKG,mBAAmBtC,EAAgBC,GAE/E,MAAMsC,EAAoBJ,KAAKpC,uBAAuBC,EAAgBC,EAAiBC,GAAaU,EAAYT,GAGhH,OAAOgC,KAAKK,oBACXxC,EACAC,EACAG,EACAG,EACA8B,EACAzB,EACA2B,EACAP,EACAC,EACAC,EACA5C,EAEF,EAEAmD,4BAA6B,SAC5BC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAoB,GAC1BF,EAA4B1E,EAAa6E,0BAA0BH,GAEnE,IAAK,MAAMI,KAAcH,EAAa,CACrC,GAAIF,EAAYK,IAAeL,EAAYK,GAAYxE,OAAS,EAAG,CAElE,MAAMyE,EAAqBrB,EAAM,CAAC,EAAGe,EAAYK,GAAY,IAC7D,MAAME,EAAYC,EAAWC,iBAAiBR,EAA2BI,GACzE,MAAMtD,EACLwD,EAAUG,YAAcC,EAAQC,cAAcL,EAAUM,SAAUN,EAAUO,cAAeP,EAAUQ,aACtG,MAAMC,EAA8BC,EAAmBC,OAAOZ,EAAoBvD,EAAagD,EAASoB,cACxG,MAAMC,EAAWC,EAAmBtE,EAAYuE,WAChDnB,EAAQoB,KACP,GAAGlB,KAAcmB,mBAAmBC,EAAWC,cAAcV,EAA4BW,OAAO,GAAIP,MAEtG,CACD,CAGA,MAAM9D,EAAkByC,EAAS6B,KAAK,cACtC,MAAMC,EAAiBvE,EAAgBwE,UAAU,EAAGxE,EAAgBzB,OAAS,GAC7E,MAAMkG,EAAsBF,EAAeG,MAAM,EAAGH,EAAeI,YAAY,MAC/E,MAAMC,EAAoBL,EAAeC,UAAUD,EAAeI,YAAY,KAAO,GAErF,MAAO,GAAGF,KAAuB5B,EAAQgC,eAAeD,GACzD,EAEAE,wBAAyB,SAAUpC,GAClC,IAAIqC,EAAe,MACnB,GAAIrC,GAAeA,EAAYsC,WAAY,CAC1C,MAAMC,EAAavC,EAAYsC,WAAWE,KAAK,SAAUC,GACxD,OAAOA,EAAUC,WAAa,kBAC/B,GACA,GAAIH,IAAeA,EAAWZ,OAAOgB,SAAS,sBAAwBJ,EAAWZ,OAAOgB,SAAS,eAAgB,CAChHN,EAAe,IAChB,CACD,CACA,OAAOA,CACR,EAYA1G,cAAe,SACdF,EACAmH,EACAC,GAEA,IAAIC,EAAqBF,GAAeA,EAAYG,mBAAsB,GAC1E,MAAMC,EAAiBJ,GAAeA,EAAYK,cACjDC,EAAoBF,EAAiBA,EAAepB,KAAK,cAAgB7F,UAC1E,MAAMoH,EAAsC,CAAC,EAC7C,IAAIpD,EAA2BtE,EAC9B2H,EACA1H,EAAqB,GACrB2H,EACAC,EAAsBV,GAAeA,EAAYW,mBAClD,UAAW9H,IAAa,SAAU,CACjCsE,EAAWyD,EAAQC,eAAehI,EACnC,CACA,GAAIsE,EAAU,CACbqD,EAAU5D,KAAKkE,gBAAgB3D,EAAU+C,GACzC,MAAM9C,EAAcR,KAAKmE,qBAAqBf,EAAaC,EAAoB9C,GAC/E,IAAIE,EACJ,GAAIF,EAASjC,IAAe,wBAAyB,CACpDmC,EAA4BT,KAAKoE,sBAAsB7D,EACxD,KAAO,CACNE,EAA4BF,EAAS8D,mBAAqB9D,EAAS8D,qBAAuB,IAC3F,CACA5D,EAA4BT,KAAKsE,6BAA6B7D,EAA2BF,GACzF,GAAI6C,GAAeA,EAAYK,eAAiBL,EAAYK,cAAcnF,IAAI,oBAAqB,CAClGiG,OAAOC,KAAKhE,GAAaiE,QAAQ,SAAUC,GAC1C,GAAIA,IAAS,aAAc,QACnBlE,EAAY,aACpB,CACD,EACD,CACA,IAAIE,EAAcH,EAAS6B,KAAK,eAAiB,GACjD1B,SAAqBA,IAAgB,SAAWiE,KAAKC,MAAMlE,GAAeA,EAC1E,GAAIA,GAAeA,EAAYrE,OAAS,EAAG,CAE1CwH,EAAe9H,EAAauE,4BAA4BC,EAAUC,EAAaC,EAA2BC,GAC1G,GAAI6D,OAAOC,KAAKhE,GAAanE,OAAQ,CACpCkI,OAAOC,KAAKhE,GAAaiE,QAASI,IACjCnE,EAAY+D,QAASK,IACpB,GAAID,IAAUC,EAAe,CAC5B,MAAMC,EAAmBvE,EAAYqE,GAAO,GAAG1C,OAC/CwB,EAAYmB,GAAiBC,EAAiB,EAC/C,KAGH,CACD,CACA,GAAIvE,EAAa,CAEhB,GAAIkD,GAAqBnD,EAAS6B,KAAK,eAAiB7B,EAAS6B,KAAK,gBAAkBsB,EAAmB,CAC1G,MAAMjF,EAAa8B,EAAS7B,WAAYC,eACxC,MAAMqG,EAA4BzE,EAChC0E,uBACAC,yBAAyBxB,EAAmBjF,EAAY8B,GAC1DuD,EAAsBkB,EAEtB,MAAMG,EAAqBnF,KAAKoF,sBAC/B3E,EACAuE,GAED,GAAIG,EAAmB9I,OAAS,EAAG,CAClCiH,EAAoBA,EAAkB+B,OAAOF,EAC9C,CACD,MAAO,IAAKrB,GAAuBrD,EAA2B,CAC7DqD,EAAsBrD,CACvB,CAKAvE,EAAW8D,KAAKsF,sBAAsB,CACrC/E,WACAC,cACAsD,sBACAR,oBACA5C,eAEF,CACD,CACA,MAAO,CAAE6E,WAAY5B,EAAavH,QAASF,EAAUsJ,OAAQ5B,GAAWrH,UAAWkJ,YAAa5B,EACjG,EAaAyB,sBAAuB,SAAAI,GAYV,IAZoBnF,SAChCA,EAAQC,YACRA,EAAWsD,oBACXA,EAAmBR,kBACnBA,EAAiB5C,YACjBA,GAOAgF,EACA,MAAMC,EACL3E,EAAW7E,cACVoE,EACAC,EACAzE,EAAa6E,0BAA0BkD,GACvCR,EAAkB+B,OAAO3E,IAEzBtE,QACF,MAAMwJ,EAAuB9B,GAAqB+B,OAAQC,GAAaA,EAASvG,OAAS,cACzF,IAAIwG,EACJ,IAAKzC,EAAkBH,SAAS,eAAiByC,GAAwBA,EAAqBvJ,OAAS,EAAG,CACzG,GAAImE,EAAYwF,eAAe,cAAe,CAC7C,MAAMC,EAAiBzF,EAAY,cACnCuF,EAAkBG,EAAUC,sBAAsBF,IAAiB,IAAI9D,SAAS,GACjF,KAAO,CACN4D,EAAkBG,EAAUC,sBAAsB,GACnD,CACD,KAAO,CACN,MAAMC,EAAO7H,EAAYC,cAAc+B,GACvC,MAAMvC,EAAeO,EAAYM,gBAAgBuH,GACjD,MAAMC,EAAwBrI,EAAasI,8BAA8BC,mBAAmBC,aACzFC,QACH,GACCJ,GACA9F,EAASyF,eAAe,gCACxBzF,EAASmG,YAAY,+BACpB,CACDX,EAAkBG,EAAUC,sBAAsB,MACnD,CACD,CACA,IAAIjK,EAAWyJ,EAAU,CAACA,GAAW,GAGrC,GAAIpF,EAASjC,IAAe,wBAAyB,CACpD0B,KAAK2G,gCAAgCzK,EAAUsE,EAAaD,EAC7D,CAEA,GAAIwF,EAAiB,CACpB,MAAMa,EAAqB5G,KAAK6G,8BAA8B3K,GAC9D,GAAI0K,EAAoB,CACvB1K,EAAW8D,KAAK8G,mCAAmCf,EAAiB7J,EACrE,KAAO,CACNA,EAAW,CACV,IAAII,EAAO,CACVF,QAAS,IAAIF,EAAU6J,GACvBgB,IAAK,OAGR,CACD,CACA,OAAO7K,CACR,EASAyK,gCAAiC,SAChCzK,EACAsE,EACAwG,GAEA,IAAK9K,IAAa+K,MAAMC,QAAQhL,KAAcsE,EAAa,CAC1D,MACD,CAIA,IAAI2G,EAA0BjL,EAC9B,MAAMkL,EAAclL,EAAS,GAC7B,GAAIkL,GAAalL,UAAYkL,EAAYlL,SAASG,OAAS,EAAG,CAC7D8K,EAAgBC,EAAYlL,QAC7B,CAGA,MAAMmL,EAAkBL,EAAWM,oBACnC,IAAKD,EAAiB,CACrB,MACD,CAGA,MAAME,EAAmC,IAAIC,IAE7CjD,OAAOC,KAAKhE,GAAaiE,QAAQ,SAAUgD,GAC1C,GAAIjH,EAAYiH,IAAmBjH,EAAYiH,GAAgBpL,OAAS,EAAG,CAE1E,MAAMqL,EAAeL,EAAgBX,YAAYe,GAcjD,MAAME,GACJD,GAAcrG,UAAU8B,SAAS,mBAAqB,SACtDuE,GAAcxG,YAAY0G,cAAcC,UAAU1E,SAAS,mBAAqB,OAClF,MAAM2E,EACLJ,GAAcnG,aAAauG,WAAaJ,GAAcxG,YAAY0G,cAAcrG,aAAauG,UAE9F,GAAIH,GAAoBG,IAAc,EAAG,CACxCP,EAAoBQ,IAAIN,EACzB,CACD,CACD,GAGAzH,KAAKgI,+CAA+Cb,EAAeI,EACpE,EAOAS,+CAAgD,SAAU9L,EAAoBqL,GAC7E,IAAK,IAAIU,EAAI,EAAGA,EAAI/L,EAASG,OAAQ4L,IAAK,CACzC,MAAMpC,EAAiB3J,EAAS+L,GAGhC,MAAMC,EAA0BrC,EAChC,GAAIqC,EAAwBhM,UAAYgM,EAAwBhM,SAASG,OAAS,EAAG,CAEpF2D,KAAKgI,+CAA+CE,EAAwBhM,SAAUqL,GACtF,QACD,CAEA,MAAMY,EAAiCtC,EAAOuC,UAC9C,MAAMC,EAA6CxC,EAAOyC,cAC1D,MAAMC,EAAwB1C,EAAO2C,YAGrC,GAAIH,IAAmB9L,UAAW,CACjCkM,EAAIC,QACH,4GACA,eAAeP,oBAA6BI,KAE7C,QACD,CAEA,GAAIF,IAAmB,MAAQE,IAAiBhM,WAAagM,IAAiB,KAAM,CAEnF,GAAIJ,GAAcZ,EAAoBoB,IAAIR,GAAa,CACtD,MAAMS,EAAmC5I,KAAK6I,oCAAoChD,GAClF,GAAI+C,EAAmB,CACtB1M,EAAS+L,GAAKW,CACf,CACD,CACD,MAAO,GAAIP,IAAmB,MAAO,CACpC,MAAMS,EAAejD,EAAOkD,eAC5B,IAAKD,EAAc,CAClB,QACD,CAGA,MAAME,EAAqCF,EAC3C,GAAIE,EAAmC9M,UAAY8M,EAAmC9M,SAASG,OAAS,EAAG,CAE1G,IAAI4M,EAAoB,MAExB,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAmC9M,SAASG,OAAQ6M,IAAK,CAC5E,MAAMC,EAAoBH,EAAmC9M,SAASgN,GAGtE,MAAME,EAAuBD,EAC7B,GAAIC,EAAqBlN,UAAYkN,EAAqBlN,SAASG,OAAS,EAAG,CAE9E2D,KAAKgI,+CAA+CoB,EAAqBlN,SAAUqL,GACnF,QACD,CAEA,MAAM8B,EAAoCF,EAAUf,UACpD,MAAMkB,EAAgDH,EAAUb,cAChE,MAAMiB,EAA2BJ,EAAUX,YAG3C,GAAIc,IAAsB/M,UAAW,CACpCkM,EAAIC,QACH,4GACA,eAAeW,oBAAgCE,KAEhD,QACD,CAEA,GAAID,IAAsB,MAAQC,IAAoBhN,WAAagN,IAAoB,KAAM,CAE5F,MAAMC,EAA4CvC,MAAMwC,KAAKlC,GAAqBvE,KAAK,SACtFyE,GAGA,MAAMiC,EAAsBjC,EAAekC,MAAM,KACjD,GAAID,EAAUrN,SAAW,EAAG,CAC3B,MAAMuN,EAAyBF,EAAU,GAAGG,QAAQ,IAAK,IACzD,MAAMC,EAAuBJ,EAAU,GAGvC,OAAOvB,IAAeyB,GAAkBG,QAAQV,GAAeW,SAASF,GACzE,CACA,OAAO,KACR,GAEA,GAAIN,EAAuB,CAC1B,MAAMS,EAAsCjK,KAAK6I,oCAAoCM,GACrF,GAAIc,EAAsB,CACzBjB,EAAmC9M,SAASgN,GAAKe,EACjDhB,EAAoB,IACrB,CACD,CACD,CACD,CAGA,GAAIA,EAAmB,CACtB/M,EAAS+L,GAAK,IAAI3L,EAAO,CACxB4N,KAAM/B,EACNjF,SAAU,MACViH,SAAUtE,EAAOuE,cACjBnH,UAAW,IAAI3G,EAAO,CACrBF,QAAS4M,EAAmC9M,SAC5C6K,IAAKiC,EAAmCqB,MAAQ,QAGnD,CACD,KAAO,CAEN,MAAMC,EAAuCxB,EAAaV,UAC1D,MAAMmC,EAAmDzB,EAAaR,cAEtE,MAAMkC,EAA8B1B,EAAaN,YAIjD,GAAI+B,IAAyBhO,UAAW,CACvCkM,EAAIC,QACH,4GACA,eAAe4B,oBAAmCE,KAEnD,QACD,CAEA,GAAID,IAAyB,MAAQC,IAAuBjO,WAAaiO,IAAuB,KAAM,CAErG,MAAMhB,EAA4CvC,MAAMwC,KAAKlC,GAAqBvE,KAAK,SACtFyE,GAGA,MAAMiC,EAAsBjC,EAAekC,MAAM,KACjD,GAAID,EAAUrN,SAAW,EAAG,CAC3B,MAAMuN,EAAyBF,EAAU,GAAGG,QAAQ,IAAK,IACzD,MAAMC,EAAuBJ,EAAU,GAGvC,OAAOvB,IAAeyB,GAAkBG,QAAQO,GAAkBN,SAASF,GAC5E,CACA,OAAO,KACR,GAEA,GAAIN,EAAuB,CAC1B,MAAMiB,EAAyCzK,KAAK6I,oCAAoCC,GACxF,GAAI2B,EAAyB,CAE5BvO,EAAS+L,GAAK,IAAI3L,EAAO,CACxB4N,KAAM/B,EACNjF,SAAU,MACViH,SAAUtE,EAAOuE,cACjBnH,UAAWwH,GAEb,CACD,CACD,CACD,CACD,CACD,CACD,EAOA5B,oCAAqC,SAAUhD,GAC9C,MAAM6E,EAAoC7E,EAAO2C,aAAa7F,WAE9D,IAAK+H,EAAe,CACnB,OAAO,IACR,CAGA,MAAMC,EAAyCD,EAAcE,MAC5D,8EAGD,GAAID,EAAe,CAClB,MAAME,EAAuBF,EAAc,GAC3C,MAAMG,EAAmBH,EAAc,GAGvC,MAAMI,EAAa,GAAGF,YAAuBC,IAC7C,MAAME,EAAW,GAAGH,YAAuBC,IAG3C,OAAO,IAAIxO,EAAO,CACjB4N,KAAMrE,EAAOuC,UACblF,SAAU+H,EAAeC,GACzBC,OAAQJ,EACRK,OAAQJ,GAEV,CAEA,OAAO,IACR,EACAnE,8BAA+B,SAAUzK,GACxC,OAAOA,EAAQiP,KAAMxF,IACpB,GAAIA,EAAOuC,YAAc,aAAc,CACtC,OAAO,IACR,MAAO,GAAIvC,EAAOyF,eAAiB/O,UAAW,CAC7C,OAAOyD,KAAK6G,8BAA8BhB,EAAOyF,aAClD,KAAO,CACN,OAAO,KACR,GAEF,EACAxE,mCAAoC,SAAUf,EAAyB3J,GACtE,OAAOA,EAAQmP,IAAK1F,IACnB,GAAIA,EAAOuC,YAAc,aAAc,CACtC,OAAOrC,CACR,MAAO,GAAIF,EAAOyF,eAAiB/O,UAAW,CAC7CsJ,EAAS,IAAIvJ,EAAO,CACnBF,QAAS4D,KAAK8G,mCAAmCf,EAAiBF,EAAOyF,cACzEvE,IAAKlB,EAAO2F,UAEb,OAAO3F,CACR,CACA,OAAOA,GAET,EACAjF,0BAA2B,SAAU6K,GACpC,GAAIA,GAAeA,EAAYpP,OAAQ,CACtCoP,EAAYhH,QAAQ,SAAUiH,GAC7B,GACCA,EAAiBxK,YACjBwK,EAAiBxK,WAAW0G,cAC3B8D,EAAiBxK,WAAW0G,aAA+C+D,0BAA0BC,SACrG,CACD,MACD,CACA,GAAIF,EAAiBxB,OAAS,aAAc,CAC3CwB,EAAiBxK,WAAaC,EAAQC,cAAc,iCAAkC,CAAC,EAAG,CAAC,EAC5F,MAAO,GAAIsK,EAAiBxB,OAAS,UAAW,CAC/CwB,EAAiBxK,WAAaC,EAAQC,cAAc,iCAAkC,CAAC,EAAG,CAAC,EAC5F,MAAO,GAAIsK,EAAiBrK,UAAaqK,EAAiBxK,YAAcwK,EAAiBxK,WAAWY,UAAY,CAC/G4J,EAAiBxK,WAAaC,EAAQC,cACrCsK,EAAiBrK,UAAYqK,EAAiBxK,YAAYY,UAC1D4J,EAAiBpK,cACjBoK,EAAiBnK,YAEnB,CACD,EACD,CACA,OAAOkK,CACR,EACAI,wBAAyB,SAAU7E,EAAuB8E,GACzD,MAAMC,EAAwBD,EAAS1J,KAAK,cAC3C4J,EAAuBhF,EAAW5E,KAAK,cACvC3D,EAAauI,EAAWtI,WAAYC,eACpCsN,EAAiCxN,EAAWyN,UAAUF,GACtDG,EAAiB,GACjB3L,EAAcwG,EAAWoF,gBACzBC,EAAyBN,IAA0BC,EACnDM,EAAWR,EAASxN,IAAW,oBAC/BiO,GAAsBD,GAAaR,EAASU,YAAyBC,qBAAqBC,gBAC1FC,GAAgBL,GAAaR,EAASU,YAAyBC,qBAAqBG,QAAQC,OAAS,YACrGC,EAAgBR,EACZS,EAAaC,gBAAgB9O,EAAaC,cAAc2N,EAAU,mBAClEmB,eACCV,GAAsBI,IAAkBb,EAASU,YAAyBC,qBAAqBS,kBAErG,GAAI1M,KAAiB6L,GAA0BE,GAAsBD,GAAYK,GAAe,CAE/F,MAAMQ,EAAoBd,EACtB,GACCrF,EACA/B,qBACAC,yBAAyB6G,EAAuBtN,EAAYuI,GAChEoG,EAAoBD,EAAkBE,OAAO,SAAUC,EAAwCC,GAC9FD,EAAMC,EAAMhO,MAAQgO,EACpB,OAAOD,CACR,EAAG,CAAC,GACJE,EAAiD,CAAC,EACnD,MAAMC,EAA6B3B,EACjCpN,WACAC,eACAuN,UAAUJ,EAAS1J,KAAK,wBAA0B,KACpD,GAAI0J,EAASxN,IAAI,oBAAqB,CACrC,MAAMoP,EAAwB5B,EAC3BpN,WACAC,eACAuN,UAAU,GAAGJ,EAAS1J,KAAK,4BAC7BuL,EAAyBC,EAAuBF,GACjDnJ,OAAOC,KAAKmJ,GAAwBlJ,QAAQ,SAAUoJ,GACrD,IAAKL,EAAsBK,GAAiB,CAC3C,MAAMC,EAAaH,EAAuBE,GAC1CL,EAAsBK,GAAkBC,CACzC,CACD,EACD,CAEA,IAAK,MAAMC,KAAavN,EAAa,CAEpC,MAAMwN,EAAqBxN,EAAYuN,GACvC,IAAIE,EAAY,KAChB,GAAIR,EAA2BM,IAAc9B,EAA+B8B,GAAY,CACvFE,EAAYR,EAA2BM,GAAW,WAAa9B,EAA+B8B,GAAW,QAC1G,CACA,GACC9G,MAAMC,QAAQ8G,IACdA,EAAmB3R,OAAS,MACxB+Q,EAAkBW,IACpBX,EAAkBW,GAAWG,gBAAkBd,EAAkBW,GAAW5Q,gBAAkBZ,WAC9F6Q,EAAkBW,KAAeE,MAChC5B,GAA2B0B,IAAc,eAAiBzB,GAAYK,GAAgBJ,KACxFiB,EAAsBO,IACtB,CACD5B,EAAepK,KAAKgM,EAAUlE,QAAQ,SAAU,IACjD,CACD,CACD,CACA,IAAKiD,GAAiB9F,EAAWmH,YAAa,CAC7ChC,EAAepK,KAAK,UACrB,CACA,OAAOoK,CACR,EAQA,uBAAMiC,CAAkBC,EAAsBC,GAC7C,MAAMvQ,EAAYsQ,EAAU3P,YAAYC,eAExC,IAAKZ,EAAW,CACf,OAAOxB,SACR,CAEA,MAAMI,EAAa0R,EAAUjM,KAAK,eAAiB,GACnD,MAAMmM,QAAuBxQ,EAAUyQ,qBAAqB7R,EAAa2R,EAAc,MAAMG,MAAM,IAAM,MACzG,OAAOF,IAAiB,GACzB,EAOAnK,sBAAsBiK,GACrB,IAAIK,EAAgBL,EAAUjM,KAAK,gBACnC,UAAWsM,IAAkB,SAAU,CACtCA,EAAgB/J,KAAKC,MAAM8J,EAC5B,CACA,OAAOA,GAAiB,EACzB,EAaAC,uBAAwBC,eACvBC,EACAP,EACAQ,GAEA,IAAKD,EAAe,CACnB,OAAOE,EAAmBC,YAC3B,CAEA,IACC,MAAMC,EAAsBJ,EAAcK,WAAWrJ,OAAQsJ,GAC5D,CAAC,yDAA8CC,UAAW,uDAA4CA,WAAWjM,SAChHgM,EAAUE,QAGVxJ,OAAQsJ,GAAcA,EAAUG,mBAAmBC,gBAAkBjB,GACrE/C,IAAK4D,GAAcA,EAAUK,mBAE/B,MAAMC,EAAwBR,EAAoB,IAAMX,EAExD,MAAMzI,EAAS,IAAIvJ,EAAO,CACzB4N,KAAMuF,EACNvM,SAAU+H,EAAeyE,GACzBvE,OAAQ2D,IAET,MAAMa,EAAcd,EAAce,OAAOC,SAAS,IAAIhB,EAAciB,iBAAkBvT,UAAWA,UAAWsJ,EAAQ,CACnHkK,QAASN,IAGV,MAAMO,SAAqBL,EAAYM,mBAAmB5T,OAAS,EACnE,GAAI2T,EAAa,CAChB,OAAOjB,EAAmBmB,SAC3B,KAAO,CACN,OAAOnB,EAAmBC,YAC3B,CACD,CAAE,MAAOmB,GACR1H,EAAI0H,MAAM,yDAA0DA,GACpE,OAAOpB,EAAmBC,YAC3B,CACD,EAOA,uBAAMoB,CAAkB/B,EAAsBgC,GAC7C,MAAMC,QAAeC,EAAUC,sBAAsBnC,GACrD,GAAIiC,EAAOzK,OAAOwK,GAAgB,CACjCC,EAAOzK,OAAOwK,GAAe5L,QAAS1B,IACrCA,EAAW0N,SAAW,cAEjBF,EAAUG,mBAAmBrC,EAAW,CAAExI,OAAQ,CAAEwK,CAACA,GAAgBC,EAAOzK,OAAOwK,KAC1F,CACD,EAYAM,gBAAiB/B,eAAgB5H,EAAmCS,GAA2D,QAAAmJ,EAAAC,UAAAxU,OAAhCyU,EAAI,IAAA7J,MAAA2J,EAAA,EAAAA,EAAA,KAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAA,CAAJD,EAAIC,EAAA,GAAAF,UAAAE,EAAA,OAC5F/Q,KAAKgR,iBAAiBhK,EAAY,MAAOS,KAAmBqJ,EACnE,EAWAG,gBAAiBrC,eAAgBP,EAAkCgC,GAA0D,QAAAa,EAAAL,UAAAxU,OAAhCyU,EAAI,IAAA7J,MAAAiK,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA,CAAJL,EAAIK,EAAA,GAAAN,UAAAM,EAAA,OAC1FnR,KAAKgR,iBAAiB3C,EAAW,KAAMgC,KAAkBS,EAChE,EASAM,iCAAiCf,GAChC,OAAOA,EAAcxG,QAAQ/N,EAAuC,GACrE,EAOAuV,iCAAiCC,GAChC,MAAOA,IAAuBA,EAAmBhT,IAAe,wBAAyB,CACxFgT,EAAqBA,EAAmB9E,WACzC,CACA,OAAO8E,CACR,EAUAC,kCAAkClD,EAAsB5R,GACvD,MAAM+U,EAAiBtT,EAAaC,cAAsBkQ,EAAW,cACrE,MAAMtQ,EAAYsQ,EAAU3P,YAAYC,eACxC,OAAOI,EAAmBC,4BACzBjB,EAAUkB,qBAAqB,GAAGuS,IAAiB/U,KACnDsB,EAAUkB,qBAAqB,GAAGuS,KAEpC,EAEAR,iBAAkBpC,eACjB5H,EACAyK,EACAhK,GAEgB,QAAAiK,EAAAb,UAAAxU,OADbyU,EAAI,IAAA7J,MAAAyK,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA,CAAJb,EAAIa,EAAA,GAAAd,UAAAc,EAAA,CAEP,IAAIC,EAAYd,IAAO,GACvB,IAAIe,EAAUf,IAAO,GAGrB,IAAK9J,EAAY,CAChB,MACD,CAIA,GACC8J,EAAKzU,SAAW,IACfwV,IAAYtV,WAAasV,IAAY,MAAQA,IAAY,KAC1DD,GACArN,OAAOC,KAAKyG,GAAgB9H,SAASyO,GACpC,CACDnJ,EAAIC,QAAQ,oDAAoDkJ,cAChE,MACD,CAIA,GAAIC,IAAYtV,YAAcuV,EAAsBC,4BAA4B5O,SAASyO,GAAa,IAAK,CAC1GC,EAAUD,GAAa,GACvBA,EAAYrV,SACb,CAGA,IAAKqV,EAAW,CACfA,EAAY3G,EAAeyE,EAC5B,CAQA,MAAMsC,EAAsB,CAAC,SAAU,SAAU,WACjD,GACCH,IAAYtV,aACT0K,MAAMC,QAAQ2K,KAAaG,EAAoB7O,gBAAgB0O,IAChE5K,MAAMC,QAAQ2K,IAAYA,EAAQxV,OAAS,IAAM2V,EAAoB7O,gBAAgB0O,EAAQ,KAC9F,CACD,MAAM,IAAII,MACT,sHAEF,CACA,IAAI9P,EACJ,GAAI0P,IAAYtV,UAAW,CAC1B4F,EAAS8E,MAAMC,QAAQ2K,GAAWA,EAAU,CAACA,EAC9C,CAEA,MAAMhM,EAA+C,CAAC,EACtD,GAAI4B,EAAgB,CAGnB,MAAMhL,EAAeV,EAAaqV,iCAAiC3J,GACnE,MAAMyK,EAAuBnW,EAAasV,iCAAiCrK,IAAeA,EAC1F,MAAMmL,EAA2BpW,EAAawV,kCAAkCW,EAAsBzV,GACtG,MAAM6R,EAAe6D,GAA0B7U,cAAciC,MAAQ9C,EACrEgL,GACE0K,EAA2BC,EAAmCD,EAA0B,MAAO,MAAQ5V,YACxGkL,EAED,MAAMoH,QAAsB7O,KAAKoO,kBAAkB8D,EAAsBzV,GACzE,GAAI0F,GAAUA,EAAO9F,OAAQ,CAC5B,GAAIuV,IAAc3G,EAAeC,GAAI,CAEpCrF,EAAO4B,GAAkB,CAAC4K,EAAUC,gBAAgBV,EAAWzP,EAAQ,KAAM,KAAM4M,EAAmBC,cACvG,KAAO,CAENnJ,EAAO4B,SAAwB8K,QAAQC,IACtCrQ,EAAOoJ,IAAIqD,UAEV,MAAM6D,EACLb,IAAc3G,EAAeyE,SACpB1P,KAAK2O,uBAAuBE,EAAeP,EAAcQ,GAC/DC,EAAmBC,aAEvB,OAAOqD,EAAUC,gBAAgBV,EAAY,CAAC9C,GAAQ,KAAM,KAAM2D,KAGrE,CACD,MAAO,GAAIX,EAAsBC,4BAA4B5O,SAASyO,GAAa,IAAK,CAEvF/L,EAAO4B,GAAkB,CAAC4K,EAAUC,gBAAgBV,EAAW,GAAI,KAAM,KAAM7C,EAAmBC,cACnG,CACD,CAEA,IAAKyC,EAAQ,OAENzR,KAAKoQ,kBAAkBpJ,EAAYS,EAC1C,CAEA,GAAI5B,EAAO4B,GAAiB,OAErB8I,EAAUG,mBAAmB1J,EAAY,CAAEnB,UAClD,CACD,EACA6M,qBAAsB,SAAUjL,GAE/B,OAAOA,EAAeoC,QAAQ,MAAO,KACtC,EACA5J,oBAAqB,SAAUpC,EAAgCE,GAC9D,OAAOA,GAAcF,EAAea,WAAYC,cACjD,EACAgU,kBAAmB,SAAU7U,GAC5B,OAAOA,GAAmB8U,EAAYC,iBAAiB/U,EACxD,EAEAqC,mBAAoB,SAAUtC,EAAgCC,GAC7D,MAAMoC,EAAiC,GAOvC,GAAIpC,EAAiB,CACpB,MAAMO,EAAQE,EAAYC,cAAcX,GACxC,MAAMiV,EACLzU,GACAA,EAAM0U,iBACL1U,EAAM0U,gBAAyCC,cAC/C3U,EAAM0U,gBAAyCC,aAAa,SAC9D,GAAIF,EAAe,CAClBA,EAAcrO,QAAQ,SAAUwO,GAC/B/S,EAAS6B,KAAMkR,EAAOzG,YAAyBC,qBAChD,EACD,CACA,OAAOvM,CACR,CACA,MAAO,EACR,EACAG,oBAAqB,SACpBxC,EACAC,EACAG,EACAG,EACA8B,EACAzB,EACA2B,EACAP,EACAC,EACAC,EACA5C,GAEA,MAAM+V,EAAetW,EAAmBuW,mBACvC/S,EACAF,EACA/C,EACA0C,EACAE,GAED,IAAIqT,EAAiCF,EAAaE,gBAClD,MAAMC,EAAiBxV,EAA2CuE,KAC/DpC,KAAKoE,sBAAsBvG,GAC3B8G,KAAKC,MAAMsO,EAAaI,cAAczJ,QAAQ,QAAS,KAAKA,QAAQ,QAAS,MAChF,IACE/J,EACEA,EAAUyT,eAAe1V,KAAoB,uBAC7CA,EAAeS,IAAI,0BACtBR,IAAoBG,EACnB,CAKD,MAAMa,EAA2BC,EAAmBC,4BAA4BP,EAAWQ,qBAAqBb,IAChH,MAAMoV,EAAepT,EAAkBlD,uBAAuBe,GAC9D,MAAMwV,EACLD,EAAaE,wBAAyC,+CAA+CC,YACpG,GACF,MAAMC,EAA8C,CAAC,EACrDR,EAAgB3O,QAAQ,SAAUoP,GACjCD,EAAmBC,EAAgBxD,eAAiB,IACrD,GAEAoD,EAAoChP,QAAQ,SAAUqP,GACrD,MAAMC,EAAQD,EAAmChF,MACjD,IAAK8E,EAAmBG,GAAQ,CAC/B,MAAMC,EAAepX,EAAmBJ,eACvCuX,EACA3T,EACAtB,EAAyBQ,kBAAkB3C,YAE5C,GAAIqX,EAAc,CACjBZ,EAAgBrR,KAAKiS,EACtB,CACD,CACD,EACD,CACA,GAAIZ,EAAiB,CACpB,MAAMa,EAAuB,GAC7Bb,EAAgB3O,QAAQ,SAAUyP,GACjCD,EAAWlS,KAAKmS,EAAOxW,IACxB,GACA0V,EAAkBpT,KAAKmU,qCAAqCF,EAAYb,EAAiBC,EAC1F,CACA,OAAOD,CACR,EASAe,qCAAsC,SACrCF,EACAb,EACA1L,GAEAA,EAAajD,QAAQ,SAAU8I,GAC9B,GAAIA,EAAMhO,OAAS,WAAagO,EAAMhO,OAAS,cAAgBgO,EAAM7P,MAAQnB,UAAW,CACvF,MACD,CAEA,MAAM6X,EAAWhB,EAAgBa,EAAWI,QAAQ9G,EAAM7P,MAC1D,GAAIuW,EAAW9Q,SAASoK,EAAM7P,MAAQ0W,EAASjX,eAAgB,CAC9DoQ,EAAM+G,MAAQF,EAASE,MACvB/G,EAAMgH,WAAaH,EAASG,WAC5BhH,EAAMiH,SAAWJ,EAASI,SAC1BjH,EAAMkH,aAAeL,EAASK,aAC9BlH,EAAMmH,MAAQnH,EAAMmH,MAAQnH,EAAMmH,MAAQN,EAASM,MACnDnH,EAAMpQ,eAAiBoQ,EAAMpQ,gBAAkBiX,EAASjX,eACxDiW,EAAgBa,EAAWI,QAAQ9G,EAAM7P,MAAQ6P,CAClD,CAEA,IAAK0G,EAAW9Q,SAASoK,EAAM7P,OAAS6P,EAAMpQ,eAAgB,CAC7DiW,EAAgBrR,KAAKwL,EACtB,CACD,GACA,OAAO6F,CACR,EACAlP,gBAAiB,SAAU3D,EAAmC+C,GAC7D,OAAO/C,EAAS4N,YAAc7K,EAAkBH,SAAS,UAAY5C,EAAS4N,YAAc,IAC7F,EACAhK,qBAAsB,SACrBf,EACAC,EACA9C,GAEA,MAAMC,EAAc6C,GAAqB9C,EAAS6L,gBAClD,GAAIhJ,GAAeA,EAAYK,eAAiBL,EAAYK,cAAcnF,IAAI,oBAAqB,CAClGiG,OAAOC,KAAKhE,GAAaiE,QAAQ,SAAUC,GAC1C,GAAIA,IAAS,aAAc,QACnBlE,EAAY,aACpB,CACD,EACD,CACA,OAAOA,CACR,EACA8D,6BAA8B,SAC7B7D,EACAF,GAEA,KAAME,GAA6BA,EAA0BpE,QAAS,CACrE,GAAIkE,EAASoU,gBAAiB,CAC7BlU,EAA4BF,EAASoU,iBACtC,KAAO,CACNlU,EAA4B,IAC7B,CACD,CACA,OAAOA,CACR,EACA2E,sBAAuB,SAAUwP,EAA0CC,GAC1E,MAAMC,EAA6B,GACnCF,EAAyBnQ,QAAQ,SAAUsQ,GAC1C,MAAMC,EAAqBD,EAAexV,KAC1C,MAAM0V,EAA0BJ,EAAiB7R,KAAMkS,GAAWA,EAAO3V,OAASyV,GAClF,GACCC,KACGF,EAAe7G,gBAAkB6G,EAAe1T,WAAa4T,EAAwB5T,UAEtF0T,EAAe7G,gBAAkB+G,EAAwB9X,iBAAmBZ,WAC7E,CACDuY,EAAiB/S,KAAKiT,EACvB,CACD,GACA,OAAOF,CACR,EACAxJ,WAAY,SAAU+C,GACrB,IAAKA,UAAoBA,EAAU8G,gBAAkB,aAAe9G,EAAU8G,gBAAiB,CAC9F,MACD,CACA,MAAM5P,WAAEA,EAAUnJ,QAAEA,EAAOoJ,OAAEA,GAAWxF,KAAK7D,cAAckS,GAC3D,MAAO,CAAE9I,aAAYnJ,UAASoJ,SAC/B,EAMA4P,mBAAoB,SAAU/B,GAC7B,UAAWA,IAAkB,SAAU,CACtC,IAAIgC,EAAWhC,EAAcxJ,QAAQ,QAAS,KAC9CwL,EAAWA,EAASxL,QAAQ,QAAS,KACrC,IAAIyL,EAAY3Q,KAAKC,MAAMyQ,GAC3BC,EAAYtV,KAAKuV,oBAAoBD,GACrC,IAAIE,EAA2B7Q,KAAK8Q,UAAUH,GAC9CE,EAA2BA,EAAyB3L,QAAQ,MAAO,OACnE2L,EAA2BA,EAAyB3L,QAAQ,MAAO,OACnE,OAAO2L,CACR,KAAO,CACN,OAAOxV,KAAKuV,oBAAoBlC,EACjC,CACD,EAMAkC,oBAAqB,SAAUlC,GAC9B,OAAOA,EAAc9H,IAAKzF,IACzB,MAAM4I,EAAsC,CAC3ChR,IAAKoI,EAASpI,KAAOoI,EAASvG,KAC9B8B,SAAU,GACVqT,MAAO,IAER,IAAK,MAAMhX,KAAO7B,EAAkB,CACnC,GAAIiK,EAASE,eAAetI,GAAM,CACjC,OAAQA,GACP,IAAK,eACJgR,EAAcgH,aAAe5P,EAAS4P,aACtC,MACD,IAAK,WACJhH,EAAciH,SAAW7P,EAAS6P,SAClC,MACD,IAAK,OACJjH,EAAcxE,KAAOpE,EAASoE,KAC9B,MACD,IAAK,UACJwE,EAAckH,QAAU9P,EAAS8P,QACjC,MACD,IAAK,UACJlH,EAAcmH,QAAU/P,EAAS+P,QACjC,MACD,IAAK,gBACJnH,EAAcoH,cAAgBhQ,EAASgQ,cACvC,MACD,IAAK,gBACJpH,EAAcpN,cAAgBwE,EAASxE,cACvC,MACD,IAAK,cACJoN,EAAcnN,YAAcuE,EAASvE,YACrC,MACD,IAAK,QACJmN,EAAc4F,MAAQxO,EAASwO,MAC/B,MACD,IAAK,aACJ5F,EAAc6F,WAAazO,EAASyO,WACpC,MACD,IAAK,gBACJ7F,EAAcqH,cAAgBjQ,EAASiQ,cAE1C,CACD,CACA,GAAIjQ,EAASzE,SAAU,CACtBqN,EAAcrN,SAAWyE,EAASzE,QACnC,KAAO,CACN,MAAM,IAAI4Q,MAAM,oEAAoEnM,IACrF,CACA,GAAIA,EAAS4O,MAAO,CACnBhG,EAAcgG,MAAQ5O,EAAS4O,KAChC,CACA,OAAOhG,GAET,GACC,OAEa3S,CAAY","ignoreList":[]}