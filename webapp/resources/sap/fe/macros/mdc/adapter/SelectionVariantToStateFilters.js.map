{"version":3,"file":"SelectionVariantToStateFilters.js","names":["IGNORED_PROPERTYNAMES","getPropertyObjectPath","filteredPropertyPath","metaModel","metaContext","createBindingContext","getInvolvedDataModelObjects","targetObject","undefined","prefillDescriptionInFilter","filter","propertyObjectPath","selectionVariant","length","operator","textProperty","annotations","Common","Text","isPathAnnotationExpression","selectOnText","getSelectOption","path","Option","Sign","values","push","Low","ValueListWithFixedValues","valueOf","selectionVariantToStateFilters","getStateFiltersFromSV","controlInfoForConversion","controlPropertyInfos","prefillDescriptions","contextPath","conditions","forEach","propertyMetadata","includes","name","filterPathConditions","conditionPath","annotationPath","propPath","replaceAll","navPath","substring","lastIndexOf","propertyName","propertyConversionInfo","propertyContextPath","controlInfo","isParameter","_getConditionsForParameter","_getConditionsForNavProperty","_getConditionsForProperty","_adjustValueListWithFixedValuesCondition","getStateToApply","propertyInfos","items","Object","keys","reduce","cummulativeItems","propertyInfo","FilterUtil","getPropertyByKey","hiddenFilter","_getPropertyFilterConfigurationSetting","property","filterFieldsConfig","settings","conditionObjects","selectOptionName","_getSelectOptionName","_getPropertyConditions","conditonPath","selectOptionPathPrefix","navigationPath","possibleSelectOptionNames","selectOptionsPropertyNames","getSelectOptionsPropertyNames","startsWith","slice","temp1","temp2","some","testName","pathToCheck","_getMaxConditions","completePropertyPath","propertyContext","maximumConditions","maxConditions","context","selectOptions","semanticDateOperators","_getSemanticDateOperators","propertyEntitySetPath","validOperators","CommonHelper","getOperatorsForProperty","this","_getConditionsFromSelectOptions","useSemanticDateRange","filterSettings","ODATA_TYPE_MAPPING","dataType","singleCondition","_addConditionFromSelectOption","bind","cumulativeConditions","selectOption","hasValueHelp","allSupportedOperators","edmType","_getEdmType","condition","getConditions","SemanticDates","semanticDates","_addSemanticDatesToConditions","high","low","isEmpty","TYPE_EDM_MAPPING","fromEntries","entries","EDM_TYPE_MAPPING","map","_ref","k","v","type","validated","ConditionValidated","Validated"],"sources":["./SelectionVariantToStateFilters.ts"],"sourcesContent":["import type { Property } from \"@sap-ux/vocabularies-types\";\nimport { EDM_TYPE_MAPPING } from \"sap/fe/base/BindingToolkit\";\nimport type {\n\tFilterFieldManifestConfiguration,\n\tFilterManifestConfiguration,\n\tFilterSettings\n} from \"sap/fe/core/converters/ManifestSettings\";\nimport { getInvolvedDataModelObjects } from \"sap/fe/core/converters/MetaModelConverter\";\nimport { isPathAnnotationExpression } from \"sap/fe/core/helpers/TypeGuards\";\nimport { ODATA_TYPE_MAPPING } from \"sap/fe/core/templating/DisplayModeFormatter\";\nimport CommonHelper from \"sap/fe/macros/CommonHelper\";\nimport { maxConditions } from \"sap/fe/macros/filter/FilterFieldHelper\";\nimport { getConditions } from \"sap/fe/macros/filterBar/FilterHelper\";\nimport type { ControlPropertyInfo } from \"sap/fe/macros/mdc/adapter/StateHelper\";\nimport type SelectionVariant from \"sap/fe/navigation/SelectionVariant\";\nimport type { SelectOption, SemanticDateConfiguration } from \"sap/fe/navigation/SelectionVariant\";\nimport type { ConditionObject } from \"sap/ui/mdc/condition/Condition\";\nimport ConditionValidated from \"sap/ui/mdc/enums/ConditionValidated\";\nimport type { StateToApply, Filter as StateUtilFilter } from \"sap/ui/mdc/p13n/StateUtil\";\nimport FilterUtil from \"sap/ui/mdc/util/FilterUtil\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\nexport type FilterFieldsConfig = Record<string, FilterFieldManifestConfiguration>;\n\nexport type ConversionInfo = {\n\tmetaModel: ODataMetaModel;\n\tcontextPath: string;\n\tuseSemanticDateRange?: boolean;\n\tfilterFieldsConfig?: FilterFieldsConfig;\n\tselectionFieldsConfigs?: FilterManifestConfiguration;\n\tnavigationProperties?: string[];\n\tshowClearButton?: boolean;\n};\n\ntype PropertyConversionInfo = {\n\tpropertyName: string;\n\tnavPath: string;\n\tpropertyMetadata: ControlPropertyInfo;\n\tpropertyContextPath: string;\n\tselectionVariant: SelectionVariant;\n\tcontrolInfo: ConversionInfo;\n};\n\nconst IGNORED_PROPERTYNAMES: string[] = [\"$search\", \"$editState\"];\n\nfunction getPropertyObjectPath(filteredPropertyPath: string, metaModel: ODataMetaModel): Property | undefined {\n\tconst metaContext = metaModel.createBindingContext(filteredPropertyPath);\n\treturn metaContext !== null ? (getInvolvedDataModelObjects(metaContext).targetObject as Property) : undefined;\n}\n\n/**\n * Function to add the description of a code in a filter (to avoid fetching it with a query).\n * @param filter The filter to update\n * @param propertyObjectPath Property object path\n * @param selectionVariant The whole selection variant where we look for the description\n */\nfunction prefillDescriptionInFilter(filter: ConditionObject[], propertyObjectPath: Property, selectionVariant: SelectionVariant): void {\n\tif (filter.length !== 1 || filter[0].operator !== \"EQ\") {\n\t\t// We search for text properties only for single-value filters\n\t\treturn;\n\t}\n\n\tconst textProperty = propertyObjectPath.annotations.Common?.Text;\n\tif (textProperty && isPathAnnotationExpression(textProperty)) {\n\t\t// Search for the Text value in the selection variant definition\n\t\tconst selectOnText = selectionVariant.getSelectOption(textProperty.path);\n\t\tif (selectOnText?.length === 1 && selectOnText[0].Option === \"EQ\" && selectOnText[0].Sign === \"I\") {\n\t\t\t// Adding a second value in the condition will be interpreted as the Text value by the field\n\t\t\t// In case this value is empty, we use \" \"\n\t\t\tfilter[0].values.push(selectOnText[0].Low.length >= 1 ? selectOnText[0].Low : \" \");\n\t\t}\n\t}\n\tif (\n\t\tfilter[0].values.length === 1 &&\n\t\tfilter[0].values[0] === \"\" &&\n\t\tpropertyObjectPath.annotations.Common?.ValueListWithFixedValues?.valueOf() !== true\n\t) {\n\t\t// Special case: an empty property value was provided in the selection variant, and the VH is not with fixed values\n\t\t// --> we use a default string for the description (empty string doesn't work)\n\t\tfilter[0].values.push(\" \");\n\t}\n}\n\nconst selectionVariantToStateFilters = {\n\t/**\n\t * Get conditions from the selection variant.\n\t * @param selectionVariant Selection variant\n\t * @param controlInfoForConversion Control information needed for the conversion of the selection variant to conditions\n\t * @param controlPropertyInfos Property information of the filterbar\n\t * @param prefillDescriptions\n\t * @param metaModel\n\t * @returns Conditions after conversion of selection variant\n\t */\n\tgetStateFiltersFromSV: function (\n\t\tselectionVariant: SelectionVariant,\n\t\tcontrolInfoForConversion: ConversionInfo,\n\t\tcontrolPropertyInfos: ControlPropertyInfo[],\n\t\tprefillDescriptions: boolean,\n\t\tmetaModel: ODataMetaModel\n\t): StateUtilFilter {\n\t\tconst { contextPath } = controlInfoForConversion;\n\t\tconst conditions: StateUtilFilter = {};\n\n\t\tcontrolPropertyInfos.forEach(function (propertyMetadata: ControlPropertyInfo) {\n\t\t\tif (!IGNORED_PROPERTYNAMES.includes(propertyMetadata.name)) {\n\t\t\t\tlet filterPathConditions: ConditionObject[] = [];\n\t\t\t\tconst { conditionPath, annotationPath } = propertyMetadata;\n\t\t\t\tconst propPath = conditionPath.replaceAll(\"*\", \"\");\n\t\t\t\tconst navPath = propPath.substring(0, propPath.lastIndexOf(\"/\"));\n\t\t\t\tconst propertyName = propPath.substring(propPath.lastIndexOf(\"/\") + 1);\n\n\t\t\t\t// Note: Conversion parameters\n\t\t\t\tconst propertyConversionInfo: PropertyConversionInfo = {\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tnavPath,\n\t\t\t\t\tpropertyContextPath: `${contextPath}${navPath ? navPath + \"/\" : \"\"}`,\n\t\t\t\t\tpropertyMetadata,\n\t\t\t\t\tselectionVariant,\n\t\t\t\t\tcontrolInfo: controlInfoForConversion\n\t\t\t\t};\n\t\t\t\tif (propertyMetadata.isParameter && annotationPath) {\n\t\t\t\t\t// parameter\n\t\t\t\t\tpropertyConversionInfo.propertyContextPath = annotationPath.substring(0, annotationPath.lastIndexOf(\"/\") + 1);\n\t\t\t\t\tfilterPathConditions = selectionVariantToStateFilters._getConditionsForParameter(propertyConversionInfo);\n\t\t\t\t} else if (conditionPath.includes(\"/\")) {\n\t\t\t\t\t// navigation property\n\t\t\t\t\tfilterPathConditions = selectionVariantToStateFilters._getConditionsForNavProperty(propertyConversionInfo);\n\t\t\t\t} else {\n\t\t\t\t\t// normal property\n\t\t\t\t\tfilterPathConditions = selectionVariantToStateFilters._getConditionsForProperty(propertyConversionInfo);\n\t\t\t\t}\n\n\t\t\t\tif (filterPathConditions.length > 0) {\n\t\t\t\t\tconst propertyObjectPath = getPropertyObjectPath(annotationPath, metaModel);\n\t\t\t\t\tif (propertyObjectPath) {\n\t\t\t\t\t\tif (propertyObjectPath.annotations.Common?.ValueListWithFixedValues) {\n\t\t\t\t\t\t\t// In case of fixed values, we would convert Empty operator to EQ->''.\n\t\t\t\t\t\t\tfilterPathConditions.forEach(selectionVariantToStateFilters._adjustValueListWithFixedValuesCondition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (prefillDescriptions) {\n\t\t\t\t\t\t\tprefillDescriptionInFilter(filterPathConditions, propertyObjectPath, selectionVariant);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconditions[conditionPath] = filterPathConditions;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn conditions;\n\t},\n\n\t/**\n\t * Method returns filters and filterfield items to apply and add. Also checks whether the property is configured with hiddenFilter.\n\t * @param propertyInfos Property information of the control\n\t * @param conditions Condtions to apply as filters to the control\n\t * @returns The object containing filters and items.\n\t */\n\tgetStateToApply: (propertyInfos: ControlPropertyInfo[], conditions: StateUtilFilter): StateToApply => {\n\t\tconst items: Record<\"name\", string>[] = Object.keys(conditions).reduce(\n\t\t\t(cummulativeItems, path) => {\n\t\t\t\tconst propertyInfo = FilterUtil.getPropertyByKey(propertyInfos, path) as ControlPropertyInfo;\n\t\t\t\tif (propertyInfo.hiddenFilter === undefined || !propertyInfo.hiddenFilter) {\n\t\t\t\t\tcummulativeItems.push({\n\t\t\t\t\t\tname: path\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn cummulativeItems;\n\t\t\t},\n\t\t\t[] as Record<\"name\", string>[]\n\t\t);\n\t\treturn {\n\t\t\tfilter: conditions,\n\t\t\titems: items\n\t\t};\n\t},\n\n\t/**\n\t * Get the filter field configuration of a property.\n\t * @param property Filter field Path\n\t * @param filterFieldsConfig Manifest Configuration of the control\n\t * @returns The Filter Field Configuration\n\t */\n\t_getPropertyFilterConfigurationSetting: function (property: string, filterFieldsConfig?: FilterFieldsConfig): FilterSettings {\n\t\treturn filterFieldsConfig?.[property]?.settings ?? {};\n\t},\n\n\t/**\n\t * Create filter conditions for a parameter property.\n\t * @param propertyConversionInfo Property info used for conversion\n\t * @returns The filter condtions for parameter property\n\t */\n\t_getConditionsForParameter: function (propertyConversionInfo: PropertyConversionInfo): ConditionObject[] {\n\t\tlet conditionObjects: ConditionObject[] = [];\n\t\tconst { propertyMetadata, selectionVariant } = propertyConversionInfo;\n\t\tconst conditionPath = propertyMetadata.name;\n\t\tconst selectOptionName = selectionVariantToStateFilters._getSelectOptionName(selectionVariant, conditionPath, true);\n\t\tif (selectOptionName) {\n\t\t\tconditionObjects = selectionVariantToStateFilters._getPropertyConditions(propertyConversionInfo, selectOptionName, true);\n\t\t}\n\t\treturn conditionObjects;\n\t},\n\n\t/**\n\t * Create filter conditions for a normal property.\n\t * @param propertyConversionInfo Property info used for conversion\n\t * @returns The filter conditions for a normal property\n\t */\n\t_getConditionsForProperty: function (propertyConversionInfo: PropertyConversionInfo): ConditionObject[] {\n\t\tconst { propertyMetadata, selectionVariant } = propertyConversionInfo;\n\t\tconst conditonPath = propertyMetadata.name;\n\t\tconst selectOptionName = selectionVariantToStateFilters._getSelectOptionName(selectionVariant, conditonPath);\n\n\t\tlet conditionObjects: ConditionObject[] = [];\n\t\tif (selectOptionName) {\n\t\t\tconditionObjects = selectionVariantToStateFilters._getPropertyConditions(propertyConversionInfo, selectOptionName, false);\n\t\t}\n\t\treturn conditionObjects;\n\t},\n\n\t/**\n\t * Create filter conditions from navigation properties.\n\t * @param propertyConversionInfo Property info used for conversion\n\t * @returns The filter condtions for navigation property\n\t */\n\t_getConditionsForNavProperty: function (propertyConversionInfo: PropertyConversionInfo): ConditionObject[] {\n\t\tconst { controlInfo, selectionVariant, propertyName, navPath } = propertyConversionInfo;\n\t\tconst { contextPath } = controlInfo;\n\n\t\tlet conditionObjects: ConditionObject[] = [];\n\n\t\t// We check with '/SalesOrderManage/_Item/Name'.\n\t\t// '/SalesOrderManage/_Item' => 'SalesOrderManage._Item'\n\t\tlet selectOptionPathPrefix = `${contextPath.substring(1)}${navPath}`.replaceAll(\"/\", \".\");\n\t\tlet selectOptionName = selectionVariantToStateFilters._getSelectOptionName(\n\t\t\tselectionVariant,\n\t\t\tpropertyName,\n\t\t\tfalse,\n\t\t\tselectOptionPathPrefix\n\t\t);\n\n\t\tif (!selectOptionName) {\n\t\t\t// We check with '_Item/Name'.\n\t\t\tselectOptionPathPrefix = navPath.replaceAll(\"/\", \".\");\n\t\t\tselectOptionName = selectionVariantToStateFilters._getSelectOptionName(\n\t\t\t\tselectionVariant,\n\t\t\t\tpropertyName,\n\t\t\t\tfalse,\n\t\t\t\tselectOptionPathPrefix\n\t\t\t);\n\t\t}\n\n\t\tif (selectOptionName) {\n\t\t\tconditionObjects = selectionVariantToStateFilters._getPropertyConditions(propertyConversionInfo, selectOptionName, false);\n\t\t}\n\n\t\treturn conditionObjects;\n\t},\n\n\t/**\n\t * Get the possible select option name based on priority order.\n\t * @param selectionVariant SelectionVariant to be converted.\n\t * @param propertyName Metadata property name\n\t * @param isParameter Property is a parameter\n\t * @param navigationPath Navigation path to be considered\n\t * @returns The correct select option name of a property to fetch the select options for conversion.\n\t */\n\t_getSelectOptionName: function (\n\t\tselectionVariant: SelectionVariant,\n\t\tpropertyName: string,\n\t\tisParameter?: boolean,\n\t\tnavigationPath?: string\n\t): string {\n\t\t// possible SelectOption Names based on priority.\n\t\tconst possibleSelectOptionNames: string[] = [];\n\t\tconst selectOptionsPropertyNames = selectionVariant.getSelectOptionsPropertyNames();\n\n\t\tif (isParameter) {\n\t\t\t// Currency ==> $Parameter.Currency\n\t\t\t// P_Currency ==> $Parameter.P_Currency\n\t\t\tpossibleSelectOptionNames.push(`$Parameter.${propertyName}`);\n\n\t\t\t// Currency ==> Currency\n\t\t\t// P_Currency ==> P_Currency\n\t\t\tpossibleSelectOptionNames.push(propertyName);\n\n\t\t\tif (propertyName.startsWith(\"P_\")) {\n\t\t\t\t// P_Currency ==> $Parameter.Currency\n\t\t\t\tpossibleSelectOptionNames.push(`$Parameter.${propertyName.slice(2, propertyName.length)}`);\n\n\t\t\t\t// P_Currency ==> Currency\n\t\t\t\tpossibleSelectOptionNames.push(propertyName.slice(2, propertyName.length));\n\t\t\t} else {\n\t\t\t\t// Currency ==> $Parameter.P_Currency\n\t\t\t\tpossibleSelectOptionNames.push(`$Parameter.P_${propertyName}`);\n\n\t\t\t\t// Currency ==> P_Currency\n\t\t\t\tpossibleSelectOptionNames.push(`P_${propertyName}`);\n\t\t\t}\n\t\t} else {\n\t\t\t// Name => Name\n\t\t\tpossibleSelectOptionNames.push(propertyName);\n\t\t\tpossibleSelectOptionNames.push(`$Parameter.${propertyName}`);\n\n\t\t\tif (propertyName.startsWith(\"P_\")) {\n\t\t\t\t// P_Name => Name\n\t\t\t\tconst temp1 = propertyName.slice(2, propertyName.length);\n\n\t\t\t\t// Name => $Parameter.Name\n\t\t\t\tpossibleSelectOptionNames.push(`$Parameter.${temp1}`);\n\n\t\t\t\t// Name => Name\n\t\t\t\tpossibleSelectOptionNames.push(temp1);\n\t\t\t} else {\n\t\t\t\t// Name => P_Name\n\t\t\t\tconst temp2 = `P_${propertyName}`;\n\n\t\t\t\t// P_Name => $Parameter.P_Name\n\t\t\t\tpossibleSelectOptionNames.push(`$Parameter.${temp2}`);\n\n\t\t\t\t// P_Name => P_Name\n\t\t\t\tpossibleSelectOptionNames.push(temp2);\n\t\t\t}\n\t\t}\n\n\t\tlet selectOptionName = \"\";\n\t\t// Find the correct select option name based on the priority\n\t\tpossibleSelectOptionNames.some((testName: string) => {\n\t\t\tconst pathToCheck = navigationPath ? `${navigationPath}.${testName}` : testName;\n\t\t\t// Name => Name\n\t\t\t// Name => _Item.Name (incase _Item is navigationPath)\n\n\t\t\treturn selectOptionsPropertyNames.includes(pathToCheck) ? (selectOptionName = pathToCheck) : false;\n\t\t});\n\n\t\treturn selectOptionName;\n\t},\n\n\t/**\n\t * Get maximum conditions supported for a property as filter.\n\t * @param propertyConversionInfo Property info used for conversion\n\t * @returns Number of maximum conditions\n\t */\n\t_getMaxConditions(propertyConversionInfo: PropertyConversionInfo): number {\n\t\tconst { controlInfo, propertyContextPath, propertyName } = propertyConversionInfo;\n\t\tconst { metaModel } = controlInfo;\n\t\tconst completePropertyPath = `${propertyContextPath}${propertyName}`;\n\t\tconst propertyContext = metaModel.createBindingContext(completePropertyPath);\n\n\t\tlet maximumConditions = 0;\n\t\tif (propertyContext) {\n\t\t\tmaximumConditions = maxConditions(propertyName, { context: propertyContext });\n\t\t}\n\t\treturn maximumConditions;\n\t},\n\n\t/**\n\t * Convert select options to property conditions.\n\t * @param propertyConversionInfo Property info used for conversion\n\t * @param selectOptionName Select option name\n\t * @param isParameter Boolean which determines if a property is parameterized\n\t * @returns The conditions of a property for control\n\t */\n\t_getPropertyConditions: function (\n\t\tpropertyConversionInfo: PropertyConversionInfo,\n\t\tselectOptionName: string,\n\t\tisParameter?: boolean\n\t): ConditionObject[] {\n\t\tconst { controlInfo, propertyMetadata, selectionVariant, propertyContextPath, propertyName } = propertyConversionInfo;\n\t\tconst selectOptions = selectionVariant.getSelectOption(selectOptionName);\n\t\tconst { metaModel } = controlInfo;\n\t\tconst maximumConditions = selectionVariantToStateFilters._getMaxConditions(propertyConversionInfo);\n\n\t\tlet conditionObjects: ConditionObject[] = [];\n\t\tif (selectOptions?.length && maximumConditions !== 0) {\n\t\t\tconst semanticDateOperators: string[] = selectionVariantToStateFilters._getSemanticDateOperators(\n\t\t\t\tpropertyConversionInfo,\n\t\t\t\tisParameter\n\t\t\t);\n\t\t\tconst propertyEntitySetPath = propertyContextPath.substring(0, propertyContextPath.length - 1);\n\n\t\t\tconst validOperators = isParameter\n\t\t\t\t? [\"EQ\"]\n\t\t\t\t: CommonHelper.getOperatorsForProperty(propertyName, propertyEntitySetPath, metaModel);\n\n\t\t\t// multiple select options => multiple conditions\n\n\t\t\tconditionObjects = this._getConditionsFromSelectOptions(\n\t\t\t\tselectOptions,\n\t\t\t\tpropertyMetadata,\n\t\t\t\tvalidOperators,\n\t\t\t\tsemanticDateOperators,\n\t\t\t\tmaximumConditions === 1\n\t\t\t);\n\t\t}\n\t\treturn conditionObjects;\n\t},\n\n\t/**\n\t * Fetch semantic date operators.\n\t * @param propertyConversionInfo Object which is used for conversion\n\t * @param isParameter Boolean which determines if a property is parameterized\n\t * @returns The semantic date operators supported for a property\n\t */\n\t_getSemanticDateOperators: function (propertyConversionInfo: PropertyConversionInfo, isParameter?: boolean): string[] {\n\t\tconst { controlInfo, propertyMetadata, propertyName, propertyContextPath } = propertyConversionInfo;\n\t\tconst conditionPath = propertyMetadata.name;\n\t\tlet semanticDateOperators: string[] = [];\n\t\tconst { useSemanticDateRange, filterFieldsConfig, metaModel } = controlInfo;\n\t\tif (useSemanticDateRange) {\n\t\t\tif (isParameter) {\n\t\t\t\tsemanticDateOperators = [\"EQ\"];\n\t\t\t} else {\n\t\t\t\tconst propertyEntitySetPath = propertyContextPath.substring(0, propertyContextPath.length - 1),\n\t\t\t\t\tfilterSettings = selectionVariantToStateFilters._getPropertyFilterConfigurationSetting(\n\t\t\t\t\t\tconditionPath,\n\t\t\t\t\t\tfilterFieldsConfig\n\t\t\t\t\t);\n\t\t\t\tsemanticDateOperators = CommonHelper.getOperatorsForProperty(\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tpropertyEntitySetPath,\n\t\t\t\t\tmetaModel,\n\t\t\t\t\tODATA_TYPE_MAPPING[propertyMetadata.dataType],\n\t\t\t\t\tuseSemanticDateRange,\n\t\t\t\t\tfilterSettings\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn semanticDateOperators;\n\t},\n\n\t/**\n\t * Get the filter conditions from selection options.\n\t * @param selectOptions Select options array\n\t * @param propertyMetadata Property metadata information\n\t * @param validOperators All valid operators\n\t * @param semanticDateOperators Semantic date operators\n\t * @param singleCondition Boolean which determines if a property takes only one condtition\n\t * @returns Converted filter conditions\n\t */\n\t_getConditionsFromSelectOptions: function (\n\t\tselectOptions: SelectOption[],\n\t\tpropertyMetadata: ControlPropertyInfo,\n\t\tvalidOperators: string[],\n\t\tsemanticDateOperators: string[],\n\t\tsingleCondition?: boolean\n\t): ConditionObject[] {\n\t\tlet conditionObjects: ConditionObject[] = [];\n\t\t// Create conditions for all the selectOptions of the property\n\t\tif (selectOptions.length) {\n\t\t\tconditionObjects = singleCondition\n\t\t\t\t? selectionVariantToStateFilters._addConditionFromSelectOption(\n\t\t\t\t\t\tpropertyMetadata,\n\t\t\t\t\t\tvalidOperators,\n\t\t\t\t\t\tsemanticDateOperators,\n\t\t\t\t\t\tconditionObjects,\n\t\t\t\t\t\tselectOptions[0]\n\t\t\t\t  )\n\t\t\t\t: selectOptions.reduce(\n\t\t\t\t\t\tselectionVariantToStateFilters._addConditionFromSelectOption.bind(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tpropertyMetadata,\n\t\t\t\t\t\t\tvalidOperators,\n\t\t\t\t\t\t\tsemanticDateOperators\n\t\t\t\t\t\t),\n\t\t\t\t\t\tconditionObjects\n\t\t\t\t  );\n\t\t}\n\t\treturn conditionObjects;\n\t},\n\n\t/**\n\t * Cumulatively add select option to condition.\n\t * @param propertyMetadata Property metadata information\n\t * @param validOperators Operators for all the data types\n\t * @param semanticDateOperators Operators for the Date type\n\t * @param cumulativeConditions Filter conditions\n\t * @param selectOption Selectoption of selection variant\n\t * @returns The filter conditions\n\t */\n\t_addConditionFromSelectOption: function (\n\t\tpropertyMetadata: ControlPropertyInfo,\n\t\tvalidOperators: string[],\n\t\tsemanticDateOperators: string[],\n\t\tcumulativeConditions: ConditionObject[],\n\t\tselectOption: SelectOption\n\t): ConditionObject[] {\n\t\tconst { hasValueHelp, dataType } = propertyMetadata;\n\t\tconst allSupportedOperators = [...validOperators, ...semanticDateOperators];\n\t\tconst edmType = selectionVariantToStateFilters._getEdmType(dataType);\n\t\tconst condition = getConditions(selectOption, edmType ?? dataType, !!hasValueHelp, validOperators, semanticDateOperators);\n\t\tif (\n\t\t\tselectOption.SemanticDates &&\n\t\t\tsemanticDateOperators.length &&\n\t\t\tsemanticDateOperators.includes(selectOption.SemanticDates.operator)\n\t\t) {\n\t\t\tconst semanticDates = selectionVariantToStateFilters._addSemanticDatesToConditions(selectOption.SemanticDates);\n\t\t\tif (Object.keys(semanticDates).length > 0) {\n\t\t\t\tcumulativeConditions.push(semanticDates);\n\t\t\t}\n\t\t} else if (condition) {\n\t\t\tif (allSupportedOperators.length === 0 || allSupportedOperators.includes(condition.operator)) {\n\t\t\t\tcumulativeConditions.push(condition);\n\t\t\t}\n\t\t}\n\t\treturn cumulativeConditions;\n\t},\n\n\t/**\n\t * Create filter conditions for a parameter property.\n\t * @param semanticDates Semantic date infomation\n\t * @returns The filter conditions containing semantic dates\n\t */\n\t_addSemanticDatesToConditions: (semanticDates: SemanticDateConfiguration): ConditionObject => {\n\t\tconst values: unknown[] = [];\n\t\tif (semanticDates.high !== null) {\n\t\t\tvalues.push(semanticDates.high);\n\t\t}\n\t\tif (semanticDates.low !== null) {\n\t\t\tvalues.push(semanticDates.low);\n\t\t}\n\t\treturn {\n\t\t\tvalues: values,\n\t\t\toperator: semanticDates.operator,\n\t\t\tisEmpty: undefined\n\t\t};\n\t},\n\n\t/**\n\t * Get EDM type from data type.\n\t * @param dataType V4 model data type\n\t * @returns EDM type equivalent of data type\n\t */\n\t_getEdmType: (dataType: string): string => {\n\t\tconst TYPE_EDM_MAPPING = Object.fromEntries(\n\t\t\tObject.entries(EDM_TYPE_MAPPING).map(([k, v]) => [(v as { type: unknown }).type, k])\n\t\t) as Record<string, unknown>;\n\t\treturn TYPE_EDM_MAPPING[dataType] as string;\n\t},\n\n\t/**\n\t * Change value depending on condition operator(Empty and NotEmpty) for properties with ValueList with fixed values.\n\t * @param condition Condition to change\n\t */\n\t_adjustValueListWithFixedValuesCondition: (condition: Record<string, unknown>): void => {\n\t\t// in case the condition is meant for a field having a VH, the format required by MDC differs\n\t\tcondition.validated = ConditionValidated.Validated;\n\t\tif (condition.operator === \"Empty\") {\n\t\t\tcondition.operator = \"EQ\";\n\t\t\tcondition.values = [\"\"];\n\t\t} else if (condition.operator === \"NotEmpty\") {\n\t\t\tcondition.operator = \"NE\";\n\t\t\tcondition.values = [\"\"];\n\t\t}\n\t\tdelete condition.isEmpty;\n\t}\n};\n\nexport default selectionVariantToStateFilters;\n"],"mappings":"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","ignoreList":[]}