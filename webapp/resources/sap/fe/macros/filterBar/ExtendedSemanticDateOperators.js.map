{"version":3,"file":"ExtendedSemanticDateOperators.js","names":["operatorsToExtend","getFixedDateSingleValueOperations","singleValueDateOperatorNames","Object","keys","FROM_OP","TO_OP","extendedFromOperators","reduce","operations","singleDateOperatorKey","key","category","DYNAMIC_DATE_CATEGORY","primitiveOperator","extendedToOperators","extendedOperators","extendedOperatorNames","isFromExtendedOperator","operatorName","includes","isToExtendedOperator","getExtendedOperator","resourceBundle","filterOperator","ExtendedSemanticDateOperators","getFilterOperator","tokenTextKey","createRangeOperator","name","longText","getText","tokenText","valueTypes","OperatorValueType","Static","group","id","text","calcRange","fromPick","toPick","fnRanges","config","RangeOperator","getOperatorsInfo","getSemanticDateOperations","getCorrespondingSingleDateOperator","isExtendedOperator","ModelOperator","EQ","GE","LE","addExtendedFilterOperators","operatorNames","arguments","length","undefined","Library","getResourceBundleFor","operators","FilterOperatorUtil","getOperator","operator","push","addOperators"],"sources":["./ExtendedSemanticDateOperators.ts"],"sourcesContent":["import type ResourceBundle from \"sap/base/i18n/ResourceBundle\";\nimport { DYNAMIC_DATE_CATEGORY, getFixedDateSingleValueOperations } from \"sap/fe/macros/filterBar/DefaultSemanticDateOperators\";\nimport Library from \"sap/ui/core/Lib\";\nimport type UniversalDate from \"sap/ui/core/date/UniversalDate\";\nimport FilterOperatorUtil from \"sap/ui/mdc/condition/FilterOperatorUtil\";\nimport RangeOperator, { type Configuration } from \"sap/ui/mdc/condition/RangeOperator\";\nimport OperatorValueType from \"sap/ui/mdc/enums/OperatorValueType\";\nimport type { default as FilterOperator } from \"sap/ui/model/FilterOperator\";\nimport { default as ModelOperator } from \"sap/ui/model/FilterOperator\";\n\n/**\n * Single value date operators with ranges.\n * We shall use these single value date operator and combine with \"FROM\" and \"TO\" operators.\n * The resultant operator is expected to be a range operator. Hence we would need the ranges.\n * Like:\n * {\n * \t<operator name>: {\n * \t\tkey: <identifier>,\n * \t\tfnRanges: <API to get the range>\n * \t},\n * \t<more operators>...\n * }\n */\nconst operatorsToExtend = getFixedDateSingleValueOperations();\n\n// Single Value date operators: Like \"TODAY\", \"TOMORROW\", \"LASTDAYYEAR\", etc.\ntype SingleValueDateOperatorName = keyof typeof operatorsToExtend;\nconst singleValueDateOperatorNames = Object.keys(operatorsToExtend) as SingleValueDateOperatorName[];\n\nconst FROM_OP = \"FROM\";\nconst TO_OP = \"TO\";\ntype ExtendedFROMOperatorName = `${typeof FROM_OP}${SingleValueDateOperatorName}`;\ntype ExtendedTOOperatorsName = `${typeof TO_OP}${SingleValueDateOperatorName}`;\n\n/**\n * Operations info to identify which operators the user wants to support.\n * Like:\n * {\n * \t<operator name>: {\n * \t\tkey: <identifier>,\n * \t\tcategory: <type of operator>\n * \t},\n * \t<more operators>...\n * }\n */\ntype Operation = {\n\tkey: string;\n\tcategory: string;\n};\ntype ExtendedOperation = Operation & {\n\tprimitiveOperator: SingleValueDateOperatorName;\n};\nconst extendedFromOperators: Record<ExtendedFROMOperatorName, ExtendedOperation> = singleValueDateOperatorNames.reduce(\n\t(operations, singleDateOperatorKey) => {\n\t\toperations[`${FROM_OP}${singleDateOperatorKey}`] = {\n\t\t\tkey: `${FROM_OP}${singleDateOperatorKey}`,\n\t\t\tcategory: DYNAMIC_DATE_CATEGORY,\n\t\t\tprimitiveOperator: singleDateOperatorKey\n\t\t};\n\t\treturn operations;\n\t},\n\t{} as Record<ExtendedFROMOperatorName, ExtendedOperation>\n);\nconst extendedToOperators: Record<ExtendedTOOperatorsName, ExtendedOperation> = singleValueDateOperatorNames.reduce(\n\t(operations, singleDateOperatorKey) => {\n\t\toperations[`${TO_OP}${singleDateOperatorKey}`] = {\n\t\t\tkey: `${TO_OP}${singleDateOperatorKey}`,\n\t\t\tcategory: DYNAMIC_DATE_CATEGORY,\n\t\t\tprimitiveOperator: singleDateOperatorKey\n\t\t};\n\t\treturn operations;\n\t},\n\t{} as Record<ExtendedTOOperatorsName, ExtendedOperation>\n);\n\n// Extend Operators like \"FROMTODAY\", \"TOTODAY\", \"FROMYESTERDAY\", etc.\nconst extendedOperators = { ...extendedFromOperators, ...extendedToOperators };\nexport type ExtendedOperatorName = ExtendedFROMOperatorName | ExtendedTOOperatorsName;\nconst extendedOperatorNames = Object.keys(extendedOperators) as ExtendedOperatorName[];\n\n/**\n * Check if the operator is a FROM extended operator like \"FROMTODAY\", \"FROMTOMORROW\".\n * @param operatorName Operator name to check\n * @returns Boolean. If 'from' extended operator.\n */\nfunction isFromExtendedOperator(operatorName: string): operatorName is ExtendedFROMOperatorName {\n\treturn Object.keys(extendedFromOperators).includes(operatorName);\n}\n\n/**\n * Check if the operator is a TO extended operator like \"TOTODAY\", \"TOTOMORROW\".\n * @param operatorName Operator name to check\n * @returns Boolean. If 'to' extended operator.\n */\nfunction isToExtendedOperator(operatorName: string): operatorName is ExtendedTOOperatorsName {\n\treturn Object.keys(extendedToOperators).includes(operatorName);\n}\n\n/**\n * Get extended operator by combining \"FROM\" and \"TO\" operations with single value dates.\n * @param operatorName Operator name\n * @param resourceBundle Resource to collect translated texts for the operators to be shown in UI.\n * @returns RangeOperator\n */\nfunction getExtendedOperator(operatorName: ExtendedOperatorName, resourceBundle: ResourceBundle): RangeOperator {\n\tconst { primitiveOperator } = extendedOperators[operatorName];\n\tconst filterOperator = ExtendedSemanticDateOperators.getFilterOperator(operatorName) as ModelOperator.GE | ModelOperator.LE;\n\tconst tokenTextKey = `M_EXTENDED_OPERATOR_${operatorName}_TOKEN_TEXT`;\n\treturn ExtendedSemanticDateOperators.createRangeOperator({\n\t\tname: operatorName,\n\t\tlongText: resourceBundle.getText(tokenTextKey, []),\n\t\ttokenText: `${resourceBundle.getText(tokenTextKey, [])} ({0})`,\n\t\tvalueTypes: [OperatorValueType.Static],\n\t\tfilterOperator,\n\t\tgroup: { id: 3, text: resourceBundle.getText(`M_EXTENDED_OPERATOR_GRP_TEXT`, []) },\n\t\tcalcRange: function (): UniversalDate[] {\n\t\t\tconst [fromPick, toPick] = operatorsToExtend[primitiveOperator].fnRanges();\n\t\t\treturn [isFromExtendedOperator(operatorName) ? fromPick : toPick];\n\t\t}\n\t});\n}\n\nconst ExtendedSemanticDateOperators = {\n\t/**\n\t * Creation of RangeOperator from configuration.\n\t * @param config Range Operator configurations\n\t * @returns Range Operator\n\t */\n\tcreateRangeOperator(config: Configuration): RangeOperator {\n\t\treturn new RangeOperator({ ...config });\n\t},\n\n\t/**\n\t * Operators Info to help decide which operations the user wants to enable.\n\t * @returns Operators Info\n\t */\n\tgetOperatorsInfo(): Record<ExtendedFROMOperatorName, ExtendedOperation> {\n\t\treturn extendedOperators;\n\t},\n\n\t/**\n\t * Extended Semantic Date operations that can be used.\n\t * @returns Extended Operator names\n\t */\n\tgetSemanticDateOperations(): string[] {\n\t\treturn [...extendedOperatorNames];\n\t},\n\n\t/**\n\t * Get the single date operator used to create the extended operator.\n\t * @param operatorName Extended operator name\n\t * @returns Single date operator name\n\t */\n\tgetCorrespondingSingleDateOperator(operatorName: ExtendedOperatorName): SingleValueDateOperatorName {\n\t\tconst { primitiveOperator } = extendedOperators[operatorName];\n\t\treturn primitiveOperator;\n\t},\n\n\t/**\n\t * Checks if it is an extended operator.\n\t * @param operatorName Operator name to check\n\t * @returns Extended Operator names\n\t */\n\tisExtendedOperator(operatorName: string): operatorName is ExtendedOperatorName {\n\t\treturn (extendedOperatorNames as string[]).includes(operatorName);\n\t},\n\n\t/**\n\t * Check if the operator is a TO extended operator like \"TOTODAY\", \"TOTOMORROW\".\n\t * @param operatorName Operator name to check\n\t * @returns Boolean. If 'to' extended operator.\n\t */\n\tgetFilterOperator(operatorName: ExtendedOperatorName): FilterOperator {\n\t\tlet filterOperator = ModelOperator.EQ;\n\t\tif (isFromExtendedOperator(operatorName)) {\n\t\t\tfilterOperator = ModelOperator.GE;\n\t\t} else if (isToExtendedOperator(operatorName)) {\n\t\t\tfilterOperator = ModelOperator.LE;\n\t\t}\n\t\treturn filterOperator;\n\t},\n\n\t/**\n\t * Add extended operations to MDC filtering environment.\n\t *\n\t * Presently only single value date operators extended via TO/FROM operations can be added.\n\t * These include...\n\t * 1. \"FROMYESTERDAY\".\n\t * 2. \"FROMTODAY\".\n\t * 3. \"FROMTOMORROW\".\n\t * 4. \"FROMFIRSTDAYWEEK\".\n\t * 5. \"FROMLASTDAYWEEK\".\n\t * 6. \"FROMFIRSTDAYMONTH\".\n\t * 7. \"FROMLASTDAYMONTH\".\n\t * 8. \"FROMFIRSTDAYQUARTER\".\n\t * 9. \"FROMLASTDAYQUARTER\".\n\t * 10. \"FROMFIRSTDAYYEAR\".\n\t * 11. \"FROMLASTDAYYEAR\".\n\t * 12. \"TOYESTERDAY\".\n\t * 13. \"TOTODAY\".\n\t * 14. \"TOTOMORROW\".\n\t * 15. \"TOFIRSTDAYWEEK\".\n\t * 16. \"TOLASTDAYWEEK\".\n\t * 17. \"TOFIRSTDAYMONTH\".\n\t * 18. \"TOLASTDAYMONTH\".\n\t * 19. \"TOFIRSTDAYQUARTER\".\n\t * 20. \"TOLASTDAYQUARTER\".\n\t * 21. \"TOFIRSTDAYYEAR\".\n\t * 22. \"TOLASTDAYYEAR\".\n\t *\n\t * These custom operators created by FE are not available by default with MDC filtering environment.\n\t * The need to be added on-demand via MDC APIs like 'FilterOperatorUtils.addOperator'.\n\t *\n\t * If operatorNames is undefined, then we add all extended semantic date operators.\n\t * @param operatorNames Operation names to be added or undefined.\n\t */\n\taddExtendedFilterOperators(operatorNames: string[] = extendedOperatorNames): void {\n\t\tconst resourceBundle = Library.getResourceBundleFor(\"sap.fe.macros\")!;\n\t\tconst operators: RangeOperator[] = operatorNames.reduce((operators, operatorName) => {\n\t\t\tif (!FilterOperatorUtil.getOperator(operatorName) && ExtendedSemanticDateOperators.isExtendedOperator(operatorName)) {\n\t\t\t\tconst operator = getExtendedOperator(operatorName, resourceBundle);\n\t\t\t\toperators.push(operator);\n\t\t\t}\n\t\t\treturn operators;\n\t\t}, [] as RangeOperator[]);\n\t\tFilterOperatorUtil.addOperators(operators);\n\t}\n};\n\nexport default ExtendedSemanticDateOperators;\n"],"mappings":";;;;sVAuBA,MAAMA,EAAoBC,IAI1B,MAAMC,EAA+BC,OAAOC,KAAKJ,GAEjD,MAAMK,EAAU,OAChB,MAAMC,EAAQ,KAsBd,MAAMC,EAA6EL,EAA6BM,OAC/G,CAACC,EAAYC,KACZD,EAAW,GAAGJ,IAAUK,KAA2B,CAClDC,IAAK,GAAGN,IAAUK,IAClBE,SAAUC,EACVC,kBAAmBJ,GAEpB,OAAOD,GAER,CAAC,GAEF,MAAMM,EAA0Eb,EAA6BM,OAC5G,CAACC,EAAYC,KACZD,EAAW,GAAGH,IAAQI,KAA2B,CAChDC,IAAK,GAAGL,IAAQI,IAChBE,SAAUC,EACVC,kBAAmBJ,GAEpB,OAAOD,GAER,CAAC,GAIF,MAAMO,EAAoB,IAAKT,KAA0BQ,GAEzD,MAAME,EAAwBd,OAAOC,KAAKY,GAO1C,SAASE,EAAuBC,GAC/B,OAAOhB,OAAOC,KAAKG,GAAuBa,SAASD,EACpD,CAOA,SAASE,EAAqBF,GAC7B,OAAOhB,OAAOC,KAAKW,GAAqBK,SAASD,EAClD,CAQA,SAASG,EAAoBH,EAAoCI,GAChE,MAAMT,kBAAEA,GAAsBE,EAAkBG,GAChD,MAAMK,EAAiBC,EAA8BC,kBAAkBP,GACvE,MAAMQ,EAAe,uBAAuBR,eAC5C,OAAOM,EAA8BG,oBAAoB,CACxDC,KAAMV,EACNW,SAAUP,EAAeQ,QAAQJ,EAAc,IAC/CK,UAAW,GAAGT,EAAeQ,QAAQJ,EAAc,YACnDM,WAAY,CAACC,EAAkBC,QAC/BX,iBACAY,MAAO,CAAEC,GAAI,EAAGC,KAAMf,EAAeQ,QAAQ,+BAAgC,KAC7EQ,UAAW,WACV,MAAOC,EAAUC,GAAUzC,EAAkBc,GAAmB4B,WAChE,MAAO,CAACxB,EAAuBC,GAAgBqB,EAAWC,EAC3D,GAEF,CAEA,MAAMhB,EAAgC,CAMrCG,oBAAoBe,GACnB,OAAO,IAAIC,EAAc,IAAKD,GAC/B,EAMAE,mBACC,OAAO7B,CACR,EAMA8B,4BACC,MAAO,IAAI7B,EACZ,EAOA8B,mCAAmC5B,GAClC,MAAML,kBAAEA,GAAsBE,EAAkBG,GAChD,OAAOL,CACR,EAOAkC,mBAAmB7B,GAClB,OAAQF,EAAmCG,SAASD,EACrD,EAOAO,kBAAkBP,GACjB,IAAIK,EAAiByB,EAAcC,GACnC,GAAIhC,EAAuBC,GAAe,CACzCK,EAAiByB,EAAcE,EAChC,MAAO,GAAI9B,EAAqBF,GAAe,CAC9CK,EAAiByB,EAAcG,EAChC,CACA,OAAO5B,CACR,EAoCA6B,6BAAkF,IAAvDC,EAAuBC,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,GAAGtC,EACpD,MAAMM,EAAiBmC,EAAQC,qBAAqB,iBACpD,MAAMC,EAA6BN,EAAc9C,OAAO,CAACoD,EAAWzC,KACnE,IAAK0C,EAAmBC,YAAY3C,IAAiBM,EAA8BuB,mBAAmB7B,GAAe,CACpH,MAAM4C,EAAWzC,EAAoBH,EAAcI,GACnDqC,EAAUI,KAAKD,EAChB,CACA,OAAOH,GACL,IACHC,EAAmBI,aAAaL,EACjC,GACC,OAEanC,CAA6B","ignoreList":[]}