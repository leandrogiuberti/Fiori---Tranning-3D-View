{"version":3,"names":["fixedDateOperators","basicOperators","_filterOperation","oOperation","aOperatorConfiguration","Array","isArray","operationKey","isExtendedOperator","ExtendedSemanticDateOperators","bResult","configFound","some","oOperatorConfiguration","j","path","sValue","bExclude","exclude","aOperatorValues","contains","split","length","includes","equals","getOperatorsInfo","type","DefaultSemanticDateOperators","SemanticDateOperators","getBasicSemanticDateOperations","getSemanticDateOperations","removeSemanticDateOperators","getFilterOperations","aOperations","operators","n","push","map","key","hasSemanticDateOperations","filterConditions","includeCheckForBasicOperators","arguments","undefined","semanticDateOps","filterCondtion","conditionWithSemanticOperator","find","condition","operator","getSemanticOpsFilterProperties","filterSelectOptions","filtersWithSemanticOperators","filterName","filterInfo","Object","entries","filterSemanticInfo","SemanticDates","filterType","getSemanticDateFiltersWithFlpPlaceholders","filtersWithSemanticOpsInfo","propertiesInfo","semanticDateFilters","flpMappedPlaceholders","forEach","_ref","correspondingPropertyInfo","propertyInfo","typeConfig","className","ODATA_TYPE_MAPPING","semanticOperator","value1","high","value2","low","filter","operatorKeyForFlpPlaceholder","getCorrespondingSingleDateOperator","getFilterOperator","Filter","commonOperatorSuffix","val","join","startFilterKey","endFilterKey","commonPrefixPlaceholder","geFilter","leFilter","filterOperator","FilterOperator","GE","filters","and","addSemanticDateOperators","addExtendedFilterOperators"],"sourceRoot":".","sources":["SemanticDateOperators.ts"],"sourcesContent":["import type { OperatorConfiguration } from \"sap/fe/core/converters/ManifestSettings\";\nimport { ODATA_TYPE_MAPPING } from \"sap/fe/core/templating/DisplayModeFormatter\";\nimport * as DefaultSemanticDateOperators from \"sap/fe/macros/filterBar/DefaultSemanticDateOperators\";\nimport ExtendedSemanticDateOperators from \"sap/fe/macros/filterBar/ExtendedSemanticDateOperators\";\nimport type { PropertyInfo } from \"sap/fe/macros/internal/PropertyInfo\";\nimport type { SelectOption, SemanticDateConfiguration } from \"sap/fe/navigation/SelectionVariant\";\nimport type { Filter as StateUtilFilter } from \"sap/ui/mdc/p13n/StateUtil\";\nimport Filter from \"sap/ui/model/Filter\";\nimport FilterOperator from \"sap/ui/model/FilterOperator\";\n\nconst fixedDateOperators = [\"TODAY\", \"TOMORROW\", \"YESTERDAY\"];\nconst basicOperators = [\"DATE\", \"FROM\", \"TO\", \"DATERANGE\"];\n\ntype semanticDateFiltersInfo = {\n\tfilterName: string;\n\tfilterSemanticInfo: SemanticDateConfiguration;\n\tfilterType: string;\n};\n\n/**\n * Check if the filter operation is supported by user configurations.\n *\n * Scenarios:\n * 1. If no configuration is maintained, then only all default semantic date operators shall be shown for the filter field.\n * 2. If configurations are maintained, then configuration shall be applied to the particular filter field.\n *\n * In case of extended operators that are a combination of single date operator like \"TODAY\", \"TOMORROW\" etc. with \"TO\"/\"FROM\" operators,\n * they shall not be shown by default.\n * The user will have to maintain configuration to enable them.\n * @param oOperation Operation\n * @param oOperation.key Operator identifier\n * @param oOperation.category Type of semantic date operation\n * @param aOperatorConfiguration User configurations for filter fields\n * @returns Extended Operator names\n */\nfunction _filterOperation(\n\toOperation: { key: string; category: string },\n\taOperatorConfiguration?: OperatorConfiguration[]\n): boolean | undefined {\n\tif (!aOperatorConfiguration) {\n\t\treturn true;\n\t}\n\taOperatorConfiguration = Array.isArray(aOperatorConfiguration) ? aOperatorConfiguration : [aOperatorConfiguration];\n\tconst operationKey = oOperation[\"key\"];\n\tconst isExtendedOperator = ExtendedSemanticDateOperators.isExtendedOperator(operationKey);\n\tlet bResult;\n\n\tconst configFound = aOperatorConfiguration.some(function (oOperatorConfiguration: OperatorConfiguration): boolean {\n\t\tlet j;\n\t\tif (!oOperatorConfiguration.path) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst sValue = oOperation[oOperatorConfiguration.path as keyof typeof oOperation];\n\t\tconst bExclude = oOperatorConfiguration.exclude ?? isExtendedOperator ?? false;\n\t\tlet aOperatorValues;\n\n\t\tif (oOperatorConfiguration.contains && sValue) {\n\t\t\taOperatorValues = oOperatorConfiguration.contains.split(\",\");\n\t\t\tfor (j = 0; j < aOperatorValues.length; j++) {\n\t\t\t\tif (bExclude && sValue.includes(aOperatorValues[j])) {\n\t\t\t\t\tbResult = false;\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!bExclude && sValue.includes(aOperatorValues[j])) {\n\t\t\t\t\tbResult = true;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (oOperatorConfiguration.equals && sValue) {\n\t\t\taOperatorValues = oOperatorConfiguration.equals.split(\",\");\n\t\t\tfor (j = 0; j < aOperatorValues.length; j++) {\n\t\t\t\tif (bExclude && sValue === aOperatorValues[j]) {\n\t\t\t\t\tbResult = false;\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!bExclude && sValue === aOperatorValues[j]) {\n\t\t\t\t\tbResult = true;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t});\n\treturn configFound ? bResult : !isExtendedOperator;\n}\n// Get the operators based on type\nfunction getOperatorsInfo(type: string | undefined): Record<string, { key: string; category: string }> {\n\treturn { ...DefaultSemanticDateOperators.getOperatorsInfo(type), ...ExtendedSemanticDateOperators.getOperatorsInfo() };\n}\nconst SemanticDateOperators = {\n\t/**\n\t * Get basic semantic date operator names.\n\t * @returns Basic Operator names like \"DATE\", \"FROM\", \"TO\", \"DATERANGE\".\n\t */\n\tgetBasicSemanticDateOperations: function (): string[] {\n\t\treturn [...basicOperators];\n\t},\n\n\t/**\n\t * Get all supported semantic date operator names that can be used via FE macro filter bar.\n\t * @param type\n\t * @returns Operator names.\n\t */\n\tgetSemanticDateOperations: function (type?: string): string[] {\n\t\treturn [\n\t\t\t...DefaultSemanticDateOperators.getSemanticDateOperations(type),\n\t\t\t...ExtendedSemanticDateOperators.getSemanticDateOperations()\n\t\t];\n\t},\n\t// TODO: Would need to check with MDC for removeOperator method\n\t// eslint-disable-next-line @typescript-eslint/no-empty-function\n\tremoveSemanticDateOperators: function (): void {},\n\t// To filter operators based on manifest aOperatorConfiguration settings\n\tgetFilterOperations: function (aOperatorConfiguration: OperatorConfiguration[], type?: string): string[] {\n\t\tconst aOperations: { key: string; category: string }[] = [];\n\t\tconst operators = getOperatorsInfo(type);\n\t\tfor (const n in operators) {\n\t\t\tconst oOperation = operators[n];\n\t\t\tif (_filterOperation(oOperation, aOperatorConfiguration)) {\n\t\t\t\taOperations.push(oOperation);\n\t\t\t}\n\t\t}\n\t\treturn aOperations.map(function (oOperation) {\n\t\t\treturn oOperation.key;\n\t\t});\n\t},\n\n\t/**\n\t * The function will check if any of the filter conditions does not have a semantic operator or a date operator.\n\t * This includes actual date fields along with Semantic operator.\n\t * If the 2nd parameter is false, we only check if filter has the semantic Operator.\n\t * @param filterConditions Filter conditions\n\t * @param includeCheckForBasicOperators Should include basic operator along with semantic operator\n\t * @returns True if any of the filter conditions is not semantic field\n\t */\n\thasSemanticDateOperations: function (filterConditions: StateUtilFilter, includeCheckForBasicOperators = true): boolean {\n\t\tconst semanticDateOps = this.getSemanticDateOperations();\n\t\tfor (const key in filterConditions) {\n\t\t\tconst filterCondtion = filterConditions[key];\n\t\t\tconst conditionWithSemanticOperator = filterCondtion.find(function (condition) {\n\t\t\t\treturn semanticDateOps.includes(condition.operator);\n\t\t\t});\n\t\t\tif (conditionWithSemanticOperator) {\n\t\t\t\tif (includeCheckForBasicOperators) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\t// if operator is one of basic operator and not a semantic operator then we return false\n\t\t\t\t\treturn !basicOperators.includes(conditionWithSemanticOperator.operator);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetSemanticOpsFilterProperties: function (filterSelectOptions: Record<string, SelectOption[]>): semanticDateFiltersInfo[] {\n\t\tconst filtersWithSemanticOperators = [];\n\n\t\tfor (const [filterName, filterInfo] of Object.entries(filterSelectOptions)) {\n\t\t\tconst filterSemanticInfo = filterInfo[0].SemanticDates;\n\t\t\tif (filterSemanticInfo && !basicOperators.includes(filterSemanticInfo.operator)) {\n\t\t\t\tfiltersWithSemanticOperators.push({ filterName, filterSemanticInfo, filterType: \"\" });\n\t\t\t}\n\t\t}\n\t\treturn filtersWithSemanticOperators;\n\t},\n\n\tgetSemanticDateFiltersWithFlpPlaceholders(\n\t\tfiltersWithSemanticOpsInfo: semanticDateFiltersInfo[],\n\t\tpropertiesInfo: PropertyInfo[]\n\t): [Record<string, string>, Filter[]] {\n\t\tconst semanticDateFilters: Filter[] = [];\n\t\tconst flpMappedPlaceholders: Record<string, string> = {};\n\n\t\tfiltersWithSemanticOpsInfo.forEach(({ filterName, filterSemanticInfo, filterType }) => {\n\t\t\tconst correspondingPropertyInfo = propertiesInfo.find(\n\t\t\t\t(propertyInfo) => (propertyInfo as PropertyInfo & { key?: string }).key === filterName\n\t\t\t);\n\t\t\tif (correspondingPropertyInfo && correspondingPropertyInfo.typeConfig?.className) {\n\t\t\t\tfilterType = ODATA_TYPE_MAPPING[correspondingPropertyInfo.typeConfig?.className];\n\t\t\t}\n\t\t\tconst semanticOperator = filterSemanticInfo.operator;\n\t\t\tconst value1 = filterSemanticInfo.high;\n\t\t\tconst value2 = filterSemanticInfo.low;\n\n\t\t\tif (semanticOperator) {\n\t\t\t\tlet filter;\n\t\t\t\tconst isExtendedOperator = ExtendedSemanticDateOperators.isExtendedOperator(semanticOperator);\n\t\t\t\t// FLP only understands single date operators like TODAY, YESTERDAY etc.\n\t\t\t\t// So in case of extended operators, we would need to use the single date operator(primitive semantic date operator) used in creating the extended operator.\n\t\t\t\tconst operatorKeyForFlpPlaceholder = isExtendedOperator\n\t\t\t\t\t? ExtendedSemanticDateOperators.getCorrespondingSingleDateOperator(semanticOperator)\n\t\t\t\t\t: semanticOperator;\n\t\t\t\tif ((isExtendedOperator || fixedDateOperators.includes(semanticOperator)) && filterType !== \"Edm.DateTimeOffset\") {\n\t\t\t\t\tconst key = `${filterName}placeholder`;\n\t\t\t\t\tconst operator = isExtendedOperator ? ExtendedSemanticDateOperators.getFilterOperator(semanticOperator) : \"EQ\";\n\t\t\t\t\tfilter = new Filter({\n\t\t\t\t\t\tpath: filterName,\n\t\t\t\t\t\toperator,\n\t\t\t\t\t\tvalue1: key\n\t\t\t\t\t});\n\t\t\t\t\tflpMappedPlaceholders[key] = `{${filterType}%%DynamicDate.${operatorKeyForFlpPlaceholder}%%}`;\n\t\t\t\t} else {\n\t\t\t\t\tconst commonOperatorSuffix = [operatorKeyForFlpPlaceholder, value1, value2]\n\t\t\t\t\t\t.filter((val) => val !== undefined && val !== null)\n\t\t\t\t\t\t.join(\".\");\n\t\t\t\t\tconst startFilterKey = `${filterName}placeholderStart`;\n\t\t\t\t\tconst endFilterKey = `${filterName}placeholderEnd`;\n\t\t\t\t\tconst commonPrefixPlaceholder = `${filterType}%%DynamicDate.${commonOperatorSuffix}`;\n\t\t\t\t\tconst geFilter = new Filter({\n\t\t\t\t\t\tpath: filterName,\n\t\t\t\t\t\toperator: \"GE\",\n\t\t\t\t\t\tvalue1: startFilterKey\n\t\t\t\t\t});\n\t\t\t\t\tconst leFilter = new Filter({\n\t\t\t\t\t\tpath: filterName,\n\t\t\t\t\t\toperator: \"LE\",\n\t\t\t\t\t\tvalue1: endFilterKey\n\t\t\t\t\t});\n\n\t\t\t\t\tif (isExtendedOperator) {\n\t\t\t\t\t\t// Extended operators are combination of single date operators like TODAY with range operator like FROM or TO.\n\t\t\t\t\t\t// In such case, single date is the anchor for the filter and the operator LE or GE is decided based on the range TO or FROM.\n\t\t\t\t\t\tconst filterOperator = ExtendedSemanticDateOperators.getFilterOperator(semanticOperator);\n\t\t\t\t\t\tfilter = filterOperator === FilterOperator.GE ? geFilter : leFilter;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// The dates' end points(start and end) shall create the range for the filter.\n\t\t\t\t\t\tfilter = new Filter({\n\t\t\t\t\t\t\tfilters: [geFilter, leFilter],\n\t\t\t\t\t\t\tand: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tflpMappedPlaceholders[startFilterKey] = `{${commonPrefixPlaceholder}.start%%}`;\n\t\t\t\t\tflpMappedPlaceholders[endFilterKey] = `{${commonPrefixPlaceholder}.end%%}`;\n\t\t\t\t}\n\n\t\t\t\tsemanticDateFilters.push(filter);\n\t\t\t}\n\t\t});\n\n\t\treturn [flpMappedPlaceholders, semanticDateFilters];\n\t},\n\n\t/**\n\t * Add all semantic date operators that can be supported by FE FilterBar building block to MDC environment.\n\t */\n\taddSemanticDateOperators(): void {\n\t\tDefaultSemanticDateOperators.addSemanticDateOperators();\n\t\tExtendedSemanticDateOperators.addExtendedFilterOperators();\n\t}\n};\nexport default SemanticDateOperators;\n"],"mappings":"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","ignoreList":[],"file":"SemanticDateOperators-dbg.js"}