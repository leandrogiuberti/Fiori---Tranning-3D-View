{"version":3,"names":["operatorsToExtend","getFixedDateSingleValueOperations","singleValueDateOperatorNames","Object","keys","FROM_OP","TO_OP","extendedFromOperators","reduce","operations","singleDateOperatorKey","key","category","DYNAMIC_DATE_CATEGORY","primitiveOperator","extendedToOperators","extendedOperators","extendedOperatorNames","isFromExtendedOperator","operatorName","includes","isToExtendedOperator","getExtendedOperator","resourceBundle","filterOperator","ExtendedSemanticDateOperators","getFilterOperator","tokenTextKey","createRangeOperator","name","longText","getText","tokenText","valueTypes","OperatorValueType","Static","group","id","text","calcRange","fromPick","toPick","fnRanges","config","RangeOperator","getOperatorsInfo","getSemanticDateOperations","getCorrespondingSingleDateOperator","isExtendedOperator","ModelOperator","EQ","GE","LE","addExtendedFilterOperators","operatorNames","arguments","length","undefined","Library","getResourceBundleFor","operators","FilterOperatorUtil","getOperator","operator","push","addOperators"],"sourceRoot":".","sources":["ExtendedSemanticDateOperators.ts"],"sourcesContent":["import type ResourceBundle from \"sap/base/i18n/ResourceBundle\";\nimport { DYNAMIC_DATE_CATEGORY, getFixedDateSingleValueOperations } from \"sap/fe/macros/filterBar/DefaultSemanticDateOperators\";\nimport Library from \"sap/ui/core/Lib\";\nimport type UniversalDate from \"sap/ui/core/date/UniversalDate\";\nimport FilterOperatorUtil from \"sap/ui/mdc/condition/FilterOperatorUtil\";\nimport RangeOperator, { type Configuration } from \"sap/ui/mdc/condition/RangeOperator\";\nimport OperatorValueType from \"sap/ui/mdc/enums/OperatorValueType\";\nimport type { default as FilterOperator } from \"sap/ui/model/FilterOperator\";\nimport { default as ModelOperator } from \"sap/ui/model/FilterOperator\";\n\n/**\n * Single value date operators with ranges.\n * We shall use these single value date operator and combine with \"FROM\" and \"TO\" operators.\n * The resultant operator is expected to be a range operator. Hence we would need the ranges.\n * Like:\n * {\n * \t<operator name>: {\n * \t\tkey: <identifier>,\n * \t\tfnRanges: <API to get the range>\n * \t},\n * \t<more operators>...\n * }\n */\nconst operatorsToExtend = getFixedDateSingleValueOperations();\n\n// Single Value date operators: Like \"TODAY\", \"TOMORROW\", \"LASTDAYYEAR\", etc.\ntype SingleValueDateOperatorName = keyof typeof operatorsToExtend;\nconst singleValueDateOperatorNames = Object.keys(operatorsToExtend) as SingleValueDateOperatorName[];\n\nconst FROM_OP = \"FROM\";\nconst TO_OP = \"TO\";\ntype ExtendedFROMOperatorName = `${typeof FROM_OP}${SingleValueDateOperatorName}`;\ntype ExtendedTOOperatorsName = `${typeof TO_OP}${SingleValueDateOperatorName}`;\n\n/**\n * Operations info to identify which operators the user wants to support.\n * Like:\n * {\n * \t<operator name>: {\n * \t\tkey: <identifier>,\n * \t\tcategory: <type of operator>\n * \t},\n * \t<more operators>...\n * }\n */\ntype Operation = {\n\tkey: string;\n\tcategory: string;\n};\ntype ExtendedOperation = Operation & {\n\tprimitiveOperator: SingleValueDateOperatorName;\n};\nconst extendedFromOperators: Record<ExtendedFROMOperatorName, ExtendedOperation> = singleValueDateOperatorNames.reduce(\n\t(operations, singleDateOperatorKey) => {\n\t\toperations[`${FROM_OP}${singleDateOperatorKey}`] = {\n\t\t\tkey: `${FROM_OP}${singleDateOperatorKey}`,\n\t\t\tcategory: DYNAMIC_DATE_CATEGORY,\n\t\t\tprimitiveOperator: singleDateOperatorKey\n\t\t};\n\t\treturn operations;\n\t},\n\t{} as Record<ExtendedFROMOperatorName, ExtendedOperation>\n);\nconst extendedToOperators: Record<ExtendedTOOperatorsName, ExtendedOperation> = singleValueDateOperatorNames.reduce(\n\t(operations, singleDateOperatorKey) => {\n\t\toperations[`${TO_OP}${singleDateOperatorKey}`] = {\n\t\t\tkey: `${TO_OP}${singleDateOperatorKey}`,\n\t\t\tcategory: DYNAMIC_DATE_CATEGORY,\n\t\t\tprimitiveOperator: singleDateOperatorKey\n\t\t};\n\t\treturn operations;\n\t},\n\t{} as Record<ExtendedTOOperatorsName, ExtendedOperation>\n);\n\n// Extend Operators like \"FROMTODAY\", \"TOTODAY\", \"FROMYESTERDAY\", etc.\nconst extendedOperators = { ...extendedFromOperators, ...extendedToOperators };\nexport type ExtendedOperatorName = ExtendedFROMOperatorName | ExtendedTOOperatorsName;\nconst extendedOperatorNames = Object.keys(extendedOperators) as ExtendedOperatorName[];\n\n/**\n * Check if the operator is a FROM extended operator like \"FROMTODAY\", \"FROMTOMORROW\".\n * @param operatorName Operator name to check\n * @returns Boolean. If 'from' extended operator.\n */\nfunction isFromExtendedOperator(operatorName: string): operatorName is ExtendedFROMOperatorName {\n\treturn Object.keys(extendedFromOperators).includes(operatorName);\n}\n\n/**\n * Check if the operator is a TO extended operator like \"TOTODAY\", \"TOTOMORROW\".\n * @param operatorName Operator name to check\n * @returns Boolean. If 'to' extended operator.\n */\nfunction isToExtendedOperator(operatorName: string): operatorName is ExtendedTOOperatorsName {\n\treturn Object.keys(extendedToOperators).includes(operatorName);\n}\n\n/**\n * Get extended operator by combining \"FROM\" and \"TO\" operations with single value dates.\n * @param operatorName Operator name\n * @param resourceBundle Resource to collect translated texts for the operators to be shown in UI.\n * @returns RangeOperator\n */\nfunction getExtendedOperator(operatorName: ExtendedOperatorName, resourceBundle: ResourceBundle): RangeOperator {\n\tconst { primitiveOperator } = extendedOperators[operatorName];\n\tconst filterOperator = ExtendedSemanticDateOperators.getFilterOperator(operatorName) as ModelOperator.GE | ModelOperator.LE;\n\tconst tokenTextKey = `M_EXTENDED_OPERATOR_${operatorName}_TOKEN_TEXT`;\n\treturn ExtendedSemanticDateOperators.createRangeOperator({\n\t\tname: operatorName,\n\t\tlongText: resourceBundle.getText(tokenTextKey, []),\n\t\ttokenText: `${resourceBundle.getText(tokenTextKey, [])} ({0})`,\n\t\tvalueTypes: [OperatorValueType.Static],\n\t\tfilterOperator,\n\t\tgroup: { id: 3, text: resourceBundle.getText(`M_EXTENDED_OPERATOR_GRP_TEXT`, []) },\n\t\tcalcRange: function (): UniversalDate[] {\n\t\t\tconst [fromPick, toPick] = operatorsToExtend[primitiveOperator].fnRanges();\n\t\t\treturn [isFromExtendedOperator(operatorName) ? fromPick : toPick];\n\t\t}\n\t});\n}\n\nconst ExtendedSemanticDateOperators = {\n\t/**\n\t * Creation of RangeOperator from configuration.\n\t * @param config Range Operator configurations\n\t * @returns Range Operator\n\t */\n\tcreateRangeOperator(config: Configuration): RangeOperator {\n\t\treturn new RangeOperator({ ...config });\n\t},\n\n\t/**\n\t * Operators Info to help decide which operations the user wants to enable.\n\t * @returns Operators Info\n\t */\n\tgetOperatorsInfo(): Record<ExtendedFROMOperatorName, ExtendedOperation> {\n\t\treturn extendedOperators;\n\t},\n\n\t/**\n\t * Extended Semantic Date operations that can be used.\n\t * @returns Extended Operator names\n\t */\n\tgetSemanticDateOperations(): string[] {\n\t\treturn [...extendedOperatorNames];\n\t},\n\n\t/**\n\t * Get the single date operator used to create the extended operator.\n\t * @param operatorName Extended operator name\n\t * @returns Single date operator name\n\t */\n\tgetCorrespondingSingleDateOperator(operatorName: ExtendedOperatorName): SingleValueDateOperatorName {\n\t\tconst { primitiveOperator } = extendedOperators[operatorName];\n\t\treturn primitiveOperator;\n\t},\n\n\t/**\n\t * Checks if it is an extended operator.\n\t * @param operatorName Operator name to check\n\t * @returns Extended Operator names\n\t */\n\tisExtendedOperator(operatorName: string): operatorName is ExtendedOperatorName {\n\t\treturn (extendedOperatorNames as string[]).includes(operatorName);\n\t},\n\n\t/**\n\t * Check if the operator is a TO extended operator like \"TOTODAY\", \"TOTOMORROW\".\n\t * @param operatorName Operator name to check\n\t * @returns Boolean. If 'to' extended operator.\n\t */\n\tgetFilterOperator(operatorName: ExtendedOperatorName): FilterOperator {\n\t\tlet filterOperator = ModelOperator.EQ;\n\t\tif (isFromExtendedOperator(operatorName)) {\n\t\t\tfilterOperator = ModelOperator.GE;\n\t\t} else if (isToExtendedOperator(operatorName)) {\n\t\t\tfilterOperator = ModelOperator.LE;\n\t\t}\n\t\treturn filterOperator;\n\t},\n\n\t/**\n\t * Add extended operations to MDC filtering environment.\n\t *\n\t * Presently only single value date operators extended via TO/FROM operations can be added.\n\t * These include...\n\t * 1. \"FROMYESTERDAY\".\n\t * 2. \"FROMTODAY\".\n\t * 3. \"FROMTOMORROW\".\n\t * 4. \"FROMFIRSTDAYWEEK\".\n\t * 5. \"FROMLASTDAYWEEK\".\n\t * 6. \"FROMFIRSTDAYMONTH\".\n\t * 7. \"FROMLASTDAYMONTH\".\n\t * 8. \"FROMFIRSTDAYQUARTER\".\n\t * 9. \"FROMLASTDAYQUARTER\".\n\t * 10. \"FROMFIRSTDAYYEAR\".\n\t * 11. \"FROMLASTDAYYEAR\".\n\t * 12. \"TOYESTERDAY\".\n\t * 13. \"TOTODAY\".\n\t * 14. \"TOTOMORROW\".\n\t * 15. \"TOFIRSTDAYWEEK\".\n\t * 16. \"TOLASTDAYWEEK\".\n\t * 17. \"TOFIRSTDAYMONTH\".\n\t * 18. \"TOLASTDAYMONTH\".\n\t * 19. \"TOFIRSTDAYQUARTER\".\n\t * 20. \"TOLASTDAYQUARTER\".\n\t * 21. \"TOFIRSTDAYYEAR\".\n\t * 22. \"TOLASTDAYYEAR\".\n\t *\n\t * These custom operators created by FE are not available by default with MDC filtering environment.\n\t * The need to be added on-demand via MDC APIs like 'FilterOperatorUtils.addOperator'.\n\t *\n\t * If operatorNames is undefined, then we add all extended semantic date operators.\n\t * @param operatorNames Operation names to be added or undefined.\n\t */\n\taddExtendedFilterOperators(operatorNames: string[] = extendedOperatorNames): void {\n\t\tconst resourceBundle = Library.getResourceBundleFor(\"sap.fe.macros\")!;\n\t\tconst operators: RangeOperator[] = operatorNames.reduce((operators, operatorName) => {\n\t\t\tif (!FilterOperatorUtil.getOperator(operatorName) && ExtendedSemanticDateOperators.isExtendedOperator(operatorName)) {\n\t\t\t\tconst operator = getExtendedOperator(operatorName, resourceBundle);\n\t\t\t\toperators.push(operator);\n\t\t\t}\n\t\t\treturn operators;\n\t\t}, [] as RangeOperator[]);\n\t\tFilterOperatorUtil.addOperators(operators);\n\t}\n};\n\nexport default ExtendedSemanticDateOperators;\n"],"mappings":"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","ignoreList":[],"file":"ExtendedSemanticDateOperators-dbg.js"}