{"version":3,"file":"SemanticDateOperators.js","names":["fixedDateOperators","basicOperators","_filterOperation","oOperation","aOperatorConfiguration","Array","isArray","operationKey","isExtendedOperator","ExtendedSemanticDateOperators","bResult","configFound","some","oOperatorConfiguration","j","path","sValue","bExclude","exclude","aOperatorValues","contains","split","length","includes","equals","getOperatorsInfo","type","DefaultSemanticDateOperators","SemanticDateOperators","getBasicSemanticDateOperations","getSemanticDateOperations","removeSemanticDateOperators","getFilterOperations","aOperations","operators","n","push","map","key","hasSemanticDateOperations","filterConditions","includeCheckForBasicOperators","arguments","undefined","semanticDateOps","this","filterCondtion","conditionWithSemanticOperator","find","condition","operator","getSemanticOpsFilterProperties","filterSelectOptions","filtersWithSemanticOperators","filterName","filterInfo","Object","entries","filterSemanticInfo","SemanticDates","filterType","getSemanticDateFiltersWithFlpPlaceholders","filtersWithSemanticOpsInfo","propertiesInfo","semanticDateFilters","flpMappedPlaceholders","forEach","_ref","correspondingPropertyInfo","propertyInfo","typeConfig","className","ODATA_TYPE_MAPPING","semanticOperator","value1","high","value2","low","filter","operatorKeyForFlpPlaceholder","getCorrespondingSingleDateOperator","getFilterOperator","Filter","commonOperatorSuffix","val","join","startFilterKey","endFilterKey","commonPrefixPlaceholder","geFilter","leFilter","filterOperator","FilterOperator","GE","filters","and","addSemanticDateOperators","addExtendedFilterOperators"],"sources":["./SemanticDateOperators.ts"],"sourcesContent":["import type { OperatorConfiguration } from \"sap/fe/core/converters/ManifestSettings\";\nimport { ODATA_TYPE_MAPPING } from \"sap/fe/core/templating/DisplayModeFormatter\";\nimport * as DefaultSemanticDateOperators from \"sap/fe/macros/filterBar/DefaultSemanticDateOperators\";\nimport ExtendedSemanticDateOperators from \"sap/fe/macros/filterBar/ExtendedSemanticDateOperators\";\nimport type { PropertyInfo } from \"sap/fe/macros/internal/PropertyInfo\";\nimport type { SelectOption, SemanticDateConfiguration } from \"sap/fe/navigation/SelectionVariant\";\nimport type { Filter as StateUtilFilter } from \"sap/ui/mdc/p13n/StateUtil\";\nimport Filter from \"sap/ui/model/Filter\";\nimport FilterOperator from \"sap/ui/model/FilterOperator\";\n\nconst fixedDateOperators = [\"TODAY\", \"TOMORROW\", \"YESTERDAY\"];\nconst basicOperators = [\"DATE\", \"FROM\", \"TO\", \"DATERANGE\"];\n\ntype semanticDateFiltersInfo = {\n\tfilterName: string;\n\tfilterSemanticInfo: SemanticDateConfiguration;\n\tfilterType: string;\n};\n\n/**\n * Check if the filter operation is supported by user configurations.\n *\n * Scenarios:\n * 1. If no configuration is maintained, then only all default semantic date operators shall be shown for the filter field.\n * 2. If configurations are maintained, then configuration shall be applied to the particular filter field.\n *\n * In case of extended operators that are a combination of single date operator like \"TODAY\", \"TOMORROW\" etc. with \"TO\"/\"FROM\" operators,\n * they shall not be shown by default.\n * The user will have to maintain configuration to enable them.\n * @param oOperation Operation\n * @param oOperation.key Operator identifier\n * @param oOperation.category Type of semantic date operation\n * @param aOperatorConfiguration User configurations for filter fields\n * @returns Extended Operator names\n */\nfunction _filterOperation(\n\toOperation: { key: string; category: string },\n\taOperatorConfiguration?: OperatorConfiguration[]\n): boolean | undefined {\n\tif (!aOperatorConfiguration) {\n\t\treturn true;\n\t}\n\taOperatorConfiguration = Array.isArray(aOperatorConfiguration) ? aOperatorConfiguration : [aOperatorConfiguration];\n\tconst operationKey = oOperation[\"key\"];\n\tconst isExtendedOperator = ExtendedSemanticDateOperators.isExtendedOperator(operationKey);\n\tlet bResult;\n\n\tconst configFound = aOperatorConfiguration.some(function (oOperatorConfiguration: OperatorConfiguration): boolean {\n\t\tlet j;\n\t\tif (!oOperatorConfiguration.path) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst sValue = oOperation[oOperatorConfiguration.path as keyof typeof oOperation];\n\t\tconst bExclude = oOperatorConfiguration.exclude ?? isExtendedOperator ?? false;\n\t\tlet aOperatorValues;\n\n\t\tif (oOperatorConfiguration.contains && sValue) {\n\t\t\taOperatorValues = oOperatorConfiguration.contains.split(\",\");\n\t\t\tfor (j = 0; j < aOperatorValues.length; j++) {\n\t\t\t\tif (bExclude && sValue.includes(aOperatorValues[j])) {\n\t\t\t\t\tbResult = false;\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!bExclude && sValue.includes(aOperatorValues[j])) {\n\t\t\t\t\tbResult = true;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (oOperatorConfiguration.equals && sValue) {\n\t\t\taOperatorValues = oOperatorConfiguration.equals.split(\",\");\n\t\t\tfor (j = 0; j < aOperatorValues.length; j++) {\n\t\t\t\tif (bExclude && sValue === aOperatorValues[j]) {\n\t\t\t\t\tbResult = false;\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (!bExclude && sValue === aOperatorValues[j]) {\n\t\t\t\t\tbResult = true;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t});\n\treturn configFound ? bResult : !isExtendedOperator;\n}\n// Get the operators based on type\nfunction getOperatorsInfo(type: string | undefined): Record<string, { key: string; category: string }> {\n\treturn { ...DefaultSemanticDateOperators.getOperatorsInfo(type), ...ExtendedSemanticDateOperators.getOperatorsInfo() };\n}\nconst SemanticDateOperators = {\n\t/**\n\t * Get basic semantic date operator names.\n\t * @returns Basic Operator names like \"DATE\", \"FROM\", \"TO\", \"DATERANGE\".\n\t */\n\tgetBasicSemanticDateOperations: function (): string[] {\n\t\treturn [...basicOperators];\n\t},\n\n\t/**\n\t * Get all supported semantic date operator names that can be used via FE macro filter bar.\n\t * @param type\n\t * @returns Operator names.\n\t */\n\tgetSemanticDateOperations: function (type?: string): string[] {\n\t\treturn [\n\t\t\t...DefaultSemanticDateOperators.getSemanticDateOperations(type),\n\t\t\t...ExtendedSemanticDateOperators.getSemanticDateOperations()\n\t\t];\n\t},\n\t// TODO: Would need to check with MDC for removeOperator method\n\t// eslint-disable-next-line @typescript-eslint/no-empty-function\n\tremoveSemanticDateOperators: function (): void {},\n\t// To filter operators based on manifest aOperatorConfiguration settings\n\tgetFilterOperations: function (aOperatorConfiguration: OperatorConfiguration[], type?: string): string[] {\n\t\tconst aOperations: { key: string; category: string }[] = [];\n\t\tconst operators = getOperatorsInfo(type);\n\t\tfor (const n in operators) {\n\t\t\tconst oOperation = operators[n];\n\t\t\tif (_filterOperation(oOperation, aOperatorConfiguration)) {\n\t\t\t\taOperations.push(oOperation);\n\t\t\t}\n\t\t}\n\t\treturn aOperations.map(function (oOperation) {\n\t\t\treturn oOperation.key;\n\t\t});\n\t},\n\n\t/**\n\t * The function will check if any of the filter conditions does not have a semantic operator or a date operator.\n\t * This includes actual date fields along with Semantic operator.\n\t * If the 2nd parameter is false, we only check if filter has the semantic Operator.\n\t * @param filterConditions Filter conditions\n\t * @param includeCheckForBasicOperators Should include basic operator along with semantic operator\n\t * @returns True if any of the filter conditions is not semantic field\n\t */\n\thasSemanticDateOperations: function (filterConditions: StateUtilFilter, includeCheckForBasicOperators = true): boolean {\n\t\tconst semanticDateOps = this.getSemanticDateOperations();\n\t\tfor (const key in filterConditions) {\n\t\t\tconst filterCondtion = filterConditions[key];\n\t\t\tconst conditionWithSemanticOperator = filterCondtion.find(function (condition) {\n\t\t\t\treturn semanticDateOps.includes(condition.operator);\n\t\t\t});\n\t\t\tif (conditionWithSemanticOperator) {\n\t\t\t\tif (includeCheckForBasicOperators) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\t// if operator is one of basic operator and not a semantic operator then we return false\n\t\t\t\t\treturn !basicOperators.includes(conditionWithSemanticOperator.operator);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetSemanticOpsFilterProperties: function (filterSelectOptions: Record<string, SelectOption[]>): semanticDateFiltersInfo[] {\n\t\tconst filtersWithSemanticOperators = [];\n\n\t\tfor (const [filterName, filterInfo] of Object.entries(filterSelectOptions)) {\n\t\t\tconst filterSemanticInfo = filterInfo[0].SemanticDates;\n\t\t\tif (filterSemanticInfo && !basicOperators.includes(filterSemanticInfo.operator)) {\n\t\t\t\tfiltersWithSemanticOperators.push({ filterName, filterSemanticInfo, filterType: \"\" });\n\t\t\t}\n\t\t}\n\t\treturn filtersWithSemanticOperators;\n\t},\n\n\tgetSemanticDateFiltersWithFlpPlaceholders(\n\t\tfiltersWithSemanticOpsInfo: semanticDateFiltersInfo[],\n\t\tpropertiesInfo: PropertyInfo[]\n\t): [Record<string, string>, Filter[]] {\n\t\tconst semanticDateFilters: Filter[] = [];\n\t\tconst flpMappedPlaceholders: Record<string, string> = {};\n\n\t\tfiltersWithSemanticOpsInfo.forEach(({ filterName, filterSemanticInfo, filterType }) => {\n\t\t\tconst correspondingPropertyInfo = propertiesInfo.find(\n\t\t\t\t(propertyInfo) => (propertyInfo as PropertyInfo & { key?: string }).key === filterName\n\t\t\t);\n\t\t\tif (correspondingPropertyInfo && correspondingPropertyInfo.typeConfig?.className) {\n\t\t\t\tfilterType = ODATA_TYPE_MAPPING[correspondingPropertyInfo.typeConfig?.className];\n\t\t\t}\n\t\t\tconst semanticOperator = filterSemanticInfo.operator;\n\t\t\tconst value1 = filterSemanticInfo.high;\n\t\t\tconst value2 = filterSemanticInfo.low;\n\n\t\t\tif (semanticOperator) {\n\t\t\t\tlet filter;\n\t\t\t\tconst isExtendedOperator = ExtendedSemanticDateOperators.isExtendedOperator(semanticOperator);\n\t\t\t\t// FLP only understands single date operators like TODAY, YESTERDAY etc.\n\t\t\t\t// So in case of extended operators, we would need to use the single date operator(primitive semantic date operator) used in creating the extended operator.\n\t\t\t\tconst operatorKeyForFlpPlaceholder = isExtendedOperator\n\t\t\t\t\t? ExtendedSemanticDateOperators.getCorrespondingSingleDateOperator(semanticOperator)\n\t\t\t\t\t: semanticOperator;\n\t\t\t\tif ((isExtendedOperator || fixedDateOperators.includes(semanticOperator)) && filterType !== \"Edm.DateTimeOffset\") {\n\t\t\t\t\tconst key = `${filterName}placeholder`;\n\t\t\t\t\tconst operator = isExtendedOperator ? ExtendedSemanticDateOperators.getFilterOperator(semanticOperator) : \"EQ\";\n\t\t\t\t\tfilter = new Filter({\n\t\t\t\t\t\tpath: filterName,\n\t\t\t\t\t\toperator,\n\t\t\t\t\t\tvalue1: key\n\t\t\t\t\t});\n\t\t\t\t\tflpMappedPlaceholders[key] = `{${filterType}%%DynamicDate.${operatorKeyForFlpPlaceholder}%%}`;\n\t\t\t\t} else {\n\t\t\t\t\tconst commonOperatorSuffix = [operatorKeyForFlpPlaceholder, value1, value2]\n\t\t\t\t\t\t.filter((val) => val !== undefined && val !== null)\n\t\t\t\t\t\t.join(\".\");\n\t\t\t\t\tconst startFilterKey = `${filterName}placeholderStart`;\n\t\t\t\t\tconst endFilterKey = `${filterName}placeholderEnd`;\n\t\t\t\t\tconst commonPrefixPlaceholder = `${filterType}%%DynamicDate.${commonOperatorSuffix}`;\n\t\t\t\t\tconst geFilter = new Filter({\n\t\t\t\t\t\tpath: filterName,\n\t\t\t\t\t\toperator: \"GE\",\n\t\t\t\t\t\tvalue1: startFilterKey\n\t\t\t\t\t});\n\t\t\t\t\tconst leFilter = new Filter({\n\t\t\t\t\t\tpath: filterName,\n\t\t\t\t\t\toperator: \"LE\",\n\t\t\t\t\t\tvalue1: endFilterKey\n\t\t\t\t\t});\n\n\t\t\t\t\tif (isExtendedOperator) {\n\t\t\t\t\t\t// Extended operators are combination of single date operators like TODAY with range operator like FROM or TO.\n\t\t\t\t\t\t// In such case, single date is the anchor for the filter and the operator LE or GE is decided based on the range TO or FROM.\n\t\t\t\t\t\tconst filterOperator = ExtendedSemanticDateOperators.getFilterOperator(semanticOperator);\n\t\t\t\t\t\tfilter = filterOperator === FilterOperator.GE ? geFilter : leFilter;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// The dates' end points(start and end) shall create the range for the filter.\n\t\t\t\t\t\tfilter = new Filter({\n\t\t\t\t\t\t\tfilters: [geFilter, leFilter],\n\t\t\t\t\t\t\tand: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tflpMappedPlaceholders[startFilterKey] = `{${commonPrefixPlaceholder}.start%%}`;\n\t\t\t\t\tflpMappedPlaceholders[endFilterKey] = `{${commonPrefixPlaceholder}.end%%}`;\n\t\t\t\t}\n\n\t\t\t\tsemanticDateFilters.push(filter);\n\t\t\t}\n\t\t});\n\n\t\treturn [flpMappedPlaceholders, semanticDateFilters];\n\t},\n\n\t/**\n\t * Add all semantic date operators that can be supported by FE FilterBar building block to MDC environment.\n\t */\n\taddSemanticDateOperators(): void {\n\t\tDefaultSemanticDateOperators.addSemanticDateOperators();\n\t\tExtendedSemanticDateOperators.addExtendedFilterOperators();\n\t}\n};\nexport default SemanticDateOperators;\n"],"mappings":"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","ignoreList":[]}