{"version":3,"file":"TableExport.js","names":["TableExport","_exports","_proto","prototype","setupMixin","_baseClass","setTableBindingInfo","bindingInfo","this","tableBindingInfo","setDownloadUrl","async","downloadUrl","undefined","getTableDefinition","enableAnalytics","table","getContent","propertyHelper","getPropertyHelper","columnsExportSettings","mdcColumn","getColumns","concat","getColumnExportSettings","bindingParameters","collectionKeys","getDataModelObjectForMetaPath","metaPath","contextPath","targetEntityType","keys","map","key","name","selectProperties","column","Array","isArray","property","join","forEach","includes","push","requestAtLeastProperties","Object","requestAtLeast","prop","parameters","$search","$$aggregation","tableBinding","getRowBinding","downloadListBinding","getModel","bindList","getPath","getContext","sorter","filters","requestDownloadUrl","destroy","error","Log","debug","_onBeforeExport","exportEvent","isSplitMode","getParameter","splitCells","getSource","exportSettings","tableDefinition","updateExportSettings","columns","setStaticSizeLimit","exportColumns","workbook","index","length","exportColumn","resourceBundle","Library","getResourceBundleFor","label","getLocalizedText","translateBooleanValueForExport","setExportConfig","addTargetValueColumn","valueMap","JSON","parse","tableAPIDownloadUrl","getParent","dataSource","dataUrl","setFileAndSheetName","control","exportFileName","fileName","exportSheetName","context","sheetName","type","sizeLimit","exportRequestSize","trueValue","falseValue","getText","referencedColumn","find","propertyInfos","relativePath","toString","exportConfigList","targetValueColumn","isPropertyFromExport","columnWithTargetValueToBeAdded","columnToBeAdded","template","exportDataPointTargetValue","splice","columnExport","columnNeedsToBeAdded"],"sources":["./TableExport.ts"],"sourcesContent":["import Log from \"sap/base/Log\";\nimport type ResourceBundle from \"sap/base/i18n/ResourceBundle\";\nimport { type IInterfaceWithMixin } from \"sap/fe/base/ClassSupport\";\nimport { type TableVisualization } from \"sap/fe/core/converters/controls/Common/Table\";\nimport {\n\ttype AnnotationTableColumn,\n\ttype ColumnExportSettings,\n\ttype TableColumn\n} from \"sap/fe/core/converters/controls/Common/table/Columns\";\nimport { getLocalizedText } from \"sap/fe/core/helpers/ResourceModelHelper\";\nimport { type CollectionBindingInfo } from \"sap/fe/macros/CollectionBindingInfo\";\nimport Library from \"sap/ui/core/Lib\";\nimport type { TextAlign } from \"sap/ui/core/library\";\nimport type MDCTable from \"sap/ui/mdc/Table\";\nimport { type Table$BeforeExportEvent } from \"sap/ui/mdc/Table\";\nimport type ODataModel from \"sap/ui/model/odata/v4/ODataModel\";\nimport { type ITableBlock } from \"../TableAPI\";\n\ntype ExportColumn = {\n\tproperty: string | string[];\n\tlabel: string;\n\tcolumnId?: string;\n\twidth?: number;\n\ttextAlign?: TextAlign;\n\tdisplayUnit?: boolean;\n\ttrueValue?: string;\n\tfalseValue?: string;\n\tvalueMap?: string;\n\ttemplate?: string;\n\ttype?: string;\n\tdelimiter?: boolean;\n\twrap?: boolean;\n\tunit?: string;\n\tscale?: number;\n};\n\ntype UserExportSettings = {\n\tsplitCells?: boolean;\n};\n\n// The type ExportSettings is not exported from \"sap/ui/export/library\" so we need to redefine them here\nexport type ExportSettings = {\n\tfileName?: string;\n\tdataSource: {\n\t\tdataUrl: string;\n\t\tsizeLimit?: number;\n\t};\n\tworkbook: {\n\t\tcolumns: ExportColumn[];\n\t\tcontext?: { sheetName?: string };\n\t};\n};\n\nexport default class TableExport implements IInterfaceWithMixin {\n\tdownloadUrl?: string;\n\n\ttableBindingInfo?: CollectionBindingInfo;\n\n\tsetupMixin(_baseClass: Function): void {\n\t\t// This method is needed to implement interface IInterfaceWithMixin\n\t}\n\n\t/**\n\t * Stores the binding info for the table used to create the list binding.\n\t * @param bindingInfo\n\t */\n\tsetTableBindingInfo(bindingInfo: CollectionBindingInfo): void {\n\t\tthis.tableBindingInfo = bindingInfo;\n\t}\n\n\t/**\n\t * Compute the download URL to be used by the export and store it in the TableAPI.\n\t * @param this\n\t * @returns Promise when downloadUrl is set\n\t */\n\tasync setDownloadUrl(this: ITableBlock & TableExport): Promise<void> {\n\t\t//empty the downloadUrl to prevent an invalid one to be used\n\t\tthis.downloadUrl = undefined;\n\n\t\tif (this.getTableDefinition().enableAnalytics === true) {\n\t\t\t// In case of an analytical table, $select is not supported, so we don't calculate the download URL (we use the default behaviour)\n\t\t\treturn;\n\t\t}\n\n\t\tlet downloadUrl: string | undefined | null;\n\t\tconst table = this.getContent();\n\t\ttry {\n\t\t\tconst propertyHelper = table.getPropertyHelper();\n\t\t\tlet columnsExportSettings: ExportColumn[] = [];\n\t\t\tfor (const mdcColumn of table.getColumns()) {\n\t\t\t\tcolumnsExportSettings = columnsExportSettings.concat(propertyHelper.getColumnExportSettings(mdcColumn));\n\t\t\t}\n\n\t\t\tconst bindingParameters: { $select?: string; $search?: string; $$aggregation?: object } = {};\n\t\t\t// we just want to request the properties necessary for the export\n\t\t\tconst collectionKeys = this.getDataModelObjectForMetaPath(this.metaPath, this.contextPath)?.targetEntityType.keys.map(\n\t\t\t\t(key) => key.name\n\t\t\t);\n\t\t\tconst selectProperties = columnsExportSettings.map((column: ExportColumn) => {\n\t\t\t\treturn Array.isArray(column.property) ? column.property.join(\",\") : column.property;\n\t\t\t});\n\t\t\tcollectionKeys?.forEach((key) => {\n\t\t\t\tif (!selectProperties.includes(key)) {\n\t\t\t\t\tselectProperties.push(key);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst requestAtLeastProperties = Object.keys(this.getTableDefinition().requestAtLeast);\n\t\t\trequestAtLeastProperties?.forEach((prop) => {\n\t\t\t\tif (!selectProperties.includes(prop)) {\n\t\t\t\t\tselectProperties.push(prop);\n\t\t\t\t}\n\t\t\t});\n\t\t\tbindingParameters[\"$select\"] = selectProperties.join(\",\");\n\n\t\t\tif (this.tableBindingInfo?.parameters?.$search) {\n\t\t\t\tbindingParameters.$search = this.tableBindingInfo.parameters.$search;\n\t\t\t}\n\n\t\t\tif (this.tableBindingInfo?.parameters?.$$aggregation) {\n\t\t\t\tbindingParameters.$$aggregation = this.tableBindingInfo.parameters.$$aggregation;\n\t\t\t}\n\n\t\t\tconst tableBinding = table.getRowBinding();\n\t\t\t// we create a list binding to compute the right url for the export from its binding parameters\n\t\t\tconst downloadListBinding = (tableBinding.getModel() as ODataModel).bindList(\n\t\t\t\ttableBinding.getPath(),\n\t\t\t\ttableBinding.getContext(),\n\t\t\t\tthis.tableBindingInfo?.sorter,\n\t\t\t\tthis.tableBindingInfo?.filters,\n\t\t\t\tbindingParameters\n\t\t\t);\n\t\t\tdownloadUrl = await downloadListBinding.requestDownloadUrl();\n\t\t\tdownloadListBinding.destroy();\n\t\t} catch (error: unknown) {\n\t\t\tLog.debug(\"Error while computing the download URL for the export\", error as Error);\n\t\t}\n\t\tif (downloadUrl) {\n\t\t\tthis.downloadUrl = downloadUrl;\n\t\t}\n\t}\n\n\t/**\n\t * Intercept the export before it's triggered to cover specific cases that couldn't be addressed on the propertyInfos for each column.\n\t * e.g. Fixed Target Value for the datapoints.\n\t * @param this\n\t * @param exportEvent\n\t */\n\t_onBeforeExport(this: ITableBlock & TableExport, exportEvent: Table$BeforeExportEvent): void {\n\t\tconst isSplitMode = (exportEvent.getParameter(\"userExportSettings\") as UserExportSettings)?.splitCells === true;\n\t\tconst table = exportEvent.getSource(),\n\t\t\texportSettings = exportEvent.getParameter(\"exportSettings\") as ExportSettings,\n\t\t\ttableDefinition = this.getTableDefinition();\n\n\t\tTableExport.updateExportSettings(exportSettings, tableDefinition, table, isSplitMode);\n\t}\n\n\t/**\n\t * Updates the table columns that can be exported.\n\t * @param exportSettings The table export settings\n\t * @param tableDefinition The table definition from the table converter\n\t * @param table The table\n\t * @param isSplitMode Defines if the export has been launched using split mode\n\t * @returns The updated columns to be exported\n\t */\n\tstatic updateExportSettings(\n\t\texportSettings: ExportSettings,\n\t\ttableDefinition: TableVisualization,\n\t\ttable: MDCTable,\n\t\tisSplitMode: boolean\n\t): ExportSettings {\n\t\tconst columns = tableDefinition.columns;\n\t\tthis.setStaticSizeLimit(tableDefinition, exportSettings);\n\t\tconst exportColumns = exportSettings.workbook.columns;\n\t\tfor (let index = exportColumns.length - 1; index >= 0; index--) {\n\t\t\tconst exportColumn = exportColumns[index];\n\t\t\tconst resourceBundle = Library.getResourceBundleFor(\"sap.fe.macros\")!;\n\t\t\texportColumn.label = getLocalizedText(exportColumn.label, table);\n\t\t\tthis.translateBooleanValueForExport(exportColumn, resourceBundle);\n\t\t\tif (isSplitMode) {\n\t\t\t\tthis.setExportConfig(columns, exportColumns, index);\n\t\t\t\tthis.addTargetValueColumn(columns, exportColumns, resourceBundle, index);\n\t\t\t}\n\t\t\tif (exportColumn.valueMap && typeof exportColumn.valueMap === \"string\") {\n\t\t\t\texportColumn.valueMap = JSON.parse(exportColumn.valueMap);\n\t\t\t}\n\t\t}\n\t\tconst tableAPIDownloadUrl = (table.getParent() as ITableBlock & TableExport).downloadUrl;\n\t\tif (tableAPIDownloadUrl) {\n\t\t\texportSettings.dataSource.dataUrl = tableAPIDownloadUrl;\n\t\t}\n\t\tthis.setFileAndSheetName(exportSettings, tableDefinition);\n\t\treturn exportSettings;\n\t}\n\n\t/**\n\t * Sets the file name and sheet name for the export settings.\n\t * @param exportSettings The table export settings\n\t * @param tableDefinition The table definition from the table converter\n\t */\n\tstatic setFileAndSheetName(exportSettings: ExportSettings, tableDefinition: TableVisualization): void {\n\t\tif (tableDefinition.control.exportFileName) {\n\t\t\texportSettings.fileName = tableDefinition.control.exportFileName;\n\t\t}\n\t\tif (tableDefinition.control.exportSheetName && exportSettings.workbook.context) {\n\t\t\texportSettings.workbook.context.sheetName = tableDefinition.control.exportSheetName;\n\t\t}\n\t}\n\n\t/**\n\t * Sets the static size limit for the table export.\n\t * @param tableDefinition The table definition from the table converter\n\t * @param exportSettings The table export settings\n\t */\n\tstatic setStaticSizeLimit(tableDefinition: TableVisualization, exportSettings: ExportSettings): void {\n\t\tif (\n\t\t\t!tableDefinition.enableAnalytics &&\n\t\t\t(tableDefinition.control.type === \"ResponsiveTable\" || tableDefinition.control.type === \"GridTable\")\n\t\t) {\n\t\t\texportSettings.dataSource.sizeLimit = tableDefinition.control.exportRequestSize ?? 1000;\n\t\t} else if (tableDefinition.control.exportRequestSize) {\n\t\t\t// In case of analytical or tree table, the size limit is set to the one defined in the table definition\n\t\t\texportSettings.dataSource.sizeLimit = tableDefinition.control.exportRequestSize;\n\t\t}\n\t}\n\n\t/**\n\t * Sets the translated textual representation of a column with a Boolean value.\n\t * @param exportColumn The column to be exported\n\t * @param resourceBundle The resource bundle\n\t */\n\tstatic translateBooleanValueForExport(exportColumn: ExportColumn, resourceBundle: ResourceBundle): void {\n\t\tif (exportColumn.type === \"Boolean\" && !(exportColumn.trueValue || exportColumn.falseValue)) {\n\t\t\texportColumn.falseValue = resourceBundle.getText(\"no\");\n\t\t\texportColumn.trueValue = resourceBundle.getText(\"yes\");\n\t\t}\n\t}\n\n\t/**\n\t * Sets the originating export config of a single property referenced on a field group or a custom column.\n\t * @param columns The columns from the table converter\n\t * @param exportColumns The list of columns to be exported\n\t * @param index The index of the column to be exported\n\t */\n\tstatic setExportConfig(columns: TableColumn[], exportColumns: ExportColumn[], index: number): void {\n\t\tconst referencedColumn = columns.find(\n\t\t\t(column) => !column.propertyInfos && (column as AnnotationTableColumn).relativePath === exportColumns[index].property.toString()\n\t\t);\n\t\tif (referencedColumn?.exportSettings) {\n\t\t\t// All export settings of a column to be exported can't be added to the export settings object\n\t\t\t// because column could have units/timezones/currencies that aren't required on custom customs but only on columns from annotations\n\t\t\tconst exportConfigList: Array<keyof ColumnExportSettings> = [\"scale\", \"delimiter\", \"format\", \"utc\", \"type\", \"inputFormat\"];\n\t\t\tfor (const key of exportConfigList) {\n\t\t\t\tif (referencedColumn.exportSettings[key]) {\n\t\t\t\t\texportColumns[index] = { ...exportColumns[index], ...{ [key]: referencedColumn.exportSettings[key] } };\n\t\t\t\t\tif (exportColumns[index].type === \"Currency\") {\n\t\t\t\t\t\texportColumns[index].type = \"Number\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Adds a target value column when there is a datapoint column.\n\t * @param columns The columns from the table converter\n\t * @param exportColumns The list of columns to be exported\n\t * @param resourceBundle The resource bundle\n\t * @param index The index of the column to be exported\n\t */\n\tstatic addTargetValueColumn(\n\t\tcolumns: TableColumn[],\n\t\texportColumns: ExportColumn[],\n\t\tresourceBundle: ResourceBundle,\n\t\tindex: number\n\t): void {\n\t\tconst targetValueColumn = (columns as AnnotationTableColumn[])?.find((column) => {\n\t\t\tif (!this.isPropertyFromExport(column, exportColumns[index])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn this.columnWithTargetValueToBeAdded(column, exportColumns[index]);\n\t\t});\n\t\tif (targetValueColumn) {\n\t\t\tconst columnToBeAdded: ExportColumn = {\n\t\t\t\tlabel: resourceBundle.getText(\"TargetValue\"),\n\t\t\t\tproperty: Array.isArray(exportColumns[index].property)\n\t\t\t\t\t? exportColumns[index].property\n\t\t\t\t\t: ([exportColumns[index].property] as string[]),\n\t\t\t\ttemplate: targetValueColumn.exportDataPointTargetValue\n\t\t\t};\n\t\t\texportColumns.splice(index + 1, 0, columnToBeAdded);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the column's property corresponds to the exportColumn.\n\t * @param column The column from the annotations column\n\t * @param exportColumn The column to be exported\n\t * @returns `true` Whether the column has the exportColumn property\n\t */\n\tstatic isPropertyFromExport(column: AnnotationTableColumn, exportColumn: ExportColumn): boolean {\n\t\tif (\n\t\t\tcolumn.relativePath === exportColumn.property ||\n\t\t\texportColumn.property.includes(column.relativePath) ||\n\t\t\texportColumn.property.includes(column.name)\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\t// In case of complex properties\n\t\tif (column.propertyInfos?.length === 1 && exportColumn.property[0] === column.propertyInfos[0]) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Defines if a column that is to be exported and contains a DataPoint with a fixed target value needs to be added.\n\t * @param column The column from the annotations column\n\t * @param columnExport The column to be exported\n\t * @returns `true` if the referenced column has defined a targetValue for the dataPoint, false else\n\t * @private\n\t */\n\tstatic columnWithTargetValueToBeAdded(column: AnnotationTableColumn, columnExport: ExportColumn): boolean {\n\t\tlet columnNeedsToBeAdded = false;\n\t\tif (column.exportDataPointTargetValue && column.propertyInfos?.length === 1) {\n\t\t\t//Add TargetValue column when exporting on split mode\n\t\t\t// part of a FieldGroup or from a lineItem or from a column on the entitySet\n\t\t\tdelete columnExport.template;\n\t\t\tcolumnNeedsToBeAdded = true;\n\t\t}\n\t\treturn columnNeedsToBeAdded;\n\t}\n}\n"],"mappings":"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","ignoreList":[]}