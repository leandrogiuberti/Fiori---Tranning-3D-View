{"version":3,"file":"ColumnManagement.js","names":["ColumnManagement","_exports","_proto","prototype","setupMixin","_baseClass","getPropertyUIHiddenCache","this","propertyUIHiddenCache","undefined","getDynamicVisibilityForColumns","dynamicVisibilityForColumns","checkIfColumnExists","aFilteredColummns","columnName","some","oColumn","sColumnNameVisible","sTextArrangement","getTableIdentifierColumnInfo","oTable","getContent","headerInfoTitlePath","getTableDefinition","headerInfoTitle","oMetaModel","getModel","getMetaModel","sCurrentEntitySetName","data","aTechnicalKeys","getObject","filteredTechnicalKeys","length","forEach","technicalKey","push","semanticKeyColumns","semanticKeys","aVisibleColumns","aTableColumns","getColumns","column","getPropertyKey","oTextArrangement","$Path","sTextPlacement","$EnumMember","getIdentifierColumn","isRecommendationRelevant","rootContext","standardRecommendationHelper","getCurrentRootContext","rootKeys","getInvolvedDataModelObjectEntityKeys","filter","key","includes","technicalKeys","computeColumnValue","tableRowContext","textAnnotationPath","textArrangement","sCodeValue","sTextValue","sComputedValue","lastIndexOf","slice","concat","sEnumNumber","indexOf","getTableColValue","tableColProperty","resourceModel","getResourceModel","labelNameWithVisibilityAndValue","visibility","columnLabel","getKeyColumnInfo","label","getText","keyColumn","columns","find","split","pop","isColumnValueVisible","rowContext","anyObject","dataModelPath","getDataModelAndConvertedTargetObject","visibleExpression","compileExpression","generateVisibleExpression","createAnyControl","setBindingContext","addDependent","columnValueVisible","getAny","checkColumnValueVisible","columnAvailability","Array","isArray","availableColumn","availability","checkVisibility","aFilteredColumns","col","getTableColumnVisibilityInfo","columnPropertyAndVisibility","availableKeys","modifyDynamicVisibilityForColumn","columnKey","visible","existingDynamicVisibility","dynamicVisibility","updateColumnsVisibility","ignoredFields","tableDefinition","updateColumnsVisibilityStatic","ignoredFieldNames","map","name","trim","ignoreColumn","relativePath","propertyInfos","relatedColumnName","relatedColumn","sortable","filterable","isGroupable"],"sources":["./ColumnManagement.ts"],"sourcesContent":["import { compileExpression } from \"sap/fe/base/BindingToolkit\";\nimport { type IInterfaceWithMixin } from \"sap/fe/base/ClassSupport\";\nimport type Any from \"sap/fe/core/controls/Any\";\nimport { getInvolvedDataModelObjectEntityKeys } from \"sap/fe/core/converters/MetaModelConverter\";\nimport type { TableVisualization } from \"sap/fe/core/converters/controls/Common/Table\";\nimport type { AnnotationTableColumn, TableColumn } from \"sap/fe/core/converters/controls/Common/table/Columns\";\nimport { getResourceModel } from \"sap/fe/core/helpers/ResourceModelHelper\";\nimport { standardRecommendationHelper } from \"sap/fe/core/helpers/StandardRecommendationHelper\";\nimport { generateVisibleExpression } from \"sap/fe/core/templating/DataFieldFormatters\";\nimport type MDCColumn from \"sap/ui/mdc/table/Column\";\nimport type Context from \"sap/ui/model/odata/v4/Context\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\nimport { type DynamicVisibilityForColumn, type ITableBlock, type TableColumnProperties } from \"../TableAPI\";\n\ntype FilteredColumn = {\n\tcolumnName: string;\n\tsTextArrangement: string;\n\tsColumnNameVisible: boolean;\n};\n\ntype TableKey = {\n\theaderInfoTitlePath: string | undefined;\n\tfilteredTechnicalKeys: string[];\n\tsemanticKeyColumns: string[];\n\taFilteredColummns: FilteredColumn[];\n};\n\n/**\n * A mixin for column-related logic in the table.\n */\nexport default class ColumnManagement implements IInterfaceWithMixin {\n\tpropertyUIHiddenCache?: Record<string, typeof Any>;\n\n\tdynamicVisibilityForColumns?: DynamicVisibilityForColumn[];\n\n\tsetupMixin(_baseClass: Function): void {\n\t\t// This method is needed to implement interface IInterfaceWithMixin\n\t}\n\n\tprivate getPropertyUIHiddenCache(): Record<string, typeof Any> {\n\t\tif (this.propertyUIHiddenCache === undefined) {\n\t\t\tthis.propertyUIHiddenCache = {};\n\t\t}\n\n\t\treturn this.propertyUIHiddenCache;\n\t}\n\n\tprivate getDynamicVisibilityForColumns(): DynamicVisibilityForColumn[] {\n\t\tif (this.dynamicVisibilityForColumns === undefined) {\n\t\t\tthis.dynamicVisibilityForColumns = [];\n\t\t}\n\n\t\treturn this.dynamicVisibilityForColumns;\n\t}\n\n\tcheckIfColumnExists(aFilteredColummns: FilteredColumn[], columnName: string): boolean {\n\t\treturn aFilteredColummns.some(function (oColumn: FilteredColumn) {\n\t\t\tif (\n\t\t\t\t(oColumn?.columnName === columnName && oColumn?.sColumnNameVisible) ||\n\t\t\t\t(oColumn?.sTextArrangement !== undefined && oColumn?.sTextArrangement === columnName)\n\t\t\t) {\n\t\t\t\treturn columnName;\n\t\t\t}\n\t\t});\n\t}\n\n\tgetTableIdentifierColumnInfo(this: ITableBlock & ColumnManagement): TableKey {\n\t\tconst oTable = this.getContent();\n\t\tconst headerInfoTitlePath = this.getTableDefinition().headerInfoTitle;\n\t\tconst oMetaModel = oTable && (oTable.getModel()?.getMetaModel() as ODataMetaModel),\n\t\t\tsCurrentEntitySetName = oTable.data(\"metaPath\");\n\t\tconst aTechnicalKeys = oMetaModel.getObject(`${sCurrentEntitySetName}/$Type/$Key`);\n\t\tconst filteredTechnicalKeys: string[] = [];\n\t\tif (aTechnicalKeys && aTechnicalKeys.length > 0) {\n\t\t\taTechnicalKeys.forEach(function (technicalKey: string) {\n\t\t\t\tif (technicalKey !== \"IsActiveEntity\") {\n\t\t\t\t\tfilteredTechnicalKeys.push(technicalKey);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tconst semanticKeyColumns = this.getTableDefinition().semanticKeys;\n\n\t\tconst aVisibleColumns: string[] = [];\n\t\tconst aFilteredColummns: FilteredColumn[] = [];\n\t\tconst aTableColumns = oTable.getColumns();\n\t\taTableColumns.forEach(function (oColumn: MDCColumn) {\n\t\t\tconst column = oColumn?.getPropertyKey?.();\n\t\t\tif (column) {\n\t\t\t\taVisibleColumns.push(column);\n\t\t\t}\n\t\t});\n\n\t\taVisibleColumns.forEach(function (oColumn: string) {\n\t\t\tconst oTextArrangement = oMetaModel.getObject(`${sCurrentEntitySetName}/$Type/${oColumn}@`);\n\t\t\tconst sTextArrangement = oTextArrangement && oTextArrangement[\"@com.sap.vocabularies.Common.v1.Text\"]?.$Path;\n\t\t\tconst sTextPlacement =\n\t\t\t\toTextArrangement &&\n\t\t\t\toTextArrangement[\"@com.sap.vocabularies.Common.v1.Text@com.sap.vocabularies.UI.v1.TextArrangement\"]?.$EnumMember;\n\t\t\taFilteredColummns.push({\n\t\t\t\tcolumnName: oColumn,\n\t\t\t\tsTextArrangement: sTextArrangement,\n\t\t\t\tsColumnNameVisible: !(sTextPlacement === \"com.sap.vocabularies.UI.v1.TextArrangementType/TextOnly\")\n\t\t\t});\n\t\t});\n\t\treturn {\n\t\t\theaderInfoTitlePath,\n\t\t\tfilteredTechnicalKeys,\n\t\t\tsemanticKeyColumns,\n\t\t\taFilteredColummns\n\t\t};\n\t}\n\n\tgetIdentifierColumn(this: ITableBlock & ColumnManagement, isRecommendationRelevant?: boolean): string | string[] | undefined {\n\t\tconst { headerInfoTitlePath, filteredTechnicalKeys, semanticKeyColumns, aFilteredColummns } = this.getTableIdentifierColumnInfo();\n\t\tlet column: string | string[] | undefined;\n\t\tif (isRecommendationRelevant) {\n\t\t\tconst rootContext = standardRecommendationHelper.getCurrentRootContext() as Context;\n\t\t\tconst rootKeys = getInvolvedDataModelObjectEntityKeys(rootContext);\n\t\t\tif (semanticKeyColumns.length > 0) {\n\t\t\t\tcolumn = semanticKeyColumns.filter((key) => !rootKeys.semanticKeys.includes(key));\n\t\t\t} else if (filteredTechnicalKeys.length > 0) {\n\t\t\t\tcolumn = filteredTechnicalKeys.filter((key) => !rootKeys.technicalKeys.includes(key));\n\t\t\t}\n\t\t\treturn column;\n\t\t}\n\n\t\tif (headerInfoTitlePath !== undefined && this.checkIfColumnExists(aFilteredColummns, headerInfoTitlePath)) {\n\t\t\tcolumn = headerInfoTitlePath;\n\t\t} else if (\n\t\t\tsemanticKeyColumns !== undefined &&\n\t\t\tsemanticKeyColumns.length === 1 &&\n\t\t\tthis.checkIfColumnExists(aFilteredColummns, semanticKeyColumns[0])\n\t\t) {\n\t\t\tcolumn = semanticKeyColumns[0];\n\t\t} else if (filteredTechnicalKeys.length === 1 && this.checkIfColumnExists(aFilteredColummns, filteredTechnicalKeys[0])) {\n\t\t\tcolumn = filteredTechnicalKeys[0];\n\t\t}\n\t\treturn column;\n\t}\n\n\t/**\n\t * Computes the column value with text arrangement.\n\t * @param key Modified key with text annotation path.\n\t * @param tableRowContext\n\t * @param textAnnotationPath\n\t * @param textArrangement\n\t * @returns Computed column value.\n\t */\n\tcomputeColumnValue(key: string, tableRowContext: Context, textAnnotationPath: string, textArrangement: string): string {\n\t\tconst sCodeValue = tableRowContext.getObject(key);\n\t\tlet sTextValue;\n\t\tlet sComputedValue = sCodeValue;\n\n\t\tif (textAnnotationPath) {\n\t\t\tif (key.lastIndexOf(\"/\") > 0) {\n\t\t\t\t// the target property is replaced with the text annotation path\n\t\t\t\tkey = key.slice(0, key.lastIndexOf(\"/\") + 1);\n\t\t\t\tkey = key.concat(textAnnotationPath);\n\t\t\t} else {\n\t\t\t\tkey = textAnnotationPath;\n\t\t\t}\n\t\t\tsTextValue = tableRowContext.getObject(key);\n\t\t\tif (sTextValue) {\n\t\t\t\tif (textArrangement) {\n\t\t\t\t\tconst sEnumNumber = textArrangement.slice(textArrangement.indexOf(\"/\") + 1);\n\t\t\t\t\tswitch (sEnumNumber) {\n\t\t\t\t\t\tcase \"TextOnly\":\n\t\t\t\t\t\t\tsComputedValue = sTextValue;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"TextFirst\":\n\t\t\t\t\t\t\tsComputedValue = `${sTextValue} (${sCodeValue})`;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"TextLast\":\n\t\t\t\t\t\t\tsComputedValue = `${sCodeValue} (${sTextValue})`;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"TextSeparate\":\n\t\t\t\t\t\t\tsComputedValue = sCodeValue;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsComputedValue = `${sTextValue} (${sCodeValue})`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sComputedValue;\n\t}\n\n\t/**\n\t * This function will get the value of first Column of Table with its text Arrangement.\n\t * @param tableRowContext\n\t * @param textAnnotationPath\n\t * @param textArrangement\n\t * @param tableColProperty\n\t * @returns Column Name with Visibility and its Value.\n\t */\n\tgetTableColValue(\n\t\tthis: ITableBlock & ColumnManagement,\n\t\ttableRowContext: Context,\n\t\ttextAnnotationPath: string,\n\t\ttextArrangement: string,\n\t\ttableColProperty: TableColumnProperties\n\t): string {\n\t\tconst resourceModel = getResourceModel(this.getContent());\n\t\tlet labelNameWithVisibilityAndValue = \"\";\n\t\tconst [{ key, visibility }] = tableColProperty;\n\t\tconst columnLabel = this.getKeyColumnInfo(key)?.label;\n\t\tconst sComputedValue = this.computeColumnValue(key, tableRowContext, textAnnotationPath, textArrangement);\n\t\tlabelNameWithVisibilityAndValue = visibility\n\t\t\t? `${columnLabel}: ${sComputedValue}`\n\t\t\t: `${columnLabel} (${resourceModel.getText(\"T_COLUMN_INDICATOR_IN_TABLE_DEFINITION\")}): ${sComputedValue}`;\n\t\treturn labelNameWithVisibilityAndValue;\n\t}\n\n\t/**\n\t * The method that is called to retrieve the column info from the associated message of the message popover.\n\t * @param keyColumn string or undefined\n\t * @returns Returns the column info.\n\t */\n\n\tgetKeyColumnInfo(this: ITableBlock & ColumnManagement, keyColumn?: string): TableColumn | undefined {\n\t\treturn this.getTableDefinition().columns.find(function (oColumn): boolean {\n\t\t\treturn oColumn.key.split(\"::\").pop() === keyColumn;\n\t\t});\n\t}\n\n\t/**\n\t * This method is used to check if the column is Path based UI.Hidden.\n\t * @param columnName string\n\t * @param rowContext Context\n\t * @returns Returns true if the column is Path based UI.Hidden and value visible on the UI, else returns false. Returns string 'true' if the column is not UI.Hidden, else returns 'false'.\n\t */\n\n\tisColumnValueVisible(this: ITableBlock & ColumnManagement, columnName: string, rowContext: Context | undefined): string | boolean {\n\t\tlet anyObject;\n\t\tif (!this.getPropertyUIHiddenCache()[columnName]) {\n\t\t\tconst dataModelPath = this.getDataModelAndConvertedTargetObject(columnName)?.dataModelPath;\n\t\t\tif (!dataModelPath) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconst visibleExpression = compileExpression(generateVisibleExpression(dataModelPath));\n\t\t\tanyObject = this.createAnyControl(visibleExpression, rowContext);\n\t\t\tthis.getPropertyUIHiddenCache()[columnName] = anyObject;\n\t\t\tanyObject.setBindingContext(null); // we need to set the binding context to null otherwise the following addDependent will set it to the context of the table\n\t\t\tthis.addDependent(anyObject);\n\t\t} else {\n\t\t\tanyObject = this.getPropertyUIHiddenCache()[columnName];\n\t\t}\n\t\tanyObject.setBindingContext(rowContext);\n\t\tconst columnValueVisible = anyObject.getAny() as string | boolean;\n\t\tanyObject.setBindingContext(null);\n\t\treturn columnValueVisible;\n\t}\n\n\t/**\n\t * Checks whether the column is UI.Hidden or not.\n\t * @param columnName string | string[]\n\t * @param tableRowContext Context\n\t * @returns string[] if the column name is not UI.Hidden.\n\t */\n\n\tcheckColumnValueVisible(\n\t\tthis: ITableBlock & ColumnManagement,\n\t\tcolumnName: string | string[],\n\t\ttableRowContext: Context | undefined\n\t): string[] | undefined {\n\t\tconst columnAvailability = Array.isArray(columnName) ? columnName : [columnName];\n\t\tconst availableColumn = [];\n\t\tfor (const column of columnAvailability) {\n\t\t\tconst availability = this.isColumnValueVisible(column, tableRowContext);\n\t\t\tif (availability === \"true\" || availability === true) {\n\t\t\t\tavailableColumn.push(column);\n\t\t\t}\n\t\t}\n\t\tif (availableColumn.length > 0) {\n\t\t\treturn availableColumn;\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether the column is present in the table view.\n\t * @param key string\n\t * @param aFilteredColumns\n\t * @returns `true` if the column is visible in the table view.\n\t */\n\n\tcheckVisibility(key: string, aFilteredColumns: FilteredColumn[]): { visibility: boolean } {\n\t\tconst column = aFilteredColumns.find((col: { columnName: string }) => col.columnName === key);\n\t\tif (column) {\n\t\t\treturn {\n\t\t\t\tvisibility: column.sColumnNameVisible\n\t\t\t};\n\t\t}\n\t\treturn { visibility: false };\n\t}\n\n\t/**\n\t * Retrieves the columns, visibility, and text arrangement based on priority order.\n\t * @param tableRowContext Context\n\t * @returns An object containing the column name and visibility.\n\t */\n\n\tgetTableColumnVisibilityInfo(this: ITableBlock & ColumnManagement, tableRowContext: Context | undefined): TableColumnProperties {\n\t\tconst { headerInfoTitlePath, filteredTechnicalKeys, semanticKeyColumns, aFilteredColummns } = this.getTableIdentifierColumnInfo();\n\t\tconst columnPropertyAndVisibility = [];\n\n\t\tif (headerInfoTitlePath !== undefined && this.checkColumnValueVisible(headerInfoTitlePath, tableRowContext)) {\n\t\t\t// If the headerInfoTitlePath is not undefined and not UI.Hidden, the headerInfoTitlePath is returned.\n\t\t\tconst { visibility } = this.checkVisibility(headerInfoTitlePath, aFilteredColummns);\n\t\t\tcolumnPropertyAndVisibility.push({ key: headerInfoTitlePath, visibility });\n\t\t} else if (\n\t\t\tsemanticKeyColumns !== undefined &&\n\t\t\tsemanticKeyColumns.length === 1 &&\n\t\t\tthis.checkColumnValueVisible(semanticKeyColumns[0], tableRowContext)\n\t\t) {\n\t\t\t// if there is only one semanticKey and it is not undefined and not UI.Hidden, the single sematicKey is returned.\n\t\t\tconst { visibility } = this.checkVisibility(semanticKeyColumns[0], aFilteredColummns);\n\t\t\tcolumnPropertyAndVisibility.push({ key: semanticKeyColumns[0], visibility });\n\t\t} else if (filteredTechnicalKeys.length === 1 && this.checkColumnValueVisible(filteredTechnicalKeys[0], tableRowContext)) {\n\t\t\t// if there is only one technicalKey and it is not undefined and not UI.Hidden, the single technicalKey is returned.\n\t\t\tconst { visibility } = this.checkVisibility(filteredTechnicalKeys[0], aFilteredColummns);\n\t\t\tcolumnPropertyAndVisibility.push({ key: filteredTechnicalKeys[0], visibility });\n\t\t} else if (\n\t\t\tsemanticKeyColumns !== undefined &&\n\t\t\tsemanticKeyColumns.length > 0 &&\n\t\t\tthis.checkColumnValueVisible(semanticKeyColumns, tableRowContext)\n\t\t) {\n\t\t\t// if there are multiple semanticKey and it is not undefined and not UI.Hidden, the multiple sematicKey is returned.\n\t\t\tconst availableKeys = this.checkColumnValueVisible(semanticKeyColumns, tableRowContext);\n\t\t\tif (availableKeys) {\n\t\t\t\tfor (const key of availableKeys) {\n\t\t\t\t\tconst { visibility } = this.checkVisibility(key, aFilteredColummns);\n\t\t\t\t\tcolumnPropertyAndVisibility.push({ key: key, visibility });\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (filteredTechnicalKeys.length > 0 && this.checkColumnValueVisible(filteredTechnicalKeys, tableRowContext)) {\n\t\t\t// if there are multiple technicalKey and it is not undefined and not UI.Hidden, the multiple technicalKey is returned.\n\t\t\tconst availableKeys = this.checkColumnValueVisible(filteredTechnicalKeys, tableRowContext);\n\t\t\tif (availableKeys) {\n\t\t\t\tfor (const key of availableKeys) {\n\t\t\t\t\tconst { visibility } = this.checkVisibility(key, aFilteredColummns);\n\t\t\t\t\tcolumnPropertyAndVisibility.push({ key: key, visibility });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn columnPropertyAndVisibility;\n\t}\n\n\tmodifyDynamicVisibilityForColumn(columnKey: string, visible: boolean): void {\n\t\tconst existingDynamicVisibility = this.getDynamicVisibilityForColumns().find(\n\t\t\t(dynamicVisibility) => dynamicVisibility.columnKey === columnKey\n\t\t);\n\t\tif (existingDynamicVisibility) {\n\t\t\texistingDynamicVisibility.visible = visible;\n\t\t} else {\n\t\t\tthis.getDynamicVisibilityForColumns().push({\n\t\t\t\tcolumnKey: columnKey,\n\t\t\t\tvisible: visible\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Updates the table definition with ignoredFields and dynamicVisibilityForColumns.\n\t * @param ignoredFields\n\t * @param tableDefinition\n\t */\n\tupdateColumnsVisibility(ignoredFields: string | undefined, tableDefinition: TableVisualization): void {\n\t\tColumnManagement.updateColumnsVisibilityStatic(ignoredFields, this.getDynamicVisibilityForColumns(), tableDefinition);\n\t}\n\n\t/**\n\t * Updates the table definition with ignoredFields and dynamicVisibilityForColumns.\n\t * This static version is needed temporarily to expose a static method in TableAPI (used in Table.block).\n\t * @param ignoredFields\n\t * @param dynamicVisibilityForColumns\n\t * @param tableDefinition\n\t */\n\tstatic updateColumnsVisibilityStatic(\n\t\tignoredFields: string | undefined,\n\t\tdynamicVisibilityForColumns: DynamicVisibilityForColumn[],\n\t\ttableDefinition: TableVisualization\n\t): void {\n\t\tif (!ignoredFields && !dynamicVisibilityForColumns.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst ignoredFieldNames = ignoredFields ? ignoredFields.split(\",\").map((name) => name.trim()) : [];\n\t\tconst columns = tableDefinition.columns;\n\n\t\t// If a columns in the table definition contains an ignored field, mark it as hidden\n\t\tcolumns.forEach((column) => {\n\t\t\tlet ignoreColumn = ignoredFieldNames.includes((column as AnnotationTableColumn).relativePath); // Standard column\n\t\t\tif (!ignoreColumn && column.propertyInfos) {\n\t\t\t\t// Complex column\n\t\t\t\tignoreColumn = column.propertyInfos.some((relatedColumnName) => {\n\t\t\t\t\tconst relatedColumn = columns.find((col) => col.name === relatedColumnName) as AnnotationTableColumn;\n\t\t\t\t\treturn relatedColumn?.relativePath && ignoredFieldNames.includes(relatedColumn.relativePath);\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (ignoreColumn) {\n\t\t\t\tcolumn.availability = \"Hidden\";\n\t\t\t\tif (\"sortable\" in column) {\n\t\t\t\t\tcolumn.sortable = false;\n\t\t\t\t}\n\t\t\t\tif (\"filterable\" in column) {\n\t\t\t\t\tcolumn.filterable = false;\n\t\t\t\t}\n\t\t\t\tif (\"isGroupable\" in column) {\n\t\t\t\t\tcolumn.isGroupable = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst dynamicVisibility = dynamicVisibilityForColumns.find((dynamicVisibility) => dynamicVisibility.columnKey === column.key);\n\t\t\tif (dynamicVisibility) {\n\t\t\t\tcolumn.availability = dynamicVisibility.visible ? \"Default\" : \"Hidden\";\n\t\t\t}\n\t\t});\n\t}\n}\n"],"mappings":"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","ignoreList":[]}