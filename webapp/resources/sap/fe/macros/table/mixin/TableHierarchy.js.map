{"version":3,"file":"TableHierarchy.js","names":["DropPosition","TableHierarchy","_exports","_proto","prototype","setupMixin","_baseClass","_onCopyCut","evt","forContextMenu","action","table","getSource","getParent","menu","internalContext","getBindingContext","selectedContexts","this","getSelectedContexts","length","Log","error","setProperty","MessageToast","show","ResourceModelHelper","getResourceModel","getText","getProperty","TableRuntime","clearSelection","fireSelectionChange","pasteButton","getActions","find","toolbarAction","test","getAction","getId","setTimeout","focus","_onDragEnterDocument","ui5Event","draggedContext","getParameter","getContent","getRowBinding","getBinding","preventDefault","targetContext","isAncestorOf","disabledBetween","disabledOn","tableDefinition","getTableDefinition","isMoveAllowedInfo","control","isMoveToPositionAllowed","customFunction","FPMHelper","getCustomFunction","moduleName","methodName","undefined","safeIsMoveAllowed","annotation","allowDropBetweenNodes","Math","abs","getIndex","getLength","changeSiblingForRootsSupported","isDropBetweenAllowedForDrag","allowedDropPosition","OnOrBetween","On","Between","setDropPosition","_onDragStartDocument","context","updatablePropertyPath","disableDrag","isRelative","isMovableInfo","isNodeMovable","_error","_onDropDocument","async","BusyLocker","lock","droppedOnContext","dropInfo","position","parentContext","contextBefore","contextAfter","getContextAfter","getContextBefore","movedContext","Promise","all","dropContext","requestSideEffectsForChangeNextSiblingAction","getTranslatedText","message","unlock","_onCollapseExpandNode","_ui5Event","expand","promiseArray","map","singleContext","isExpanded","collapse","Number","MAX_SAFE_INTEGER","_onMoveUpDown","moveUp","arguments","mdcTable","setBusy","requestParent","contextMoved","movePromise","previousSibling","requestSibling","move","nextSibling","parent","newIndex","scrollToIndex","focusRow","_requestSideEffectsForHierarchyActions","requestSideEffectsForCopyAction","entityPath","data","metaModel","getModel","getMetaModel","targetObject","getContext","convertMetaModelContext","MetaModelConverter","entityType","targetType","actionName","annotations","Hierarchy","hierarchyQualifier","appComponent","CommonUtils","getAppComponent","sideEffectsService","getSideEffectsService","sideEffects","getODataActionSideEffects","requestSideEffectsForODataAction","allowed","isAllowed","parentBefore","paramsBefore","getDropBetweenParameters","parentAfter","paramsAfter","contextIndex","Error","listBinding","getAllCurrentContexts","ctx","info","internalModelContext","isTableSorted","moveContext","finally","params"],"sources":["./TableHierarchy.ts"],"sourcesContent":["import type { EntitySet, NavigationProperty } from \"@sap-ux/vocabularies-types\";\nimport Log from \"sap/base/Log\";\nimport { type IInterfaceWithMixin } from \"sap/fe/base/ClassSupport\";\nimport CommonUtils from \"sap/fe/core/CommonUtils\";\nimport BusyLocker from \"sap/fe/core/controllerextensions/BusyLocker\";\nimport * as MetaModelConverter from \"sap/fe/core/converters/MetaModelConverter\";\nimport FPMHelper from \"sap/fe/core/helpers/FPMHelper\";\nimport { type InternalModelContext } from \"sap/fe/core/helpers/ModelHelper\";\nimport ResourceModelHelper from \"sap/fe/core/helpers/ResourceModelHelper\";\nimport type Menu from \"sap/m/Menu\";\nimport MessageToast from \"sap/m/MessageToast\";\nimport type UI5Event from \"sap/ui/base/Event\";\nimport type Control from \"sap/ui/core/Control\";\nimport type UI5Element from \"sap/ui/core/Element\";\nimport type DragDropInfo from \"sap/ui/core/dnd/DragDropInfo\";\nimport type MDCTable from \"sap/ui/mdc/Table\";\nimport type ActionToolbarAction from \"sap/ui/mdc/actiontoolbar/ActionToolbarAction\";\nimport type Context from \"sap/ui/model/odata/v4/Context\";\nimport type ODataListBinding from \"sap/ui/model/odata/v4/ODataListBinding\";\nimport { type ITableBlock } from \"../TableAPI\";\nimport TableRuntime from \"../TableRuntime\";\n\nenum DropPosition {\n\tOn = \"On\",\n\tBetween = \"Between\",\n\tOnOrBetween = \"OnOrBetween\"\n}\n\ntype DropInformation =\n\t| { position: DropPosition.On; parentContext: Context | null }\n\t| { position: DropPosition.Between; contextBefore: Context | null; contextAfter: Context | null };\n\nexport default class TableHierarchy implements IInterfaceWithMixin {\n\tsetupMixin(_baseClass: Function): void {\n\t\t// This method is needed to implement interface IInterfaceWithMixin\n\t}\n\n\t/**\n\t * Handles the Cut/Copy operation.\n\t * @param evt The UI5 event\n\t * @param forContextMenu\n\t */\n\t_onCopyCut(this: ITableBlock & TableHierarchy, evt: UI5Event<{}, UI5Element>, forContextMenu: boolean, action: \"Copy\" | \"Cut\"): void {\n\t\tlet table: MDCTable;\n\t\tif (!forContextMenu) {\n\t\t\ttable = evt.getSource().getParent() as MDCTable;\n\t\t} else {\n\t\t\tconst menu = evt.getSource().getParent() as Menu;\n\t\t\ttable = menu.getParent()?.getParent() as MDCTable;\n\t\t}\n\t\tconst internalContext = table.getBindingContext(\"internal\") as InternalModelContext;\n\t\tconst selectedContexts = this.getSelectedContexts();\n\t\tif (selectedContexts.length > 1) {\n\t\t\tLog.error(`Multi ${action === \"Cut\" ? \"cutting\" : \"copying\"} is not supported`);\n\t\t\treturn;\n\t\t}\n\n\t\tinternalContext.setProperty(\"nodeUpdatesInfo/pastableContexts\", selectedContexts);\n\t\tinternalContext.setProperty(\"nodeUpdatesInfo/lastAction\", action);\n\t\tMessageToast.show(ResourceModelHelper.getResourceModel(table).getText(\"M_CUTCOPY_READY\"));\n\t\tif (!forContextMenu || internalContext.getProperty(\"numberOfSelectedContexts\") > 0) {\n\t\t\tTableRuntime.clearSelection(table);\n\t\t\ttable.fireSelectionChange();\n\t\t} else if (forContextMenu) {\n\t\t\t// Using the context menu implicitly defines a context for the action\n\t\t\ttable.fireSelectionChange();\n\t\t}\n\n\t\tinternalContext.setProperty(\"nodeUpdatesInfo/cutEnablement\", false);\n\t\tinternalContext.setProperty(\"contextmenu/nodeUpdatesInfo/cutEnablement\", false);\n\t\tinternalContext.setProperty(\"nodeUpdatesInfo/copyEnablement\", false);\n\t\tinternalContext.setProperty(\"contextmenu/nodeUpdatesInfo/copyEnablement\", false);\n\t\tconst pasteButton = (table.getActions() as ActionToolbarAction[]).find((toolbarAction) =>\n\t\t\t/::Paste$/.test(toolbarAction.getAction().getId())\n\t\t);\n\t\tsetTimeout(() => {\n\t\t\tpasteButton?.focus();\n\t\t}, 0);\n\t}\n\n\t/**\n\t * The dragged element enters a table row.\n\t * @param ui5Event UI5 event coming from the MDC drag and drop config\n\t */\n\t_onDragEnterDocument(\n\t\tthis: ITableBlock & TableHierarchy,\n\t\tui5Event: UI5Event<{ bindingContext: Context; dragSource: Context; dropPosition: \"Before\" | \"After\" | \"On\" }, DragDropInfo>\n\t): void {\n\t\tconst draggedContext = ui5Event.getParameter(\"dragSource\");\n\t\tif (this.getContent().getRowBinding() !== draggedContext.getBinding()) {\n\t\t\t// The drag is done on a different table -> not authorized\n\t\t\tui5Event.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tconst targetContext: Context | null = ui5Event.getParameter(\"bindingContext\");\n\t\tif (draggedContext.isAncestorOf(targetContext)) {\n\t\t\t// The ancestor is dropped on a descendant -> not authorized\n\t\t\tui5Event.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tlet disabledBetween = false;\n\t\tlet disabledOn = false;\n\t\tconst tableDefinition = this.getTableDefinition();\n\t\tconst isMoveAllowedInfo = tableDefinition.control.isMoveToPositionAllowed;\n\t\tconst customFunction = isMoveAllowedInfo\n\t\t\t? FPMHelper.getCustomFunction<(node: Context, parent: Context | null) => boolean>(\n\t\t\t\t\tisMoveAllowedInfo.moduleName,\n\t\t\t\t\tisMoveAllowedInfo.methodName,\n\t\t\t\t\tui5Event.getSource().getParent() as Control\n\t\t\t  )\n\t\t\t: undefined;\n\n\t\tif (targetContext === this.getContent().getBindingContext()) {\n\t\t\t// The drag is done on the table itself -> drop as root node)\n\t\t\tdisabledOn = !this.safeIsMoveAllowed(customFunction, draggedContext, null);\n\t\t\tdisabledBetween = true;\n\t\t} else {\n\t\t\tdisabledOn = !this.safeIsMoveAllowed(customFunction, draggedContext, targetContext);\n\t\t\tdisabledBetween = tableDefinition.annotation.allowDropBetweenNodes !== true;\n\n\t\t\tif (\n\t\t\t\tMath.abs(targetContext.getIndex()! - draggedContext.getIndex()!) === 1 &&\n\t\t\t\t!(targetContext.getIndex() === 0 && ui5Event.getParameter(\"dropPosition\") === \"Before\") &&\n\t\t\t\t!(\n\t\t\t\t\ttargetContext.getIndex() === this.getContent().getRowBinding().getLength() - 1 &&\n\t\t\t\t\tui5Event.getParameter(\"dropPosition\") === \"After\"\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t//\n\t\t\t\tdisabledBetween = true;\n\t\t\t}\n\n\t\t\t// If the drop between node is allowed, we need to check if the target is a root node and if the table supports changeSiblingForRoots\n\t\t\tif (\n\t\t\t\t!disabledBetween &&\n\t\t\t\t!tableDefinition.annotation.changeSiblingForRootsSupported &&\n\t\t\t\ttargetContext.getProperty(\"@$ui5.node.level\") === 1\n\t\t\t) {\n\t\t\t\tdisabledBetween = true;\n\t\t\t}\n\n\t\t\t// Check custom logic for drop between if there's some, and if it's not already disabled at the table level\n\t\t\tif (customFunction && !disabledBetween) {\n\t\t\t\tdisabledBetween = !this.isDropBetweenAllowedForDrag(customFunction, draggedContext, targetContext);\n\t\t\t}\n\t\t}\n\n\t\tlet allowedDropPosition: DropPosition = DropPosition.OnOrBetween;\n\t\tif (disabledBetween && disabledOn) {\n\t\t\t//Set the element as non droppable\n\t\t\tui5Event.preventDefault();\n\t\t\treturn;\n\t\t}\n\t\tif (disabledBetween) {\n\t\t\tallowedDropPosition = DropPosition.On;\n\t\t} else if (disabledOn) {\n\t\t\tallowedDropPosition = DropPosition.Between;\n\t\t}\n\t\tui5Event.getSource().setDropPosition(allowedDropPosition);\n\t}\n\n\t/**\n\t * Starts the drag of the document.\n\t * @param ui5Event UI5 event coming from the MDC drag and drop config\n\t */\n\t_onDragStartDocument(this: ITableBlock & TableHierarchy, ui5Event: UI5Event<{ bindingContext: Context }, Control>): void {\n\t\tconst context = ui5Event.getParameter(\"bindingContext\");\n\t\tconst updatablePropertyPath = this.getTableDefinition().annotation.updatablePropertyPath;\n\n\t\t// Check if the context can be updated according to update restrictions\n\t\tlet disableDrag = !!updatablePropertyPath && !context.getProperty(updatablePropertyPath);\n\n\t\t// In case of a TreeTable in a ListReport with draft, check that the context has no associated draft\n\t\tif (!disableDrag && !(context.getBinding() as ODataListBinding).isRelative()) {\n\t\t\tdisableDrag = context.getProperty(\"HasDraftEntity\") === true;\n\t\t}\n\n\t\t// Apply custom logic if there's one\n\t\tconst isMovableInfo = this.getTableDefinition().control.isNodeMovable;\n\t\ttry {\n\t\t\tif (isMovableInfo && !disableDrag) {\n\t\t\t\tdisableDrag =\n\t\t\t\t\t(\n\t\t\t\t\t\tFPMHelper.getCustomFunction<(contexts: Context[]) => boolean>(\n\t\t\t\t\t\t\tisMovableInfo.moduleName,\n\t\t\t\t\t\t\tisMovableInfo.methodName,\n\t\t\t\t\t\t\tui5Event.getSource()\n\t\t\t\t\t\t) as Function\n\t\t\t\t\t)(context) === false;\n\t\t\t}\n\t\t} catch (_error) {\n\t\t\tdisableDrag = false;\n\t\t}\n\t\tif (disableDrag) {\n\t\t\t//Set the element as non draggable\n\t\t\tui5Event.preventDefault();\n\t\t}\n\t}\n\n\t/**\n\t * Drops the document.\n\t * @param ui5Event UI5 event coming from the MDC drag and drop config\n\t * @returns The Promise\n\t */\n\tasync _onDropDocument(\n\t\tthis: ITableBlock & TableHierarchy,\n\t\tui5Event: UI5Event<{\n\t\t\tbindingContext: Context;\n\t\t\tdragSource: Context;\n\t\t\tdropPosition: string;\n\t\t}>\n\t): Promise<void> {\n\t\tBusyLocker.lock(this.getContent());\n\n\t\ttry {\n\t\t\tconst droppedOnContext = ui5Event.getParameter(\"bindingContext\");\n\t\t\tlet dropInfo: DropInformation;\n\t\t\tif (droppedOnContext === this.getContent().getBindingContext()) {\n\t\t\t\t// The drop is done on the table itself -> drop as root node)\n\t\t\t\tdropInfo = { position: DropPosition.On, parentContext: null };\n\t\t\t} else if (ui5Event.getParameter(\"dropPosition\") === DropPosition.On) {\n\t\t\t\t// Drop on a node\n\t\t\t\tdropInfo = { position: DropPosition.On, parentContext: droppedOnContext };\n\t\t\t} else {\n\t\t\t\t// Drop between 2 nodes\n\t\t\t\tlet contextBefore: Context | null;\n\t\t\t\tlet contextAfter: Context | null;\n\t\t\t\tif (ui5Event.getParameter(\"dropPosition\") === \"After\") {\n\t\t\t\t\tcontextBefore = droppedOnContext;\n\t\t\t\t\tcontextAfter = this.getContextAfter(droppedOnContext);\n\t\t\t\t} else {\n\t\t\t\t\tcontextBefore = this.getContextBefore(droppedOnContext);\n\t\t\t\t\tcontextAfter = droppedOnContext;\n\t\t\t\t}\n\t\t\t\tdropInfo = { position: DropPosition.Between, contextAfter, contextBefore };\n\t\t\t}\n\n\t\t\tconst movedContext = ui5Event.getParameter(\"dragSource\");\n\t\t\tawait Promise.all([this.dropContext(movedContext, dropInfo), this.requestSideEffectsForChangeNextSiblingAction(movedContext)]);\n\t\t} catch (error) {\n\t\t\tMessageToast.show(this.getTranslatedText(\"M_TABLEDROP_FAILED\", [\"\"]));\n\t\t\tLog.error(\"The operation is unsuccessful. \" + (error as Error).message ?? \"\");\n\t\t} finally {\n\t\t\tBusyLocker.unlock(this.getContent());\n\t\t}\n\t}\n\n\t/**\n\t * Handler for collapse/expand from the context menu.\n\t * @param this\n\t * @param _ui5Event\n\t * @param expand\n\t */\n\tasync _onCollapseExpandNode(this: ITableBlock & TableHierarchy, _ui5Event: UI5Event, expand: boolean): Promise<void> {\n\t\tconst selectedContexts = this.getSelectedContexts();\n\t\tif (expand) {\n\t\t\tconst promiseArray = selectedContexts.map(async (singleContext: Context) => {\n\t\t\t\t// Checking for false specifically; undefined means the node cannot expand/collapse\n\t\t\t\tif (singleContext.isExpanded() !== undefined) {\n\t\t\t\t\t// Temporary workaround due to model limitation.\n\t\t\t\t\t// We need to collapse a node before expanding it to ensure we expand it completely.\n\t\t\t\t\t// Will be changed once the model fixes the issue.\n\t\t\t\t\tif (singleContext.isExpanded() === true) {\n\t\t\t\t\t\tawait singleContext.collapse();\n\t\t\t\t\t}\n\t\t\t\t\treturn singleContext.expand(Number.MAX_SAFE_INTEGER);\n\t\t\t\t}\n\t\t\t});\n\t\t\tawait Promise.all(promiseArray);\n\t\t} else {\n\t\t\tawait Promise.all(\n\t\t\t\tselectedContexts.map(async (singleContext: Context) => {\n\t\t\t\t\tif (singleContext.isExpanded() === true) {\n\t\t\t\t\t\treturn singleContext.collapse(true);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Internal method to move a row up or down in a Tree table.\n\t * @param _ui5Event\n\t * @param moveUp True for move up, false for move down\n\t * @param forContextMenu\n\t */\n\tasync _onMoveUpDown(this: ITableBlock & TableHierarchy, _ui5Event: UI5Event, moveUp: boolean, forContextMenu = false): Promise<void> {\n\t\tconst selectedContexts = this.getSelectedContexts();\n\t\tif (selectedContexts.length !== 1) {\n\t\t\treturn;\n\t\t}\n\t\tconst mdcTable = this.getContent();\n\t\tmdcTable.setBusy(true);\n\n\t\t// Move the context up or down\n\t\tconst movedContext = selectedContexts[0];\n\t\tconst parentContext = await movedContext.requestParent();\n\t\tlet contextMoved = false;\n\t\tlet movePromise = null;\n\t\tif (moveUp) {\n\t\t\tconst previousSibling = await movedContext.requestSibling(-1);\n\t\t\tif (previousSibling) {\n\t\t\t\tmovePromise = movedContext.move({ nextSibling: previousSibling, parent: parentContext });\n\t\t\t\tcontextMoved = true;\n\t\t\t}\n\t\t} else {\n\t\t\tconst nextSibling = await movedContext.requestSibling(1);\n\t\t\tif (nextSibling) {\n\t\t\t\tmovePromise = nextSibling.move({ nextSibling: movedContext, parent: parentContext });\n\t\t\t\tcontextMoved = true;\n\t\t\t}\n\t\t}\n\n\t\tawait Promise.all([movePromise, this.requestSideEffectsForChangeNextSiblingAction(movedContext)]);\n\n\t\t// Scroll to the new position\n\t\tconst newIndex = movedContext.getIndex();\n\t\tif (contextMoved && newIndex !== undefined && newIndex >= 0) {\n\t\t\tif (!forContextMenu) {\n\t\t\t\tmdcTable.scrollToIndex(newIndex);\n\t\t\t} else {\n\t\t\t\tmdcTable.focusRow(newIndex);\n\t\t\t}\n\t\t}\n\t\tmdcTable.setBusy(false);\n\t}\n\n\t/**\n\t * Requests the side effect for the ChangeNextSiblingAction.\n\t * @param movedContext The context that has been moved\n\t * @returns A Promise\n\t */\n\tasync requestSideEffectsForChangeNextSiblingAction(this: ITableBlock & TableHierarchy, movedContext: Context): Promise<void> {\n\t\treturn this._requestSideEffectsForHierarchyActions(movedContext, \"ChangeNextSiblingAction\");\n\t}\n\n\t/**\n\t * Requests the side effect for the CopyAction.\n\t * @param movedContext The context that has been moved\n\t * @returns A Promise\n\t */\n\tasync requestSideEffectsForCopyAction(this: ITableBlock & TableHierarchy, movedContext: Context): Promise<void> {\n\t\treturn this._requestSideEffectsForHierarchyActions(movedContext, \"CopyAction\");\n\t}\n\n\t/**\n\t * Requests the side effect for the CopyAction or ChangeNextSiblingAction.\n\t * @param movedContext The context that has been moved\n\t * @param action\n\t * @returns A Promise\n\t */\n\tasync _requestSideEffectsForHierarchyActions(\n\t\tthis: ITableBlock & TableHierarchy,\n\t\tmovedContext: Context,\n\t\taction: \"ChangeNextSiblingAction\" | \"CopyAction\"\n\t): Promise<void> {\n\t\tconst entityPath = this.getContent().data(\"metaPath\");\n\t\tconst metaModel = movedContext.getModel().getMetaModel();\n\n\t\tconst targetObject = metaModel.getContext(entityPath);\n\t\tconst convertMetaModelContext = MetaModelConverter.convertMetaModelContext(targetObject) as NavigationProperty | EntitySet;\n\t\tconst entityType = (convertMetaModelContext as NavigationProperty).targetType ?? (convertMetaModelContext as EntitySet).entityType;\n\t\tconst actionName = entityType.annotations.Hierarchy?.[\n\t\t\t`RecursiveHierarchyActions#${this.getTableDefinition().control.hierarchyQualifier ?? \"\"}`\n\t\t]?.[action] as string | undefined;\n\n\t\tif (actionName) {\n\t\t\tconst appComponent = CommonUtils.getAppComponent(this.getContent());\n\t\t\tconst sideEffectsService = appComponent.getSideEffectsService();\n\t\t\tconst sideEffects = sideEffectsService.getODataActionSideEffects(actionName, movedContext);\n\t\t\tif (sideEffects) {\n\t\t\t\tawait sideEffectsService.requestSideEffectsForODataAction(sideEffects, movedContext);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Safely checks if moving a node is allowed.\n\t * @param customFunction\n\t * @param movedContext\n\t * @param parentContext\n\t * @returns True if allowed\n\t */\n\tprivate safeIsMoveAllowed(\n\t\tcustomFunction: ((context: Context, parent: Context | null) => boolean) | undefined,\n\t\tmovedContext: Context,\n\t\tparentContext: Context | null\n\t): boolean {\n\t\tif (!customFunction) {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet allowed = true;\n\t\ttry {\n\t\t\tallowed = customFunction(movedContext, parentContext) === true;\n\t\t} catch (error) {\n\t\t\tLog.error(\"Cannot execute function related to isMoveToPositionAllowed\", error as string);\n\t\t\tallowed = true;\n\t\t}\n\n\t\treturn allowed;\n\t}\n\n\t/**\n\t * Checks is drop \"between\" is allowed by custom logic for a given targetContext.\n\t * @param customFunction\n\t * @param draggedContext\n\t * @param targetContext\n\t * @returns True if allowed\n\t */\n\tprivate isDropBetweenAllowedForDrag(\n\t\tcustomFunction: (context: Context, parent: Context | null) => boolean,\n\t\tdraggedContext: Context,\n\t\ttargetContext: Context\n\t): boolean {\n\t\tlet isAllowed = true;\n\n\t\t// Determine what to do if we drop before targetContext\n\t\tconst contextBefore = this.getContextBefore(targetContext);\n\t\tconst parentBefore = contextBefore === null ? null : contextBefore.getParent();\n\t\tconst paramsBefore = this.getDropBetweenParameters(contextBefore, parentBefore, targetContext, targetContext.getParent());\n\n\t\t// Determine what to do if we drop after targetContext\n\t\tconst contextAfter = this.getContextAfter(targetContext);\n\t\tconst parentAfter = contextAfter === null ? null : contextAfter.getParent();\n\t\tconst paramsAfter = this.getDropBetweenParameters(targetContext, targetContext.getParent(), contextAfter, parentAfter);\n\n\t\t// If paramsBefore or paramsAfter cannot be determined (because parents are not loaded), we allow drop between and do the real check in onDropDocument\n\t\tif (paramsBefore !== undefined && paramsAfter !== undefined) {\n\t\t\tif (paramsBefore.parent === paramsAfter.parent) {\n\t\t\t\t// Dropping before or after will move under the same parent --> we call the custom logic only once\n\t\t\t\tisAllowed = this.safeIsMoveAllowed(customFunction, draggedContext, paramsBefore.parent);\n\t\t\t} else {\n\t\t\t\t// As the MDC table cannot disable drop before and after separately, we disable drop between only if both drop before and after are forbidden\n\t\t\t\tisAllowed =\n\t\t\t\t\tthis.safeIsMoveAllowed(customFunction, draggedContext, paramsBefore.parent) ||\n\t\t\t\t\tthis.safeIsMoveAllowed(customFunction, draggedContext, paramsAfter.parent);\n\t\t\t}\n\t\t}\n\n\t\treturn isAllowed;\n\t}\n\n\t/**\n\t * Returns the context that is placed before a given context in a ListBinding.\n\t * @param context\n\t * @returns The context before, or null\n\t */\n\tprivate getContextBefore(context: Context): Context | null {\n\t\tconst contextIndex = context.getIndex();\n\t\tif (contextIndex === undefined) {\n\t\t\tthrow new Error(\"Unexpected error\");\n\t\t}\n\n\t\tconst listBinding = context.getBinding() as ODataListBinding;\n\t\treturn contextIndex === 0\n\t\t\t? null\n\t\t\t: listBinding.getAllCurrentContexts().find((ctx) => {\n\t\t\t\t\treturn ctx.getIndex() === contextIndex - 1;\n\t\t\t  }) ?? null;\n\t}\n\n\t/**\n\t * Returns the context that is placed after a given context in a ListBinding.\n\t * @param context\n\t * @returns The context after, or null\n\t */\n\tprivate getContextAfter(context: Context): Context | null {\n\t\tconst contextIndex = context.getIndex();\n\t\tif (contextIndex === undefined) {\n\t\t\tthrow new Error(\"Unexpected error\");\n\t\t}\n\n\t\tconst listBinding = context.getBinding() as ODataListBinding;\n\t\treturn (\n\t\t\tlistBinding.getAllCurrentContexts().find((ctx) => {\n\t\t\t\treturn ctx.getIndex() === contextIndex + 1;\n\t\t\t}) ?? null\n\t\t);\n\t}\n\n\t/**\n\t * Returns information to perform a drop between 2 nodes: the new parent and the next sibling.\n\t * @param contextBefore Context after which the drop is done\n\t * @param parentBefore Parent of contextBefore (undefined if not known)\n\t * @param contextAfter Context before which the drop is done\n\t * @param parentAfter Parent of contextAfter (undefined if not known)\n\t * @returns The new parent and the next sibling, or undefined if it cannot be determined\n\t */\n\tprivate getDropBetweenParameters(\n\t\tcontextBefore: Context | null,\n\t\tparentBefore: Context | null | undefined,\n\t\tcontextAfter: Context | null,\n\t\tparentAfter: Context | null | undefined\n\t): { parent: Context | null; nextSibling?: Context | null } | undefined {\n\t\tif (contextBefore === null) {\n\t\t\t// Drop before first node --> move as first root node\n\t\t\treturn { parent: null, nextSibling: contextAfter };\n\t\t} else if (contextAfter === null) {\n\t\t\t// Drop after last node --> move as next sibling of the last node\n\t\t\treturn parentBefore !== undefined ? { parent: parentBefore, nextSibling: null } : undefined;\n\t\t} else if (parentAfter === contextBefore) {\n\t\t\t// Drop between a parent and its first child --> move as first child of the parent\n\t\t\treturn { parent: contextBefore, nextSibling: contextAfter };\n\t\t} else if (parentBefore === undefined || parentAfter === undefined) {\n\t\t\t// If one of the parent is not known, we don't know what to do\n\t\t\treturn undefined;\n\t\t} else if (parentBefore === parentAfter) {\n\t\t\t// Drop between 2 siblings\n\t\t\treturn { parent: parentBefore, nextSibling: contextAfter };\n\t\t} else {\n\t\t\t// NodeX\n\t\t\t//  ....\n\t\t\t//     |-- contextBefore\n\t\t\t// contextAfter\n\t\t\t// --> Move as the next sibling of contextBefore\n\t\t\treturn { parent: parentBefore, nextSibling: null };\n\t\t}\n\t}\n\n\t/**\n\t * Internal method to drop a context on or between 2 nodes.\n\t * @param context\n\t * @param info\n\t * @returns The move Promise\n\t */\n\tprivate async dropContext(this: ITableBlock & TableHierarchy, context: Context, info: DropInformation): Promise<void> {\n\t\tconst isMoveAllowedInfo = this.getTableDefinition().control.isMoveToPositionAllowed;\n\t\tconst customFunction = isMoveAllowedInfo\n\t\t\t? FPMHelper.getCustomFunction<(node: Context, parent: Context | null) => boolean>(\n\t\t\t\t\tisMoveAllowedInfo.moduleName,\n\t\t\t\t\tisMoveAllowedInfo.methodName,\n\t\t\t\t\tthis.getContent()\n\t\t\t  )\n\t\t\t: undefined;\n\t\tconst table = this.getContent();\n\t\ttable.setBusy(true);\n\t\tconst internalModelContext = table.getBindingContext(\"internal\") as InternalModelContext;\n\t\tconst isTableSorted = internalModelContext.getProperty(\"isSorted\") === true;\n\n\t\tconst moveContext = async (parent: Context | null, nextSibling?: Context | null): Promise<void> => {\n\t\t\t// We check if the move is allowed by custom logic (if any), as this check might\n\t\t\t// not have been done in onDragEnterDocument if the parent was not loaded yet.\n\t\t\tif (this.safeIsMoveAllowed(customFunction, context, parent)) {\n\t\t\t\t// If the table is sorted, we ignore the sibling as the position shall be determined by the server\n\t\t\t\treturn context.move({ parent, nextSibling: isTableSorted ? undefined : nextSibling });\n\t\t\t} else {\n\t\t\t\tMessageToast.show(this.getTranslatedText(\"M_TABLE_DROP_NOT_ALLOWED\"));\n\t\t\t}\n\t\t};\n\n\t\tif (info.position === DropPosition.On) {\n\t\t\t// Drop on a node\n\t\t\treturn moveContext(info.parentContext).finally(() => table.setBusy(false));\n\t\t} else {\n\t\t\t// Drop between 2 nodes\n\t\t\tconst [parentBefore, parentAfter] = await Promise.all([\n\t\t\t\tinfo.contextBefore?.requestParent() ?? null,\n\t\t\t\tinfo.contextAfter?.requestParent() ?? null\n\t\t\t]);\n\t\t\tconst params = this.getDropBetweenParameters(info.contextBefore, parentBefore, info.contextAfter, parentAfter)!;\n\t\t\treturn moveContext(params.parent, params.nextSibling).finally(() => table.setBusy(false));\n\t\t}\n\t}\n}\n"],"mappings":"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","ignoreList":[]}