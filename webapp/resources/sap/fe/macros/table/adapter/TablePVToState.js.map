{"version":3,"file":"TablePVToState.js","names":["overridePVGroupLevels","newGroupLevels","oldGroupLevels","propertyInfoNames","groupsInNewVariant","map","group","groupLevels","name","includes","push","filter","grouped","overridePVSorters","newSortOrder","oldSortOrder","sortersInNewVariant","sorter","Property","sorters","descending","Descending","sorted","overridePVAggregations","newAggregations","oldAggregations","newAggregationsKeys","Object","keys","mixedAggregates","singleNewAggregate","newAggregate","singleOldAggregate","oldAggregate","aggregated","overridePVContent","newPVContent","oldPVContent","itemsInNewVariant","item","items","itemIndex","Value","visible","position","convertPVToState","pvToSet","pvToReplace","newPVProps","getProperties","oldPVProps","getTableVisualization","Content","overriddenProps","GroupBy","SortOrder","overriddenAggregation","Aggregations","length","aggregations","_exports"],"sources":["./TablePVToState.ts"],"sourcesContent":["import type PresentationVariant from \"sap/fe/navigation/PresentationVariant\";\nimport type { Aggregation, PvProperties, SortOrder, VisContentType } from \"sap/fe/navigation/PresentationVariant\";\nimport type { AppState, GroupLevels, Items, Sorters } from \"sap/ui/mdc/p13n/StateUtil\";\n\n/**\n * Override the group levels for new state to be set on the table.\n * @param newGroupLevels\n * @param oldGroupLevels\n * @param propertyInfoNames\n * @returns Overridden group levels to be set on the table\n */\nconst overridePVGroupLevels = function (newGroupLevels: string[], oldGroupLevels: string[], propertyInfoNames: string[]): GroupLevels[] {\n\tconst groupsInNewVariant = newGroupLevels.map((group) => {\n\t\treturn group;\n\t});\n\n\tconst groupLevels =\n\t\tnewGroupLevels.map((group) => {\n\t\t\treturn {\n\t\t\t\tname: propertyInfoNames.includes(`Property::${group}`) ? `Property::${group}` : group\n\t\t\t};\n\t\t}) || [];\n\n\tgroupLevels.push(\n\t\t...oldGroupLevels\n\t\t\t.filter((group) => {\n\t\t\t\treturn !groupsInNewVariant.includes(group);\n\t\t\t})\n\t\t\t.map((group) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: propertyInfoNames.includes(`Property::${group}`) ? `Property::${group}` : group,\n\t\t\t\t\tgrouped: false\n\t\t\t\t};\n\t\t\t})\n\t);\n\n\treturn groupLevels;\n};\n\n/**\n * Override the sorters for new state to be set on the table.\n * @param newSortOrder\n * @param oldSortOrder\n * @param propertyInfoNames\n * @returns Overridden sorters to be set on the table\n */\nconst overridePVSorters = function (newSortOrder: SortOrder[], oldSortOrder: SortOrder[], propertyInfoNames: string[]): Sorters[] {\n\tconst sortersInNewVariant = newSortOrder.map((sorter) => {\n\t\treturn sorter.Property;\n\t});\n\n\tconst sorters = newSortOrder.map((sorter) => {\n\t\treturn {\n\t\t\tname: propertyInfoNames.includes(`Property::${sorter.Property}`) ? `Property::${sorter.Property}` : sorter.Property,\n\t\t\tdescending: sorter.Descending\n\t\t};\n\t});\n\n\tsorters.push(\n\t\t...oldSortOrder\n\t\t\t.filter((sorter) => {\n\t\t\t\treturn !sortersInNewVariant.includes(sorter.Property);\n\t\t\t})\n\t\t\t.map((sorter) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: propertyInfoNames.includes(`Property::${sorter.Property}`) ? `Property::${sorter.Property}` : sorter.Property,\n\t\t\t\t\tdescending: sorter.Descending,\n\t\t\t\t\tsorted: false\n\t\t\t\t};\n\t\t\t})\n\t);\n\n\treturn sorters;\n};\n\n/**\n * Override the Aggregations for the new state to be set on the table.\n * @param newAggregations\n * @param oldAggregations\n * @param propertyInfoNames\n * @returns Overridden Aggregations to be set on the table\n */\nconst overridePVAggregations = function (\n\tnewAggregations: Aggregation,\n\toldAggregations: Aggregation,\n\tpropertyInfoNames: string[]\n): Aggregation {\n\tconst newAggregationsKeys = Object.keys(newAggregations);\n\n\t// Return object\n\tconst mixedAggregates: Aggregation = {};\n\n\t// Put the new keys in the return object.\n\tfor (const singleNewAggregate in newAggregations) {\n\t\tlet newAggregate = singleNewAggregate;\n\t\tif (propertyInfoNames.includes(`Property::${singleNewAggregate}`)) {\n\t\t\tnewAggregate = `Property::${singleNewAggregate}`;\n\t\t}\n\t\tmixedAggregates[newAggregate] = newAggregations[singleNewAggregate];\n\t}\n\n\t// Hide the old aggregates if they are not present in the new Variant\n\tfor (const singleOldAggregate in oldAggregations) {\n\t\tif (!newAggregationsKeys.includes(singleOldAggregate)) {\n\t\t\tlet oldAggregate = singleOldAggregate;\n\t\t\tif (propertyInfoNames.includes(`Property::${singleOldAggregate}`)) {\n\t\t\t\toldAggregate = `Property::${singleOldAggregate}`;\n\t\t\t}\n\t\t\tmixedAggregates[oldAggregate] = { aggregated: false };\n\t\t}\n\t}\n\n\treturn mixedAggregates;\n};\n\n/**\n * Override the column content for new state to be set on the table.\n * @param newPVContent\n * @param oldPVContent\n * @returns Overridden column content to be set on the table\n */\nconst overridePVContent = function (newPVContent: VisContentType[], oldPVContent: VisContentType[]): Items[] {\n\tconst itemsInNewVariant =\n\t\tnewPVContent.map((item) => {\n\t\t\treturn item[\"Value\"];\n\t\t}) || [];\n\n\tconst items: Items[] =\n\t\tnewPVContent?.map((item, itemIndex: number) => {\n\t\t\treturn {\n\t\t\t\tname: item.Value,\n\t\t\t\tvisible: true,\n\t\t\t\tposition: itemIndex\n\t\t\t};\n\t\t}) || [];\n\n\titems.push(\n\t\t...oldPVContent\n\t\t\t.filter((item) => {\n\t\t\t\treturn !itemsInNewVariant.includes(item.Value);\n\t\t\t})\n\t\t\t.map((item) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: item.Value,\n\t\t\t\t\tvisible: false\n\t\t\t\t} as Items;\n\t\t\t})\n\t);\n\n\treturn items;\n};\n\n/**\n * Convert the presentation variant to state format.\n *\n * When a new presentation variant is to be applied on the table,\n * properties that are conflicting with the existing presentation variant\n * must be handled appropriately.\n * @param pvToSet The presentation variant that is to be applied on the table.\n * @param pvToReplace The existing presentation variant set on the table.\n * @param propertyInfoNames\n * @returns The app state that must be set on the table\n */\nexport const convertPVToState = function (\n\tpvToSet: PresentationVariant,\n\tpvToReplace: PresentationVariant,\n\tpropertyInfoNames: string[]\n): AppState {\n\tconst newPVProps = pvToSet.getProperties() ?? {};\n\tconst oldPVProps = (pvToReplace.getProperties() as PvProperties) ?? {};\n\n\tconst newPVContent = (pvToSet.getTableVisualization()?.Content || []) as VisContentType[];\n\tconst oldPVContent = (pvToReplace.getTableVisualization()?.Content || []) as VisContentType[];\n\n\tconst overriddenProps: AppState = {\n\t\titems: overridePVContent(newPVContent, oldPVContent),\n\t\tgroupLevels: overridePVGroupLevels(newPVProps.GroupBy ?? [], oldPVProps.GroupBy ?? [], propertyInfoNames),\n\t\tsorters: overridePVSorters(newPVProps.SortOrder ?? [], oldPVProps.SortOrder ?? [], propertyInfoNames)\n\t};\n\tconst overriddenAggregation = overridePVAggregations(newPVProps.Aggregations ?? {}, oldPVProps.Aggregations ?? {}, propertyInfoNames);\n\tif (Object.keys(overriddenAggregation).length > 0) {\n\t\toverriddenProps.aggregations = overriddenAggregation;\n\t}\n\treturn overriddenProps;\n};\n"],"mappings":";;;;kDAWA,MAAMA,EAAwB,SAAUC,EAA0BC,EAA0BC,GAC3F,MAAMC,EAAqBH,EAAeI,IAAKC,GACvCA,GAGR,MAAMC,EACLN,EAAeI,IAAKC,IACZ,CACNE,KAAML,EAAkBM,SAAS,aAAaH,KAAW,aAAaA,IAAUA,MAE5E,GAEPC,EAAYG,QACRR,EACDS,OAAQL,IACAF,EAAmBK,SAASH,IAEpCD,IAAKC,IACE,CACNE,KAAML,EAAkBM,SAAS,aAAaH,KAAW,aAAaA,IAAUA,EAChFM,QAAS,UAKb,OAAOL,CACR,EASA,MAAMM,EAAoB,SAAUC,EAA2BC,EAA2BZ,GACzF,MAAMa,EAAsBF,EAAaT,IAAKY,GACtCA,EAAOC,UAGf,MAAMC,EAAUL,EAAaT,IAAKY,IAC1B,CACNT,KAAML,EAAkBM,SAAS,aAAaQ,EAAOC,YAAc,aAAaD,EAAOC,WAAaD,EAAOC,SAC3GE,WAAYH,EAAOI,cAIrBF,EAAQT,QACJK,EACDJ,OAAQM,IACAD,EAAoBP,SAASQ,EAAOC,WAE5Cb,IAAKY,IACE,CACNT,KAAML,EAAkBM,SAAS,aAAaQ,EAAOC,YAAc,aAAaD,EAAOC,WAAaD,EAAOC,SAC3GE,WAAYH,EAAOI,WACnBC,OAAQ,UAKZ,OAAOH,CACR,EASA,MAAMI,EAAyB,SAC9BC,EACAC,EACAtB,GAEA,MAAMuB,EAAsBC,OAAOC,KAAKJ,GAGxC,MAAMK,EAA+B,CAAC,EAGtC,IAAK,MAAMC,KAAsBN,EAAiB,CACjD,IAAIO,EAAeD,EACnB,GAAI3B,EAAkBM,SAAS,aAAaqB,KAAuB,CAClEC,EAAe,aAAaD,GAC7B,CACAD,EAAgBE,GAAgBP,EAAgBM,EACjD,CAGA,IAAK,MAAME,KAAsBP,EAAiB,CACjD,IAAKC,EAAoBjB,SAASuB,GAAqB,CACtD,IAAIC,EAAeD,EACnB,GAAI7B,EAAkBM,SAAS,aAAauB,KAAuB,CAClEC,EAAe,aAAaD,GAC7B,CACAH,EAAgBI,GAAgB,CAAEC,WAAY,MAC/C,CACD,CAEA,OAAOL,CACR,EAQA,MAAMM,EAAoB,SAAUC,EAAgCC,GACnE,MAAMC,EACLF,EAAa/B,IAAKkC,GACVA,EAAK,WACP,GAEP,MAAMC,EACLJ,GAAc/B,IAAI,CAACkC,EAAME,KACjB,CACNjC,KAAM+B,EAAKG,MACXC,QAAS,KACTC,SAAUH,MAEN,GAEPD,EAAM9B,QACF2B,EACD1B,OAAQ4B,IACAD,EAAkB7B,SAAS8B,EAAKG,QAExCrC,IAAKkC,IACE,CACN/B,KAAM+B,EAAKG,MACXC,QAAS,UAKb,OAAOH,CACR,EAaO,MAAMK,EAAmB,SAC/BC,EACAC,EACA5C,GAEA,MAAM6C,EAAaF,EAAQG,iBAAmB,CAAC,EAC/C,MAAMC,EAAcH,EAAYE,iBAAoC,CAAC,EAErE,MAAMb,EAAgBU,EAAQK,yBAAyBC,SAAW,GAClE,MAAMf,EAAgBU,EAAYI,yBAAyBC,SAAW,GAEtE,MAAMC,EAA4B,CACjCb,MAAOL,EAAkBC,EAAcC,GACvC9B,YAAaP,EAAsBgD,EAAWM,SAAW,GAAIJ,EAAWI,SAAW,GAAInD,GACvFgB,QAASN,EAAkBmC,EAAWO,WAAa,GAAIL,EAAWK,WAAa,GAAIpD,IAEpF,MAAMqD,EAAwBjC,EAAuByB,EAAWS,cAAgB,CAAC,EAAGP,EAAWO,cAAgB,CAAC,EAAGtD,GACnH,GAAIwB,OAAOC,KAAK4B,GAAuBE,OAAS,EAAG,CAClDL,EAAgBM,aAAeH,CAChC,CACA,OAAOH,CACR,EAAEO,EAAAf,mBAAA,OAAAe,CAAA","ignoreList":[]}