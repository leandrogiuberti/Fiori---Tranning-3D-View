{"version":3,"file":"BaseStateHandler.js","names":["BaseStateHandler","_IViewStateContributo","apply","this","arguments","_exports","_inheritsLoose","_proto","prototype","setupMixin","baseClass","call","baseInit","init","setupStateInteractionsForLazyRendering","isBlocksAvailable","registerSubSectionDelegate","subSection","eventDelegates","onBeforeRendering","checkForStateInteractions","removeEventDelegate","addEventDelegate","setInitialState","async","retrieveState","_stateHandlersAvailable","_retrieveHandler","blocksAvailable","_retrieveStatePending","view","CommonUtils","getTargetView","extensionAPI","getController","getExtensionAPI","_applyStatePending","_stateToApply","applyLegacyState","getControlState","controlState","applyState","_applyHandler","resetStateToApply","triggerStateInteractions","retrieveIsRelevant","applyIsRelevant","updateAppState","undefined","getStateHandlerInstance","stateHandler","handlerModuleName","getModulePath","modules","requireDependencies","handlerName","substring","lastIndexOf","handlerInstance","Error","err","Log","warning","getId","_setStateHandler","handlerType","setApplyStateHandler","applyStateHandler","Promise","resolve","then","setRetrieveStateHandler","retrieveStateHandler","handlerPath","replace","IViewStateContributorMixin"],"sources":["./BaseStateHandler.ts"],"sourcesContent":["import Log from \"sap/base/Log\";\nimport CommonUtils from \"sap/fe/core/CommonUtils\";\nimport type ExtensionAPI from \"sap/fe/core/ExtensionAPI\";\nimport type { ControlState as ViewStateControlState } from \"sap/fe/core/controllerextensions/ViewState\";\nimport IViewStateContributorMixin from \"sap/fe/core/controllerextensions/viewState/IViewStateContributorMixin\";\nimport { requireDependencies } from \"sap/fe/core/helpers/LoaderUtils\";\nimport type ManagedObject from \"sap/ui/base/ManagedObject\";\nimport type Control from \"sap/ui/core/Control\";\nimport type ObjectPageSubSection from \"sap/uxap/ObjectPageSubSection\";\n\ntype StateContributor = Control & {\n\tapplyStateHandler?: string;\n\tretrieveStateHandler?: string;\n};\ntype HandlerType = \"apply\" | \"retrieve\";\n\nexport default class BaseStateHandler<CtrlState> extends IViewStateContributorMixin<CtrlState> {\n\t/**\n\t * Store the state to be applied until the section is ready.\n\t */\n\t_stateToApply?: CtrlState;\n\n\t/**\n\t * Apply state is pending.\n\t */\n\t_applyStatePending?: boolean;\n\n\t/**\n\t * Retrieve state is pending.\n\t */\n\t_retrieveStatePending?: boolean;\n\n\t/**\n\t * Promise that resolves on state handlers' creation.\n\t */\n\t_stateHandlersAvailable?: Promise<void>;\n\n\t/**\n\t * The instance of the apply-state handler provided by the control user.\n\t */\n\t_applyHandler?: (this: ExtensionAPI, control: StateContributor, state?: CtrlState) => void;\n\n\t/**\n\t * The instance of the retrieve-state handler provided by the control user.\n\t */\n\t_retrieveHandler?: (this: ExtensionAPI, control: StateContributor) => CtrlState;\n\n\tsetupMixin(baseClass: Function): void {\n\t\t// This method is needed to implement interface IInterfaceWithMixin\n\t\tsuper.setupMixin(baseClass);\n\t\tconst baseInit = baseClass.prototype.init;\n\t\tbaseClass.prototype.init = function (this: StateContributor & BaseStateHandler<CtrlState>): void {\n\t\t\tbaseInit?.call(this);\n\n\t\t\t// The control is ready for state interactions if the blocks are available,\n\t\t\t// Else we wait for blocks to be added.\n\t\t\tthis.setupStateInteractionsForLazyRendering();\n\t\t};\n\t}\n\n\t/**\n\t * Listen to subsections rendering to enable state interactions.\n\t */\n\tsetupStateInteractionsForLazyRendering(this: StateContributor & BaseStateHandler<CtrlState>): void {}\n\n\tisBlocksAvailable(this: StateContributor & BaseStateHandler<CtrlState>): boolean {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Register subsection delegate to enable state interactions.\n\t * We use onBeforeRendering, as when a parent is set for a newly available block, the subsection is rerendered.\n\t * @param subSection Subsection control\n\t */\n\tregisterSubSectionDelegate(this: StateContributor & BaseStateHandler<CtrlState>, subSection: ObjectPageSubSection): void {\n\t\tconst eventDelegates = {\n\t\t\tonBeforeRendering: (): void => {\n\t\t\t\tif (this.checkForStateInteractions()) {\n\t\t\t\t\tsubSection.removeEventDelegate(eventDelegates);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tsubSection.addEventDelegate(eventDelegates);\n\t}\n\n\t/**\n\t * Hook to set the initial state.\n\t */\n\tasync setInitialState(this: StateContributor & BaseStateHandler<CtrlState>): Promise<void> {}\n\n\t/**\n\t * Retrieve the state to store as part of the view state.\n\t * @returns StateContributor state\n\t */\n\tasync retrieveState(this: StateContributor & BaseStateHandler<CtrlState>): Promise<CtrlState | null> {\n\t\tawait this._stateHandlersAvailable;\n\t\tif (this._retrieveHandler) {\n\t\t\tconst blocksAvailable = this.isBlocksAvailable();\n\t\t\tif (blocksAvailable) {\n\t\t\t\t// blocks are available, we carry on with the retrieve state\n\t\t\t\tthis._retrieveStatePending = false;\n\t\t\t\tconst view = CommonUtils.getTargetView(this);\n\t\t\t\tconst extensionAPI = view.getController().getExtensionAPI();\n\t\t\t\treturn this._retrieveHandler.call(extensionAPI, this);\n\t\t\t} else if (this._applyStatePending) {\n\t\t\t\t// blocks are not available but applyState is already pending, hence we return the state that is on hold.\n\t\t\t\tthis._retrieveStatePending = false;\n\t\t\t\treturn this._stateToApply ?? null;\n\t\t\t} else {\n\t\t\t\t// blocks are not available hence we sent the retrieve state to pending.\n\t\t\t\tthis._retrieveStatePending = true;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Apply state to the contributor.\n\t * @param getControlState Function to fetch the state to apply.\n\t * @returns Promise that resolves on state application.\n\t */\n\tasync applyLegacyState(\n\t\tthis: StateContributor & BaseStateHandler<CtrlState>,\n\t\tgetControlState: (control: ManagedObject) => ViewStateControlState\n\t): Promise<void> {\n\t\tconst controlState = getControlState(this) as CtrlState;\n\t\treturn this.applyState(controlState);\n\t}\n\n\t/**\n\t * Apply state to the contributor.\n\t * @param controlState State to apply\n\t * @returns Promise that resolves on state application.\n\t */\n\tasync applyState(this: StateContributor & BaseStateHandler<CtrlState>, controlState?: CtrlState): Promise<void> {\n\t\tawait this._stateHandlersAvailable;\n\t\tif (this._applyHandler) {\n\t\t\tconst blocksAvailable = this.isBlocksAvailable();\n\t\t\tif (blocksAvailable) {\n\t\t\t\t// blocks are available, we carry on with the apply state\n\t\t\t\tconst view = CommonUtils.getTargetView(this);\n\t\t\t\tconst extensionAPI = view.getController().getExtensionAPI();\n\t\t\t\tthis.resetStateToApply();\n\t\t\t\treturn this._applyHandler?.call(extensionAPI, this, controlState);\n\t\t\t} else {\n\t\t\t\t// blocks are not available hence we sent the apply state to pending.\n\t\t\t\tthis._stateToApply = controlState;\n\t\t\t\tthis._applyStatePending = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Trigger state interactions.\n\t */\n\tasync triggerStateInteractions(this: StateContributor & BaseStateHandler<CtrlState>): Promise<void> {\n\t\tawait this._stateHandlersAvailable;\n\t\tconst retrieveIsRelevant = this._retrieveHandler && this._retrieveStatePending;\n\t\tconst applyIsRelevant = this._applyHandler && this._applyStatePending;\n\t\tif (retrieveIsRelevant) {\n\t\t\tif (applyIsRelevant) {\n\t\t\t\t// Both retrieve and apply are pending\n\t\t\t\tthis.applyState(this._stateToApply);\n\t\t\t}\n\t\t\tthis._retrieveStatePending = false;\n\t\t\tconst view = CommonUtils.getTargetView(this);\n\t\t\tconst extensionAPI = view.getController().getExtensionAPI();\n\t\t\t// appState update would call the retrieveState.\n\t\t\tawait extensionAPI.updateAppState();\n\t\t} else if (applyIsRelevant) {\n\t\t\tthis.applyState(this._stateToApply);\n\t\t}\n\t}\n\n\t/**\n\t * Reset the state to apply.\n\t */\n\tresetStateToApply(this: StateContributor & BaseStateHandler<CtrlState>): void {\n\t\tthis._stateToApply = undefined;\n\t\tthis._applyStatePending = false;\n\t}\n\n\t/**\n\t * Check for state interactions to trigger.\n\t * @returns Boolean true if any pending state interactions are executed.\n\t */\n\tcheckForStateInteractions(this: StateContributor & BaseStateHandler<CtrlState>): boolean {\n\t\tconst blocksAvailable = this.isBlocksAvailable();\n\t\tif (blocksAvailable) {\n\t\t\tthis.triggerStateInteractions();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create an instance of a state handler from a function's path.\n\t * @param stateHandler Path to the state handler.\n\t * @returns Handler instance to use for state handling.\n\t */\n\tasync getStateHandlerInstance(\n\t\tthis: StateContributor & BaseStateHandler<CtrlState>,\n\t\tstateHandler?: string\n\t): Promise<(() => unknown) | undefined> {\n\t\ttry {\n\t\t\tif (stateHandler) {\n\t\t\t\tconst handlerModuleName = this.getModulePath(stateHandler);\n\t\t\t\tconst modules = (await requireDependencies([handlerModuleName])) as Record<string, (() => {}) | undefined>[];\n\t\t\t\tconst handlerName = stateHandler.substring(stateHandler.lastIndexOf(\".\") + 1);\n\t\t\t\tconst handlerInstance = modules[0][handlerName];\n\t\t\t\tif (handlerInstance) {\n\t\t\t\t\treturn handlerInstance;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"handler not found\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err: unknown) {\n\t\t\tLog.warning(`'${this.getId()}' control's state handler '${stateHandler}' couldn't be resolved: ${err}`);\n\t\t}\n\t}\n\n\t/**\n\t * Set the instance of the state handler.\n\t * @param handlerType Apply or Retrieve.\n\t * @param stateHandler Path to the handler instance.\n\t */\n\tasync _setStateHandler(\n\t\tthis: StateContributor & BaseStateHandler<CtrlState>,\n\t\thandlerType: HandlerType,\n\t\tstateHandler?: string\n\t): Promise<void> {\n\t\tthis[`_${handlerType}Handler`] = (await this.getStateHandlerInstance(stateHandler)) as typeof handlerType extends \"apply\"\n\t\t\t? typeof this._applyHandler\n\t\t\t: typeof this._retrieveHandler;\n\t\tthis[`${handlerType}StateHandler`] = stateHandler;\n\t}\n\n\t/**\n\t * Set the apply-state handler.\n\t * @param applyStateHandler Path to the instance of the apply-state handler.\n\t * @returns Promise\n\t */\n\tasync setApplyStateHandler(this: StateContributor & BaseStateHandler<CtrlState>, applyStateHandler?: string): Promise<void> {\n\t\tthis._stateHandlersAvailable = (this._stateHandlersAvailable || Promise.resolve()).then(async () => {\n\t\t\treturn this._setStateHandler(\"apply\", applyStateHandler);\n\t\t});\n\t\treturn this._stateHandlersAvailable;\n\t}\n\n\t/**\n\t * Set the retrieve-state handler.\n\t * @param retrieveStateHandler Path to the instance of the retrieve-state handler.\n\t * @returns Promise\n\t */\n\tasync setRetrieveStateHandler(this: StateContributor & BaseStateHandler<CtrlState>, retrieveStateHandler?: string): Promise<void> {\n\t\tthis._stateHandlersAvailable = (this._stateHandlersAvailable || Promise.resolve()).then(async () => {\n\t\t\treturn this._setStateHandler(\"retrieve\", retrieveStateHandler);\n\t\t});\n\t\treturn this._stateHandlersAvailable;\n\t}\n\n\t/**\n\t * Get the module path of the function.\n\t * @param handlerPath Path to the handler instance.\n\t * @returns Module Path\n\t */\n\tgetModulePath(handlerPath: string): string {\n\t\treturn handlerPath.substring(0, handlerPath.lastIndexOf(\".\")).replace(/\\./g, \"/\");\n\t}\n}\n"],"mappings":"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","ignoreList":[]}