{"version":3,"file":"AdditionalValueHelper.js","names":["AdditionalValueGroupKey","_exports","additionalValueHelper","requestForAdditionalValueContextData","async","additionalValues","valueHelpListBinding","valueHelpBindingInfo","payload","sorters","table","allListBinding","additionalValueContextPromise","reverseRecommendationValues","filter","value","groupKey","recommendation","reverse","parameters","$select","qualifiers","valueHelpQualifier","vhProperties","searchTerm","$search","isValueListWithFixedValues","$count","listSorters","forEach","sorter","push","Sorter","name","descending","valueHelpListModel","getModel","additionalValueListBindings","this","getAdditionalValueContextBindings","length","requestContexts","submitBatch","additionalValuesContext","Promise","all","count","getCount","getBindingContext","setProperty","recommendationContexts","allContexts","recommendationValuesContextData","map","context","getObject","othersValuesContextData","additionalValueContextBindings","valueHelpFilters","getValueHelpBindingFilters","getMetaModel","recommendationValueFilters","getAdditionalValueFilters","bindList","path","undefined","metaModel","filters","Array","isArray","addDraftFilter","metaContext","getMetaContext","objectPath","MetaModelConverter","getInvolvedDataModelObjects","isDraftSupported","ModelHelper","isObjectPathDraftSupported","Filter","operator","value1","resumeValueListBindingAndResetChanges","isSuspended","resumeAsync","resetChanges","error","sortAndFilterListBinding","NONE","FilterType","Application","modifiedSorters","getSorterFunction","sort","reverseAdditionalValues","additionalValue","values","propertyPath","resourceBundle","Library","getResourceBundleFor","getProperty","getText","recentValue","createTransientContextsForAdditionalValueContextData","recentValuesContextData","createGroupedTransientContexts","other","additionalValueContextData","contextData","create","created","canceled","Log","getRelevantRecommendations","data","bindingContext","bindingPath","relevantRecommendations","Object","keys","getRecommendationPropertyPath","version","getAdditionalValueFromPropertyPath","valueData","_checkForKeysInRecommendations","keyProperties","key","getAdditionalValueFromKeys","recommendationData","result","recData","allKeysMatch","_getRecommendation","oldData","assign","includes","propertyPaths","split","navPropPath","splice","join","standardRecommendationHelper","getStandardRecommendations","getRelevantOthersValuesContextData","valueHelpKeys","checkValuesMatch","getRelevantRecentValuesContextData","bindingInfo","recentValuesModel","JSONModel","recentValuesList","getAllCurrentContexts","recentValueContextData","filterRecentValuesContextData","contextDataToBeMatched","contextDataList","obj","match","getRelevantRecommendationValuesContextData","recommendationValues","arguments","valueListProperty","relevantRecommendationValuesContextData","foundObject","find","updateFinished","event","source","getSource","tableBindingContext","actual","total","reason","getParameters","paginationData","additionalData","getBinding"],"sources":["./AdditionalValueHelper.ts"],"sourcesContent":["import Log from \"sap/base/Log\";\nimport * as MetaModelConverter from \"sap/fe/core/converters/MetaModelConverter\";\nimport ModelHelper from \"sap/fe/core/helpers/ModelHelper\";\nimport type {\n\tInCompletenessInfoType,\n\tInternalPropertyAdditionalValue,\n\tKeyPropertiesDataType,\n\tRecommendationDataForNavPropertyType,\n\tRecommendationValueType\n} from \"sap/fe/core/helpers/RecommendationHelper\";\nimport type { RecommendationInfo, StandardRecommendationDataType } from \"sap/fe/core/helpers/StandardRecommendationHelper\";\nimport { standardRecommendationHelper } from \"sap/fe/core/helpers/StandardRecommendationHelper\";\nimport type { FieldDataType } from \"sap/fe/core/services/ValueHelpHistoryServiceFactory\";\nimport type { SorterType, ValueHelpPayload } from \"sap/fe/macros/internal/valuehelp/ValueListHelper\";\nimport type Table from \"sap/m/Table\";\nimport type UI5Event from \"sap/ui/base/Event\";\nimport type EventProvider from \"sap/ui/base/EventProvider\";\nimport type { BaseAggregationBindingInfo } from \"sap/ui/base/ManagedObject\";\nimport Library from \"sap/ui/core/Lib\";\nimport type MTable from \"sap/ui/mdc/valuehelp/content/MTable\";\nimport type Context from \"sap/ui/model/Context\";\nimport Filter from \"sap/ui/model/Filter\";\nimport FilterType from \"sap/ui/model/FilterType\";\nimport Sorter from \"sap/ui/model/Sorter\";\nimport JSONModel from \"sap/ui/model/json/JSONModel\";\nimport type V4Context from \"sap/ui/model/odata/v4/Context\";\nimport type { ContextErrorType } from \"sap/ui/model/odata/v4/Context\";\nimport type ODataListBinding from \"sap/ui/model/odata/v4/ODataListBinding\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\nimport type ODataModel from \"sap/ui/model/odata/v4/ODataModel\";\n\nenum AdditionalValueGroupKey {\n\trecommendation = \"recommendation\",\n\trecentValue = \"recentValue\",\n\tother = \"other\"\n}\nexport type AdditionalValueType = {\n\tpropertyPath: string;\n\tvalues: (string | number | boolean)[];\n\tgroupKey: AdditionalValueGroupKey; // unique identifier for the group\n};\nexport type BindingInfoParameters = {\n\t$select: string[];\n\t$expand?: string[];\n\t$search: string;\n\t$count: boolean;\n};\n\nexport type AdditionValueDefinition =\n\t| InCompletenessInfoType\n\t| RecommendationDataForNavPropertyType[]\n\t| InternalPropertyAdditionalValue\n\t| object;\nconst additionalValueHelper = {\n\t/**\n\t * This function is responsible to create context based on additional value filters and custom sorter and request contexts from it.\n\t * @param additionalValues Array of additional values\n\t * @param valueHelpListBinding List binding\n\t * @param valueHelpBindingInfo The binding info object to be used to bind the list to the model\n\t * @param payload Payload of the value help\n\t * @param sorters Sorters of the value help list binding\n\t * @param table Table for which the value help is requested\n\t * @returns Additional value contexts\n\t */\n\trequestForAdditionalValueContextData: async function (\n\t\tadditionalValues: AdditionalValueType[],\n\t\tvalueHelpListBinding: ODataListBinding,\n\t\tvalueHelpBindingInfo: BaseAggregationBindingInfo,\n\t\tpayload: ValueHelpPayload,\n\t\tsorters: SorterType[],\n\t\ttable: Table\n\t): Promise<{\n\t\trecommendationValuesContextData: FieldDataType[];\n\t\tothersValuesContextData: FieldDataType[];\n\t}> {\n\t\tlet allListBinding: ODataListBinding | undefined;\n\t\tconst additionalValueContextPromise: Promise<V4Context[]>[] = [];\n\t\t// reverse the array so that while creating transient context first additional value is grouped first\n\t\tconst reverseRecommendationValues = [\n\t\t\t...additionalValues.filter((value) => value.groupKey === AdditionalValueGroupKey.recommendation)\n\t\t].reverse();\n\n\t\t// logic to add $select for multi-level navigation properties as filling $select is sufficient for the model to create the expand calls\n\t\t(valueHelpBindingInfo.parameters as BindingInfoParameters).$select =\n\t\t\tpayload.qualifiers[payload.valueHelpQualifier].vhProperties ?? [];\n\n\t\t// check if there is any input in the field\n\t\t// This information is used to determine to show the \"others\" section or not\n\t\t// and also to determine if typeAhead should open or not\n\t\tconst searchTerm = (valueHelpBindingInfo.parameters as BindingInfoParameters).$search;\n\t\t(valueHelpBindingInfo.parameters as BindingInfoParameters).$search = searchTerm;\n\t\tif (payload.isValueListWithFixedValues) {\n\t\t\t(valueHelpBindingInfo.parameters as BindingInfoParameters).$count = true;\n\t\t}\n\t\tconst listSorters: Sorter[] = [];\n\t\tsorters.forEach((sorter: SorterType) => listSorters.push(new Sorter(sorter.name ?? \"\", sorter.descending)));\n\t\tconst valueHelpListModel: ODataModel = valueHelpListBinding.getModel() as ODataModel;\n\t\t// get the list binding for recommendation values and others values\n\t\tconst additionalValueListBindings: ODataListBinding[] = this.getAdditionalValueContextBindings(\n\t\t\treverseRecommendationValues,\n\t\t\tsearchTerm,\n\t\t\tpayload,\n\t\t\tvalueHelpListModel,\n\t\t\tvalueHelpBindingInfo,\n\t\t\tlistSorters\n\t\t);\n\t\tif (additionalValueListBindings.length > 0) {\n\t\t\tif (additionalValueListBindings.length === 2) {\n\t\t\t\tadditionalValueContextPromise.push(additionalValueListBindings[0].requestContexts(0, 10, \"additionalValue\"));\n\t\t\t\tallListBinding = additionalValueListBindings[1];\n\t\t\t} else {\n\t\t\t\tallListBinding = additionalValueListBindings[0];\n\t\t\t}\n\t\t\t// in case of dropdown, we fetch first 100 records on first load and then make subsequent requests upon user's scroll.\n\t\t\tadditionalValueContextPromise.push(\n\t\t\t\tallListBinding.requestContexts(0, payload.isValueListWithFixedValues ? 100 : 10, \"additionalValue\")\n\t\t\t);\n\t\t}\n\t\tawait valueHelpListModel.submitBatch(\"additionalValue\");\n\t\tconst additionalValuesContext = await Promise.all(additionalValueContextPromise);\n\t\t// we store this list bindings in order to be able to make subsequent requests on user's scroll\n\t\tconst count = allListBinding?.getCount();\n\t\tif (count && count > 100) {\n\t\t\ttable.getBindingContext(\"internal\")?.setProperty(\"allListBinding\", allListBinding);\n\t\t}\n\t\tlet recommendationContexts: V4Context[] = [],\n\t\t\tallContexts: V4Context[] = [];\n\t\tif (reverseRecommendationValues.length > 0) {\n\t\t\trecommendationContexts = additionalValuesContext[0];\n\t\t\tif (searchTerm || payload.isValueListWithFixedValues) {\n\t\t\t\tallContexts = additionalValuesContext[1];\n\t\t\t}\n\t\t} else if (searchTerm || payload.isValueListWithFixedValues) {\n\t\t\tallContexts = additionalValuesContext[0];\n\t\t}\n\n\t\tconst recommendationValuesContextData = recommendationContexts.map((context) => context.getObject() as FieldDataType);\n\t\tconst othersValuesContextData: FieldDataType[] = allContexts.map((context) => context.getObject() as FieldDataType);\n\n\t\treturn {\n\t\t\trecommendationValuesContextData,\n\t\t\tothersValuesContextData\n\t\t};\n\t},\n\t/**\n\t * Method to retrieve all relevant list bindings (recommendation and others) that is needed to make a backend call.\n\t * @param reverseRecommendationValues Reversed recommendation values\n\t * @param searchTerm Search term entered by the user\n\t * @param payload Payload of the value help\n\t * @param valueHelpListModel Model of the value help\n\t * @param valueHelpBindingInfo Binding info of the value help\n\t * @param sorter Custom sorter which needs to be applied to the list binding\n\t * @returns All the list binding which would be used to trigger calls to the backend.\n\t */\n\tgetAdditionalValueContextBindings: function (\n\t\treverseRecommendationValues: AdditionalValueType[],\n\t\tsearchTerm: string,\n\t\tpayload: ValueHelpPayload,\n\t\tvalueHelpListModel: ODataModel,\n\t\tvalueHelpBindingInfo: BaseAggregationBindingInfo,\n\t\tsorter: Sorter[]\n\t): ODataListBinding[] {\n\t\tconst additionalValueContextBindings: ODataListBinding[] = [];\n\t\tconst valueHelpFilters: Filter[] = [\n\t\t\t...this.getValueHelpBindingFilters(valueHelpBindingInfo, payload, valueHelpListModel.getMetaModel())\n\t\t];\n\t\tconst recommendationValueFilters = this.getAdditionalValueFilters(reverseRecommendationValues, [...valueHelpFilters]);\n\n\t\tif (reverseRecommendationValues.length > 0) {\n\t\t\t// binding represent recommendation list binding.\n\t\t\tadditionalValueContextBindings.push(\n\t\t\t\tvalueHelpListModel.bindList(\n\t\t\t\t\tvalueHelpBindingInfo.path,\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\trecommendationValueFilters,\n\t\t\t\t\tvalueHelpBindingInfo.parameters\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\tif (searchTerm || payload.isValueListWithFixedValues) {\n\t\t\t// binding represent all data list bindings.\n\t\t\tadditionalValueContextBindings.push(\n\t\t\t\tvalueHelpListModel.bindList(valueHelpBindingInfo.path, undefined, sorter, valueHelpFilters, valueHelpBindingInfo.parameters)\n\t\t\t);\n\t\t}\n\n\t\treturn additionalValueContextBindings;\n\t},\n\t/**\n\t * This function is responsible to fetch the valuehelp binding filters.\n\t * @param valueHelpBindingInfo The binding info object to be used to bind the list to the model\n\t * @param payload Payload of the value help to check if it's a dropdown scenario\n\t * @param metaModel The OData meta model to resolve entity set from path\n\t * @returns Filters of valuehelp binding\n\t */\n\tgetValueHelpBindingFilters: function (\n\t\tvalueHelpBindingInfo: BaseAggregationBindingInfo,\n\t\tpayload?: ValueHelpPayload,\n\t\tmetaModel?: ODataMetaModel\n\t): Filter[] {\n\t\tconst filters: Filter[] = [];\n\t\t// get all existing filters from the binding info\n\t\t// this + additional value filters will be used later on to fetch additional values from the backend\n\t\tif (valueHelpBindingInfo.filters) {\n\t\t\tif (Array.isArray(valueHelpBindingInfo.filters)) {\n\t\t\t\tfilters.push(...valueHelpBindingInfo.filters);\n\t\t\t} else {\n\t\t\t\tfilters.push(valueHelpBindingInfo.filters);\n\t\t\t}\n\t\t}\n\t\t// Add draft filter for OData draft-enabled entities\n\t\t// Check if the entity is draft-enabled and apply IsActiveEntity = true filter\n\t\tthis.addDraftFilter(valueHelpBindingInfo, filters, payload, metaModel);\n\t\treturn filters;\n\t},\n\t/**\n\t * This function adds a draft filter for OData draft-enabled entities.\n\t * @param valueHelpBindingInfo The binding info object to be used to bind the list to the model\n\t * @param filters The existing filters array to add the draft filter to\n\t * @param payload Payload of the value help to check if it's a dropdown scenario\n\t * @param metaModel The OData meta model to resolve entity set from path\n\t */\n\taddDraftFilter: function (\n\t\tvalueHelpBindingInfo: BaseAggregationBindingInfo,\n\t\tfilters: Filter[],\n\t\tpayload?: ValueHelpPayload,\n\t\tmetaModel?: ODataMetaModel\n\t): void {\n\t\tif (valueHelpBindingInfo.path && metaModel) {\n\t\t\t// Get the EntitySet from the path using MetaModel\n\t\t\tconst metaContext = metaModel.getMetaContext(valueHelpBindingInfo.path);\n\t\t\tconst objectPath = MetaModelConverter.getInvolvedDataModelObjects(metaContext);\n\n\t\t\t// Check if the entity is draft-enabled using ModelHelper\n\t\t\t// This covers DraftRoot, DraftNode, and containment scenarios\n\t\t\tconst isDraftSupported = ModelHelper.isObjectPathDraftSupported(objectPath);\n\n\t\t\t// Check if it's a dropdown scenario (ValueListWithFixedValues)\n\t\t\tconst isValueListWithFixedValues = payload?.isValueListWithFixedValues ?? false;\n\n\t\t\t// Only add draft filter if entity is draft-enabled and it's a dropdown scenario\n\t\t\tif (isDraftSupported && isValueListWithFixedValues) {\n\t\t\t\t// Add IsActiveEntity filter for draft-enabled entities\n\t\t\t\t// This filter ensures only active (non-draft) entities are shown in value help dropdowns\n\t\t\t\tfilters.push(\n\t\t\t\t\tnew Filter({\n\t\t\t\t\t\tpath: \"IsActiveEntity\",\n\t\t\t\t\t\toperator: \"EQ\",\n\t\t\t\t\t\tvalue1: true\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * This function resumes the suspended list binding and then resets changes on it.\n\t * @param valueHelpListBinding List binding\n\t */\n\tresumeValueListBindingAndResetChanges: async function (valueHelpListBinding: ODataListBinding): Promise<void> {\n\t\tif (valueHelpListBinding.isSuspended()) {\n\t\t\tawait valueHelpListBinding.resumeAsync();\n\t\t}\n\t\t// get rid of existing transient contexts.\n\n\t\t// destroying causes issues sometimes, contexts are not always available to destroy but appear afterwards magically\n\t\ttry {\n\t\t\tawait valueHelpListBinding.resetChanges();\n\t\t} catch (error: unknown) {\n\t\t\t//We do not do anything here as we know the model will always throw an error and this will fill up the console with errors.\n\t\t}\n\t},\n\t/**\n\t * This function is used for sorting and filtering the list binding.\n\t * @param valueHelpListBinding List Binding\n\t * @param sorters Sorters of the value help list binding\n\t */\n\tsortAndFilterListBinding: function (valueHelpListBinding: ODataListBinding, sorters: SorterType[]): void {\n\t\t// In order to not show the list at all, we pass an empty filter which would render an empty list\n\t\tvalueHelpListBinding.filter(Filter.NONE, FilterType.Application);\n\n\t\tif (sorters.length) {\n\t\t\tconst modifiedSorters: Sorter[] = [];\n\t\t\tsorters.forEach((sorter: SorterType) =>\n\t\t\t\tmodifiedSorters.push(new Sorter(sorter.name ?? \"\", sorter.descending, this.getSorterFunction))\n\t\t\t);\n\t\t\tvalueHelpListBinding.sort(modifiedSorters);\n\t\t} else valueHelpListBinding.sort(new Sorter(\"\", false, this.getSorterFunction));\n\t},\n\t/**\n\t * This functions creates the filters for additional values.\n\t * @param reverseAdditionalValues Array of additional values in reverse order\n\t * @param filters Existing valuehelp binding filters\n\t * @returns Additional value filters\n\t */\n\tgetAdditionalValueFilters: function (reverseAdditionalValues: AdditionalValueType[], filters: Filter[]): Filter[] {\n\t\treverseAdditionalValues.forEach((additionalValue) => {\n\t\t\tif (additionalValue.values.length > 0) {\n\t\t\t\tconst values = additionalValue.values;\n\t\t\t\tconst propertyPath = additionalValue.propertyPath;\n\t\t\t\t// add additional value filters to existing filters from the binding info\n\t\t\t\tvalues.forEach((value) => {\n\t\t\t\t\t// update the value help binding info to get additional values from the backend\n\t\t\t\t\tfilters.push(\n\t\t\t\t\t\tnew Filter({\n\t\t\t\t\t\t\tpath: propertyPath,\n\t\t\t\t\t\t\tvalue1: value,\n\t\t\t\t\t\t\toperator: \"EQ\"\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\treturn filters;\n\t},\n\t/**\n\t * This function is a callback to the custom sorter.\n\t * @param context Context of the Field\n\t * @returns Group key that can be used for sorting\n\t */\n\tgetSorterFunction: function (context: V4Context): string {\n\t\t//eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\tconst resourceBundle = Library.getResourceBundleFor(\"sap.fe.macros\")!;\n\t\t//get the client side annotation to figure out the group key\n\t\tconst groupKey = context.getProperty(\"@$fe.additionalValueGroupKey\") as AdditionalValueGroupKey;\n\t\tif (groupKey === AdditionalValueGroupKey.recommendation) {\n\t\t\treturn resourceBundle.getText(\"M_ADDITIONALVALUEHELPER_RECOMMENDATIONS\");\n\t\t} else if (groupKey === AdditionalValueGroupKey.recentValue) {\n\t\t\treturn resourceBundle.getText(\"M_ADDITIONALVALUEHELPER_RECENTVALUE\");\n\t\t} else {\n\t\t\treturn resourceBundle.getText(\"M_ADDITIONALVALUEHELPER_OTHERS\");\n\t\t}\n\t},\n\t/**\n\t * Method to create transient contexts of the value help list binding for the given different types additional value context data.\n\t * @param recommendationValuesContextData Recommendation values context data\n\t * @param recentValuesContextData Recent values context data\n\t * @param othersValuesContextData Other values context data\n\t * @param valueHelpListBinding List binding\n\t */\n\tcreateTransientContextsForAdditionalValueContextData: function (\n\t\trecommendationValuesContextData: FieldDataType[],\n\t\trecentValuesContextData: FieldDataType[],\n\t\tothersValuesContextData: FieldDataType[],\n\t\tvalueHelpListBinding: ODataListBinding\n\t): void {\n\t\tthis.createGroupedTransientContexts(othersValuesContextData, valueHelpListBinding, AdditionalValueGroupKey.other);\n\t\tthis.createGroupedTransientContexts(recentValuesContextData, valueHelpListBinding, AdditionalValueGroupKey.recentValue);\n\t\tthis.createGroupedTransientContexts(recommendationValuesContextData, valueHelpListBinding, AdditionalValueGroupKey.recommendation);\n\t},\n\t/**\n\t * Method to create transient context for the given additional value context data. It also adds a key for each context which is used to group the newly created transient contexts accordingly.\n\t * @param additionalValueContextData Additional value context data\n\t * @param valueHelpListBinding List binding\n\t * @param groupKey Key which indicates the group of the additional value context data\n\t */\n\tcreateGroupedTransientContexts: function (\n\t\tadditionalValueContextData: FieldDataType[],\n\t\tvalueHelpListBinding: ODataListBinding,\n\t\tgroupKey: AdditionalValueGroupKey\n\t): void {\n\t\t// reverse of the context data is required so that the context which needs to be shown below in the list gets created first\n\t\t[...additionalValueContextData].reverse().forEach(async (contextData: FieldDataType) => {\n\t\t\t// groupKey is added in order to properly group the transient contexts amongst all 3 groups\n\t\t\tcontextData[\"@$fe.additionalValueGroupKey\"] = groupKey;\n\t\t\tconst context = valueHelpListBinding.create(contextData);\n\t\t\ttry {\n\t\t\t\tawait context.created();\n\t\t\t} catch (error) {\n\t\t\t\t// For transient contexts the canceled is set to true and for other cases it will be false. Atleast in recommendations\n\t\t\t\t// use case we do not face the scenario where canceled is set to false. For now we are just logging the error.\n\t\t\t\tif (!(error as ContextErrorType).canceled) {\n\t\t\t\t\tLog.error((error as ContextErrorType).name);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\t/**\n\t * This functions returns the relevant recommendations for the valuelist.\n\t * @param data Object containing recommendation model data\n\t * @param bindingContext Binding context of the Field\n\t * @param propertyPath Property Path of the Field\n\t * @param bindingPath\n\t * @returns Relevant recommendations for the valuelist\n\t */\n\tgetRelevantRecommendations: function (\n\t\tdata: InCompletenessInfoType | object,\n\t\tbindingContext: V4Context,\n\t\tpropertyPath: string,\n\t\tbindingPath?: string\n\t): Array<string | number> | null | undefined {\n\t\tconst values: Array<string | number> = [];\n\t\tlet relevantRecommendations: InternalPropertyAdditionalValue | undefined;\n\t\tif (Object.keys(data).length > 0) {\n\t\t\t//get the right property path by eliminating the starting / and also main entityset name\n\t\t\tpropertyPath = this.getRecommendationPropertyPath(propertyPath);\n\t\t\tif ((data as RecommendationInfo).version === 2.0 && bindingPath) {\n\t\t\t\tpropertyPath = bindingPath;\n\t\t\t}\n\t\t\t//get the recommendations based on property path and binding context passed\n\t\t\trelevantRecommendations = this.getAdditionalValueFromPropertyPath(propertyPath, bindingContext, data) as\n\t\t\t\t| InternalPropertyAdditionalValue\n\t\t\t\t| undefined;\n\t\t\t//if we get recommendations then push the values\n\t\t\tif (relevantRecommendations && Object.keys(relevantRecommendations).length > 0) {\n\t\t\t\trelevantRecommendations.additionalValues.forEach((valueData: RecommendationValueType) => {\n\t\t\t\t\tvalues.push(valueData.value);\n\t\t\t\t});\n\t\t\t\treturn values;\n\t\t\t} else {\n\t\t\t\t//if recommendations are not found then return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\n\t_checkForKeysInRecommendations: function (keyProperties: KeyPropertiesDataType, contextData: Record<string, string>): boolean {\n\t\tfor (const key in keyProperties) {\n\t\t\tif (keyProperties[key] !== contextData[key]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\t/**\n\t * This function is responsible to fetch the exact object from an array of objects that contains relevant recommendationData based on keys.\n\t * @param recommendationData Array containing additional values\n\t * @param bindingContext Binding context of the Field\n\t * @returns Relevant object from an array of object that contains the additional value\n\t */\n\tgetAdditionalValueFromKeys: function (\n\t\trecommendationData: AdditionValueDefinition,\n\t\tbindingContext?: V4Context | Context\n\t): AdditionValueDefinition {\n\t\tconst contextData = bindingContext?.getObject() as Record<string, string> | undefined;\n\t\tlet result: AdditionValueDefinition = {};\n\t\t//loop through the recommendationData and check if the keyProperties match with the binding context data\n\t\tif (bindingContext && contextData) {\n\t\t\tif (Array.isArray(recommendationData)) {\n\t\t\t\t(recommendationData as RecommendationDataForNavPropertyType[]).forEach((recData) => {\n\t\t\t\t\tconst keyProperties = recData.keyProperties as KeyPropertiesDataType;\n\t\t\t\t\tconst allKeysMatch = this._checkForKeysInRecommendations(keyProperties, contextData);\n\t\t\t\t\t//if every key value matches with the binding context data then assign it to result which will be returned\n\t\t\t\t\tif (allKeysMatch) {\n\t\t\t\t\t\tresult = recData as AdditionValueDefinition;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\t_getRecommendation: function (\n\t\tpropertyPath: string,\n\t\tbindingContext: Context,\n\t\trecommendationData: AdditionValueDefinition\n\t): AdditionValueDefinition {\n\t\t//create a copy of the recommendationData to store its previous value as it will change because of the recursive approach\n\t\tlet oldData = Object.assign(recommendationData, {});\n\t\t//check if property path exists on the recommendationData object and if so then return the object pointing to the property path\n\t\tif (Object.keys(recommendationData).includes(propertyPath)) {\n\t\t\treturn (recommendationData as InCompletenessInfoType)[propertyPath] as AdditionValueDefinition;\n\t\t} else {\n\t\t\t//if property path is not present then check if it is 1:n mapping and we need to do a recursive approach to land on the exact object containing the relevant recommendations\n\t\t\t//continue the while loop till the property path is found in the previous recommendationData\n\t\t\twhile (Object.keys(oldData).length > 0 && !Object.keys(oldData).includes(propertyPath)) {\n\t\t\t\t// as it might be 1:n mapping so first seperate the navprop name and actual prop name to make sure we find the navprop first and then from its pointing object we find the property path\n\t\t\t\t//eg: _Item/Material will be first divided into _Item and we search for it and then from its relevant object we search for Material\n\t\t\t\tconst propertyPaths = propertyPath.split(\"/\");\n\t\t\t\tif (propertyPaths.length > 1) {\n\t\t\t\t\t//getting the navprop path\n\t\t\t\t\tconst navPropPath = propertyPaths[0];\n\t\t\t\t\t//removing the navprop path from propertypaths so that we only check for actual property path\n\t\t\t\t\tpropertyPaths.splice(0, 1);\n\t\t\t\t\tpropertyPath = propertyPaths.join(\"/\");\n\t\t\t\t\t//using getAdditionalValueFromPropertyPath and passing navPropPath we get the exact array of objects pointing to the navProp\n\t\t\t\t\trecommendationData = this.getAdditionalValueFromPropertyPath(\n\t\t\t\t\t\tnavPropPath,\n\t\t\t\t\t\tbindingContext,\n\t\t\t\t\t\trecommendationData\n\t\t\t\t\t) as RecommendationDataForNavPropertyType[];\n\t\t\t\t\t//no pass the array of objects of navProp to getAdditionalValueFromKeys and get the exact object that contains the recommendationData based on keys\n\t\t\t\t\trecommendationData = this.getAdditionalValueFromKeys(recommendationData, bindingContext);\n\t\t\t\t\tif (Object.keys(recommendationData).length > 0) {\n\t\t\t\t\t\t//set the recommendationData to oldData before assigning the new value to it\n\t\t\t\t\t\toldData = Object.assign(recommendationData, {});\n\t\t\t\t\t\t//here we check for the actual property path from the object we found from getAdditionalValueFromKeys\n\t\t\t\t\t\t//eg: Material can be found in the object which is part of array of objects of _Item\n\t\t\t\t\t\trecommendationData = this.getAdditionalValueFromPropertyPath(\n\t\t\t\t\t\t\tpropertyPath,\n\t\t\t\t\t\t\tbindingContext,\n\t\t\t\t\t\t\trecommendationData\n\t\t\t\t\t\t) as AdditionValueDefinition;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn {};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn recommendationData;\n\t\t}\n\t},\n\n\t/**\n\t * This function is responsible for getting the additional value based on property path and binding context passed.\n\t * @param propertyPath Property path of the field\n\t * @param bindingContext Binding context of the field\n\t * @param recommendationData Object containing additional value\n\t * @returns Additional value based on property path and binding context passed\n\t */\n\tgetAdditionalValueFromPropertyPath: function (\n\t\tpropertyPath: string,\n\t\tbindingContext: V4Context | Context,\n\t\trecommendationData?: AdditionValueDefinition | RecommendationInfo\n\t): AdditionValueDefinition | StandardRecommendationDataType | undefined {\n\t\tif ((recommendationData as RecommendationInfo).version === 2) {\n\t\t\treturn standardRecommendationHelper.getStandardRecommendations(\n\t\t\t\tbindingContext,\n\t\t\t\tpropertyPath,\n\t\t\t\trecommendationData as RecommendationInfo\n\t\t\t);\n\t\t}\n\t\tif (recommendationData) {\n\t\t\treturn this._getRecommendation(propertyPath, bindingContext, recommendationData);\n\t\t}\n\t},\n\t/**\n\t * This function returns the property path of the field by removing the leading '/' and main entity set name.\n\t * @param propertyPath Property Path of the Field\n\t * @returns Property path of the field by removing the leading '/' and main entity set name.\n\t */\n\tgetRecommendationPropertyPath: function (propertyPath: string): string {\n\t\t//First we split the property path based on /\n\t\tconst propertyPaths = propertyPath.split(\"/\");\n\t\t//Now remove the first two elements of the array. As first element will always be '' and second element will be main entity set name\n\t\tpropertyPaths.splice(0, 2);\n\t\t//Now join the remaining elements to create a new property path and return it\n\t\treturn propertyPaths.join(\"/\");\n\t},\n\t/**\n\t * Method to filter Others values context data and remove values which are also present in Recently Used and Recommendation group.\n\t * @param recommendationValuesContextData Recommendation values context data\n\t * @param recentValuesContextData Recent values context data\n\t * @param othersValuesContextData Others values context data\n\t * @param valueHelpKeys ValueListProperty of the payload\n\t * @returns Others values context data.\n\t */\n\tgetRelevantOthersValuesContextData: function (\n\t\trecommendationValuesContextData: FieldDataType[],\n\t\trecentValuesContextData: FieldDataType[],\n\t\tothersValuesContextData: FieldDataType[],\n\t\tvalueHelpKeys: string[]\n\t): FieldDataType[] {\n\t\treturn othersValuesContextData.filter(\n\t\t\t(contextData) =>\n\t\t\t\t!this.checkValuesMatch(contextData, recommendationValuesContextData, valueHelpKeys) &&\n\t\t\t\t!this.checkValuesMatch(contextData, recentValuesContextData, valueHelpKeys)\n\t\t);\n\t},\n\t/**\n\t * Method to check whether recent values matches either with the search term or with the others values.\n\t * @param othersValuesContextData Others values context data\n\t * @param recentValuesContextData Recent values context data\n\t * @param valueHelpKeys ValueListProperty of the payload\n\t * @param searchTerm Search term entered by the user\n\t * @param bindingInfo Binding info object of the value help\n\t * @returns Recent values context data which needs to be show in the Recently Used group in the type ahead suggestion list.\n\t */\n\tgetRelevantRecentValuesContextData: function (\n\t\tothersValuesContextData: FieldDataType[],\n\t\trecentValuesContextData: FieldDataType[],\n\t\tvalueHelpKeys: string[],\n\t\tsearchTerm: string,\n\t\tbindingInfo: BaseAggregationBindingInfo\n\t): FieldDataType[] {\n\t\t// filter out recent value based on existing value help filters\n\t\tconst recentValuesModel = new JSONModel({ recentValuesContextData });\n\t\tconst recentValuesList = recentValuesModel.bindList(\n\t\t\t\"/recentValuesContextData\",\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tthis.getValueHelpBindingFilters(bindingInfo)\n\t\t);\n\t\trecentValuesContextData = recentValuesList.getAllCurrentContexts().map((context) => context.getObject() as FieldDataType);\n\n\t\t// consider only those recent values which either matches with the search term or with the response received from backend for the Others group.\n\t\t// Both the filters needs to be applied so that so that order of the recent values does not change, which is important for the order in which\n\t\t// the data would be shown in the type ahead suggestion list.\n\t\treturn recentValuesContextData.filter((recentValueContextData) =>\n\t\t\tthis.filterRecentValuesContextData(recentValueContextData, searchTerm, valueHelpKeys, othersValuesContextData)\n\t\t);\n\t},\n\t/**\n\t * Method to check whether the given recent value context data matches with the given search term or the others values.\n\t * @param recentValueContextData Recent values context data\n\t * @param searchTerm Search term entered by the user\n\t * @param valueHelpKeys ValueListProperty of the payload\n\t * @param othersValuesContextData Others values context data\n\t * @returns True if the given recent value context satisfies the filter condition.\n\t */\n\tfilterRecentValuesContextData: function (\n\t\trecentValueContextData: FieldDataType,\n\t\tsearchTerm: string,\n\t\tvalueHelpKeys: string[],\n\t\tothersValuesContextData: FieldDataType[]\n\t): boolean {\n\t\tfor (const key in recentValueContextData) {\n\t\t\tif (typeof recentValueContextData[key] === \"object\") {\n\t\t\t\tif (\n\t\t\t\t\tthis.filterRecentValuesContextData(\n\t\t\t\t\t\trecentValueContextData[key] as FieldDataType,\n\t\t\t\t\t\tsearchTerm,\n\t\t\t\t\t\tvalueHelpKeys,\n\t\t\t\t\t\tothersValuesContextData\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (typeof recentValueContextData[key] === \"string\") {\n\t\t\t\tif (\n\t\t\t\t\t(!searchTerm && othersValuesContextData.length === 0) || // Case where focus is just set to the value help field\n\t\t\t\t\t(recentValueContextData[key] as string).includes(searchTerm) ||\n\t\t\t\t\t(valueHelpKeys.includes(key) && this.checkValuesMatch(recentValueContextData, othersValuesContextData, valueHelpKeys))\n\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\t/**\n\t * Checks if the values of specified keys in contextDataToBeMatched match with any object in contextDataList.\n\t * @param contextDataToBeMatched The context data object to compare\n\t * @param contextDataList The array of context data objects to compare against\n\t * @param valueHelpKeys The keys to compare from contextDataToBeMatched with contextDataList objects\n\t * @returns Returns true if any object in contextDataList matches the values of the specified keys in contextDataToBeMatched, otherwise false.\n\t */\n\tcheckValuesMatch: function (contextDataToBeMatched: FieldDataType, contextDataList: FieldDataType[], valueHelpKeys: string[]): boolean {\n\t\tfor (const obj of contextDataList) {\n\t\t\tlet match = true;\n\t\t\tfor (const key of valueHelpKeys) {\n\t\t\t\t// Check if the value of the key in recentValuesContextData\n\t\t\t\t// matches the value of the key in the current object from othersValuesContextData\n\t\t\t\tif (contextDataToBeMatched[key] !== obj[key]) {\n\t\t\t\t\tmatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (match) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\t/**\n\t * Method to rearrange the given additional value context data as per the chronological order of the given additional values.\n\t * This is to ensure that the recommendation data fetched from backend are shown in the same order of recommendation values fetched from recommendation service.\n\t * @param recommendationValuesContextData Recommendation values context data\n\t * @param recommendationValues Recommendation values\n\t * @param valueListProperty Value list property of the value help\n\t * @returns Recommendation values context data in the correct order.\n\t */\n\tgetRelevantRecommendationValuesContextData: function (\n\t\trecommendationValuesContextData: FieldDataType[],\n\t\trecommendationValues: (string | number | boolean)[] = [],\n\t\tvalueListProperty: string\n\t): FieldDataType[] {\n\t\tconst relevantRecommendationValuesContextData: FieldDataType[] = [];\n\t\trecommendationValues.forEach((value) => {\n\t\t\tconst foundObject = recommendationValuesContextData.find((contextData) => contextData[valueListProperty] === value);\n\t\t\tif (foundObject) {\n\t\t\t\trelevantRecommendationValuesContextData.push(foundObject);\n\t\t\t}\n\t\t});\n\n\t\treturn relevantRecommendationValuesContextData;\n\t},\n\t/**\n\t * Method to make batch calls to support pagination.\n\t * This is to ensure that the additional data fetched from the backend is displayed in the correct order.\n\t * @param event An event object that consists of an ID, source, and a parameter map.\n\t */\n\tupdateFinished: async function name(event: UI5Event): Promise<void> {\n\t\tconst source = event.getSource() as { source?: EventProvider } as MTable;\n\t\tconst tableBindingContext: Context | undefined | null = source.getBindingContext(\"internal\"),\n\t\t\tallListBinding = tableBindingContext?.getProperty(\"allListBinding\") as ODataListBinding | undefined;\n\t\tconst { actual, total, reason } = event.getParameters() as { actual: number; total: number; reason: string };\n\t\t// as user scrolls down and once we reach end of the list, we fetch the next set of data from the backend\n\t\tif (allListBinding && reason === \"Growing\" && actual === total) {\n\t\t\tconst paginationData = await allListBinding.requestContexts(total, 100),\n\t\t\t\tadditionalData = paginationData.map((data: V4Context) => data.getObject() as FieldDataType);\n\t\t\tadditionalData.forEach(async (contextData: FieldDataType) => {\n\t\t\t\tconst context = (source.getBinding(\"items\") as ODataListBinding).create(contextData, undefined, true);\n\t\t\t\ttry {\n\t\t\t\t\tawait context.created();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tLog.error((error as ContextErrorType).name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n};\nexport { AdditionalValueGroupKey, RecommendationValueType, additionalValueHelper };\n"],"mappings":"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","ignoreList":[]}