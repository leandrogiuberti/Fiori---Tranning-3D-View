{"version":3,"file":"EasyFilterDataFetcher.js","names":["getKeyPropertyFilter","valueList","keyProperty","operator","valueToMatch","filterValue","annotations","Common","IsUpperCase","valueOf","toUpperCase","Filter","path","keyPath","value1","async","resolveValueUsingValueList","looseMatch","arguments","length","undefined","model","valueListInfo","$model","CollectionPath","$select","generateSelectParameter","$search","CommonUtils","normalizeSearchTerm","Date","toISOString","toString","isNegation","isNegationOperator","cleanedOperator","getPositiveOperator","keyPropertyFilter","characterLimitOverflow","maxLength","valueHelpKeyQuery","valueHelpSearchQuery","Promise","allSettled","bindList","requestContexts","mapResult","mapValueListToCodeList","status","value","FilterOperator","EQ","selectedValues","map","description","results","filteredResults","filter","result","toLowerCase","noMatch","ensureDescription","context","data","getObject","descriptionPath","_exports","includes","join","resolveTokenValue","setContinueOnError","valueListMetamodel","convertTypes","getMetaModel","resolvePath","target","isProperty","unresolvedResult","isComparisonOperator","BT","NB","lowerBound","upperBound","resolvedValues","all","selectedValue","flat","values","_ref","NE","NotContains","NotStartsWith","NotEndsWith","GT","GE","LT","LE","negationOperator","Contains","StartsWith","EndsWith"],"sources":["./EasyFilterDataFetcher.ts"],"sourcesContent":["import type { Property } from \"@sap-ux/vocabularies-types\";\nimport type {\n\tCodeListType,\n\tTokenSelectedValuesDefinition,\n\tValueHelpBetweenSelectedValues,\n\tValueHelpSelectedValuesDefinition\n} from \"sap/fe/controls/easyFilter/EasyFilterBarContainer\";\nimport CommonUtils from \"sap/fe/core/CommonUtils\";\nimport { convertTypes } from \"sap/fe/core/converters/MetaModelConverter\";\nimport { isProperty } from \"sap/fe/core/helpers/TypeGuards\";\nimport { type ValueListInfo } from \"sap/fe/macros/internal/valuehelp/ValueListHelper\";\nimport type Context from \"sap/ui/model/Context\";\nimport Filter from \"sap/ui/model/Filter\";\nimport FilterOperator from \"sap/ui/model/FilterOperator\";\nimport type { CodeListEntry } from \"ux/eng/fioriai/reuse/easyfilter/EasyFilter\";\n\ntype ScalarOperator = Exclude<FilterOperator, FilterOperator.BT | FilterOperator.NB>;\ntype ScalarValue = string | boolean | number | Date;\n\n/**\n * Generates a filter for the key property of a value list.\n * @param valueList The value list information.\n * @param keyProperty The key property of the value list.\n * @param operator The filter operator.\n * @param valueToMatch The value to match.\n * @returns A filter for the key property.\n */\nfunction getKeyPropertyFilter(\n\tvalueList: ValueListInfo,\n\tkeyProperty: Property,\n\toperator: ScalarOperator,\n\tvalueToMatch: ScalarValue\n): Filter {\n\tlet filterValue = valueToMatch;\n\n\t// If the key property is known to contain only uppercase values, convert the filter value to uppercase as well\n\tif (typeof filterValue === \"string\" && keyProperty.annotations.Common?.IsUpperCase?.valueOf() === true) {\n\t\tfilterValue = filterValue.toUpperCase();\n\t}\n\n\treturn new Filter({ path: valueList.keyPath, operator, value1: filterValue });\n}\n\n/**\n * Resolves a single scalar value using a value list.\n * @param valueList The value list information.\n * @param keyProperty The key property of the value list.\n * @param operator The filter operator.\n * @param valueToMatch The value to match.\n * @param looseMatch Whether to apply loose matching or not\n * @returns A promise that resolves to the selected values.\n */\nasync function resolveValueUsingValueList(\n\tvalueList: ValueListInfo,\n\tkeyProperty: Property,\n\toperator: ScalarOperator,\n\tvalueToMatch: ScalarValue,\n\tlooseMatch = false\n): Promise<ValueHelpSelectedValuesDefinition> {\n\tconst model = valueList.valueListInfo.$model;\n\tconst path = `/${valueList.valueListInfo.CollectionPath}`;\n\tconst $select = generateSelectParameter(valueList);\n\tlet $search = CommonUtils.normalizeSearchTerm(valueToMatch instanceof Date ? valueToMatch.toISOString() : valueToMatch.toString());\n\n\t// Handle negation operators (NE, NotContains, NotStartsWith, NotEndsWith)\n\t// Strategy: Query for positive case, then apply negation client-side\n\tconst isNegation = isNegationOperator(operator);\n\t// \"cleaned\" operator for possible negation operators\n\tconst cleanedOperator = isNegation ? getPositiveOperator(operator) : operator;\n\tconst keyPropertyFilter = getKeyPropertyFilter(valueList, keyProperty, cleanedOperator, valueToMatch);\n\n\t// Check if the query exceeds the maximum length of the key property\n\tconst characterLimitOverflow = !$search || $search.length > (keyProperty.maxLength ?? $search.length);\n\n\tif (!looseMatch) {\n\t\t$search = `\"${$search}\"`; // Ensure the search term is treated as a phrase\n\t}\n\t// If query exceeds the maximum length of the key property, we don't filter at all, as it would give no result anyway\n\tconst [valueHelpKeyQuery, valueHelpSearchQuery] = await Promise.allSettled([\n\t\t!characterLimitOverflow ? model.bindList(path, undefined, undefined, keyPropertyFilter, { $select }).requestContexts(0, 1) : [], // $filter on the key property of the value list\n\t\tmodel.bindList(path, undefined, undefined, undefined, { $search: $search, $select }).requestContexts() // $search on the value list\n\t]);\n\n\tconst mapResult = mapValueListToCodeList(valueList, true);\n\n\tif (valueHelpKeyQuery.status === \"fulfilled\" && valueHelpKeyQuery.value.length > 0) {\n\t\t// There is at least one match in the key column:\n\t\t// - If the operator is EQ: This indicates an exact key match, so the returned data will be used.\n\t\t// - For other operators: One or more keys match the value based on the operator, so the original condition is preserved.\n\t\treturn cleanedOperator === FilterOperator.EQ\n\t\t\t? { operator, selectedValues: valueHelpKeyQuery.value.map(mapResult) }\n\t\t\t: {\n\t\t\t\t\toperator,\n\t\t\t\t\tselectedValues: [{ value: valueToMatch, description: valueToMatch }]\n\t\t\t  };\n\t}\n\n\tif (valueHelpSearchQuery.status === \"fulfilled\" && valueHelpSearchQuery.value.length > 0) {\n\t\t// The key query did not return any matches, but the search query found results. Use the search results instead.\n\n\t\tlet results = valueHelpSearchQuery.value.map(mapResult);\n\n\t\tif (cleanedOperator === FilterOperator.EQ) {\n\t\t\tconst filteredResults = results.filter(\n\t\t\t\t(result) => result.description.toString().toLowerCase() === valueToMatch.toString().toLowerCase()\n\t\t\t);\n\t\t\t// If the search query is found once/multiple times in the result + operator is EQ, we need to return only those results\n\t\t\tif (filteredResults.length > 0) {\n\t\t\t\tresults = filteredResults;\n\t\t\t}\n\t\t}\n\n\t\treturn { operator, selectedValues: results };\n\t}\n\n\t// No matches were found in either query; the original value will be used as a fallback.\n\n\treturn {\n\t\toperator,\n\t\tselectedValues: [{ value: valueToMatch, description: valueToMatch }],\n\t\tnoMatch: true\n\t};\n}\n\n/**\n * Create a mapping function for mapping a value list query result to a code list.\n * @param valueList The value list information used to identify the key and description properties.\n * @param ensureDescription Whether to ensure that the description is always returned.\n * @returns A function that maps a single value list query result to a code list entry.\n */\nexport function mapValueListToCodeList(valueList: ValueListInfo, ensureDescription: true): (context: Context) => CodeListType;\nexport function mapValueListToCodeList(valueList: ValueListInfo, ensureDescription?: false): (context: Context) => CodeListEntry;\nexport function mapValueListToCodeList(\n\tvalueList: ValueListInfo,\n\tensureDescription = false\n): (context: Context) => CodeListEntry | CodeListType {\n\treturn (context: Context): CodeListEntry => {\n\t\tconst data = context.getObject();\n\t\tconst value = data[valueList.keyPath];\n\t\tconst description = valueList.descriptionPath ? data[valueList.descriptionPath] : undefined;\n\t\treturn { value, description: ensureDescription ? description ?? value : description };\n\t};\n}\n\n/**\n * Generates the $select parameter for a value list query.\n * @param valueList The value list information.\n * @returns The $select parameter as a string.\n */\nexport function generateSelectParameter(valueList: ValueListInfo): string {\n\treturn [valueList.keyPath, valueList.descriptionPath].filter((path) => path && !path.includes(\"/\")).join(\",\");\n}\n\n/**\n * Resolves token-based filter values using a value list.\n * @param valueList The value list used for resolving values.\n * @param value The token-based filter values to resolve.\n * @param looseMatch Whether to perform a loose match on the values.\n * @returns A promise that resolves to an array of resolved filter values.\n */\nexport async function resolveTokenValue(\n\tvalueList: ValueListInfo,\n\tvalue: TokenSelectedValuesDefinition,\n\tlooseMatch = false\n): Promise<ValueHelpSelectedValuesDefinition[]> {\n\tconst { operator, selectedValues } = value;\n\tconst model = valueList.valueListInfo.$model;\n\n\t// Make sure all values are resolved, even if some requests fail. It can happen that the backend cannot process the $filter queries we\n\t// run on the value list, but we still want to get the fallback $search results.\n\tmodel.setContinueOnError(\"$auto\");\n\n\tconst valueListMetamodel = convertTypes(model.getMetaModel());\n\tconst keyProperty = valueListMetamodel.resolvePath(`/${valueList.valueListInfo.CollectionPath}/${valueList.keyPath}`)?.target;\n\n\tif (!isProperty(keyProperty)) {\n\t\t// something went wrong - the key property is not a property of the value list entity\n\t\treturn unresolvedResult([value]);\n\t}\n\n\t// For comparison operators (GreaterThan, LessThan, Between, etc.), skip backend calls\n\t// and return user input directly to EasyFilter\n\tif (isComparisonOperator(operator)) {\n\t\tif (operator === FilterOperator.BT || operator === FilterOperator.NB) {\n\t\t\t// Handle Between/Not Between operators - they expect exactly 2 values\n\t\t\tconst [lowerBound, upperBound] = selectedValues;\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\toperator,\n\t\t\t\t\tselectedValues: [\n\t\t\t\t\t\t{ value: lowerBound, description: lowerBound },\n\t\t\t\t\t\t{ value: upperBound, description: upperBound }\n\t\t\t\t\t] as ValueHelpBetweenSelectedValues\n\t\t\t\t}\n\t\t\t];\n\t\t} else {\n\t\t\t// Handle other comparison operators (GT, GE, LT, LE)\n\t\t\treturn unresolvedResult([value]);\n\t\t}\n\t} else {\n\t\tconst resolvedValues = await Promise.all(\n\t\t\tselectedValues.map(async (selectedValue) =>\n\t\t\t\tresolveValueUsingValueList(valueList, keyProperty, operator as ScalarOperator, selectedValue, looseMatch)\n\t\t\t)\n\t\t);\n\t\treturn resolvedValues.flat();\n\t}\n}\n\n/**\n * Returns the unresolved values in the format expected by the Easy Filter Bar.\n * @param values The values to be resolved.\n * @returns An array of unresolved values.\n */\nexport function unresolvedResult(values: TokenSelectedValuesDefinition[]): ValueHelpSelectedValuesDefinition[] {\n\treturn values.map(({ operator, selectedValues }) => ({\n\t\toperator,\n\t\tselectedValues: selectedValues.map((value) => ({ value, description: value }))\n\t})) as ValueHelpSelectedValuesDefinition[];\n}\n\n/**\n * Checks if the operator is a negation operator (NE, NotContains, NotStartsWith, NotEndsWith).\n * @param operator The filter operator to check.\n * @returns True if the operator is a negation operator.\n */\nfunction isNegationOperator(operator: FilterOperator): boolean {\n\treturn [FilterOperator.NE, FilterOperator.NotContains, FilterOperator.NotStartsWith, FilterOperator.NotEndsWith].includes(operator);\n}\n\n/**\n * Checks if the operator is a comparison operator (GT, GE, LT, LE, BT, NB).\n * @param operator The filter operator to check.\n * @returns True if the operator is a comparison operator.\n */\nfunction isComparisonOperator(operator: FilterOperator): boolean {\n\treturn [FilterOperator.GT, FilterOperator.GE, FilterOperator.LT, FilterOperator.LE, FilterOperator.BT, FilterOperator.NB].includes(\n\t\toperator\n\t);\n}\n\n/**\n * Converts a negation operator to its positive equivalent (NE -> EQ, NotContains -> Contains, etc.).\n * @param negationOperator The negation operator to convert.\n * @returns The corresponding positive operator.\n */\nexport function getPositiveOperator(negationOperator: FilterOperator): ScalarOperator {\n\tswitch (negationOperator) {\n\t\tcase FilterOperator.NE:\n\t\t\treturn FilterOperator.EQ;\n\t\tcase FilterOperator.NotContains:\n\t\t\treturn FilterOperator.Contains;\n\t\tcase FilterOperator.NotStartsWith:\n\t\t\treturn FilterOperator.StartsWith;\n\t\tcase FilterOperator.NotEndsWith:\n\t\t\treturn FilterOperator.EndsWith;\n\t\tdefault:\n\t\t\treturn FilterOperator.EQ;\n\t}\n}\n"],"mappings":"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","ignoreList":[]}