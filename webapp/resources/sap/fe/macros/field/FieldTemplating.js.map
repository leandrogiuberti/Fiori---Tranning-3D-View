{"version":3,"file":"FieldTemplating.js","names":["addTextArrangementToBindingExpression","bindingExpressionToEnhance","fullContextPath","transformRecursively","expression","outExpression","modelName","undefined","oPropertyDataModelPath","enhanceDataModelPath","path","CommonFormatters","getBindingWithTextArrangement","_exports","formatValueRecursively","targetObject","formatWithTypeInformation","getTextBindingExpression","oPropertyDataModelObjectPath","fieldFormatOptions","getTextBinding","inputDataModelPath","asObject","arguments","length","customFormatter","isAnnotationOfType","fieldValue","getExpressionFromAnnotation","Value","compileExpression","isPathAnnotationExpression","$target","oPropertyBindingExpression","pathInModel","getContextRelativeTargetObjectPath","oTargetBinding","propertyDataModelObjectPath","oTargetProperty","annotations","UI","InputMask","type","formatOptions","mask","Mask","toString","placeholderSymbol","PlaceholderSymbol","maskRule","_getMaskingRules","Rules","Common","Masked","valueOf","editStyle","Measures","Unit","ISOCurrency","UIFormatters","getBindingWithUnitOrCurrency","showOnlyUnitDecimals","preserveDecimalsForCurrency","measureDisplayMode","isComplexTypeExpression","showMeasure","Timezone","getBindingWithTimezone","IsTimezone","getBindingForTimezone","DateTimeStyle","dateTimePattern","dateTimeStyle","getBindingForDateFormat","getValueBinding","ignoreUnit","ignoreFormatting","bindingParameters","targetTypeAny","keepUnit","decimalPadding","forDisplay","oNavPath","targetEntityType","resolvePath","target","visitedObjects","forEach","oNavObj","isNavigationProperty","navigationProperties","push","isProperty","oBindingExpression","isPathInModelExpression","Communication","IsEmailAddress","style","targetFormatOptions","String","isCurrencyOrUnitAligned","ExternalID","constraints","parameters","targetType","$Type","getAssociatedTextBinding","textPropertyPath","PropertyHelper","getAssociatedTextPropertyPath","oTextPropertyPath","allowPatch","valueListOutParameters","ValueList","Parameters","map","parameter","LocalDataProperty","fullyQualifiedName","includes","$$noPatch","isUsedInNavigationWithQuickViewFacets","oDataModelPath","oProperty","aNavigationProperties","aSemanticObjects","SemanticKey","bIsUsedInNavigationWithQuickViewFacets","oNavProp","referentialConstraint","oRefConstraint","sourceProperty","name","QuickViewFacets","contextLocation","targetEntitySet","aIsTargetSemanticKey","some","oSemantic","isKey","isRetrieveTextFromValueListEnabled","oPropertyPath","Text","hasValueHelp","textAlignMode","getTextAlignment","dataFieldModelPath","computedEditMode","considerTextAnnotation","typeForAlignment","Target","displayMode","textAnnotation","textArrangementAnnotation","TextArrangement","FieldHelper","getPropertyAlignment","getVisibleExpression","generateVisibleExpression","visibleExpressionsForConnectedFieldsFormElement","dataFieldForAnnotation","visibleExpression","dataFieldsBindingExpressions","connectedFields","Object","values","Data","filter","connectedField","hasOwnProperty","dataField","bindingExpressionObject","or","getQuickViewBinding","getQuickViewType","dataFieldDataModelObjectPath","Url","IsPhoneNumber","getSemanticObjects","aSemObjExprToResolve","sCustomDataKey","sCustomDataValue","aSemObjCustomData","item","key","value","oSemanticObjectsModel","JSONModel","$$valueAsPromise","createBindingContext","getMultipleLinesForDataField","oThis","isMultiLineText","wrap","_hasValueHelpToShow","oPropertyUnit","getAssociatedUnitProperty","oPropertyCurrency","getAssociatedCurrencyProperty","getMinMaxDateExpression","dateAnnotation","relativeLocation","fixedDate","Validation","$Date","dateProperty","formatResult","constant","valueFormatters","provideDateInstance","BindingToolkit","setEditStyleProperties","oProps","oDataField","onlyEditStyle","Maximum","Minimum","propertyBindingExpression","valueBindingExpression","getBindingForDatePicker","editStylePlaceholder","Placeholder","dataPointAnnotation","isDataFieldForAnnotation","Visualization","QuickInfo","ratingIndicatorTooltip","ratingIndicatorTargetValue","TargetValue","hasStaticPercentUnit","textBindingExpression","dataModelPathExternalID","isJSONModelUsedForValue","test","description","getRelativePaths","maxDateExpression","minDateExpression","showTimezone","MultiLineText","staticDescription","maskingRules","symbol","regex","maskingRule","MaskSymbol","RegExp","hasSemanticObjectInNavigationOrProperty","property","SemanticObjectHelper","hasSemanticObject","lastNavProp","find","contextNavProp","getDataModelObjectPathForValue","initialDataModelObjectPath","valuePath","isAnnotationOfTerm","indexOf","replace","hasPropertyInsertRestrictions","nonInsertableProperties","getContextPropertyRestriction","capabilities","InsertRestrictions","NonInsertableProperties","nonInsertableProperty","getDraftIndicatorVisibleBinding","draftIndicatorKey","getAvatarShape","IsImageURL","IsNaturalPerson","IsImage","entityAnnotationTarget","avatarShapeExpression","ifElse","AvatarShape","Circle","Square"],"sources":["./FieldTemplating.ts"],"sourcesContent":["import type {\n\tNavigationProperty,\n\tPathAnnotationExpression,\n\tProperty,\n\tPropertyAnnotationValue,\n\tServiceObjectAndAnnotation\n} from \"@sap-ux/vocabularies-types\";\nimport type { EntitySetAnnotations_Capabilities } from \"@sap-ux/vocabularies-types/vocabularies/Capabilities_Edm\";\nimport type {\n\tValueListParameterInOut,\n\tValueListParameterOutTypes,\n\tValueListParameterTypes\n} from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport type { PropertyAnnotations } from \"@sap-ux/vocabularies-types/vocabularies/Edm_Types\";\nimport type {\n\tDataField,\n\tDataFieldAbstractTypes,\n\tDataFieldTypes,\n\tDataFieldWithAction,\n\tDataFieldWithIntentBasedNavigation,\n\tDataFieldWithNavigationPath,\n\tDataFieldWithUrl,\n\tDataPointType,\n\tDataPointTypeTypes,\n\tInputMaskRuleTypeTypes\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTerms, UIAnnotationTypes, type DataFieldForAnnotation } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type {\n\tBindingToolkitExpression,\n\tCompiledBindingToolkitExpression,\n\tExpressionOrPrimitive,\n\tFormatOptions,\n\tPathInModelExpression,\n\tPrimitiveType\n} from \"sap/fe/base/BindingToolkit\";\nimport * as BindingToolkit from \"sap/fe/base/BindingToolkit\";\nimport {\n\tcompileExpression,\n\tconstant,\n\tformatResult,\n\tformatWithTypeInformation,\n\tgetExpressionFromAnnotation,\n\tifElse,\n\tisComplexTypeExpression,\n\tisPathInModelExpression,\n\tor,\n\tpathInModel,\n\ttransformRecursively\n} from \"sap/fe/base/BindingToolkit\";\nimport type { PageContextPathTarget } from \"sap/fe/core/converters/TemplateConverter\";\nimport { isDataFieldForAnnotation } from \"sap/fe/core/converters/annotations/DataField\";\nimport valueFormatters from \"sap/fe/core/formatters/ValueFormatter\";\nimport {\n\tisAnnotationOfTerm,\n\tisAnnotationOfType,\n\tisNavigationProperty,\n\tisPathAnnotationExpression,\n\tisProperty\n} from \"sap/fe/core/helpers/TypeGuards\";\nimport * as CommonFormatters from \"sap/fe/core/templating/CommonFormatters\";\nimport { generateVisibleExpression } from \"sap/fe/core/templating/DataFieldFormatters\";\nimport type { DataModelObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport {\n\tenhanceDataModelPath,\n\tgetContextPropertyRestriction,\n\tgetContextRelativeTargetObjectPath,\n\tgetRelativePaths\n} from \"sap/fe/core/templating/DataModelPathHelper\";\nimport * as PropertyHelper from \"sap/fe/core/templating/PropertyHelper\";\nimport { hasStaticPercentUnit } from \"sap/fe/core/templating/PropertyHelper\";\nimport * as SemanticObjectHelper from \"sap/fe/core/templating/SemanticObjectHelper\";\nimport type { DisplayMode, PropertyOrPath } from \"sap/fe/core/templating/UIFormatters\";\nimport * as UIFormatters from \"sap/fe/core/templating/UIFormatters\";\nimport type { InputMaskRule } from \"sap/fe/core/type/InputMask\";\nimport type { FieldBlockProperties } from \"sap/fe/macros/internal/field/FieldStructureHelper\";\nimport AvatarShape from \"sap/m/AvatarShape\";\nimport type Context from \"sap/ui/model/Context\";\nimport JSONModel from \"sap/ui/model/json/JSONModel\";\nimport type FieldFormatOptions from \"./FieldFormatOptions\";\nimport FieldHelper from \"./FieldHelper\";\n\n/**\n * Recursively add the text arrangement to a binding expression.\n * @param bindingExpressionToEnhance The binding expression to be enhanced\n * @param fullContextPath The current context path we're on (to properly resolve the text arrangement properties)\n * @returns An updated expression containing the text arrangement binding.\n */\nexport const addTextArrangementToBindingExpression = function (\n\tbindingExpressionToEnhance: BindingToolkitExpression<PrimitiveType>,\n\tfullContextPath: DataModelObjectPath<PageContextPathTarget>\n): BindingToolkitExpression<PrimitiveType> {\n\treturn transformRecursively(bindingExpressionToEnhance, \"PathInModel\", (expression: PathInModelExpression<PrimitiveType>) => {\n\t\tlet outExpression: BindingToolkitExpression<PrimitiveType> = expression;\n\t\tif (expression.modelName === undefined) {\n\t\t\t// In case of default model we then need to resolve the text arrangement property\n\t\t\tconst oPropertyDataModelPath = enhanceDataModelPath<Property>(fullContextPath, expression.path);\n\t\t\toutExpression = CommonFormatters.getBindingWithTextArrangement(oPropertyDataModelPath, expression);\n\t\t}\n\t\treturn outExpression;\n\t});\n};\n\nexport const formatValueRecursively = function (\n\tbindingExpressionToEnhance: BindingToolkitExpression<unknown>,\n\tfullContextPath: DataModelObjectPath<unknown>\n): BindingToolkitExpression<unknown> {\n\treturn transformRecursively(bindingExpressionToEnhance, \"PathInModel\", (expression: PathInModelExpression<unknown>) => {\n\t\tlet outExpression: BindingToolkitExpression<unknown> = expression;\n\t\tif (expression.modelName === undefined) {\n\t\t\t// In case of default model we then need to resolve the text arrangement property\n\t\t\tconst oPropertyDataModelPath = enhanceDataModelPath<Property>(fullContextPath, expression.path);\n\t\t\tif (oPropertyDataModelPath.targetObject) {\n\t\t\t\toutExpression = formatWithTypeInformation(oPropertyDataModelPath.targetObject, expression);\n\t\t\t}\n\t\t}\n\t\treturn outExpression;\n\t});\n};\n\nexport const getTextBindingExpression = function (\n\toPropertyDataModelObjectPath: DataModelObjectPath<Property>,\n\tfieldFormatOptions: Partial<FieldFormatOptions>\n): BindingToolkitExpression<string> {\n\treturn getTextBinding(oPropertyDataModelObjectPath, fieldFormatOptions, true) as BindingToolkitExpression<string>;\n};\n\nexport const getTextBinding = function (\n\tinputDataModelPath: DataModelObjectPath<DataFieldAbstractTypes | DataPointTypeTypes | Property>,\n\tfieldFormatOptions: Partial<FieldFormatOptions>,\n\tasObject = false,\n\tcustomFormatter?: string\n): BindingToolkitExpression<string> | CompiledBindingToolkitExpression {\n\tif (\n\t\tisAnnotationOfType<\n\t\t\t| DataField\n\t\t\t| DataPointType\n\t\t\t| DataFieldWithNavigationPath\n\t\t\t| DataFieldWithUrl\n\t\t\t| DataFieldWithIntentBasedNavigation\n\t\t\t| DataFieldWithAction\n\t\t>(inputDataModelPath.targetObject, [\n\t\t\tUIAnnotationTypes.DataField,\n\t\t\tUIAnnotationTypes.DataPointType,\n\t\t\tUIAnnotationTypes.DataFieldWithNavigationPath,\n\t\t\tUIAnnotationTypes.DataFieldWithUrl,\n\t\t\tUIAnnotationTypes.DataFieldWithIntentBasedNavigation,\n\t\t\tUIAnnotationTypes.DataFieldWithAction\n\t\t])\n\t) {\n\t\t// If there is no resolved property, the value is returned as a constant\n\t\tconst fieldValue = getExpressionFromAnnotation(inputDataModelPath.targetObject.Value) ?? \"\";\n\t\treturn compileExpression(fieldValue);\n\t}\n\tif (isPathAnnotationExpression(inputDataModelPath.targetObject) && inputDataModelPath.targetObject.$target) {\n\t\tinputDataModelPath = enhanceDataModelPath<Property>(inputDataModelPath, inputDataModelPath.targetObject.path);\n\t}\n\t// When targetObject is a constant value\n\tif (typeof inputDataModelPath.targetObject === \"string\") {\n\t\treturn inputDataModelPath.targetObject;\n\t}\n\tconst oPropertyBindingExpression = pathInModel(getContextRelativeTargetObjectPath(inputDataModelPath));\n\tlet oTargetBinding;\n\tconst propertyDataModelObjectPath = inputDataModelPath as DataModelObjectPath<Property>; // At this point we should only have a property\n\tconst oTargetProperty = propertyDataModelObjectPath.targetObject;\n\t// formatting\n\n\tif (oTargetProperty?.annotations?.UI?.InputMask) {\n\t\toTargetBinding = formatWithTypeInformation(oTargetProperty, oPropertyBindingExpression);\n\t\toTargetBinding.type = \"sap.fe.core.type.InputMask\";\n\t\toTargetBinding.formatOptions = {\n\t\t\tmask: oTargetProperty.annotations?.UI?.InputMask?.Mask.toString(),\n\t\t\tplaceholderSymbol: oTargetProperty.annotations?.UI?.InputMask?.PlaceholderSymbol.toString(),\n\t\t\tmaskRule: _getMaskingRules(oTargetProperty.annotations?.UI?.InputMask?.Rules)\n\t\t} as unknown as FormatOptions;\n\t} else if (oTargetProperty?.annotations?.Common?.Masked?.valueOf()) {\n\t\toTargetBinding = formatWithTypeInformation(oTargetProperty, oPropertyBindingExpression);\n\t\toTargetBinding.formatOptions = {\n\t\t\teditStyle: \"Masked\"\n\t\t} as unknown as FormatOptions;\n\t} else if (oTargetProperty?.annotations?.Measures?.Unit || oTargetProperty?.annotations?.Measures?.ISOCurrency) {\n\t\toTargetBinding = UIFormatters.getBindingWithUnitOrCurrency(\n\t\t\tpropertyDataModelObjectPath,\n\t\t\toPropertyBindingExpression,\n\t\t\tundefined,\n\t\t\t{},\n\t\t\ttrue,\n\t\t\tfieldFormatOptions.showOnlyUnitDecimals,\n\t\t\tfieldFormatOptions.preserveDecimalsForCurrency\n\t\t);\n\t\tif (fieldFormatOptions?.measureDisplayMode === \"Hidden\" && isComplexTypeExpression(oTargetBinding)) {\n\t\t\t// TODO: Refactor once types are less generic here\n\t\t\toTargetBinding.formatOptions = {\n\t\t\t\t...oTargetBinding.formatOptions,\n\t\t\t\tshowMeasure: false\n\t\t\t};\n\t\t}\n\t} else if (oTargetProperty?.annotations?.Common?.Timezone && oTargetProperty.type == \"Edm.DateTimeOffset\") {\n\t\toTargetBinding = UIFormatters.getBindingWithTimezone(\n\t\t\tpropertyDataModelObjectPath,\n\t\t\toPropertyBindingExpression,\n\t\t\tfalse,\n\t\t\ttrue,\n\t\t\tfieldFormatOptions as FieldFormatOptions\n\t\t);\n\t} else if (oTargetProperty?.annotations?.Common?.IsTimezone) {\n\t\toTargetBinding = UIFormatters.getBindingForTimezone(propertyDataModelObjectPath, oPropertyBindingExpression);\n\t} else if (\n\t\toTargetProperty?.annotations?.UI?.DateTimeStyle ||\n\t\tfieldFormatOptions?.dateTimePattern ||\n\t\tfieldFormatOptions?.dateTimeStyle\n\t) {\n\t\toTargetBinding = UIFormatters.getBindingForDateFormat(propertyDataModelObjectPath, oPropertyBindingExpression, fieldFormatOptions);\n\t} else {\n\t\toTargetBinding = CommonFormatters.getBindingWithTextArrangement(\n\t\t\tpropertyDataModelObjectPath,\n\t\t\toPropertyBindingExpression,\n\t\t\tfieldFormatOptions,\n\t\t\tcustomFormatter\n\t\t);\n\t}\n\n\tif (asObject) {\n\t\treturn oTargetBinding;\n\t}\n\t// We don't include $$nopatch and parseKeepEmptyString as they make no sense in the text binding case\n\treturn compileExpression(oTargetBinding);\n};\n\nexport const getValueBinding = function (\n\toPropertyDataModelObjectPath: DataModelObjectPath<Property | DataFieldTypes>,\n\tfieldFormatOptions: Partial<FieldFormatOptions>,\n\tignoreUnit = false,\n\tignoreFormatting = false,\n\tbindingParameters?: object,\n\ttargetTypeAny = false,\n\tkeepUnit = false,\n\tdecimalPadding?: number,\n\tforDisplay = false,\n\tasObject = false\n): CompiledBindingToolkitExpression {\n\tif (isPathAnnotationExpression(oPropertyDataModelObjectPath.targetObject) && oPropertyDataModelObjectPath.targetObject.$target) {\n\t\tconst oNavPath = oPropertyDataModelObjectPath.targetEntityType.resolvePath(oPropertyDataModelObjectPath.targetObject.path, true);\n\t\toPropertyDataModelObjectPath.targetObject = oNavPath.target;\n\t\toNavPath.visitedObjects.forEach((oNavObj: ServiceObjectAndAnnotation) => {\n\t\t\tif (isNavigationProperty(oNavObj)) {\n\t\t\t\toPropertyDataModelObjectPath.navigationProperties.push(oNavObj);\n\t\t\t}\n\t\t});\n\t}\n\n\tconst targetObject = oPropertyDataModelObjectPath.targetObject;\n\tif (isProperty(targetObject)) {\n\t\tlet oBindingExpression: BindingToolkitExpression<unknown> = pathInModel(\n\t\t\tgetContextRelativeTargetObjectPath(oPropertyDataModelObjectPath)\n\t\t);\n\t\tif (isPathInModelExpression(oBindingExpression)) {\n\t\t\tif (targetObject.annotations?.Communication?.IsEmailAddress) {\n\t\t\t\toBindingExpression = formatWithTypeInformation(targetObject, oBindingExpression);\n\t\t\t\toBindingExpression.type = \"sap.fe.core.type.Email\";\n\t\t\t} else if (targetObject.annotations?.UI?.InputMask) {\n\t\t\t\toBindingExpression = formatWithTypeInformation(targetObject, oBindingExpression);\n\t\t\t\toBindingExpression.type = \"sap.fe.core.type.InputMask\";\n\t\t\t\toBindingExpression.formatOptions = {\n\t\t\t\t\t...oBindingExpression.formatOptions,\n\t\t\t\t\tmask: targetObject.annotations.UI.InputMask.Mask,\n\t\t\t\t\tplaceholderSymbol: targetObject.annotations.UI.InputMask.PlaceholderSymbol,\n\t\t\t\t\tmaskRule: _getMaskingRules(targetObject.annotations.UI.InputMask.Rules)\n\t\t\t\t} as FormatOptions;\n\t\t\t} else if (targetObject.annotations?.Common?.Masked?.valueOf()) {\n\t\t\t\toBindingExpression = formatWithTypeInformation(targetObject, oBindingExpression);\n\t\t\t\toBindingExpression.formatOptions = {\n\t\t\t\t\t...oBindingExpression.formatOptions,\n\t\t\t\t\tstyle: \"password\"\n\t\t\t\t} as FormatOptions;\n\t\t\t} else if (!ignoreUnit && (targetObject.annotations?.Measures?.ISOCurrency || targetObject.annotations?.Measures?.Unit)) {\n\t\t\t\tconst targetFormatOptions: {\n\t\t\t\t\tshowMeasure?: boolean;\n\t\t\t\t\tdecimalPadding?: number;\n\t\t\t\t} = {};\n\t\t\t\tif (!keepUnit) {\n\t\t\t\t\ttargetFormatOptions[\"showMeasure\"] = false;\n\t\t\t\t}\n\t\t\t\tif (String(fieldFormatOptions.isCurrencyOrUnitAligned) === \"true\") {\n\t\t\t\t\ttargetFormatOptions[\"decimalPadding\"] = decimalPadding;\n\t\t\t\t}\n\t\t\t\toBindingExpression = UIFormatters.getBindingWithUnitOrCurrency(\n\t\t\t\t\toPropertyDataModelObjectPath as DataModelObjectPath<Property>,\n\t\t\t\t\toBindingExpression,\n\t\t\t\t\ttrue,\n\t\t\t\t\tkeepUnit ? undefined : targetFormatOptions,\n\t\t\t\t\tforDisplay,\n\t\t\t\t\tfieldFormatOptions.showOnlyUnitDecimals,\n\t\t\t\t\tfieldFormatOptions.preserveDecimalsForCurrency\n\t\t\t\t);\n\t\t\t} else if (targetObject?.annotations?.Common?.IsTimezone) {\n\t\t\t\toBindingExpression = UIFormatters.getBindingForTimezone(\n\t\t\t\t\toPropertyDataModelObjectPath as DataModelObjectPath<Property>,\n\t\t\t\t\toBindingExpression\n\t\t\t\t);\n\t\t\t} else if (\n\t\t\t\ttargetObject?.annotations?.UI?.DateTimeStyle ||\n\t\t\t\tfieldFormatOptions?.dateTimePattern ||\n\t\t\t\tfieldFormatOptions?.dateTimeStyle\n\t\t\t) {\n\t\t\t\toBindingExpression = UIFormatters.getBindingForDateFormat(\n\t\t\t\t\toPropertyDataModelObjectPath as DataModelObjectPath<Property>,\n\t\t\t\t\toBindingExpression,\n\t\t\t\t\tfieldFormatOptions\n\t\t\t\t);\n\t\t\t} else if (targetObject?.annotations?.Common?.Timezone && targetObject.type === \"Edm.DateTimeOffset\") {\n\t\t\t\toBindingExpression = UIFormatters.getBindingWithTimezone(\n\t\t\t\t\toPropertyDataModelObjectPath as DataModelObjectPath<Property>,\n\t\t\t\t\toBindingExpression,\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\toBindingExpression = formatWithTypeInformation(targetObject, oBindingExpression);\n\t\t\t\tif (targetObject.annotations.Common?.ExternalID) {\n\t\t\t\t\t(oBindingExpression as { path: string }).path += \"@$ui5.fe.@Common/ExternalID\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isPathInModelExpression(oBindingExpression)) {\n\t\t\t\tif (ignoreFormatting) {\n\t\t\t\t\tdelete oBindingExpression.formatOptions;\n\t\t\t\t\tdelete oBindingExpression.constraints;\n\t\t\t\t\tdelete oBindingExpression.type;\n\t\t\t\t}\n\t\t\t\tif (bindingParameters) {\n\t\t\t\t\toBindingExpression.parameters = bindingParameters;\n\t\t\t\t}\n\t\t\t\tif (targetTypeAny) {\n\t\t\t\t\toBindingExpression.targetType = \"any\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (asObject) {\n\t\t\t\treturn oBindingExpression as unknown as CompiledBindingToolkitExpression;\n\t\t\t}\n\t\t\treturn compileExpression(oBindingExpression);\n\t\t} else {\n\t\t\t// if somehow we could not compile the binding -> return empty string\n\t\t\treturn \"\";\n\t\t}\n\t} else if (\n\t\ttargetObject?.$Type === UIAnnotationTypes.DataFieldWithUrl ||\n\t\ttargetObject?.$Type === UIAnnotationTypes.DataFieldWithNavigationPath\n\t) {\n\t\treturn compileExpression(getExpressionFromAnnotation((targetObject as DataFieldWithUrl).Value));\n\t} else {\n\t\treturn \"\";\n\t}\n};\n\nexport const getAssociatedTextBinding = function (\n\toPropertyDataModelObjectPath: DataModelObjectPath<Property>,\n\tfieldFormatOptions: Partial<FieldFormatOptions>\n): CompiledBindingToolkitExpression {\n\tconst textPropertyPath = PropertyHelper.getAssociatedTextPropertyPath(oPropertyDataModelObjectPath.targetObject);\n\tif (textPropertyPath) {\n\t\tconst oTextPropertyPath = enhanceDataModelPath<Property>(oPropertyDataModelObjectPath, textPropertyPath);\n\t\t//BCP 2380120806: getValueBinding needs to be able to set formatOptions.parseKeepsEmptyString.\n\t\t//Otherwise emptying an input field that has a text annotation to a not nullable string would result in\n\t\t//an error message. Therefore import param 'ignoreFormatting' is now set to false.\n\t\tlet allowPatch = false;\n\t\tconst valueListOutParameters: string[] =\n\t\t\toPropertyDataModelObjectPath.targetObject?.annotations?.Common?.ValueList?.Parameters.map(\n\t\t\t\t(parameter: ValueListParameterTypes) => {\n\t\t\t\t\tif (!parameter) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\t\t\t\t\treturn (\n\t\t\t\t\t\t(parameter as ValueListParameterInOut | ValueListParameterOutTypes)?.LocalDataProperty?.$target\n\t\t\t\t\t\t\t?.fullyQualifiedName ?? \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t) || [];\n\t\tif (\n\t\t\toTextPropertyPath?.targetObject?.fullyQualifiedName &&\n\t\t\tvalueListOutParameters.includes(oTextPropertyPath.targetObject.fullyQualifiedName)\n\t\t) {\n\t\t\tallowPatch = true;\n\t\t}\n\t\tconst bindingParameters = allowPatch ? undefined : { $$noPatch: true };\n\t\treturn getValueBinding(oTextPropertyPath, fieldFormatOptions, true, false, bindingParameters, false, false, undefined, true);\n\t}\n\treturn undefined;\n};\n\nexport const isUsedInNavigationWithQuickViewFacets = function (oDataModelPath: DataModelObjectPath<unknown>, oProperty: Property): boolean {\n\tconst aNavigationProperties = oDataModelPath?.targetEntityType?.navigationProperties || [];\n\tconst aSemanticObjects = oDataModelPath?.targetEntityType?.annotations?.Common?.SemanticKey || [];\n\tlet bIsUsedInNavigationWithQuickViewFacets = false;\n\taNavigationProperties.forEach((oNavProp: NavigationProperty) => {\n\t\tif (oNavProp.referentialConstraint && oNavProp.referentialConstraint.length) {\n\t\t\toNavProp.referentialConstraint.forEach((oRefConstraint) => {\n\t\t\t\tif (oRefConstraint?.sourceProperty === oProperty.name) {\n\t\t\t\t\tif (oNavProp?.targetType?.annotations?.UI?.QuickViewFacets) {\n\t\t\t\t\t\tbIsUsedInNavigationWithQuickViewFacets = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\tif (oDataModelPath.contextLocation?.targetEntitySet !== oDataModelPath.targetEntitySet) {\n\t\tconst aIsTargetSemanticKey = aSemanticObjects.some(function (oSemantic) {\n\t\t\treturn oSemantic?.$target?.name === oProperty.name;\n\t\t});\n\t\tif ((aIsTargetSemanticKey || oProperty.isKey) && oDataModelPath?.targetEntityType?.annotations?.UI?.QuickViewFacets) {\n\t\t\tbIsUsedInNavigationWithQuickViewFacets = true;\n\t\t}\n\t}\n\treturn bIsUsedInNavigationWithQuickViewFacets;\n};\n\nexport const isRetrieveTextFromValueListEnabled = function (\n\toPropertyPath: PropertyOrPath<Property>,\n\tfieldFormatOptions: { displayMode?: DisplayMode; textAlignMode?: string }\n): boolean {\n\tconst oProperty: Property = (isPathAnnotationExpression(oPropertyPath) && oPropertyPath.$target) || (oPropertyPath as Property);\n\tif (\n\t\t!oProperty.annotations?.Common?.Text &&\n\t\t!oProperty.annotations?.Measures &&\n\t\tPropertyHelper.hasValueHelp(oProperty) &&\n\t\tfieldFormatOptions.textAlignMode === \"Form\"\n\t) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\n/**\n * Calculates text alignment based on the dataModelObjectPath.\n * @param dataFieldModelPath The property's type\n * @param formatOptions The field format options\n * @param formatOptions.displayMode Display format\n * @param formatOptions.textAlignMode Text alignment of the field\n * @param computedEditMode The editMode used in this case\n * @param considerTextAnnotation Whether to consider the text annotation when computing the alignment\n * @returns The property alignment\n */\nexport const getTextAlignment = function (\n\tdataFieldModelPath: DataModelObjectPath<DataFieldAbstractTypes>,\n\tformatOptions: { displayMode?: string; textAlignMode?: string },\n\tcomputedEditMode: BindingToolkitExpression<string>,\n\tconsiderTextAnnotation = false\n): CompiledBindingToolkitExpression {\n\t// check for the target value type directly, or in case it is pointing to a DataPoint we look at the dataPoint's value\n\tlet typeForAlignment =\n\t\t(dataFieldModelPath.targetObject as DataFieldTypes)?.Value?.$target.type ||\n\t\t((dataFieldModelPath.targetObject as DataFieldForAnnotation)?.Target?.$target as DataPointType)?.Value.$target.type;\n\n\tif (\n\t\tPropertyHelper.isKey(\n\t\t\t(dataFieldModelPath.targetObject as DataFieldTypes)?.Value?.$target ||\n\t\t\t\t((dataFieldModelPath.targetObject as DataFieldForAnnotation)?.Target?.$target as DataPointType)?.Value?.$target\n\t\t)\n\t) {\n\t\treturn \"Begin\";\n\t}\n\tif (\n\t\tconsiderTextAnnotation &&\n\t\tformatOptions.displayMode &&\n\t\t[\"Description\", \"DescriptionValue\", \"ValueDescription\"].includes(formatOptions.displayMode)\n\t) {\n\t\tconst textAnnotation = (dataFieldModelPath.targetObject as DataFieldTypes)?.Value?.$target.annotations?.Common?.Text;\n\t\tconst textArrangementAnnotation = textAnnotation?.annotations?.UI?.TextArrangement.valueOf();\n\t\tif (textAnnotation && textArrangementAnnotation !== \"UI.TextArrangementType/TextSeparate\") {\n\t\t\ttypeForAlignment = textAnnotation.$target.type;\n\t\t}\n\t}\n\n\treturn FieldHelper.getPropertyAlignment(typeForAlignment, formatOptions, computedEditMode);\n};\n\n/**\n * Returns the binding expression to evaluate the visibility of a DataField or DataPoint annotation.\n *\n * SAP Fiori elements will evaluate either the UI.Hidden annotation defined on the annotation itself or on the target property.\n * @param dataFieldModelPath The metapath referring to the annotation we are evaluating.\n * @param [formatOptions] FormatOptions optional.\n * @param formatOptions.isAnalytics This flag is set when using an analytical table.\n * @returns An expression that you can bind to the UI.\n */\nexport const getVisibleExpression = function (\n\tdataFieldModelPath: DataModelObjectPath<DataFieldAbstractTypes | DataPointTypeTypes | Property>,\n\tformatOptions?: { isAnalytics?: boolean }\n): CompiledBindingToolkitExpression {\n\treturn compileExpression(generateVisibleExpression(dataFieldModelPath, formatOptions));\n};\n\n/**\n * Returns the Boolean or other expression for the visibility of a FormElement.\n * The FormElement is visible if at least one content is visible, otherwise invisible.\n * @param dataFieldModelPath The metapath referring to the annotation we are evaluating.\n * @returns A Boolean or other expression that can be bound to the UI.\n */\nexport const visibleExpressionsForConnectedFieldsFormElement = function (\n\tdataFieldModelPath: DataModelObjectPath<DataFieldAbstractTypes | DataPointTypeTypes | Property>\n): CompiledBindingToolkitExpression {\n\tconst dataFieldForAnnotation = dataFieldModelPath.targetObject as DataFieldAbstractTypes;\n\tconst visibleExpression = compileExpression(generateVisibleExpression(dataFieldModelPath));\n\n\tconst dataFieldsBindingExpressions: (boolean | BindingToolkitExpression<boolean>)[] = [];\n\tif (typeof visibleExpression === \"string\" && visibleExpression.includes(\"{=\")) {\n\t\treturn visibleExpression;\n\t}\n\tif (\n\t\tdataFieldForAnnotation.$Type === UIAnnotationTypes.DataFieldForAnnotation &&\n\t\tdataFieldForAnnotation.Target.$target?.$Type === UIAnnotationTypes.ConnectedFieldsType\n\t) {\n\t\tconst connectedFields = Object.values(dataFieldForAnnotation.Target.$target.Data).filter(\n\t\t\t(connectedField) => connectedField?.hasOwnProperty(\"Value\")\n\t\t) as DataFieldAbstractTypes[];\n\t\tconnectedFields.forEach((dataField) => {\n\t\t\tdataFieldModelPath.targetObject = dataField;\n\t\t\tconst bindingExpressionObject = generateVisibleExpression(dataFieldModelPath);\n\t\t\tif (bindingExpressionObject !== undefined) {\n\t\t\t\tdataFieldsBindingExpressions.push(bindingExpressionObject);\n\t\t\t}\n\t\t});\n\t\t/* Combine the expressions with or */\n\t\treturn dataFieldsBindingExpressions.length ? compileExpression(or(...dataFieldsBindingExpressions)) : visibleExpression;\n\t}\n\treturn visibleExpression;\n};\n\n/**\n * Returns the binding for a property in a QuickViewFacets.\n * @param propertyDataModelObjectPath The DataModelObjectPath of the property\n * @returns A string of the value, or a BindingExpression\n */\nexport const getQuickViewBinding = function (\n\tpropertyDataModelObjectPath: DataModelObjectPath<Property>\n): BindingToolkitExpression<string> | CompiledBindingToolkitExpression | string {\n\tif (!propertyDataModelObjectPath.targetObject) {\n\t\treturn \"\";\n\t}\n\tif (typeof propertyDataModelObjectPath.targetObject === \"string\") {\n\t\treturn propertyDataModelObjectPath.targetObject;\n\t}\n\n\treturn getTextBinding(propertyDataModelObjectPath, {} as FieldFormatOptions);\n};\n\n/**\n * Return the type of the QuickViewGroupElement.\n * @param dataFieldDataModelObjectPath The DataModelObjectPath of the DataField\n * @returns The type of the QuickViewGroupElement\n */\nexport const getQuickViewType = function (dataFieldDataModelObjectPath: DataModelObjectPath<DataFieldTypes | Property>): string {\n\tconst targetObject = dataFieldDataModelObjectPath.targetObject;\n\tif (isAnnotationOfType<DataFieldWithUrl>(targetObject, UIAnnotationTypes.DataFieldWithUrl) && targetObject?.Url) {\n\t\treturn \"link\";\n\t}\n\tif (\n\t\t(!isProperty(targetObject) && targetObject?.Value.$target?.annotations?.Communication?.IsEmailAddress) ||\n\t\t(isProperty(targetObject) && targetObject?.annotations?.Communication?.IsEmailAddress)\n\t) {\n\t\treturn \"email\";\n\t}\n\tif (\n\t\t(!isProperty(targetObject) && targetObject?.Value.$target?.annotations?.Communication?.IsPhoneNumber) ||\n\t\t(isProperty(targetObject) && targetObject?.annotations?.Communication?.IsPhoneNumber)\n\t) {\n\t\treturn \"phone\";\n\t}\n\treturn \"text\";\n};\n\nexport type SemanticObjectCustomData = {\n\tkey: string;\n\tvalue: string;\n};\n\nexport const getSemanticObjects = function (\n\taSemObjExprToResolve: { key: string; value: PropertyAnnotationValue<PrimitiveType> }[]\n): Context {\n\tif (aSemObjExprToResolve.length > 0) {\n\t\tlet sCustomDataKey = \"\";\n\t\tlet sCustomDataValue: CompiledBindingToolkitExpression = \"\";\n\t\tconst aSemObjCustomData: { key: string; value: CompiledBindingToolkitExpression }[] = [];\n\t\tfor (const item of aSemObjExprToResolve) {\n\t\t\tsCustomDataKey = item.key;\n\t\t\tsCustomDataValue = compileExpression(getExpressionFromAnnotation(item.value));\n\t\t\taSemObjCustomData.push({\n\t\t\t\tkey: sCustomDataKey,\n\t\t\t\tvalue: sCustomDataValue\n\t\t\t});\n\t\t}\n\t\tconst oSemanticObjectsModel = new JSONModel(aSemObjCustomData);\n\t\t(oSemanticObjectsModel as { $$valueAsPromise?: boolean }).$$valueAsPromise = true;\n\t\treturn oSemanticObjectsModel.createBindingContext(\"/\");\n\t} else {\n\t\treturn new JSONModel([]).createBindingContext(\"/\");\n\t}\n};\n\n/**\n * Method to get MultipleLines for a DataField.\n * @param {any} oThis The current object\n * @param {boolean} isMultiLineText The property isMultiLineText\n * @returns {CompiledBindingToolkitExpression<string>} The binding expression to determine if a data field should be a MultiLineText or not\n * @public\n */\n\nexport const getMultipleLinesForDataField = function (oThis: Partial<{ wrap?: boolean }>, isMultiLineText: boolean): boolean {\n\tif (oThis.wrap === false) {\n\t\treturn false;\n\t}\n\treturn isMultiLineText;\n};\n\nconst _hasValueHelpToShow = function (oProperty: Property, measureDisplayMode: string | undefined): boolean | undefined {\n\t// we show a value help if teh property has one or if its visible unit has one\n\tconst oPropertyUnit = PropertyHelper.getAssociatedUnitProperty(oProperty);\n\tconst oPropertyCurrency = PropertyHelper.getAssociatedCurrencyProperty(oProperty);\n\treturn (\n\t\t(PropertyHelper.hasValueHelp(oProperty) && oProperty.type !== \"Edm.Boolean\") ||\n\t\t(measureDisplayMode !== \"Hidden\" &&\n\t\t\t((oPropertyUnit && PropertyHelper.hasValueHelp(oPropertyUnit)) ||\n\t\t\t\t(oPropertyCurrency && PropertyHelper.hasValueHelp(oPropertyCurrency))))\n\t);\n};\n\n/**\n * Sets the minimum and maximum date for the date field.\n * @param dateAnnotation Property Annotations for the date field.\n * @param type Either 'Maximum' or 'Minimum'.\n * @param relativeLocation\n * @returns Mininum or Maximum date expression.\n */\nexport const getMinMaxDateExpression = function (\n\tdateAnnotation: PropertyAnnotations | undefined,\n\ttype: \"Maximum\" | \"Minimum\",\n\trelativeLocation: string[]\n): BindingToolkitExpression<unknown> | undefined {\n\tconst fixedDate = dateAnnotation?.Validation?.[type]?.$Date;\n\tconst dateProperty = dateAnnotation?.Validation?.[type];\n\tif (fixedDate) {\n\t\treturn formatResult([constant(fixedDate)], valueFormatters.provideDateInstance);\n\t} else if (dateProperty) {\n\t\treturn BindingToolkit.getExpressionFromAnnotation(dateAnnotation?.Validation?.[type], relativeLocation);\n\t}\n\treturn undefined;\n};\n\n/**\n * Sets Edit Style properties for Field in case of Macro Field and MassEditDialog fields.\n * @param oProps Field Properties for the Macro Field.\n * @param oDataField DataField Object.\n * @param oDataModelPath DataModel Object Path to the property.\n * @param onlyEditStyle To add only editStyle.\n */\nexport const setEditStyleProperties = function (\n\toProps: FieldBlockProperties,\n\toDataField: DataFieldAbstractTypes | DataPointTypeTypes,\n\toDataModelPath: DataModelObjectPath<Property | DataFieldTypes>,\n\tonlyEditStyle?: boolean\n): void {\n\tconst oProperty = oDataModelPath.targetObject;\n\tif (\n\t\t!isProperty(oProperty) ||\n\t\t[\n\t\t\tUIAnnotationTypes.DataFieldForAction,\n\t\t\tUIAnnotationTypes.DataFieldWithNavigationPath,\n\t\t\tUIAnnotationTypes.DataFieldForActionGroup,\n\t\t\tUIAnnotationTypes.DataFieldForIntentBasedNavigation\n\t\t].includes(oDataField.$Type)\n\t) {\n\t\toProps.editStyle = null;\n\t\treturn;\n\t}\n\tif (!onlyEditStyle) {\n\t\tif (oProperty?.annotations?.Validation?.Maximum?.$Date || oProperty?.annotations?.Validation?.Minimum?.$Date) {\n\t\t\tconst propertyBindingExpression = pathInModel(getContextRelativeTargetObjectPath(oDataModelPath));\n\t\t\toProps.valueBindingExpression = UIFormatters.getBindingForDatePicker(\n\t\t\t\toDataModelPath,\n\t\t\t\tpropertyBindingExpression\n\t\t\t) as CompiledBindingToolkitExpression;\n\t\t} else {\n\t\t\toProps.valueBindingExpression = oProps.value ? oProps.value : getValueBinding(oDataModelPath, oProps.formatOptions);\n\t\t}\n\n\t\tconst editStylePlaceholder =\n\t\t\t(oDataField as unknown as Property).annotations?.UI?.Placeholder ||\n\t\t\t(oDataField as DataField)?.Value?.$target?.annotations?.UI?.Placeholder;\n\n\t\tif (editStylePlaceholder) {\n\t\t\toProps.editStylePlaceholder = compileExpression(getExpressionFromAnnotation(editStylePlaceholder));\n\t\t}\n\t}\n\n\t// Setup RatingIndicator\n\tconst dataPointAnnotation = (isDataFieldForAnnotation(oDataField) ? oDataField.Target?.$target : oDataField) as DataPointType;\n\tif (dataPointAnnotation?.Visualization === \"UI.VisualizationType/Rating\") {\n\t\toProps.editStyle = \"RatingIndicator\";\n\n\t\tif (dataPointAnnotation.annotations?.Common?.QuickInfo) {\n\t\t\toProps.ratingIndicatorTooltip = compileExpression(\n\t\t\t\tgetExpressionFromAnnotation(dataPointAnnotation.annotations?.Common?.QuickInfo)\n\t\t\t);\n\t\t}\n\n\t\toProps.ratingIndicatorTargetValue = compileExpression(getExpressionFromAnnotation(dataPointAnnotation.TargetValue));\n\t\treturn;\n\t}\n\n\tif (\n\t\t_hasValueHelpToShow(oProperty, oProps.formatOptions?.measureDisplayMode) ||\n\t\t(oProps.formatOptions?.measureDisplayMode !== \"Hidden\" &&\n\t\t\t(oProperty.annotations?.Measures?.ISOCurrency || (oProperty.annotations?.Measures?.Unit && !hasStaticPercentUnit(oProperty))))\n\t) {\n\t\tif (!onlyEditStyle) {\n\t\t\t/* The textBindingExpression is used for mdcField-attribute 'additionalValue' and means the description of the value */\n\t\t\tconst textBindingExpression = oProperty.annotations?.Common?.ExternalID\n\t\t\t\t? getAssociatedTextBinding(oProps.dataModelPathExternalID as DataModelObjectPath<Property>, oProps.formatOptions)\n\t\t\t\t: getAssociatedTextBinding(oDataModelPath as DataModelObjectPath<Property>, oProps.formatOptions);\n\n\t\t\tconst isJSONModelUsedForValue = !!oProps.value && /{\\w+>.+}/.test(oProps.value);\n\n\t\t\tif (isJSONModelUsedForValue) {\n\t\t\t\tif (oProps.description) {\n\t\t\t\t\toProps.textBindingExpression = oProps.description;\n\t\t\t\t} else {\n\t\t\t\t\toProps.textBindingExpression = undefined;\n\t\t\t\t\toProps.formatOptions.displayMode = \"Value\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toProps.textBindingExpression = textBindingExpression;\n\t\t\t}\n\n\t\t\tif (oProps.formatOptions?.measureDisplayMode !== \"Hidden\") {\n\t\t\t\t// for the MDC Field we need to keep the unit inside the valueBindingExpression\n\t\t\t\toProps.valueBindingExpression = oProps.value\n\t\t\t\t\t? oProps.value\n\t\t\t\t\t: getValueBinding(oDataModelPath, oProps.formatOptions, false, false, undefined, false, true);\n\t\t\t}\n\t\t}\n\t\toProps.editStyle = \"InputWithValueHelp\";\n\t\treturn;\n\t}\n\n\tswitch (oProperty.type) {\n\t\tcase \"Edm.Date\":\n\t\t\toProps.editStyle = \"DatePicker\";\n\t\t\tconst relativeLocation = getRelativePaths(oDataModelPath);\n\t\t\tif (oProperty?.annotations?.Validation?.Maximum) {\n\t\t\t\toProps.maxDateExpression = getMinMaxDateExpression(oProperty?.annotations, \"Maximum\", relativeLocation);\n\t\t\t}\n\t\t\tif (oProperty?.annotations?.Validation?.Minimum) {\n\t\t\t\toProps.minDateExpression = getMinMaxDateExpression(oProperty?.annotations, \"Minimum\", relativeLocation);\n\t\t\t}\n\t\t\treturn;\n\t\tcase \"Edm.Time\":\n\t\tcase \"Edm.TimeOfDay\":\n\t\t\toProps.editStyle = \"TimePicker\";\n\t\t\treturn;\n\t\tcase \"Edm.DateTime\":\n\t\tcase \"Edm.DateTimeOffset\":\n\t\t\toProps.editStyle = \"DateTimePicker\";\n\t\t\t// No timezone defined. Also for compatibility reasons.\n\t\t\tif (!oProperty.annotations?.Common?.Timezone) {\n\t\t\t\toProps.showTimezone = undefined;\n\t\t\t} else {\n\t\t\t\toProps.showTimezone = true;\n\t\t\t}\n\t\t\treturn;\n\t\tcase \"Edm.Boolean\":\n\t\t\toProps.editStyle = \"CheckBox\";\n\t\t\treturn;\n\t\tcase \"Edm.Stream\":\n\t\t\toProps.editStyle = \"File\";\n\t\t\treturn;\n\t\tcase \"Edm.String\":\n\t\t\tif (oProperty.annotations?.UI?.MultiLineText?.valueOf()) {\n\t\t\t\toProps.editStyle = \"TextArea\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (oProperty.annotations?.UI?.InputMask?.valueOf()) {\n\t\t\t\toProps.editStyle = \"InputMask\";\n\t\t\t\toProps.mask = {\n\t\t\t\t\tmask: oProperty.annotations?.UI?.InputMask?.Mask.toString(),\n\t\t\t\t\tplaceholderSymbol: oProperty.annotations?.UI?.InputMask?.PlaceholderSymbol.toString(),\n\t\t\t\t\tmaskRule: _getMaskingRules(oProperty.annotations?.UI?.InputMask?.Rules)\n\t\t\t\t};\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (oProperty.annotations?.Common?.Masked?.valueOf()) {\n\t\t\t\toProps.editStyle = \"Masked\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (hasStaticPercentUnit(oProperty)) {\n\t\t\t\toProps.staticDescription = \"%\";\n\t\t\t}\n\t\t\toProps.editStyle = \"Input\";\n\t}\n\n\toProps.editStyle = \"Input\";\n};\n\nconst _getMaskingRules = (maskingRules: InputMaskRuleTypeTypes[] | undefined): InputMaskRule[] => {\n\tif (!maskingRules || maskingRules.length === 0) {\n\t\treturn [{ symbol: \"*\", regex: \"[a-zA-Z0-9]\" }];\n\t}\n\n\treturn maskingRules.map((maskingRule) => ({\n\t\tsymbol: maskingRule.MaskSymbol.toString(),\n\t\tregex: maskingRule.RegExp.toString()\n\t}));\n};\n\nexport const hasSemanticObjectInNavigationOrProperty = (propertyDataModelObjectPath: DataModelObjectPath<Property>): boolean => {\n\tconst property = propertyDataModelObjectPath.targetObject as Property;\n\tif (SemanticObjectHelper.hasSemanticObject(property)) {\n\t\treturn true;\n\t}\n\tconst lastNavProp = propertyDataModelObjectPath?.navigationProperties?.length\n\t\t? propertyDataModelObjectPath?.navigationProperties[propertyDataModelObjectPath?.navigationProperties?.length - 1]\n\t\t: null;\n\tif (\n\t\t!lastNavProp ||\n\t\tpropertyDataModelObjectPath.contextLocation?.navigationProperties?.find(\n\t\t\t(contextNavProp) => contextNavProp.name === lastNavProp.name\n\t\t)\n\t) {\n\t\treturn false;\n\t}\n\treturn SemanticObjectHelper.hasSemanticObject(lastNavProp);\n};\n\n/**\n * Get the dataModelObjectPath with the value property as targetObject if it exists\n * for a dataModelObjectPath targeting a DataField or a DataPoint annotation.\n * @param initialDataModelObjectPath\n * @returns The dataModelObjectPath targeting the value property or undefined\n */\nexport const getDataModelObjectPathForValue = (\n\tinitialDataModelObjectPath: DataModelObjectPath<DataFieldAbstractTypes | DataPointTypeTypes | Property>\n): DataModelObjectPath<Property> | undefined => {\n\tif (!initialDataModelObjectPath.targetObject) {\n\t\treturn undefined;\n\t}\n\tif (isProperty(initialDataModelObjectPath.targetObject)) {\n\t\treturn initialDataModelObjectPath as DataModelObjectPath<Property>;\n\t}\n\tlet valuePath = \"\";\n\t// data point annotations need not have $Type defined, so add it if missing\n\tif (isAnnotationOfTerm(initialDataModelObjectPath, UIAnnotationTerms.DataPoint)) {\n\t\tinitialDataModelObjectPath.targetObject.$Type = initialDataModelObjectPath.targetObject.$Type || UIAnnotationTypes.DataPointType;\n\t}\n\tswitch (initialDataModelObjectPath.targetObject.$Type) {\n\t\tcase UIAnnotationTypes.DataField:\n\t\tcase UIAnnotationTypes.DataPointType:\n\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\tcase UIAnnotationTypes.DataFieldWithIntentBasedNavigation:\n\t\tcase UIAnnotationTypes.DataFieldWithAction:\n\t\t\tif (typeof initialDataModelObjectPath.targetObject.Value === \"object\") {\n\t\t\t\tvaluePath = initialDataModelObjectPath.targetObject.Value.path;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\t\tif (initialDataModelObjectPath.targetObject.Target.$target) {\n\t\t\t\tif (\n\t\t\t\t\tisAnnotationOfType<DataField | DataPointType>(initialDataModelObjectPath.targetObject.Target.$target, [\n\t\t\t\t\t\tUIAnnotationTypes.DataPointType,\n\t\t\t\t\t\tUIAnnotationTypes.DataField\n\t\t\t\t\t])\n\t\t\t\t) {\n\t\t\t\t\tif (initialDataModelObjectPath.targetObject.Target.value.indexOf(\"/\") > 0) {\n\t\t\t\t\t\tvaluePath = initialDataModelObjectPath.targetObject.Target.value.replace(\n\t\t\t\t\t\t\t/\\/@.*/,\n\t\t\t\t\t\t\t`/${initialDataModelObjectPath.targetObject.Target.$target.Value?.path}`\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvaluePath = initialDataModelObjectPath.targetObject.Target.$target.Value?.path;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvaluePath = (initialDataModelObjectPath.targetObject.Target as unknown as PathAnnotationExpression<unknown>)?.path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UIAnnotationTypes.DataFieldForAction:\n\t\tcase UIAnnotationTypes.DataFieldForIntentBasedNavigation:\n\t\tcase UIAnnotationTypes.DataFieldForActionGroup:\n\t\tcase UIAnnotationTypes.DataFieldWithActionGroup:\n\t\t\tbreak;\n\t}\n\n\tif (valuePath && valuePath.length > 0) {\n\t\treturn enhanceDataModelPath(initialDataModelObjectPath, valuePath);\n\t} else {\n\t\treturn undefined;\n\t}\n};\n\n/**\n * Check if the considered property is a non-insertable property\n * A first check is done on the last navigation from the contextLocation:\n * - If the annotation 'nonInsertableProperty' is found and the property is listed, then the property is non-insertable,\n * - Else the same check is done on the target entity.\n * @param propertyDataModelObjectPath\n * @returns True if the property is not insertable\n */\nexport const hasPropertyInsertRestrictions = (propertyDataModelObjectPath: DataModelObjectPath<Property>): boolean => {\n\tconst nonInsertableProperties = getContextPropertyRestriction(propertyDataModelObjectPath, (capabilities) => {\n\t\treturn (capabilities as EntitySetAnnotations_Capabilities | undefined)?.InsertRestrictions?.NonInsertableProperties;\n\t});\n\n\treturn nonInsertableProperties.some((nonInsertableProperty) => {\n\t\treturn nonInsertableProperty?.$target?.fullyQualifiedName === propertyDataModelObjectPath.targetObject?.fullyQualifiedName;\n\t});\n};\n\n/**\n * Get the binding for the draft indicator visibility.\n * @param draftIndicatorKey\n * @returns  The visibility binding expression.\n */\nexport const getDraftIndicatorVisibleBinding = (draftIndicatorKey: string | undefined): string | undefined => {\n\treturn draftIndicatorKey\n\t\t? compileExpression(\n\t\t\t\tformatResult(\n\t\t\t\t\t[\n\t\t\t\t\t\tconstant(draftIndicatorKey),\n\t\t\t\t\t\tpathInModel(\"semanticKeyHasDraftIndicator\", \"internal\"),\n\t\t\t\t\t\tpathInModel(\"HasDraftEntity\"),\n\t\t\t\t\t\tpathInModel(\"IsActiveEntity\"),\n\t\t\t\t\t\tpathInModel(\"hideDraftInfo\", \"pageInternal\")\n\t\t\t\t\t],\n\t\t\t\t\t\"sap.fe.macros.field.FieldRuntime.isDraftIndicatorVisible\"\n\t\t\t\t)\n\t\t  )\n\t\t: \"false\";\n};\n/**\n * Returns the DisplayShape for the Avatar depending on the annotation IsNaturalPerson.\n *\n * If the entity type is annotated with \"IsNaturalPerson\", then all Streams and ImageURls\n * in this entity are considered to be person therefore have shape circle by default.\n *\n * If a property within such an entity is annotated with UI.IsImage or UI.IsImageURL, both\n * of these annotations can be annotated with Common.IsNaturalPerson.\n *\n * The annotation at the property level overrides the annotation at the entity type.\n * @param dataModelPath\n * @param property\n * @returns The shape of the Avatar as string or as an expression\n */\n\nexport const getAvatarShape = (dataFieldModelPath: DataModelObjectPath<Property>): CompiledBindingToolkitExpression => {\n\tconst targetObject =\n\t\tdataFieldModelPath.targetObject?.annotations?.UI?.IsImageURL?.annotations?.Common?.IsNaturalPerson ||\n\t\tdataFieldModelPath.targetObject?.annotations?.UI?.IsImage?.annotations?.Common?.IsNaturalPerson;\n\tconst entityAnnotationTarget = dataFieldModelPath.targetEntityType.annotations?.Common?.IsNaturalPerson;\n\tlet avatarShapeExpression: ExpressionOrPrimitive<boolean>;\n\n\tif (targetObject) {\n\t\tavatarShapeExpression = getExpressionFromAnnotation(targetObject);\n\t} else if (entityAnnotationTarget) {\n\t\tavatarShapeExpression = getExpressionFromAnnotation(entityAnnotationTarget);\n\t} else avatarShapeExpression = false;\n\n\treturn compileExpression(ifElse(avatarShapeExpression, AvatarShape.Circle, AvatarShape.Square));\n};\n"],"mappings":"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","ignoreList":[]}