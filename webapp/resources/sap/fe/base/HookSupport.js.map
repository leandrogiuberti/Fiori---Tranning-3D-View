{"version":3,"file":"HookSupport.js","names":["registeredInstances","registeredHandlers","hookable","execution","target","propertyKey","descriptor","indexableTarget","toString","fn","cExTInstanceHookMap","this","hookedHandlers","push","handlers","Array","isArray","index","indexOf","splice","oldValue","value","async","returnValue","bind","arguments","handler","_exports","isAlreadyRegistered","existingRegistrations","newRegistration","find","r","name","method","targetMethod","hooks","Symbol","controllerExtensionHandler","String","constructor","Object","defineProperty","initControllerExtensionHookHandlers","controller","registeredHooks","deepClone","indexableController","registeredHook","handlerFunction","getView","attachBeforeExit","removeControllerExtensionHookHandlers","propagateHookFromMixin","source","getOwnPropertyDescriptor","create"],"sources":["./HookSupport.ts"],"sourcesContent":["import deepClone from \"sap/base/util/deepClone\";\nimport type { ExtensionOverrideExecution } from \"sap/fe/base/ClassSupport\";\nimport type Controller from \"sap/ui/core/mvc/Controller\";\n/**\n * This type is to be extended with all controller extensions and methods that are hookable.\n */\ntype HookableControllerExtensions = {\n\teditFlow: {\n\t\tonAfterSave: true;\n\t\tonBeforeSave: true;\n\t};\n\tinlineEditFlow: {\n\t\tinlineEditEnd: true;\n\t\tinlineEditStart: true;\n\t};\n\tcollaborationManager: {\n\t\tcollectAvailableCards: true;\n\t};\n\tpaginator: {\n\t\tinitialize: true;\n\t};\n\trouting: {\n\t\tonAfterBinding: true;\n\t};\n\tviewState: {\n\t\tretrieveAdditionalStates: true;\n\t\tapplyAdditionalStates: true;\n\t};\n};\n\ntype HandlerConfiguration<CExtName extends keyof HookableControllerExtensions> = {\n\tname: CExtName;\n\tmethod: keyof HookableControllerExtensions[CExtName];\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype HandlerRegistration = HandlerConfiguration<any> & { targetMethod: string; handlerFunction?: Function };\n\ntype FunctionMap = {\n\t[key: string]: Function;\n};\ntype DeepFunctionMap = {\n\t[key: string]: FunctionMap;\n};\ntype HookMap = {\n\thookedHandlers: {\n\t\t[key: string]: Function[];\n\t};\n};\n\n// Use two arrays as we cannot index a map through an arbitrary object instance\nconst registeredInstances: Function[] = [];\nconst registeredHandlers: HandlerRegistration[][] = [];\n\n/**\n * Marks a controller extension method to be hookable by generating additional methods that can be used to attach and detach handlers at runtime.\n * @param execution\n * @returns A method decorator\n */\nexport function hookable(execution: ExtensionOverrideExecution): MethodDecorator {\n\treturn function (target: unknown, propertyKey: string | symbol, descriptor: PropertyDescriptor) {\n\t\tconst indexableTarget = target as FunctionMap;\n\n\t\tindexableTarget[`attach${propertyKey.toString()}`] = function (fn: Function): void {\n\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\tif (!cExTInstanceHookMap.hookedHandlers) {\n\t\t\t\tcExTInstanceHookMap.hookedHandlers = {};\n\t\t\t}\n\t\t\tif (!cExTInstanceHookMap.hookedHandlers[propertyKey.toString()]) {\n\t\t\t\tcExTInstanceHookMap.hookedHandlers[propertyKey.toString()] = [];\n\t\t\t}\n\t\t\tcExTInstanceHookMap.hookedHandlers[propertyKey.toString()].push(fn);\n\t\t};\n\t\tindexableTarget[`detach${propertyKey.toString()}`] = function (fn: Function): void {\n\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\tconst handlers = cExTInstanceHookMap.hookedHandlers?.[propertyKey.toString()];\n\t\t\tif (Array.isArray(handlers)) {\n\t\t\t\tconst index = handlers.indexOf(fn);\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\thandlers.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst oldValue = descriptor.value;\n\t\tif (execution === \"BeforeAsync\" || execution === \"AfterAsync\") {\n\t\t\tdescriptor.value = async function (...args: unknown[]): Promise<unknown> {\n\t\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\t\tconst handlers = (cExTInstanceHookMap?.hookedHandlers && cExTInstanceHookMap?.hookedHandlers[propertyKey.toString()]) || [];\n\t\t\t\tlet returnValue: unknown;\n\t\t\t\tif (execution === \"AfterAsync\") {\n\t\t\t\t\treturnValue = await oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tfor (const handler of handlers) {\n\t\t\t\t\tawait handler.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tif (execution === \"BeforeAsync\") {\n\t\t\t\t\treturnValue = await oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t} else {\n\t\t\tdescriptor.value = function (...args: unknown[]): unknown {\n\t\t\t\tconst cExTInstanceHookMap = this as unknown as HookMap;\n\t\t\t\tconst handlers = (cExTInstanceHookMap?.hookedHandlers && cExTInstanceHookMap?.hookedHandlers[propertyKey.toString()]) || [];\n\t\t\t\tlet returnValue: unknown;\n\t\t\t\tif (execution === \"After\") {\n\t\t\t\t\treturnValue = oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tfor (const handler of handlers) {\n\t\t\t\t\thandler.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\tif (execution === \"Before\") {\n\t\t\t\t\treturnValue = oldValue.bind(this)(...args);\n\t\t\t\t}\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t}\n\t};\n}\n\n/**\n * Checks whether a newRegistration is already included in some existingRegistrations by comparing all relevant attributes.\n * @param existingRegistrations\n * @param newRegistration\n * @returns Result of the check\n */\nfunction isAlreadyRegistered(existingRegistrations: HandlerRegistration[], newRegistration: HandlerRegistration): boolean {\n\treturn !!existingRegistrations.find(\n\t\t(r) => r.name === newRegistration.name && r.method === newRegistration.method && r.targetMethod === newRegistration.targetMethod\n\t);\n}\n\nexport const hooks = Symbol(\"hooks\");\n\n/**\n * Registers a method as controller extension hook handler.\n *\n * Currently, only methods of runtime building blocks are supported.\n * @param name Controller extension to hook into\n * @param method Method to hook into\n * @returns A method decorator\n */\nexport function controllerExtensionHandler<CExtName extends keyof HookableControllerExtensions>(\n\tname: CExtName,\n\tmethod: keyof HookableControllerExtensions[CExtName]\n): MethodDecorator {\n\treturn function (target: { constructor: Function & { [hooks]?: HandlerRegistration[] } }, propertyKey: string) {\n\t\tconst newRegistration = { name, method: String(method), targetMethod: propertyKey };\n\t\tconst index = registeredInstances.indexOf(target.constructor);\n\t\tif (!target.constructor[hooks]) {\n\t\t\tObject.defineProperty(target.constructor, hooks, {\n\t\t\t\tvalue: []\n\t\t\t});\n\t\t}\n\t\ttarget.constructor[hooks]?.push(newRegistration);\n\t\t// We need to check if this exact handler is already registered as handlers are registered statically (on the constructor)\n\t\tif (index !== -1 && !isAlreadyRegistered(registeredHandlers[index], newRegistration)) {\n\t\t\tregisteredHandlers[index].push(newRegistration);\n\t\t} else {\n\t\t\tregisteredInstances.push(target.constructor);\n\t\t\tregisteredHandlers.push([newRegistration]);\n\t\t}\n\t} as MethodDecorator;\n}\n\n/**\n * Initializes all controller extension handlers registered for a given target.\n * @param target Target class to initialize the handlers for\n * @param target.constructor\n * @param controller PageController instance to get the controller extensions instances from\n */\nexport function initControllerExtensionHookHandlers(\n\ttarget: { constructor: Function & { [hooks]?: HandlerRegistration[] } } & { [hooks]?: HandlerRegistration[] },\n\tcontroller: Controller\n): void {\n\tif (target.constructor[hooks]) {\n\t\tlet registeredHooks = target.constructor[hooks];\n\t\ttarget[hooks] = deepClone(registeredHooks);\n\t\tregisteredHooks = target[hooks]!;\n\t\tconst indexableTarget = target as unknown as FunctionMap;\n\t\tconst indexableController = controller as unknown as DeepFunctionMap;\n\t\tfor (const registeredHook of registeredHooks) {\n\t\t\tregisteredHook.handlerFunction = indexableTarget[registeredHook.targetMethod].bind(target);\n\t\t\tindexableController[registeredHook.name][`attach${String(registeredHook.method)}`](registeredHook.handlerFunction);\n\t\t\tcontroller.getView()?.attachBeforeExit(() => {\n\t\t\t\tindexableController[registeredHook.name][`detach${String(registeredHook.method)}`](registeredHook.handlerFunction);\n\t\t\t});\n\t\t}\n\t}\n}\n\nexport function removeControllerExtensionHookHandlers(\n\ttarget: { constructor: Function & { [hooks]?: HandlerRegistration[] } } & { [hooks]?: HandlerRegistration[] },\n\tcontroller: Controller\n): void {\n\tif (target[hooks]) {\n\t\tconst registeredHooks = target[hooks];\n\t\tconst indexableController = controller as unknown as DeepFunctionMap;\n\t\tfor (const registeredHook of registeredHooks) {\n\t\t\tindexableController[registeredHook.name]?.[`detach${String(registeredHook.method)}`]?.(registeredHook.handlerFunction);\n\t\t}\n\t}\n}\n\nexport function propagateHookFromMixin(\n\ttarget: Function & { [hooks]?: HandlerRegistration[] },\n\tsource: Function & { [hooks]?: HandlerRegistration[] }\n): void {\n\tif (source[hooks]) {\n\t\tif (target[hooks]) {\n\t\t\ttarget[hooks]!.splice(0, 0, ...source[hooks]);\n\t\t} else {\n\t\t\tObject.defineProperty(target, hooks, Object.getOwnPropertyDescriptor(source, hooks) || Object.create([]));\n\t\t}\n\t}\n}\n"],"mappings":"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","ignoreList":[]}