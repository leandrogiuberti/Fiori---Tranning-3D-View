{"version":3,"file":"jsx-control.js","names":["FL_DELEGATE","CORE_REQUIRE","DT_DESIGNTIME","addChildAggregation","aggregationChildren","aggregationName","child","undefined","isChildAnElement","push","Array","isArray","forEach","subChild","Object","keys","childKey","children","isA","isAControl","getMetadata","processAggregations","metadata","mSettings","metadataAggregations","getAllAggregations","defaultAggregationName","getDefaultAggregationName","hasOwnProperty","resultingParse","BindingInfo","parse","path","model","factory","template","processBindingToolkitExpression","settings","settingsKey","bindingToolkitExpression","allProperties","isConstant","compileConstant","call","isPathInModelExpression","modelName","compileExpression","processStringProperty","value","allEvents","startsWith","Log","error","getName","propertyType","getType","DataType","includes","parseValue","processObjectProperty","lateProperties","then","__bindingInfo","processProperties","getAllEvents","getAllProperties","isBindingToolkitExpression","processCommand","commandProperty","command","eventName","split","event","name","EventHandlerResolver","resolveEventHandler","jsxControl","ControlType","key","_jsxContext","_jsxFormatterContext","targetControl","isFragment","classDef","class","refDef","ref","bindingDef","binding","flDelegate","dtDesigntime","targetControlInstance","addStyleClass","setCurrent","customSettings","data","delegate","designtime","length","bindingInfo","bindElement","parameters","bindingDefKey","latePropertiesKey","setProperty","catch","controlTypeFn","Text","text"],"sources":["./jsx-control.ts"],"sourcesContent":["import Log from \"sap/base/Log\";\nimport type { BindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport {\n\tcompileConstant,\n\tcompileExpression,\n\tisBindingToolkitExpression,\n\tisConstant,\n\tisPathInModelExpression\n} from \"sap/fe/base/BindingToolkit\";\nimport type { BindingInfoHolder, NonAbstractClass } from \"sap/fe/base/ClassSupport\";\nimport type { ControlProperties, JSXContext, NonControlProperties, Ref } from \"sap/fe/base/jsx-runtime/jsx\";\nimport Text from \"sap/m/Text\";\nimport BindingInfo from \"sap/ui/base/BindingInfo\";\nimport DataType from \"sap/ui/base/DataType\";\nimport type ManagedObjectMetadata from \"sap/ui/base/ManagedObjectMetadata\";\nimport type Control from \"sap/ui/core/Control\";\nimport type { $ControlSettings } from \"sap/ui/core/Control\";\nimport type { default as Element, default as UI5Element } from \"sap/ui/core/Element\";\nimport EventHandlerResolver from \"sap/ui/core/mvc/EventHandlerResolver\";\n\nconst FL_DELEGATE = \"fl:delegate\";\nconst CORE_REQUIRE = \"core:require\";\nconst DT_DESIGNTIME = \"dt:designtime\";\nconst addChildAggregation = function (\n\taggregationChildren: Record<string, (string | UI5Element)[]>,\n\taggregationName: string,\n\tchild?: string | UI5Element | UI5Element[]\n): void {\n\tif (child === null || child === undefined || typeof child === \"string\") {\n\t\treturn;\n\t}\n\tif (!aggregationChildren[aggregationName]) {\n\t\taggregationChildren[aggregationName] = [];\n\t}\n\tif (isChildAnElement(child)) {\n\t\taggregationChildren[aggregationName].push(child);\n\t} else if (Array.isArray(child)) {\n\t\tchild.forEach((subChild) => {\n\t\t\taddChildAggregation(aggregationChildren, aggregationName, subChild);\n\t\t});\n\t} else if (typeof child === \"function\") {\n\t\taggregationChildren[aggregationName] = child;\n\t} else {\n\t\tObject.keys(child).forEach((childKey) => {\n\t\t\taddChildAggregation(aggregationChildren, childKey, child[childKey]);\n\t\t});\n\t}\n};\nconst isChildAnElement = function (children?: unknown): children is Element {\n\treturn (children as Element)?.isA?.(\"sap.ui.core.Element\");\n};\nconst isAControl = function (children?: typeof Control | Function): children is NonAbstractClass<Control> {\n\treturn !!(children as typeof Control)?.getMetadata;\n};\n\nfunction processAggregations(metadata: ManagedObjectMetadata, mSettings: Record<string, unknown>): void {\n\tconst metadataAggregations = metadata.getAllAggregations();\n\tconst defaultAggregationName = metadata.getDefaultAggregationName();\n\tconst aggregationChildren: Record<string, (string | UI5Element)[]> = {};\n\taddChildAggregation(aggregationChildren, defaultAggregationName, mSettings.children as string | UI5Element | UI5Element[]);\n\tdelete mSettings.children;\n\t// find out which aggregation are bound (both in children and directly under it)\n\tObject.keys(metadataAggregations).forEach((aggregationName) => {\n\t\tif (aggregationChildren[aggregationName] !== undefined) {\n\t\t\tif (mSettings.hasOwnProperty(aggregationName)) {\n\t\t\t\tif (typeof mSettings[aggregationName] === \"string\") {\n\t\t\t\t\tconst resultingParse = BindingInfo.parse(mSettings[aggregationName]);\n\t\t\t\t\tif (resultingParse) {\n\t\t\t\t\t\tmSettings[aggregationName] = {\n\t\t\t\t\t\t\tpath: resultingParse.path,\n\t\t\t\t\t\t\tmodel: resultingParse.model\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmSettings[aggregationName] = {\n\t\t\t\t\t\t\tpath: mSettings[aggregationName]\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (typeof aggregationChildren[aggregationName] === \"function\") {\n\t\t\t\t\t(mSettings[aggregationName] as { factory: Function }).factory = aggregationChildren[\n\t\t\t\t\t\taggregationName\n\t\t\t\t\t] as unknown as Function;\n\t\t\t\t} else {\n\t\t\t\t\t(mSettings[aggregationName] as { template: string | UI5Element }).template = aggregationChildren[aggregationName][0];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmSettings[aggregationName] = aggregationChildren[aggregationName];\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * Processes a binding toolkit expression property for function processProperties\n *\n * If the property is a constant, it compiles it as a constant. If the property is an aggregation,\n * it compiles the expression as an object. Otherwise, it compiles the expression normally.\n * @param settings The settings of the control\n * @param settingsKey The key of the setting being processed\n * @param bindingToolkitExpression The binding toolkit expression to process\n * @param allProperties All properties of the control\n */\nfunction processBindingToolkitExpression(\n\tsettings: Record<string, unknown>,\n\tsettingsKey: keyof typeof settings,\n\tbindingToolkitExpression: BindingToolkitExpression<unknown>,\n\tallProperties: Record<string, unknown>\n): void {\n\tif (isConstant(bindingToolkitExpression)) {\n\t\tsettings[settingsKey] = compileConstant(bindingToolkitExpression, false, true, true);\n\t} else if (!Object.hasOwnProperty.call(allProperties, settingsKey)) {\n\t\t// Aggregation case - we need to compile the expression but as an object\n\t\tif (isPathInModelExpression(bindingToolkitExpression)) {\n\t\t\tsettings[settingsKey] = { path: bindingToolkitExpression.path, model: bindingToolkitExpression.modelName };\n\t\t}\n\t} else {\n\t\tsettings[settingsKey] = compileExpression(bindingToolkitExpression);\n\t}\n}\n\n/**\n * Processes a string property for function processProperties\n *\n * If the property is not a binding expression and does not match the expected format,\n * it parses the value to provide the expected format. If the property is an event handler,\n * it logs an error.\n * @param settings The settings of the control\n * @param settingsKey The key of the setting being processed\n * @param value The string value to process\n * @param allEvents All events of the control\n * @param allProperties All properties of the control\n * @param metadata Metadata of the control\n */\nfunction processStringProperty(\n\tsettings: Record<string, unknown>,\n\tsettingsKey: keyof typeof settings,\n\tvalue: string,\n\tallEvents: Record<string, unknown>,\n\tallProperties: Record<string, unknown>,\n\tmetadata: ManagedObjectMetadata\n): void {\n\tif (!value.startsWith(\"{\")) {\n\t\tif (Object.hasOwnProperty.call(allEvents, settingsKey)) {\n\t\t\tLog.error(`Event handlers cannot be set as string in JSX, ${settingsKey} in ${metadata.getName()}`);\n\t\t}\n\t\tconst propertyType = (allProperties[settingsKey] as { getType?: Function })?.getType?.();\n\t\tif (propertyType && propertyType instanceof DataType && [\"boolean\", \"int\", \"float\"].includes(propertyType.getName())) {\n\t\t\tsettings[settingsKey] = propertyType.parseValue(value);\n\t\t}\n\t} else {\n\t\tsettings[settingsKey] = value;\n\t}\n}\n\n/**\n * Processes an object property for function processProperties.\n *\n * If the property is a promise, it adds it to the late properties map. If the property is a binding info holder,\n * it sets the binding info to the settings.\n * @param settings The settings of the control\n * @param settingsKey The key of the setting being processed\n * @param value The object value to process\n * @param lateProperties A map of the control's late properties\n */\nfunction processObjectProperty(\n\tsettings: Record<string, unknown>,\n\tsettingsKey: keyof typeof settings,\n\tvalue: unknown,\n\tlateProperties: Record<string, Promise<unknown>>\n): void {\n\tif ((value as Promise<unknown>).then) {\n\t\tlateProperties[settingsKey] = value as Promise<unknown>;\n\t\tdelete settings[settingsKey];\n\t} else if ((value as BindingInfoHolder<unknown>).__bindingInfo) {\n\t\tsettings[settingsKey] = (value as BindingInfoHolder<unknown>).__bindingInfo;\n\t}\n}\n\n/**\n * Processes the properties.\n *\n * If the property is a bindingToolkit expression we need to compile it.\n * Else if the property is set as string (compiled binding expression returns string by default even if it's a boolean, int, etc.) and it doesn't match with expected\n * format the value is parsed to provide expected format.\n * @param metadata Metadata of the control\n * @param settings Settings of the control\n * @returns A map of late properties that need to be awaited after the control is created\n */\nfunction processProperties(metadata: ManagedObjectMetadata, settings: Record<string, unknown>): Record<string, Promise<unknown>> {\n\tlet settingsKey: keyof typeof settings;\n\tconst lateProperties: Record<string, Promise<unknown>> = {};\n\tconst allEvents = metadata.getAllEvents();\n\tconst allProperties = metadata.getAllProperties();\n\n\tfor (settingsKey in settings) {\n\t\tconst value = settings[settingsKey];\n\t\tif (isBindingToolkitExpression(value)) {\n\t\t\tprocessBindingToolkitExpression(settings, settingsKey, value, allProperties);\n\t\t} else if (value !== null && typeof value === \"object\") {\n\t\t\tprocessObjectProperty(settings, settingsKey, value, lateProperties);\n\t\t} else if (typeof value === \"string\") {\n\t\t\tprocessStringProperty(settings, settingsKey, value, allEvents, allProperties, metadata);\n\t\t} else if (value === undefined) {\n\t\t\tdelete settings[settingsKey];\n\t\t}\n\t}\n\treturn lateProperties;\n}\n\n/**\n * Processes the command.\n *\n * Resolves the command set on the control via the intrinsic class attribute \"jsx:command\".\n * If no command has been set or the targeted event doesn't exist, no configuration is set.\n * @param metadata Metadata of the control\n * @param settings Settings of the control\n */\nfunction processCommand(metadata: ManagedObjectMetadata, settings: Record<string, unknown>): void {\n\tconst commandProperty = settings[\"jsx:command\"];\n\tif (commandProperty) {\n\t\tconst [command, eventName] = (commandProperty as string).split(\"|\");\n\t\tconst event = metadata.getAllEvents()[eventName];\n\t\tif (event && command.startsWith(\"cmd:\")) {\n\t\t\tsettings[event.name] = EventHandlerResolver.resolveEventHandler(command);\n\t\t}\n\t}\n\tdelete settings[\"jsx:command\"];\n}\n\nconst jsxControl = function <T extends Element>(\n\tControlType: NonAbstractClass<Control> | Function,\n\tsettings: NonControlProperties<T> & {\n\t\tkey: string;\n\t\tchildren?: Element | ControlProperties<T>;\n\t\tref?: Ref<T>;\n\t\tbinding?: string;\n\t\tclass?: string;\n\t\t[FL_DELEGATE]?: string;\n\t\t[DT_DESIGNTIME]?: string;\n\t\t[CORE_REQUIRE]?: string;\n\t},\n\tkey: string,\n\t_jsxContext: JSXContext,\n\t_jsxFormatterContext: object\n): Control | Control[] | undefined {\n\tlet targetControl: Control | Control[] | undefined;\n\n\tif ((ControlType as { isFragment?: boolean })?.isFragment) {\n\t\ttargetControl = settings.children as Control | Control[];\n\t} else if (isAControl(ControlType)) {\n\t\tconst metadata = ControlType.getMetadata();\n\t\tif (key !== undefined) {\n\t\t\tsettings[\"key\"] = key;\n\t\t}\n\t\tconst lateProperties = processProperties(metadata, settings);\n\t\tprocessCommand(metadata, settings);\n\t\tprocessAggregations(metadata, settings);\n\t\tconst classDef = settings.class;\n\t\tconst refDef = settings.ref;\n\t\tconst bindingDef = settings.binding;\n\t\tconst flDelegate = settings[FL_DELEGATE];\n\t\tconst dtDesigntime = settings[DT_DESIGNTIME];\n\t\tdelete settings.ref;\n\t\tdelete settings.class;\n\t\tdelete settings.binding;\n\t\tdelete settings[FL_DELEGATE];\n\t\tdelete settings[DT_DESIGNTIME];\n\t\tdelete settings[CORE_REQUIRE]; // Core require is not useful in control mode\n\t\tconst targetControlInstance = new ControlType(settings as $ControlSettings, { ..._jsxFormatterContext });\n\t\tif (classDef) {\n\t\t\ttargetControlInstance.addStyleClass(classDef);\n\t\t}\n\t\tif (refDef) {\n\t\t\trefDef.setCurrent(targetControlInstance as unknown as T);\n\t\t}\n\t\tconst customSettings = targetControlInstance.data(\"sap-ui-custom-settings\") ?? {};\n\t\tif (flDelegate) {\n\t\t\tcustomSettings[\"sap.ui.fl\"] ??= {};\n\t\t\tcustomSettings[\"sap.ui.fl\"].delegate = flDelegate;\n\t\t}\n\t\tif (dtDesigntime) {\n\t\t\tcustomSettings[\"sap.ui.dt\"] ??= {};\n\t\t\tcustomSettings[\"sap.ui.dt\"].designtime = dtDesigntime;\n\t\t}\n\t\tif (Object.keys(customSettings).length > 0) {\n\t\t\ttargetControlInstance.data(\"sap-ui-custom-settings\", customSettings);\n\t\t}\n\n\t\tif (bindingDef) {\n\t\t\tif (typeof bindingDef === \"string\") {\n\t\t\t\tconst bindingInfo = BindingInfo.parse(bindingDef);\n\t\t\t\tif (bindingInfo) {\n\t\t\t\t\ttargetControlInstance.bindElement({\n\t\t\t\t\t\tmodel: bindingInfo.model ?? undefined,\n\t\t\t\t\t\tpath: bindingInfo.path,\n\t\t\t\t\t\tparameters: bindingInfo.parameters ?? undefined\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttargetControlInstance.bindElement(bindingDef);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We consider it's an object\n\t\t\t\tObject.keys(bindingDef).forEach((bindingDefKey) => {\n\t\t\t\t\ttargetControlInstance.bindElement({ model: bindingDefKey, path: bindingDef[bindingDefKey] });\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tfor (const latePropertiesKey in lateProperties) {\n\t\t\tlateProperties[latePropertiesKey]\n\t\t\t\t.then((value) => {\n\t\t\t\t\treturn targetControlInstance.setProperty(latePropertiesKey, value);\n\t\t\t\t})\n\t\t\t\t.catch((error) => {\n\t\t\t\t\tLog.error(`Couldn't set property ${latePropertiesKey} on ${ControlType.getMetadata().getName()}`, error, \"jsxControl\");\n\t\t\t\t});\n\t\t}\n\t\ttargetControl = targetControlInstance;\n\t} else if (typeof ControlType === \"function\") {\n\t\tconst controlTypeFn = ControlType;\n\t\ttargetControl = controlTypeFn(settings as $ControlSettings);\n\t} else {\n\t\ttargetControl = new Text({ text: \"Missing component \" + (ControlType as string) });\n\t}\n\n\treturn targetControl;\n};\n\nexport default jsxControl;\n"],"mappings":";;;;4UAoBA,MAAMA,EAAc,cACpB,MAAMC,EAAe,eACrB,MAAMC,EAAgB,gBACtB,MAAMC,EAAsB,SAC3BC,EACAC,EACAC,GAEA,GAAIA,IAAU,MAAQA,IAAUC,kBAAoBD,IAAU,SAAU,CACvE,MACD,CACA,IAAKF,EAAoBC,GAAkB,CAC1CD,EAAoBC,GAAmB,EACxC,CACA,GAAIG,EAAiBF,GAAQ,CAC5BF,EAAoBC,GAAiBI,KAAKH,EAC3C,MAAO,GAAII,MAAMC,QAAQL,GAAQ,CAChCA,EAAMM,QAASC,IACdV,EAAoBC,EAAqBC,EAAiBQ,IAE5D,MAAO,UAAWP,IAAU,WAAY,CACvCF,EAAoBC,GAAmBC,CACxC,KAAO,CACNQ,OAAOC,KAAKT,GAAOM,QAASI,IAC3Bb,EAAoBC,EAAqBY,EAAUV,EAAMU,KAE3D,CACD,EACA,MAAMR,EAAmB,SAAUS,GAClC,OAAQA,GAAsBC,MAAM,sBACrC,EACA,MAAMC,EAAa,SAAUF,GAC5B,QAAUA,GAA6BG,WACxC,EAEA,SAASC,EAAoBC,EAAiCC,GAC7D,MAAMC,EAAuBF,EAASG,qBACtC,MAAMC,EAAyBJ,EAASK,4BACxC,MAAMvB,EAA+D,CAAC,EACtED,EAAoBC,EAAqBsB,EAAwBH,EAAUN,iBACpEM,EAAUN,SAEjBH,OAAOC,KAAKS,GAAsBZ,QAASP,IAC1C,GAAID,EAAoBC,KAAqBE,UAAW,CACvD,GAAIgB,EAAUK,eAAevB,GAAkB,CAC9C,UAAWkB,EAAUlB,KAAqB,SAAU,CACnD,MAAMwB,EAAiBC,EAAYC,MAAMR,EAAUlB,IACnD,GAAIwB,EAAgB,CACnBN,EAAUlB,GAAmB,CAC5B2B,KAAMH,EAAeG,KACrBC,MAAOJ,EAAeI,MAExB,KAAO,CACNV,EAAUlB,GAAmB,CAC5B2B,KAAMT,EAAUlB,GAElB,CACD,CACA,UAAWD,EAAoBC,KAAqB,WAAY,CAC9DkB,EAAUlB,GAA2C6B,QAAU9B,EAC/DC,EAEF,KAAO,CACLkB,EAAUlB,GAAuD8B,SAAW/B,EAAoBC,GAAiB,EACnH,CACD,KAAO,CACNkB,EAAUlB,GAAmBD,EAAoBC,EAClD,CACD,GAEF,CAYA,SAAS+B,EACRC,EACAC,EACAC,EACAC,GAEA,GAAIC,EAAWF,GAA2B,CACzCF,EAASC,GAAeI,EAAgBH,EAA0B,MAAO,KAAM,KAChF,MAAO,IAAKzB,OAAOc,eAAee,KAAKH,EAAeF,GAAc,CAEnE,GAAIM,EAAwBL,GAA2B,CACtDF,EAASC,GAAe,CAAEN,KAAMO,EAAyBP,KAAMC,MAAOM,EAAyBM,UAChG,CACD,KAAO,CACNR,EAASC,GAAeQ,EAAkBP,EAC3C,CACD,CAeA,SAASQ,EACRV,EACAC,EACAU,EACAC,EACAT,EACAlB,GAEA,IAAK0B,EAAME,WAAW,KAAM,CAC3B,GAAIpC,OAAOc,eAAee,KAAKM,EAAWX,GAAc,CACvDa,EAAIC,MAAM,kDAAkDd,QAAkBhB,EAAS+B,YACxF,CACA,MAAMC,EAAgBd,EAAcF,IAAyCiB,YAC7E,GAAID,GAAgBA,aAAwBE,GAAY,CAAC,UAAW,MAAO,SAASC,SAASH,EAAaD,WAAY,CACrHhB,EAASC,GAAegB,EAAaI,WAAWV,EACjD,CACD,KAAO,CACNX,EAASC,GAAeU,CACzB,CACD,CAYA,SAASW,EACRtB,EACAC,EACAU,EACAY,GAEA,GAAKZ,EAA2Ba,KAAM,CACrCD,EAAetB,GAAeU,SACvBX,EAASC,EACjB,MAAO,GAAKU,EAAqCc,cAAe,CAC/DzB,EAASC,GAAgBU,EAAqCc,aAC/D,CACD,CAYA,SAASC,EAAkBzC,EAAiCe,GAC3D,IAAIC,EACJ,MAAMsB,EAAmD,CAAC,EAC1D,MAAMX,EAAY3B,EAAS0C,eAC3B,MAAMxB,EAAgBlB,EAAS2C,mBAE/B,IAAK3B,KAAeD,EAAU,CAC7B,MAAMW,EAAQX,EAASC,GACvB,GAAI4B,EAA2BlB,GAAQ,CACtCZ,EAAgCC,EAAUC,EAAaU,EAAOR,EAC/D,MAAO,GAAIQ,IAAU,aAAeA,IAAU,SAAU,CACvDW,EAAsBtB,EAAUC,EAAaU,EAAOY,EACrD,MAAO,UAAWZ,IAAU,SAAU,CACrCD,EAAsBV,EAAUC,EAAaU,EAAOC,EAAWT,EAAelB,EAC/E,MAAO,GAAI0B,IAAUzC,UAAW,QACxB8B,EAASC,EACjB,CACD,CACA,OAAOsB,CACR,CAUA,SAASO,EAAe7C,EAAiCe,GACxD,MAAM+B,EAAkB/B,EAAS,eACjC,GAAI+B,EAAiB,CACpB,MAAOC,EAASC,GAAcF,EAA2BG,MAAM,KAC/D,MAAMC,EAAQlD,EAAS0C,eAAeM,GACtC,GAAIE,GAASH,EAAQnB,WAAW,QAAS,CACxCb,EAASmC,EAAMC,MAAQC,EAAqBC,oBAAoBN,EACjE,CACD,QACOhC,EAAS,cACjB,CAEA,MAAMuC,EAAa,SAClBC,EACAxC,EAUAyC,EACAC,EACAC,GAEA,IAAIC,EAEJ,GAAKJ,GAA0CK,WAAY,CAC1DD,EAAgB5C,EAASpB,QAC1B,MAAO,GAAIE,EAAW0D,GAAc,CACnC,MAAMvD,EAAWuD,EAAYzD,cAC7B,GAAI0D,IAAQvE,UAAW,CACtB8B,EAAS,OAASyC,CACnB,CACA,MAAMlB,EAAiBG,EAAkBzC,EAAUe,GACnD8B,EAAe7C,EAAUe,GACzBhB,EAAoBC,EAAUe,GAC9B,MAAM8C,EAAW9C,EAAS+C,MAC1B,MAAMC,EAAShD,EAASiD,IACxB,MAAMC,EAAalD,EAASmD,QAC5B,MAAMC,EAAapD,EAASrC,GAC5B,MAAM0F,EAAerD,EAASnC,UACvBmC,EAASiD,WACTjD,EAAS+C,aACT/C,EAASmD,eACTnD,EAASrC,UACTqC,EAASnC,UACTmC,EAASpC,GAChB,MAAM0F,EAAwB,IAAId,EAAYxC,EAA8B,IAAK2C,IACjF,GAAIG,EAAU,CACbQ,EAAsBC,cAAcT,EACrC,CACA,GAAIE,EAAQ,CACXA,EAAOQ,WAAWF,EACnB,CACA,MAAMG,EAAiBH,EAAsBI,KAAK,2BAA6B,CAAC,EAChF,GAAIN,EAAY,CACfK,EAAe,eAAiB,CAAC,EACjCA,EAAe,aAAaE,SAAWP,CACxC,CACA,GAAIC,EAAc,CACjBI,EAAe,eAAiB,CAAC,EACjCA,EAAe,aAAaG,WAAaP,CAC1C,CACA,GAAI5E,OAAOC,KAAK+E,GAAgBI,OAAS,EAAG,CAC3CP,EAAsBI,KAAK,yBAA0BD,EACtD,CAEA,GAAIP,EAAY,CACf,UAAWA,IAAe,SAAU,CACnC,MAAMY,EAAcrE,EAAYC,MAAMwD,GACtC,GAAIY,EAAa,CAChBR,EAAsBS,YAAY,CACjCnE,MAAOkE,EAAYlE,OAAS1B,UAC5ByB,KAAMmE,EAAYnE,KAClBqE,WAAYF,EAAYE,YAAc9F,WAExC,KAAO,CACNoF,EAAsBS,YAAYb,EACnC,CACD,KAAO,CAENzE,OAAOC,KAAKwE,GAAY3E,QAAS0F,IAChCX,EAAsBS,YAAY,CAAEnE,MAAOqE,EAAetE,KAAMuD,EAAWe,MAE7E,CACD,CACA,IAAK,MAAMC,KAAqB3C,EAAgB,CAC/CA,EAAe2C,GACb1C,KAAMb,GACC2C,EAAsBa,YAAYD,EAAmBvD,IAE5DyD,MAAOrD,IACPD,EAAIC,MAAM,yBAAyBmD,QAAwB1B,EAAYzD,cAAciC,YAAaD,EAAO,eAE5G,CACA6B,EAAgBU,CACjB,MAAO,UAAWd,IAAgB,WAAY,CAC7C,MAAM6B,EAAgB7B,EACtBI,EAAgByB,EAAcrE,EAC/B,KAAO,CACN4C,EAAgB,IAAI0B,EAAK,CAAEC,KAAM,qBAAwB/B,GAC1D,CAEA,OAAOI,CACR,EAAE,OAEaL,CAAU","ignoreList":[]}