{"version":3,"file":"BindingToolkit.js","names":["isProperty","serviceObject","_type","_exports","EDM_TYPE_MAPPING","type","constraints","$Precision","$V4","$Scale","$MaxLength","$Nullable","unresolvableExpression","escapeXmlAttribute","inputString","replace","hasUnresolvableExpression","_len","arguments","length","expressions","Array","_key","find","expr","undefined","_checkExpressionsAreEqual","a","b","value","operand","operator","operands","every","expression","some","otherExpression","condition","onTrue","onFalse","operand1","operand2","aExpressions","bExpressions","index","pathInModel","modelName","path","targetEntitySet","fn","parameters","bindingParameters","otherFunction","obj","ref","flattenSetExpression","reduce","result","candidatesForFlattening","forEach","candidate","e","push","hasOppositeExpressions","negatedExpressions","map","not","i","and","_len2","_key2","wrapPrimitive","isStaticFalse","nonTrivialExpression","filter","isFalse","isConstant","constant","isValid","isTrue","or","_len3","_key3","isStaticTrue","isComparison","isTruthy","bindingExpression","visitedNavigationPaths","pathVisitor","targetPath","localPath","concat","join","constantValue","isArray","isPrimitiveObject","valueOf","Object","entries","plainExpression","_ref","key","val","wrappedValue","resolveBindingString","targetType","startsWith","pathInModelRegex","pathInModelRegexMatch","exec","isNaN","Number","reference","bindState","stateObjectProp","__bindingInfo","toString","model","something","isBindingToolkitExpression","maybeConstant","isPathInModelExpression","maybeBinding","isComplexTypeExpression","isConcatExpression","isIfElseExpression","isUndefinedExpression","expressionAsExpression","objectType","constructor","name","isComplexAnnotationExpression","annotationValue","getExpressionFromAnnotation","defaultValue","annotationIfExpression","$If","parseAnnotationCondition","$Not","equal","$Eq","notEqual","$Ne","greaterThan","$Gt","greaterOrEqual","$Ge","lessThan","$Lt","lessOrEqual","$Le","$Or","orCondition","$And","andCondition","annotationApplyExpression","hasOwnProperty","$Path","$Function","$Apply","resolveEnumValue","$EnumMember","ifElse","convertSubApplyParameters","applyParam","applyParamConverted","applyExpression","parameter","template","templateParams","slice","targetObject","$Name","$LabeledElement","comparison","leftOperand","rightOperand","leftExpression","rightExpression","checkUndefined","left","right","reduced","conditionExpression","onTrueExpression","onFalseExpression","pathIdx","myIfElseExpression","formatResult","allParts","transformRecursively","constantPath","unshift","JSON","stringify","hasReferenceToDefaultContext","formatterFunction","contextEntityType","ignoreComplexType","parameterExpressions","keys","functionName","__functionName","formatterClass","formatterName","split","myFormatExpression","setUpConstraints","targetMapping","property","scale","precision","maxLength","nullable","annotations","Validation","Minimum","minimum","Maximum","maximum","Common","IsDigitSequence","isDigitSequence","V4","formatWithTypeInformation","propertyBindingExpression","ignoreConstraints","outExpression","formatOptions","indexOf","assign","parseAsString","parseKeepsEmptyString","fiscalType","getFiscalType","typesSupportingParseEmptyValueToZero","includes","parseEmptyValueToZero","emptyString","IsFiscalYear","IsFiscalPeriod","IsFiscalYearPeriod","IsFiscalQuarter","IsFiscalYearQuarter","IsFiscalWeek","IsFiscalYearWeek","IsDayOfFiscalYear","addTypeInformation","oFormatOptions","oConstraintOptions","_getComplexTypeFormatOptionsFromFirstParam","uomPath","mode","preserveDecimals","skipDecimalsValidation","currencyPath","decimals","param","showNumber","showMeasure","decimalPadding","func","on","isFormattingFn","isEmpty","aBindings","finalExpression","alwaysKeepTargetType","_len4","inExpressions","_key4","concatenated","myConcatExpression","inExpression","expressionType","transformFunction","includeAllExpression","subExpression","bindingParameter","needParenthesis","compileConstantObject","isNullable","objects","properties","childResult","compileExpression","compileConstant","embeddedInBinding","doNotStringify","compilePathInModelExpression","expressionForBinding","embeddedSeparator","complexBindingDefinition","compilePathInModel","outBinding","separator","compileComplexTypeExpression","compilePathParameter","outputEnd","hasElements","wrapBindingExpression","parenthesisRequired","keepTargetType","hasEmbeddedFunctionCallOrBinding","subFn","subSubFn","argumentString","arg","fnCall","substring","comparisonExpression","compileComparisonExpression","ifElseExpression","setExpression","concatExpression","nestedExpression","lengthExpression","notExpression","truthyExpression","formatterExpression","compileFormatterExpression","complexTypeExpression","compileOperand","compiledOperand","parts","singlePath","outValue"],"sources":["./BindingToolkit.ts"],"sourcesContent":["import type {\n\tActionParameter,\n\tAndAnnotationExpression,\n\tAndConditionalExpression,\n\tApplyAnnotationExpression,\n\tBoolean,\n\tConditionalCheckOrValue,\n\tEntitySet,\n\tEntityType,\n\tEqAnnotationExpression,\n\tEqConditionalExpression,\n\tGeAnnotationExpression,\n\tGeConditionalExpression,\n\tGtAnnotationExpression,\n\tGtConditionalExpression,\n\tIfAnnotationExpression,\n\tIfAnnotationExpressionValue,\n\tLeAnnotationExpression,\n\tLeConditionalExpression,\n\tLtAnnotationExpression,\n\tLtConditionalExpression,\n\tNeAnnotationExpression,\n\tNeConditionalExpression,\n\tNotAnnotationExpression,\n\tNotConditionalExpression,\n\tOrAnnotationExpression,\n\tOrConditionalExpression,\n\tPathAnnotationExpression,\n\tPathConditionExpression,\n\tProperty,\n\tPropertyAnnotationValue,\n\tConstantExpression as VocabConstantExpression\n} from \"@sap-ux/vocabularies-types\";\nimport { CommonAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport { resolveEnumValue } from \"sap/fe/base/AnnotationEnum\";\nimport type { BindingInfoHolder } from \"sap/fe/base/ClassSupport\";\n\nexport type PrimitiveType = string | number | bigint | boolean | object | null | undefined;\ntype DefinedPrimitiveType = string | number | bigint | boolean | object;\ntype PrimitiveTypeCast<P> = P extends String ? string : P extends Boolean ? boolean : P extends Number ? number : P;\ntype BaseExpression<_T> = {\n\t_type: string;\n};\n\nexport type FormatOptions = Partial<{\n\tcustomUnits: Record<string, object>;\n\tcustomCurrencies: Record<string, object>;\n\tdecimals: number;\n\temptyString: null | number | string;\n\tfiscalType: string;\n\tgroupingEnabled: boolean;\n\tmaxFractionDigits: number;\n\tmaxIntegerDigits: number;\n\tminFractionDigits: number;\n\tminIntegerDigits: number;\n\tparseAsString: boolean;\n\tparseKeepsEmptyString: boolean;\n\tpattern: string;\n\tprecision: number;\n\tpreserveDecimals: boolean;\n\tshortDecimals: number;\n\tshortRefNumber: number;\n\tshowMeasure: boolean;\n\tshowNumber: boolean;\n\tshowScale: boolean;\n\tstyle: string;\n}>;\n\nexport type ConstantExpression<T> = BaseExpression<T> & {\n\t_type: \"Constant\";\n\tvalue: T;\n};\n\ntype SetOperator = \"&&\" | \"||\";\nexport type SetExpression = BaseExpression<boolean> & {\n\t_type: \"Set\";\n\toperator: SetOperator;\n\toperands: BindingToolkitExpression<boolean>[];\n};\n\nexport type NotExpression = BaseExpression<boolean> & {\n\t_type: \"Not\";\n\toperand: BindingToolkitExpression<boolean>;\n};\n\nexport type TruthyExpression = BaseExpression<boolean> & {\n\t_type: \"Truthy\";\n\toperand: BindingToolkitExpression<string>;\n};\n\nexport type ReferenceExpression = BaseExpression<object> & {\n\t_type: \"Ref\";\n\tref: string | null;\n};\n\nexport type FormatterExpression<T> = BaseExpression<T> & {\n\t_type: \"Formatter\";\n\tfn: string;\n\tparameters: BindingToolkitExpression<unknown>[];\n};\n\ntype ComplexTypeExpression<T> = BaseExpression<T> & {\n\t_type: \"ComplexType\";\n\ttype: string;\n\tformatOptions: FormatOptions;\n\tconstraints: object;\n\tparameters: object;\n\tbindingParameters: BindingToolkitExpression<unknown>[];\n};\n\nexport type FunctionExpression<T> = BaseExpression<T> & {\n\t_type: \"Function\";\n\tobj?: BindingToolkitExpression<object>;\n\tfn: string;\n\tisFormattingFn: boolean;\n\tparameters: BindingToolkitExpression<unknown>[];\n};\n\nexport type ConcatExpression = BaseExpression<string> & {\n\t_type: \"Concat\";\n\texpressions: BindingToolkitExpression<string>[];\n};\n\nexport type LengthExpression = BaseExpression<string> & {\n\t_type: \"Length\";\n\tpathInModel: PathInModelExpression<unknown>;\n};\n\ntype UnresolvablePathExpression = BaseExpression<string> & {\n\t_type: \"Unresolvable\";\n};\n\n/**\n * @typedef PathInModelExpression\n */\nexport type PathInModelExpression<T> = BaseExpression<T> & {\n\t_type: \"PathInModel\";\n\tmodelName?: string;\n\tpath: string;\n\ttargetEntitySet?: EntitySet;\n\ttype?: string;\n\tconstraints?: BindingConstraints;\n\tparameters?: object;\n\ttargetType?: string;\n\tmode?: string;\n\tformatOptions?: FormatOptions;\n\talwaysKeepTargetType?: boolean;\n};\n\nexport type EmbeddedUI5BindingExpression<T> = BaseExpression<T> & {\n\t_type: \"EmbeddedBinding\";\n\tvalue: string;\n};\n\nexport type EmbeddedUI5ExpressionBindingExpression<T> = BaseExpression<T> & {\n\t_type: \"EmbeddedExpressionBinding\";\n\tvalue: string;\n};\n\nexport type ComparisonOperator = \"===\" | \"!==\" | \">=\" | \">\" | \"<=\" | \"<\";\nexport type ComparisonExpression = BaseExpression<boolean> & {\n\t_type: \"Comparison\";\n\toperator: ComparisonOperator;\n\toperand1: BindingToolkitExpression<unknown>;\n\toperand2: BindingToolkitExpression<unknown>;\n};\n\nexport type IfElseExpression<T> = BaseExpression<T> & {\n\t_type: \"IfElse\";\n\tcondition: BindingToolkitExpression<boolean>;\n\tonTrue: BindingToolkitExpression<T>;\n\tonFalse: BindingToolkitExpression<T>;\n};\nexport function isProperty(serviceObject: unknown): serviceObject is Property {\n\treturn (serviceObject as Property)?._type === \"Property\";\n}\n\n/**\n * An expression that evaluates to type T.\n * @typedef BindingToolkitExpression\n */\nexport type BindingToolkitExpression<T> =\n\t| UnresolvablePathExpression\n\t| ConstantExpression<T>\n\t| SetExpression\n\t| NotExpression\n\t| TruthyExpression\n\t| ConcatExpression\n\t| LengthExpression\n\t| PathInModelExpression<T>\n\t| EmbeddedUI5BindingExpression<T>\n\t| EmbeddedUI5ExpressionBindingExpression<T>\n\t| ComparisonExpression\n\t| IfElseExpression<T>\n\t| FormatterExpression<T>\n\t| ComplexTypeExpression<T>\n\t| ReferenceExpression\n\t| FunctionExpression<T>;\n\ntype TypeMappingDefinition = {\n\ttype: string;\n\tconstraints?: {\n\t\t$Precision?: string;\n\t\t$V4?: string;\n\t\t$Scale?: string;\n\t\t$MaxLength?: string;\n\t\t$Nullable?: string;\n\t\t\"@Org.OData.Validation.V1.Minimum/$Decimal\"?: string;\n\t\t\"@Org.OData.Validation.V1.Minimum@Org.OData.Validation.V1.Exclusive\"?: string;\n\t\t\"@Org.OData.Validation.V1.Maximum/$Decimal\"?: string;\n\t\t\"@Org.OData.Validation.V1.Maximum@Org.OData.Validation.V1.Exclusive\"?: string;\n\t\t\"@com.sap.vocabularies.Common.v1.IsDigitSequence\"?: string;\n\t};\n};\nexport const EDM_TYPE_MAPPING: Record<string, TypeMappingDefinition> = {\n\t\"Edm.Boolean\": { type: \"sap.ui.model.odata.type.Boolean\" },\n\t\"Edm.Byte\": { type: \"sap.ui.model.odata.type.Byte\" },\n\t\"Edm.Date\": { type: \"sap.ui.model.odata.type.Date\" },\n\t\"Edm.DateTimeOffset\": {\n\t\tconstraints: {\n\t\t\t$Precision: \"precision\",\n\t\t\t$V4: \"V4\"\n\t\t},\n\t\ttype: \"sap.ui.model.odata.type.DateTimeOffset\"\n\t},\n\t\"Edm.Decimal\": {\n\t\tconstraints: {\n\t\t\t\"@Org.OData.Validation.V1.Minimum/$Decimal\": \"minimum\",\n\t\t\t\"@Org.OData.Validation.V1.Minimum@Org.OData.Validation.V1.Exclusive\": \"minimumExclusive\",\n\t\t\t\"@Org.OData.Validation.V1.Maximum/$Decimal\": \"maximum\",\n\t\t\t\"@Org.OData.Validation.V1.Maximum@Org.OData.Validation.V1.Exclusive\": \"maximumExclusive\",\n\t\t\t$Precision: \"precision\",\n\t\t\t$Scale: \"scale\"\n\t\t},\n\t\ttype: \"sap.ui.model.odata.type.Decimal\"\n\t},\n\t\"Edm.Double\": { type: \"sap.ui.model.odata.type.Double\" },\n\t\"Edm.Guid\": { type: \"sap.ui.model.odata.type.Guid\" },\n\t\"Edm.Int16\": { type: \"sap.ui.model.odata.type.Int16\" },\n\t\"Edm.Int32\": { type: \"sap.ui.model.odata.type.Int32\" },\n\t\"Edm.Int64\": { type: \"sap.ui.model.odata.type.Int64\" },\n\t\"Edm.SByte\": { type: \"sap.ui.model.odata.type.SByte\" },\n\t\"Edm.Single\": { type: \"sap.ui.model.odata.type.Single\" },\n\t\"Edm.Stream\": { type: \"sap.ui.model.odata.type.Stream\" },\n\t\"Edm.Binary\": { type: \"sap.ui.model.odata.type.Stream\" },\n\t\"Edm.String\": {\n\t\tconstraints: {\n\t\t\t\"@com.sap.vocabularies.Common.v1.IsDigitSequence\": \"isDigitSequence\",\n\t\t\t$MaxLength: \"maxLength\",\n\t\t\t$Nullable: \"nullable\"\n\t\t},\n\t\ttype: \"sap.ui.model.odata.type.String\"\n\t},\n\t\"Edm.TimeOfDay\": {\n\t\tconstraints: {\n\t\t\t$Precision: \"precision\"\n\t\t},\n\t\ttype: \"sap.ui.model.odata.type.TimeOfDay\"\n\t}\n};\n\n/**\n * An expression that evaluates to type T, or a constant value of type T\n */\nexport type ExpressionOrPrimitive<T extends PrimitiveType> = BindingToolkitExpression<T> | T;\n\nexport const unresolvableExpression: UnresolvablePathExpression = {\n\t_type: \"Unresolvable\"\n};\n\nexport function escapeXmlAttribute(inputString: string): string {\n\treturn inputString.replace(/'/g, \"\\\\'\");\n}\n\nexport function hasUnresolvableExpression(...expressions: BindingToolkitExpression<unknown>[]): boolean {\n\treturn expressions.find((expr) => expr._type === \"Unresolvable\") !== undefined;\n}\n/**\n * Check two expressions for (deep) equality.\n * @param a\n * @param b\n * @returns `true` if the two expressions are equal\n */\nexport function _checkExpressionsAreEqual<T>(a: BindingToolkitExpression<T>, b: BindingToolkitExpression<T>): boolean {\n\tif (a._type !== b._type) {\n\t\treturn false;\n\t}\n\n\tswitch (a._type) {\n\t\tcase \"Unresolvable\":\n\t\t\treturn false; // Unresolvable is never equal to anything even itself\n\t\tcase \"Constant\":\n\t\tcase \"EmbeddedBinding\":\n\t\tcase \"EmbeddedExpressionBinding\":\n\t\t\treturn a.value === (b as ConstantExpression<T>).value;\n\n\t\tcase \"Not\":\n\t\t\treturn _checkExpressionsAreEqual(a.operand, (b as NotExpression).operand);\n\t\tcase \"Truthy\":\n\t\t\treturn _checkExpressionsAreEqual(a.operand, (b as TruthyExpression).operand);\n\t\tcase \"Set\":\n\t\t\treturn (\n\t\t\t\ta.operator === (b as SetExpression).operator &&\n\t\t\t\ta.operands.length === (b as SetExpression).operands.length &&\n\t\t\t\ta.operands.every((expression) =>\n\t\t\t\t\t(b as SetExpression).operands.some((otherExpression) => _checkExpressionsAreEqual(expression, otherExpression))\n\t\t\t\t)\n\t\t\t);\n\n\t\tcase \"IfElse\":\n\t\t\treturn (\n\t\t\t\t_checkExpressionsAreEqual(a.condition, (b as IfElseExpression<T>).condition) &&\n\t\t\t\t_checkExpressionsAreEqual(a.onTrue, (b as IfElseExpression<T>).onTrue) &&\n\t\t\t\t_checkExpressionsAreEqual(a.onFalse, (b as IfElseExpression<T>).onFalse)\n\t\t\t);\n\n\t\tcase \"Comparison\":\n\t\t\treturn (\n\t\t\t\ta.operator === (b as ComparisonExpression).operator &&\n\t\t\t\t_checkExpressionsAreEqual(a.operand1, (b as ComparisonExpression).operand1) &&\n\t\t\t\t_checkExpressionsAreEqual(a.operand2, (b as ComparisonExpression).operand2)\n\t\t\t);\n\n\t\tcase \"Concat\":\n\t\t\tconst aExpressions = a.expressions;\n\t\t\tconst bExpressions = (b as ConcatExpression).expressions;\n\t\t\tif (aExpressions.length !== bExpressions.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn aExpressions.every((expression, index) => {\n\t\t\t\treturn _checkExpressionsAreEqual(expression, bExpressions[index]);\n\t\t\t});\n\n\t\tcase \"Length\":\n\t\t\treturn _checkExpressionsAreEqual(a.pathInModel, (b as LengthExpression).pathInModel);\n\n\t\tcase \"PathInModel\":\n\t\t\treturn (\n\t\t\t\ta.modelName === (b as PathInModelExpression<T>).modelName &&\n\t\t\t\ta.path === (b as PathInModelExpression<T>).path &&\n\t\t\t\ta.targetEntitySet === (b as PathInModelExpression<T>).targetEntitySet\n\t\t\t);\n\n\t\tcase \"Formatter\":\n\t\t\treturn (\n\t\t\t\ta.fn === (b as FormatterExpression<T>).fn &&\n\t\t\t\ta.parameters.length === (b as FormatterExpression<T>).parameters.length &&\n\t\t\t\ta.parameters.every((value, index) => _checkExpressionsAreEqual((b as FormatterExpression<T>).parameters[index], value))\n\t\t\t);\n\t\tcase \"ComplexType\":\n\t\t\treturn (\n\t\t\t\ta.type === (b as ComplexTypeExpression<T>).type &&\n\t\t\t\ta.bindingParameters.length === (b as ComplexTypeExpression<T>).bindingParameters.length &&\n\t\t\t\ta.bindingParameters.every((value, index) =>\n\t\t\t\t\t_checkExpressionsAreEqual((b as ComplexTypeExpression<T>).bindingParameters[index], value)\n\t\t\t\t)\n\t\t\t);\n\t\tcase \"Function\":\n\t\t\tconst otherFunction = b as FunctionExpression<T>;\n\t\t\tif (a.obj === undefined || otherFunction.obj === undefined) {\n\t\t\t\treturn a.obj === otherFunction;\n\t\t\t}\n\n\t\t\treturn (\n\t\t\t\ta.fn === otherFunction.fn &&\n\t\t\t\t_checkExpressionsAreEqual(a.obj, otherFunction.obj) &&\n\t\t\t\ta.parameters.length === otherFunction.parameters.length &&\n\t\t\t\ta.parameters.every((value, index) => _checkExpressionsAreEqual(otherFunction.parameters[index], value))\n\t\t\t);\n\n\t\tcase \"Ref\":\n\t\t\treturn a.ref === (b as ReferenceExpression).ref;\n\t}\n\treturn false;\n}\n\n/**\n * Converts a nested SetExpression by inlining operands of type SetExpression with the same operator.\n * @param expression The expression to flatten\n * @returns A new SetExpression with the same operator\n */\nfunction flattenSetExpression(expression: SetExpression): SetExpression {\n\treturn expression.operands.reduce(\n\t\t(result: SetExpression, operand) => {\n\t\t\tconst candidatesForFlattening =\n\t\t\t\toperand._type === \"Set\" && operand.operator === expression.operator ? operand.operands : [operand];\n\t\t\tcandidatesForFlattening.forEach((candidate) => {\n\t\t\t\tif (result.operands.every((e) => !_checkExpressionsAreEqual(e, candidate))) {\n\t\t\t\t\tresult.operands.push(candidate);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn result;\n\t\t},\n\t\t{ _type: \"Set\", operator: expression.operator, operands: [] }\n\t);\n}\n\n/**\n * Detects whether an array of boolean expressions contains an expression and its negation.\n * @param expressions Array of expressions\n * @returns `true` if the set of expressions contains an expression and its negation\n */\nfunction hasOppositeExpressions(expressions: BindingToolkitExpression<boolean>[]): boolean {\n\tconst negatedExpressions = expressions.map(not);\n\treturn expressions.some((expression, index) => {\n\t\tfor (let i = index + 1; i < negatedExpressions.length; i++) {\n\t\t\tif (_checkExpressionsAreEqual(expression, negatedExpressions[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t});\n}\n\n/**\n * Logical `and` expression.\n *\n * The expression is simplified to false if this can be decided statically (that is, if one operand is a constant\n * false or if the expression contains an operand and its negation).\n * @param operands Expressions to connect by `and`\n * @returns Expression evaluating to boolean\n */\nexport function and(...operands: ExpressionOrPrimitive<boolean>[]): BindingToolkitExpression<boolean> {\n\tconst expressions = flattenSetExpression({\n\t\t_type: \"Set\",\n\t\toperator: \"&&\",\n\t\toperands: operands.map(wrapPrimitive)\n\t}).operands;\n\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet isStaticFalse = false;\n\tconst nonTrivialExpression = expressions.filter((expression) => {\n\t\tif (isFalse(expression)) {\n\t\t\tisStaticFalse = true;\n\t\t}\n\t\treturn !isConstant(expression);\n\t});\n\tif (isStaticFalse) {\n\t\treturn constant(false);\n\t} else if (nonTrivialExpression.length === 0) {\n\t\t// Resolve the constant then\n\t\tconst isValid = expressions.reduce((result, expression) => result && isTrue(expression), true);\n\t\treturn constant(isValid);\n\t} else if (nonTrivialExpression.length === 1) {\n\t\treturn nonTrivialExpression[0];\n\t} else if (hasOppositeExpressions(nonTrivialExpression)) {\n\t\treturn constant(false);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Set\",\n\t\t\toperator: \"&&\",\n\t\t\toperands: nonTrivialExpression\n\t\t};\n\t}\n}\n\n/**\n * Logical `or` expression.\n *\n * The expression is simplified to true if this can be decided statically (that is, if one operand is a constant\n * true or if the expression contains an operand and its negation).\n * @param operands Expressions to connect by `or`\n * @returns Expression evaluating to boolean\n */\nexport function or(...operands: ExpressionOrPrimitive<boolean>[]): BindingToolkitExpression<boolean> {\n\tconst expressions = flattenSetExpression({\n\t\t_type: \"Set\",\n\t\toperator: \"||\",\n\t\toperands: operands.map(wrapPrimitive)\n\t}).operands;\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet isStaticTrue = false;\n\tconst nonTrivialExpression = expressions.filter((expression) => {\n\t\tif (isTrue(expression)) {\n\t\t\tisStaticTrue = true;\n\t\t}\n\t\treturn !isConstant(expression) || expression.value;\n\t});\n\tif (isStaticTrue) {\n\t\treturn constant(true);\n\t} else if (nonTrivialExpression.length === 0) {\n\t\t// Resolve the constant then\n\t\tconst isValid = expressions.reduce((result, expression) => result && isTrue(expression), true);\n\t\treturn constant(isValid);\n\t} else if (nonTrivialExpression.length === 1) {\n\t\treturn nonTrivialExpression[0];\n\t} else if (hasOppositeExpressions(nonTrivialExpression)) {\n\t\treturn constant(true);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Set\",\n\t\t\toperator: \"||\",\n\t\t\toperands: nonTrivialExpression\n\t\t};\n\t}\n}\n\n/**\n * Logical `not` operator.\n * @param operand The expression to reverse\n * @returns The resulting expression that evaluates to boolean\n */\nexport function not(operand: ExpressionOrPrimitive<boolean>): BindingToolkitExpression<boolean> {\n\toperand = wrapPrimitive(operand);\n\tif (hasUnresolvableExpression(operand)) {\n\t\treturn unresolvableExpression;\n\t} else if (isConstant(operand)) {\n\t\treturn constant(!operand.value);\n\t} else if (\n\t\ttypeof operand === \"object\" &&\n\t\toperand._type === \"Set\" &&\n\t\toperand.operator === \"||\" &&\n\t\toperand.operands.every((expression) => isConstant(expression) || isComparison(expression))\n\t) {\n\t\treturn and(...operand.operands.map((expression) => not(expression)));\n\t} else if (\n\t\ttypeof operand === \"object\" &&\n\t\toperand._type === \"Set\" &&\n\t\toperand.operator === \"&&\" &&\n\t\toperand.operands.every((expression) => isConstant(expression) || isComparison(expression))\n\t) {\n\t\treturn or(...operand.operands.map((expression) => not(expression)));\n\t} else if (isComparison(operand)) {\n\t\t// Create the reverse comparison\n\t\tswitch (operand.operator) {\n\t\t\tcase \"!==\":\n\t\t\t\treturn { ...operand, operator: \"===\" };\n\t\t\tcase \"<\":\n\t\t\t\treturn { ...operand, operator: \">=\" };\n\t\t\tcase \"<=\":\n\t\t\t\treturn { ...operand, operator: \">\" };\n\t\t\tcase \"===\":\n\t\t\t\treturn { ...operand, operator: \"!==\" };\n\t\t\tcase \">\":\n\t\t\t\treturn { ...operand, operator: \"<=\" };\n\t\t\tcase \">=\":\n\t\t\t\treturn { ...operand, operator: \"<\" };\n\t\t}\n\t} else if (operand._type === \"Not\") {\n\t\treturn operand.operand;\n\t}\n\n\treturn {\n\t\t_type: \"Not\",\n\t\toperand: operand\n\t};\n}\n\n/**\n * Evaluates whether a binding expression is equal to true with a loose equality.\n * @param operand The expression to check\n * @returns The resulting expression that evaluates to boolean\n */\nexport function isTruthy(operand: BindingToolkitExpression<string>): BindingToolkitExpression<boolean> {\n\tif (isConstant(operand)) {\n\t\treturn constant(!!operand.value);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Truthy\",\n\t\t\toperand: operand\n\t\t};\n\t}\n}\n\n/**\n * Creates a binding expression that will be evaluated by the corresponding model.\n * @param path\n * @param modelName\n * @param visitedNavigationPaths\n * @param pathVisitor\n * @returns An expression representating that path in the model\n * @deprecated use pathInModel instead\n */\nexport function bindingExpression<TargetType extends PrimitiveType>(\n\tpath: string,\n\tmodelName?: string,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): PathInModelExpression<TargetType> | UnresolvablePathExpression {\n\treturn pathInModel(path, modelName, visitedNavigationPaths, pathVisitor);\n}\n\n/**\n * Creates a binding expression that will be evaluated by the corresponding model.\n * @template TargetType\n * @param path The path on the model\n * @param [modelName] The name of the model\n * @param [visitedNavigationPaths] The paths from the root entitySet\n * @param [pathVisitor] A function to modify the resulting path\n * @returns An expression representating that path in the model\n */\nexport function pathInModel(\n\tpath: undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: Function\n): UnresolvablePathExpression;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: undefined\n): PathInModelExpression<TargetType>;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string | undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: Function\n): UnresolvablePathExpression | PathInModelExpression<TargetType>;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string | undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): UnresolvablePathExpression | PathInModelExpression<TargetType> {\n\tif (path === undefined) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet targetPath;\n\tif (pathVisitor) {\n\t\ttargetPath = pathVisitor(path);\n\t\tif (targetPath === undefined) {\n\t\t\treturn unresolvableExpression;\n\t\t}\n\t} else {\n\t\tconst localPath = visitedNavigationPaths.concat();\n\t\tlocalPath.push(path);\n\t\ttargetPath = localPath.join(\"/\");\n\t}\n\treturn {\n\t\t_type: \"PathInModel\",\n\t\tmodelName: modelName,\n\t\tpath: targetPath\n\t};\n}\n\ntype PlainExpressionObject = { [index: string]: BindingToolkitExpression<unknown> };\n\n/**\n * Creates a constant expression based on a primitive value.\n * @template T\n * @param value The constant to wrap in an expression\n * @returns The constant expression\n */\nexport function constant<T extends PrimitiveType>(value: T): ConstantExpression<T> {\n\tlet constantValue: T;\n\n\tif (typeof value === \"object\" && value !== null && value !== undefined) {\n\t\tif (Array.isArray(value)) {\n\t\t\tconstantValue = value.map(wrapPrimitive) as T;\n\t\t} else if (isPrimitiveObject(value)) {\n\t\t\tconstantValue = value.valueOf() as T;\n\t\t} else {\n\t\t\tconstantValue = Object.entries(value).reduce((plainExpression, [key, val]) => {\n\t\t\t\tconst wrappedValue = wrapPrimitive(val);\n\t\t\t\tif (wrappedValue._type !== \"Constant\" || wrappedValue.value !== undefined) {\n\t\t\t\t\tplainExpression[key] = wrappedValue;\n\t\t\t\t}\n\t\t\t\treturn plainExpression;\n\t\t\t}, {} as PlainExpressionObject) as T;\n\t\t}\n\t} else {\n\t\tconstantValue = value;\n\t}\n\n\treturn { _type: \"Constant\", value: constantValue };\n}\n\nexport function resolveBindingString<T extends PrimitiveType>(\n\tvalue: string | boolean | number,\n\ttargetType?: string\n): ConstantExpression<T> | PathInModelExpression<T> | EmbeddedUI5BindingExpression<T> | EmbeddedUI5ExpressionBindingExpression<T> {\n\tif (value !== undefined && typeof value === \"string\" && value.startsWith(\"{\")) {\n\t\tconst pathInModelRegex = /^{(.*)>(.+)}$/; // Matches model paths like \"model>path\" or \">path\" (default model)\n\t\tconst pathInModelRegexMatch = pathInModelRegex.exec(value);\n\n\t\tif (value.startsWith(\"{=\")) {\n\t\t\t// Expression binding, we can just remove the outer binding things\n\t\t\treturn {\n\t\t\t\t_type: \"EmbeddedExpressionBinding\",\n\t\t\t\tvalue: value\n\t\t\t};\n\t\t} else if (pathInModelRegexMatch) {\n\t\t\treturn pathInModel(pathInModelRegexMatch[2] || \"\", pathInModelRegexMatch[1] || undefined);\n\t\t} else {\n\t\t\treturn {\n\t\t\t\t_type: \"EmbeddedBinding\",\n\t\t\t\tvalue: value\n\t\t\t};\n\t\t}\n\t} else if (targetType === \"boolean\" && typeof value === \"string\" && (value === \"true\" || value === \"false\")) {\n\t\treturn constant(value === \"true\") as ConstantExpression<T>;\n\t} else if (targetType === \"number\" && typeof value === \"string\" && (!isNaN(Number(value)) || value === \"NaN\")) {\n\t\treturn constant(Number(value)) as ConstantExpression<T>;\n\t} else {\n\t\treturn constant(value) as ConstantExpression<T>;\n\t}\n}\n\n/**\n * A named reference.\n * @see fn\n * @param reference Reference\n * @returns The object reference binding part\n */\nexport function ref(reference: string | null): ReferenceExpression {\n\treturn { _type: \"Ref\", ref: reference };\n}\n\n/**\n * Wrap a state object into a path in model expression.\n * @template T\n * @param stateObjectProp The object to evaluate, if it's a constant it will be wrapped in a constant expression, if it's a state property it will be bound\n * @param key The key of the state object to bind\n * @returns The correct binding toolkit expression\n */\nexport function bindState<T extends object, K extends PrimitiveType>(\n\tstateObjectProp: T,\n\tkey: keyof T\n): PathInModelExpression<K> | ConstantExpression<K> {\n\tif (typeof stateObjectProp === \"object\" && (stateObjectProp as BindingInfoHolder<T>).__bindingInfo) {\n\t\treturn pathInModel(\"/\" + key.toString(), (stateObjectProp as BindingInfoHolder<T>).__bindingInfo.model);\n\t} else {\n\t\treturn constant(stateObjectProp) as unknown as ConstantExpression<K>;\n\t}\n}\n/**\n * Wrap a primitive into a constant expression if it is not already an expression.\n * @template T\n * @param something The object to wrap in a Constant expression\n * @returns Either the original object or the wrapped one depending on the case\n */\nexport function wrapPrimitive<T extends PrimitiveType>(something: ExpressionOrPrimitive<T>): BindingToolkitExpression<T> {\n\tif (isBindingToolkitExpression(something)) {\n\t\treturn something as BindingToolkitExpression<T>;\n\t}\n\n\treturn constant(something);\n}\n\n/**\n * Checks if the expression or value provided is a binding tooling expression or not.\n *\n * Every object having a property named `_type` of some value is considered an expression, even if there is actually\n * no such expression type supported.\n * @param expression\n * @returns `true` if the expression is a binding toolkit expression\n */\nexport function isBindingToolkitExpression(\n\texpression: BindingToolkitExpression<unknown> | unknown\n): expression is BindingToolkitExpression<unknown> {\n\treturn (expression as BindingToolkitExpression<unknown>)?._type !== undefined;\n}\n\n/**\n * Checks if the expression or value provided is constant or not.\n * @template T The target type\n * @param  maybeConstant The expression or primitive value that is to be checked\n * @returns `true` if it is constant\n */\nexport function isConstant<T extends PrimitiveType>(maybeConstant: ExpressionOrPrimitive<T>): maybeConstant is ConstantExpression<T> {\n\treturn typeof maybeConstant !== \"object\" || (maybeConstant as BaseExpression<T>)._type === \"Constant\";\n}\n\nfunction isTrue(expression: BindingToolkitExpression<PrimitiveType>): boolean {\n\treturn isConstant(expression) && expression.value === true;\n}\n\nfunction isFalse(expression: BindingToolkitExpression<PrimitiveType>): boolean {\n\treturn isConstant(expression) && expression.value === false;\n}\n\n/**\n * Checks if the expression or value provided is a path in model expression or not.\n * @template T The target type\n * @param  maybeBinding The expression or primitive value that is to be checked\n * @returns `true` if it is a path in model expression\n */\nexport function isPathInModelExpression<T extends PrimitiveType>(\n\tmaybeBinding: ExpressionOrPrimitive<T>\n): maybeBinding is PathInModelExpression<T> {\n\treturn (maybeBinding as BaseExpression<T>)?._type === \"PathInModel\";\n}\n\n/**\n * Checks if the expression or value provided is a complex type expression.\n * @template T The target type\n * @param  maybeBinding The expression or primitive value that is to be checked\n * @returns `true` if it is a path in model expression\n */\nexport function isComplexTypeExpression<T extends PrimitiveType>(\n\tmaybeBinding: ExpressionOrPrimitive<T>\n): maybeBinding is ComplexTypeExpression<T> {\n\treturn (maybeBinding as BaseExpression<T>)?._type === \"ComplexType\";\n}\n\n/**\n * Checks if the expression or value provided is a concat expression or not.\n * @param expression\n * @returns `true` if the expression is a ConcatExpression\n */\nfunction isConcatExpression(expression: BindingToolkitExpression<PrimitiveType>): expression is ConcatExpression {\n\treturn (expression as BaseExpression<PrimitiveType>)?._type === \"Concat\";\n}\n\n/**\n * Checks if the expression or value provided is a IfElse expression or not.\n * @param expression\n * @returns `true` if the expression is a IfElseExpression\n */\nfunction isIfElseExpression(expression: BindingToolkitExpression<PrimitiveType>): expression is ConcatExpression {\n\treturn (expression as BaseExpression<PrimitiveType>)?._type === \"IfElse\";\n}\n\n/**\n * Checks if the expression provided is a comparison or not.\n * @template T The target type\n * @param expression The expression\n * @returns `true` if the expression is a ComparisonExpression\n */\nfunction isComparison<T extends PrimitiveType>(expression: BindingToolkitExpression<T>): expression is ComparisonExpression {\n\treturn expression._type === \"Comparison\";\n}\n\n/**\n * Checks whether the input parameter is a constant expression of type undefined.\n * @param expression The input expression or object in general\n * @returns `true` if the input is constant which has undefined for value\n */\nexport function isUndefinedExpression(expression: unknown): expression is ConstantExpression<undefined> {\n\tconst expressionAsExpression = expression as BindingToolkitExpression<unknown>;\n\treturn expressionAsExpression?._type === \"Constant\" && expressionAsExpression?.value === undefined;\n}\n\ntype ComplexAnnotationExpression<P> =\n\t| PathAnnotationExpression<P>\n\t| ApplyAnnotationExpression<P>\n\t| IfAnnotationExpression<P>\n\t| OrAnnotationExpression<P>\n\t| AndAnnotationExpression<P>\n\t| NeAnnotationExpression<P>\n\t| EqAnnotationExpression<P>\n\t| NotAnnotationExpression<P>\n\t| GtAnnotationExpression<P>\n\t| GeAnnotationExpression<P>\n\t| LeAnnotationExpression<P>\n\t| LtAnnotationExpression<P>\n\t| VocabConstantExpression<P>;\n\nfunction isPrimitiveObject(objectType: object): boolean {\n\tswitch (objectType.constructor.name) {\n\t\tcase \"String\":\n\t\tcase \"Number\":\n\t\tcase \"Boolean\":\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n/**\n * Check if the passed annotation annotationValue is a ComplexAnnotationExpression.\n * @template T The target type\n * @param  annotationValue The annotation annotationValue to evaluate\n * @returns `true` if the object is a {ComplexAnnotationExpression}\n */\nfunction isComplexAnnotationExpression<T>(annotationValue: PropertyAnnotationValue<T>): annotationValue is ComplexAnnotationExpression<T> {\n\treturn typeof annotationValue === \"object\" && !isPrimitiveObject(annotationValue as object);\n}\n\n/**\n * Generate the corresponding annotationValue for a given annotation annotationValue.\n * @template T The target type\n * @param annotationValue The source annotation annotationValue\n * @param visitedNavigationPaths The path from the root entity set\n * @param defaultValue Default value if the annotationValue is undefined\n * @param pathVisitor A function to modify the resulting path\n * @returns The annotationValue equivalent to that annotation annotationValue\n */\nexport function getExpressionFromAnnotation<T extends PrimitiveType>(\n\tannotationValue: PropertyAnnotationValue<T> | undefined,\n\tvisitedNavigationPaths: string[] = [],\n\tdefaultValue?: ExpressionOrPrimitive<T>,\n\tpathVisitor?: Function\n): BindingToolkitExpression<PrimitiveTypeCast<T>> {\n\tif (annotationValue === undefined) {\n\t\treturn wrapPrimitive(defaultValue as PrimitiveTypeCast<T>);\n\t}\n\tannotationValue = annotationValue?.valueOf() as PropertyAnnotationValue<T>;\n\tif (!isComplexAnnotationExpression(annotationValue)) {\n\t\treturn constant(annotationValue);\n\t}\n\n\tswitch (annotationValue.type) {\n\t\tcase \"Path\":\n\t\t\treturn pathInModel(annotationValue.path, undefined, visitedNavigationPaths, pathVisitor);\n\t\tcase \"If\":\n\t\t\treturn annotationIfExpression(annotationValue.$If, visitedNavigationPaths, pathVisitor) as BindingToolkitExpression<\n\t\t\t\tPrimitiveTypeCast<T>\n\t\t\t>;\n\t\tcase \"Not\":\n\t\t\treturn not(parseAnnotationCondition(annotationValue.$Not, visitedNavigationPaths, pathVisitor)) as BindingToolkitExpression<\n\t\t\t\tPrimitiveTypeCast<T>\n\t\t\t>;\n\t\tcase \"Eq\":\n\t\t\treturn equal(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Eq[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Eq[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Ne\":\n\t\t\treturn notEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ne[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ne[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Gt\":\n\t\t\treturn greaterThan(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Gt[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Gt[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Ge\":\n\t\t\treturn greaterOrEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ge[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ge[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Lt\":\n\t\t\treturn lessThan(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Lt[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Lt[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Le\":\n\t\t\treturn lessOrEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Le[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Le[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Or\":\n\t\t\treturn or(\n\t\t\t\t...annotationValue.$Or.map(function (orCondition) {\n\t\t\t\t\treturn parseAnnotationCondition<boolean>(orCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t\t})\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"And\":\n\t\t\treturn and(\n\t\t\t\t...annotationValue.$And.map(function (andCondition) {\n\t\t\t\t\treturn parseAnnotationCondition<boolean>(andCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t\t})\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Apply\":\n\t\t\treturn annotationApplyExpression(\n\t\t\t\tannotationValue as ApplyAnnotationExpression<string>,\n\t\t\t\tvisitedNavigationPaths,\n\t\t\t\tpathVisitor\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Constant\":\n\t\t\t// Not a real case but the type system needs it\n\t\t\treturn constant(annotationValue.value as PrimitiveTypeCast<T>);\n\t}\n\treturn unresolvableExpression;\n}\n\n/**\n * Parse the annotation condition into an expression.\n * @template T The target type\n * @param annotationValue The condition or value from the annotation\n * @param visitedNavigationPaths The path from the root entity set\n * @param pathVisitor A function to modify the resulting path\n * @returns An equivalent expression\n */\nfunction parseAnnotationCondition<T extends PrimitiveType>(\n\tannotationValue: ConditionalCheckOrValue,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): BindingToolkitExpression<T> {\n\tif (annotationValue === null || typeof annotationValue !== \"object\") {\n\t\treturn constant(annotationValue as T);\n\t} else if (annotationValue.hasOwnProperty(\"$Or\")) {\n\t\treturn or(\n\t\t\t...((annotationValue as OrConditionalExpression).$Or.map(function (orCondition) {\n\t\t\t\treturn parseAnnotationCondition(orCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t}) as unknown as BindingToolkitExpression<boolean>[])\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$And\")) {\n\t\treturn and(\n\t\t\t...((annotationValue as AndConditionalExpression).$And.map(function (andCondition) {\n\t\t\t\treturn parseAnnotationCondition(andCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t}) as unknown as BindingToolkitExpression<boolean>[])\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Not\")) {\n\t\treturn not(\n\t\t\tparseAnnotationCondition((annotationValue as NotConditionalExpression).$Not, visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Eq\")) {\n\t\treturn equal(\n\t\t\tparseAnnotationCondition((annotationValue as EqConditionalExpression).$Eq[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as EqConditionalExpression).$Eq[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Ne\")) {\n\t\treturn notEqual(\n\t\t\tparseAnnotationCondition((annotationValue as NeConditionalExpression).$Ne[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as NeConditionalExpression).$Ne[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Gt\")) {\n\t\treturn greaterThan(\n\t\t\tparseAnnotationCondition((annotationValue as GtConditionalExpression).$Gt[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as GtConditionalExpression).$Gt[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Ge\")) {\n\t\treturn greaterOrEqual(\n\t\t\tparseAnnotationCondition((annotationValue as GeConditionalExpression).$Ge[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as GeConditionalExpression).$Ge[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Lt\")) {\n\t\treturn lessThan(\n\t\t\tparseAnnotationCondition((annotationValue as LtConditionalExpression).$Lt[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as LtConditionalExpression).$Lt[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Le\")) {\n\t\treturn lessOrEqual(\n\t\t\tparseAnnotationCondition((annotationValue as LeConditionalExpression).$Le[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as LeConditionalExpression).$Le[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Path\")) {\n\t\treturn pathInModel((annotationValue as PathConditionExpression<T>).$Path, undefined, visitedNavigationPaths, pathVisitor);\n\t} else if (annotationValue.hasOwnProperty(\"$Apply\")) {\n\t\treturn getExpressionFromAnnotation(\n\t\t\t{\n\t\t\t\ttype: \"Apply\",\n\t\t\t\t$Function: (annotationValue as { $Function?: string }).$Function,\n\t\t\t\t$Apply: (annotationValue as { $Apply?: unknown }).$Apply\n\t\t\t} as ApplyAnnotationExpression<T>,\n\t\t\tvisitedNavigationPaths,\n\t\t\tundefined,\n\t\t\tpathVisitor\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$If\")) {\n\t\treturn getExpressionFromAnnotation(\n\t\t\t{\n\t\t\t\ttype: \"If\",\n\t\t\t\t$If: (annotationValue as { $If?: unknown }).$If\n\t\t\t} as IfAnnotationExpression<T>,\n\t\t\tvisitedNavigationPaths,\n\t\t\tundefined,\n\t\t\tpathVisitor\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$EnumMember\")) {\n\t\treturn constant(resolveEnumValue((annotationValue as { $EnumMember?: string }).$EnumMember) as T);\n\t}\n\treturn constant(false as T);\n}\n\n/**\n * Process the {IfAnnotationExpressionValue} into an expression.\n * @template T The target type\n * @param annotationValue An If expression returning the type T\n * @param visitedNavigationPaths The path from the root entity set\n * @param pathVisitor A function to modify the resulting path\n * @returns The equivalent ifElse expression\n */\nexport function annotationIfExpression<T extends PrimitiveType>(\n\tannotationValue: IfAnnotationExpressionValue<T>,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): BindingToolkitExpression<T> {\n\treturn ifElse(\n\t\tparseAnnotationCondition(annotationValue[0], visitedNavigationPaths, pathVisitor),\n\t\tparseAnnotationCondition(annotationValue[1] as ConditionalCheckOrValue, visitedNavigationPaths, pathVisitor),\n\t\tparseAnnotationCondition(annotationValue[2] as ConditionalCheckOrValue, visitedNavigationPaths, pathVisitor)\n\t);\n}\n// This type is not recursively transformed from the metamodel content, as such we have some ugly things there\ntype SubApplyExpressionFromMetamodel = Record<string, unknown>;\nfunction convertSubApplyParameters(applyParam: SubApplyExpressionFromMetamodel): SubApplyExpressionFromMetamodel | PrimitiveType {\n\tlet applyParamConverted = applyParam;\n\tif (applyParam.hasOwnProperty(\"$Path\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"Path\",\n\t\t\tpath: applyParam.$Path\n\t\t} as PathAnnotationExpression<string>;\n\t} else if (applyParam.hasOwnProperty(\"$If\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"If\",\n\t\t\t$If: applyParam.$If\n\t\t} as IfAnnotationExpression<string>;\n\t} else if (applyParam.hasOwnProperty(\"$Apply\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"Apply\",\n\t\t\t$Function: applyParam.$Function,\n\t\t\t$Apply: applyParam.$Apply\n\t\t} as ApplyAnnotationExpression<string>;\n\t}\n\treturn applyParamConverted;\n}\n\ntype ODataFunction = \"odata.concat\" | \"odata.fillUriTemplate\" | \"odata.uriEncode\";\nexport function annotationApplyExpression(\n\tapplyExpression: ApplyAnnotationExpression<string>,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): BindingToolkitExpression<string> {\n\tswitch (applyExpression.$Function as ODataFunction) {\n\t\tcase \"odata.concat\":\n\t\t\treturn concat(\n\t\t\t\t...applyExpression.$Apply.map((applyParam) => {\n\t\t\t\t\treturn getExpressionFromAnnotation(\n\t\t\t\t\t\tconvertSubApplyParameters(applyParam) as PropertyAnnotationValue<string>,\n\t\t\t\t\t\tvisitedNavigationPaths,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tpathVisitor\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\tcase \"odata.uriEncode\":\n\t\t\tconst parameter = getExpressionFromAnnotation(\n\t\t\t\tconvertSubApplyParameters(\n\t\t\t\t\tapplyExpression.$Apply[0] as unknown as SubApplyExpressionFromMetamodel\n\t\t\t\t) as PropertyAnnotationValue<string>,\n\t\t\t\tvisitedNavigationPaths,\n\t\t\t\tundefined,\n\t\t\t\tpathVisitor\n\t\t\t);\n\t\t\t// The second parameter for uriEncode is always a string since the target evaluation is against a formatValue call in ODataUtils which expect the target type as second parameter\n\t\t\treturn fn(\"odata.uriEncode\", [parameter, \"Edm.String\"], undefined, true);\n\t\tcase \"odata.fillUriTemplate\":\n\t\t\tconst template = applyExpression.$Apply[0];\n\t\t\tconst templateParams = applyExpression.$Apply.slice(1) as unknown as SubApplyExpressionFromMetamodel[];\n\t\t\tconst targetObject: Record<string, BindingToolkitExpression<unknown>> = {};\n\t\t\ttemplateParams.forEach((applyParam) => {\n\t\t\t\ttargetObject[applyParam.$Name as string] = getExpressionFromAnnotation(\n\t\t\t\t\tconvertSubApplyParameters(\n\t\t\t\t\t\tapplyParam.$LabeledElement as SubApplyExpressionFromMetamodel\n\t\t\t\t\t) as PropertyAnnotationValue<string>,\n\t\t\t\t\tvisitedNavigationPaths,\n\t\t\t\t\tundefined,\n\t\t\t\t\tpathVisitor\n\t\t\t\t);\n\t\t\t});\n\t\t\treturn fn(\"odata.fillUriTemplate\", [template, targetObject], undefined, true);\n\t}\n\treturn unresolvableExpression;\n}\n\n/**\n * Generic helper for the comparison operations (equal, notEqual, ...).\n * @template T The target type\n * @param operator The operator to apply\n * @param leftOperand The operand on the left side of the operator\n * @param rightOperand The operand on the right side of the operator\n * @returns An expression representing the comparison\n */\nfunction comparison<T extends PrimitiveType>(\n\toperator: ComparisonOperator,\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\tconst leftExpression = wrapPrimitive(leftOperand);\n\tconst rightExpression = wrapPrimitive(rightOperand);\n\tif (hasUnresolvableExpression(leftExpression, rightExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (isConstant(leftExpression) && isConstant(rightExpression)) {\n\t\tswitch (operator) {\n\t\t\tcase \"!==\":\n\t\t\t\treturn constant(leftExpression.value !== rightExpression.value);\n\t\t\tcase \"===\":\n\t\t\t\treturn constant(leftExpression.value === rightExpression.value);\n\t\t\tcase \"<\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value < rightExpression.value);\n\t\t\tcase \"<=\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value <= rightExpression.value);\n\t\t\tcase \">\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value > rightExpression.value);\n\t\t\tcase \">=\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value >= rightExpression.value);\n\t\t}\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Comparison\",\n\t\t\toperator: operator,\n\t\t\toperand1: leftExpression,\n\t\t\toperand2: rightExpression\n\t\t};\n\t}\n}\n\n/**\n * Generic helper for the length of an expression.\n * @param expression The input expression pointing to an array\n * @param checkUndefined Is the array potentially undefined\n * @returns An expression representing the length\n */\nexport function length(\n\texpression: PathInModelExpression<unknown> | UnresolvablePathExpression,\n\tcheckUndefined = false\n): BindingToolkitExpression<number> {\n\tif (expression._type === \"Unresolvable\") {\n\t\treturn expression;\n\t}\n\tif (!checkUndefined) {\n\t\treturn {\n\t\t\t_type: \"Length\",\n\t\t\tpathInModel: expression\n\t\t};\n\t}\n\treturn ifElse(equal(expression, undefined), -1, length(expression));\n}\n\n/**\n * Comparison: \"equal\" (===).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function equal<T extends PrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\tconst leftExpression = wrapPrimitive(leftOperand);\n\tconst rightExpression = wrapPrimitive(rightOperand);\n\tif (hasUnresolvableExpression(leftExpression, rightExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (_checkExpressionsAreEqual(leftExpression, rightExpression)) {\n\t\treturn constant(true);\n\t}\n\n\tfunction reduce(left: BindingToolkitExpression<T>, right: BindingToolkitExpression<T>): BindingToolkitExpression<boolean> | undefined {\n\t\tif (left._type === \"Comparison\" && isTrue(right)) {\n\t\t\t// compare(a, b) === true ~~> compare(a, b)\n\t\t\treturn left;\n\t\t} else if (left._type === \"Comparison\" && isFalse(right)) {\n\t\t\t// compare(a, b) === false ~~> !compare(a, b)\n\t\t\treturn not(left);\n\t\t} else if (left._type === \"IfElse\" && _checkExpressionsAreEqual(left.onTrue, right)) {\n\t\t\t// (if (x) { a } else { b }) === a ~~> x || (b === a)\n\t\t\treturn or(left.condition, equal(left.onFalse, right));\n\t\t} else if (left._type === \"IfElse\" && _checkExpressionsAreEqual(left.onFalse, right)) {\n\t\t\t// (if (x) { a } else { b }) === b ~~> !x || (a === b)\n\t\t\treturn or(not(left.condition), equal(left.onTrue, right));\n\t\t} else if (\n\t\t\tleft._type === \"IfElse\" &&\n\t\t\tisConstant(left.onTrue) &&\n\t\t\tisConstant(left.onFalse) &&\n\t\t\tisConstant(right) &&\n\t\t\t!_checkExpressionsAreEqual(left.onTrue, right) &&\n\t\t\t!_checkExpressionsAreEqual(left.onFalse, right)\n\t\t) {\n\t\t\treturn constant(false);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t// exploit symmetry: a === b <~> b === a\n\tconst reduced = reduce(leftExpression, rightExpression) ?? reduce(rightExpression, leftExpression);\n\treturn reduced ?? comparison(\"===\", leftExpression, rightExpression);\n}\n\n/**\n * Comparison: \"not equal\" (!==).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function notEqual<T extends PrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn not(equal(leftOperand, rightOperand));\n}\n\n/**\n * Comparison: \"greater or equal\" (>=).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function greaterOrEqual<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn comparison(\">=\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"greater than\" (>).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function greaterThan<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn comparison(\">\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"less or equal\" (<=).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function lessOrEqual<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn comparison(\"<=\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"less than\" (<).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function lessThan<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn comparison(\"<\", leftOperand, rightOperand);\n}\n\n/**\n * If-then-else expression.\n *\n * Evaluates to onTrue if the condition evaluates to true, else evaluates to onFalse.\n * @template T The target type\n * @param condition The condition to evaluate\n * @param onTrue Expression result if the condition evaluates to true\n * @param onFalse Expression result if the condition evaluates to false\n * @returns The expression that represents this conditional check\n */\nexport function ifElse<T extends PrimitiveType>(\n\tcondition: ExpressionOrPrimitive<boolean>,\n\tonTrue: ExpressionOrPrimitive<T>,\n\tonFalse: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<T> {\n\tlet conditionExpression = wrapPrimitive(condition);\n\tlet onTrueExpression = wrapPrimitive(onTrue);\n\tlet onFalseExpression = wrapPrimitive(onFalse);\n\n\t// swap branches if the condition is a negation\n\tif (conditionExpression._type === \"Not\") {\n\t\t// ifElse(not(X), a, b) --> ifElse(X, b, a)\n\t\t[onTrueExpression, onFalseExpression] = [onFalseExpression, onTrueExpression];\n\t\tconditionExpression = not(conditionExpression);\n\t}\n\n\t// inline nested if-else expressions: onTrue branch\n\t// ifElse(X, ifElse(X, a, b), c) ==> ifElse(X, a, c)\n\tif (onTrueExpression._type === \"IfElse\" && _checkExpressionsAreEqual(conditionExpression, onTrueExpression.condition)) {\n\t\tonTrueExpression = onTrueExpression.onTrue;\n\t}\n\n\t// inline nested if-else expressions: onFalse branch\n\t// ifElse(X, a, ifElse(X, b, c)) ==> ifElse(X, a, c)\n\tif (onFalseExpression._type === \"IfElse\" && _checkExpressionsAreEqual(conditionExpression, onFalseExpression.condition)) {\n\t\tonFalseExpression = onFalseExpression.onFalse;\n\t}\n\n\t// (if true then a else b)  ~~> a\n\t// (if false then a else b) ~~> b\n\tif (isConstant(conditionExpression)) {\n\t\treturn conditionExpression.value ? onTrueExpression : onFalseExpression;\n\t}\n\n\t// if (isConstantBoolean(onTrueExpression) || isConstantBoolean(onFalseExpression)) {\n\t// \treturn or(and(condition, onTrueExpression as Expression<boolean>), and(not(condition), onFalseExpression as Expression<boolean>)) as Expression<T>\n\t// }\n\n\t// (if X then a else a) ~~> a\n\tif (_checkExpressionsAreEqual(onTrueExpression, onFalseExpression)) {\n\t\treturn onTrueExpression;\n\t}\n\n\t// if X then a else false ~~> X && a\n\tif (isFalse(onFalseExpression)) {\n\t\treturn and(conditionExpression, onTrueExpression as BindingToolkitExpression<boolean>) as BindingToolkitExpression<T>;\n\t}\n\n\t// if X then a else true ~~> !X || a\n\tif (isTrue(onFalseExpression)) {\n\t\treturn or(not(conditionExpression), onTrueExpression as BindingToolkitExpression<boolean>) as BindingToolkitExpression<T>;\n\t}\n\n\t// if X then false else a ~~> !X && a\n\tif (isFalse(onTrueExpression)) {\n\t\treturn and(not(conditionExpression), onFalseExpression as BindingToolkitExpression<boolean>) as BindingToolkitExpression<T>;\n\t}\n\n\t// if X then true else a ~~> X || a\n\tif (isTrue(onTrueExpression)) {\n\t\treturn or(conditionExpression, onFalseExpression as BindingToolkitExpression<boolean>) as BindingToolkitExpression<T>;\n\t}\n\tif (hasUnresolvableExpression(conditionExpression, onTrueExpression, onFalseExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (isComplexTypeExpression(condition) || isComplexTypeExpression(onTrue) || isComplexTypeExpression(onFalse)) {\n\t\tlet pathIdx = 0;\n\t\tconst myIfElseExpression = formatResult([condition, onTrue, onFalse], \"._formatters.StandardFormatter#ifElse\");\n\t\tconst allParts = [];\n\t\ttransformRecursively(\n\t\t\tmyIfElseExpression,\n\t\t\t\"PathInModel\",\n\t\t\t(constantPath: PathInModelExpression<unknown>) => {\n\t\t\t\tallParts.push(constantPath);\n\t\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t\t},\n\t\t\ttrue\n\t\t);\n\t\tallParts.unshift(constant(JSON.stringify(myIfElseExpression)));\n\t\treturn formatResult(allParts, \"._formatters.StandardFormatter.bind($control)#evaluateComplexExpression\", undefined, true);\n\t}\n\treturn {\n\t\t_type: \"IfElse\",\n\t\tcondition: conditionExpression,\n\t\tonTrue: onTrueExpression,\n\t\tonFalse: onFalseExpression\n\t};\n}\n\n/**\n * Checks whether the current expression has a reference to the default model (undefined).\n * @param expression The expression to evaluate\n * @returns `true` if there is a reference to the default context\n */\nfunction hasReferenceToDefaultContext(expression: BindingToolkitExpression<unknown>): boolean {\n\tswitch (expression._type) {\n\t\tcase \"Constant\":\n\t\tcase \"Formatter\":\n\t\tcase \"ComplexType\":\n\t\t\treturn false;\n\t\tcase \"Set\":\n\t\t\treturn expression.operands.some(hasReferenceToDefaultContext);\n\t\tcase \"PathInModel\":\n\t\t\treturn expression.modelName === undefined;\n\t\tcase \"Comparison\":\n\t\t\treturn hasReferenceToDefaultContext(expression.operand1) || hasReferenceToDefaultContext(expression.operand2);\n\t\tcase \"IfElse\":\n\t\t\treturn (\n\t\t\t\thasReferenceToDefaultContext(expression.condition) ||\n\t\t\t\thasReferenceToDefaultContext(expression.onTrue) ||\n\t\t\t\thasReferenceToDefaultContext(expression.onFalse)\n\t\t\t);\n\t\tcase \"Not\":\n\t\tcase \"Truthy\":\n\t\t\treturn hasReferenceToDefaultContext(expression.operand);\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n// This is one case where any does make sense...\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Fn<T> = ((...params: any) => T | Promise<T>) & {\n\t__functionName: string;\n};\n\n/**\n * @typedef WrappedTuple\n */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\ntype WrappedTuple<T> = { [K in keyof T]: WrappedTuple<T[K]> | ExpressionOrPrimitive<T[K]> | undefined };\n\n// So, this works but I cannot get it to compile :D, but it still does what is expected...\n\n/**\n * A function reference or a function name.\n */\ntype FunctionOrName<T> = Fn<T> | string;\n\n/**\n * Function parameters, either derived from the function or an untyped array.\n */\ntype FunctionParameters<T, F extends FunctionOrName<T>> = F extends Fn<T> ? Parameters<F> : unknown[];\n\n/**\n * Calls a formatter function to process the parameters.\n * If requireContext is set to true and no context is passed a default context will be added automatically.\n * @template T\n * @template U\n * @param parameters The list of parameter that should match the type and number of the formatter function\n * @param formatterFunction The function to call\n * @param [contextEntityType] If no parameter refers to the context then we use this information to add a reference to the keys from the entity type.\n * @param [ignoreComplexType] Whether to ignore the transgformation to the StandardFormatter or not\n * @returns The corresponding expression\n */\nexport function formatResult<T, U extends Fn<T>>(\n\tparameters: WrappedTuple<Parameters<U>>,\n\tformatterFunction: U | string,\n\tcontextEntityType?: EntityType,\n\tignoreComplexType = false\n): BindingToolkitExpression<T> {\n\tconst parameterExpressions = (parameters as ExpressionOrPrimitive<PrimitiveType>[]).map(wrapPrimitive);\n\n\tif (hasUnresolvableExpression(...parameterExpressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (contextEntityType) {\n\t\t// Otherwise, if the context is required and no context is provided make sure to add the default binding\n\t\tif (!parameterExpressions.some(hasReferenceToDefaultContext)) {\n\t\t\tcontextEntityType.keys.forEach((key) => parameterExpressions.push(pathInModel(key.name, \"\")));\n\t\t}\n\t}\n\tlet functionName = \"\";\n\tif (typeof formatterFunction === \"string\") {\n\t\tfunctionName = formatterFunction;\n\t} else {\n\t\tfunctionName = formatterFunction.__functionName;\n\t}\n\t// FormatterName can be of format sap.fe.core.xxx#methodName to have multiple formatter in one class\n\tconst [formatterClass, formatterName] = functionName.split(\"#\");\n\n\t// In some case we also cannot call directly a function because of too complex input, in that case we need to convert to a simpler function call\n\tif (\n\t\t!ignoreComplexType &&\n\t\t(parameterExpressions.some(isComplexTypeExpression) ||\n\t\t\tparameterExpressions.some(isConcatExpression) ||\n\t\t\tparameterExpressions.some(isIfElseExpression))\n\t) {\n\t\tlet pathIdx = 0;\n\t\tconst myFormatExpression = formatResult(parameterExpressions, functionName, undefined, true);\n\t\tconst allParts = [];\n\t\ttransformRecursively(\n\t\t\tmyFormatExpression,\n\t\t\t\"PathInModel\",\n\t\t\t(constantPath: PathInModelExpression<unknown>) => {\n\t\t\t\tallParts.push(constantPath);\n\t\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t\t},\n\t\t\ttrue\n\t\t);\n\t\tallParts.unshift(constant(JSON.stringify(myFormatExpression)));\n\t\treturn formatResult(allParts, \"._formatters.StandardFormatter.bind($control)#evaluateComplexExpression\", undefined, true);\n\t} else if (!!formatterName && formatterName.length > 0) {\n\t\tparameterExpressions.unshift(constant(formatterName));\n\t}\n\n\treturn {\n\t\t_type: \"Formatter\",\n\t\tfn: formatterClass,\n\t\tparameters: parameterExpressions\n\t};\n}\n\ntype BindingConstraints = {\n\tscale?: number;\n\tprecision?: number;\n\tmaxLength?: number;\n\tnullable?: boolean;\n\tminimum?: string;\n\tmaximum?: string;\n\tisDigitSequence?: boolean;\n\tV4?: boolean;\n};\nexport function setUpConstraints(targetMapping: TypeMappingDefinition, property: Property | ActionParameter): BindingConstraints {\n\tconst constraints: BindingConstraints = {};\n\tif (targetMapping?.constraints?.$Scale && property.scale !== undefined) {\n\t\tconstraints.scale = property.scale;\n\t}\n\tif (targetMapping?.constraints?.$Precision && property.precision !== undefined) {\n\t\tconstraints.precision = property.precision;\n\t}\n\tif (targetMapping?.constraints?.$MaxLength && property.maxLength !== undefined) {\n\t\tconstraints.maxLength = property.maxLength;\n\t}\n\tif (property.nullable === false) {\n\t\tconstraints.nullable = false;\n\t}\n\tif (targetMapping?.constraints?.[\"@Org.OData.Validation.V1.Minimum/$Decimal\"] && !isNaN(property.annotations?.Validation?.Minimum)) {\n\t\tconstraints.minimum = `${property.annotations?.Validation?.Minimum}`;\n\t}\n\tif (targetMapping?.constraints?.[\"@Org.OData.Validation.V1.Maximum/$Decimal\"] && !isNaN(property.annotations?.Validation?.Maximum)) {\n\t\tconstraints.maximum = `${property.annotations?.Validation?.Maximum}`;\n\t}\n\tif (\n\t\tproperty.annotations?.Common?.IsDigitSequence &&\n\t\ttargetMapping.type === \"sap.ui.model.odata.type.String\" &&\n\t\ttargetMapping?.constraints?.[\"@com.sap.vocabularies.Common.v1.IsDigitSequence\"]\n\t) {\n\t\tconstraints.isDigitSequence = true;\n\t}\n\tif (targetMapping?.constraints?.$V4) {\n\t\tconstraints.V4 = true;\n\t}\n\treturn constraints;\n}\n\n/**\n * Generates the binding expression for the property, and sets up the formatOptions and constraints.\n * @param property The Property for which we are setting up the binding\n * @param propertyBindingExpression The BindingExpression of the property above. Serves as the basis to which information can be added\n * @param ignoreConstraints Ignore constraints of the property\n * @returns The binding expression for the property with formatOptions and constraints\n */\nexport function formatWithTypeInformation<T>(\n\tproperty: Property | ActionParameter,\n\tpropertyBindingExpression: BindingToolkitExpression<string>,\n\tignoreConstraints = false\n): PathInModelExpression<T> {\n\tconst outExpression: PathInModelExpression<unknown> = propertyBindingExpression as PathInModelExpression<unknown>;\n\tif (property._type !== \"Property\" && property._type !== \"ActionParameter\") {\n\t\treturn outExpression;\n\t}\n\tconst targetMapping = EDM_TYPE_MAPPING[property.type];\n\tif (!targetMapping) {\n\t\treturn outExpression;\n\t}\n\tif (!outExpression.formatOptions) {\n\t\toutExpression.formatOptions = {};\n\t}\n\toutExpression.constraints = {};\n\n\toutExpression.type = targetMapping.type;\n\tif (!ignoreConstraints) {\n\t\toutExpression.constraints = setUpConstraints(targetMapping, property);\n\t}\n\n\tif (\n\t\t(outExpression?.type?.indexOf(\"sap.ui.model.odata.type.Int\") === 0 && outExpression?.type !== \"sap.ui.model.odata.type.Int64\") ||\n\t\toutExpression?.type === \"sap.ui.model.odata.type.Double\"\n\t) {\n\t\toutExpression.formatOptions = Object.assign(outExpression.formatOptions, {\n\t\t\tparseAsString: false\n\t\t});\n\t}\n\tif (outExpression.type === \"sap.ui.model.odata.type.String\" && isProperty(property)) {\n\t\tif (outExpression.constraints?.isDigitSequence || (outExpression.constraints?.nullable !== false && property.nullable === true)) {\n\t\t\toutExpression.formatOptions.parseKeepsEmptyString = false;\n\t\t} else {\n\t\t\toutExpression.formatOptions.parseKeepsEmptyString = true;\n\t\t}\n\t\tconst fiscalType = getFiscalType(property);\n\t\tif (fiscalType) {\n\t\t\toutExpression.formatOptions.fiscalType = fiscalType;\n\t\t\toutExpression.type = \"sap.fe.core.type.FiscalDate\";\n\t\t}\n\t}\n\tconst typesSupportingParseEmptyValueToZero = [\n\t\t\"sap.ui.model.odata.type.Int16\",\n\t\t\"sap.ui.model.odata.type.Int32\",\n\t\t\"sap.ui.model.odata.type.Int64\",\n\t\t\"sap.ui.model.odata.type.Single\",\n\t\t\"sap.ui.model.odata.type.Double\",\n\t\t\"sap.ui.model.odata.type.Decimal\",\n\t\t\"sap.ui.model.odata.type.Byte\",\n\t\t\"sap.ui.model.odata.type.SByte\"\n\t];\n\tif (\n\t\toutExpression.constraints?.nullable === false &&\n\t\toutExpression.type &&\n\t\ttypesSupportingParseEmptyValueToZero.includes(outExpression.type)\n\t) {\n\t\toutExpression.formatOptions = Object.assign(outExpression.formatOptions, {\n\t\t\tparseEmptyValueToZero: true\n\t\t});\n\t}\n\tif (\n\t\toutExpression.constraints?.nullable !== false &&\n\t\t(outExpression.type === \"sap.ui.model.odata.type.Int64\" || outExpression.type === \"sap.ui.model.odata.type.Decimal\")\n\t) {\n\t\toutExpression.formatOptions = Object.assign(outExpression.formatOptions, {\n\t\t\temptyString: \"\"\n\t\t});\n\t}\n\n\treturn outExpression;\n}\n\nexport const getFiscalType = function (property: Property): string | undefined {\n\tif (property.annotations?.Common?.IsFiscalYear) {\n\t\treturn CommonAnnotationTerms.IsFiscalYear;\n\t}\n\tif (property.annotations?.Common?.IsFiscalPeriod) {\n\t\treturn CommonAnnotationTerms.IsFiscalPeriod;\n\t}\n\tif (property.annotations?.Common?.IsFiscalYearPeriod) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearPeriod;\n\t}\n\tif (property.annotations?.Common?.IsFiscalQuarter) {\n\t\treturn CommonAnnotationTerms.IsFiscalQuarter;\n\t}\n\tif (property.annotations?.Common?.IsFiscalYearQuarter) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearQuarter;\n\t}\n\tif (property.annotations?.Common?.IsFiscalWeek) {\n\t\treturn CommonAnnotationTerms.IsFiscalWeek;\n\t}\n\tif (property.annotations?.Common?.IsFiscalYearWeek) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearWeek;\n\t}\n\tif (property.annotations?.Common?.IsDayOfFiscalYear) {\n\t\treturn CommonAnnotationTerms.IsDayOfFiscalYear;\n\t}\n};\n\n/**\n * Calls a complex type to process the parameters.\n * If requireContext is set to true and no context is passed, a default context will be added automatically.\n * @template T\n * @template U\n * @param parameters The list of parameters that should match the type for the complex type=\n * @param type The complex type to use\n * @param [contextEntityType] The context entity type to consider\n * @param oFormatOptions\n * @param oConstraintOptions\n * @returns The corresponding expression\n */\nexport function addTypeInformation<T, U extends Fn<T>>(\n\tparameters: WrappedTuple<Parameters<U>>,\n\ttype: string,\n\tcontextEntityType?: EntityType,\n\toFormatOptions?: ComplexTypeFormatOptions,\n\toConstraintOptions?: ComplexTypeConstraintOptions\n): UnresolvablePathExpression | ComplexTypeExpression<T> | ConstantExpression<T> {\n\tconst parameterExpressions = (parameters as ExpressionOrPrimitive<PrimitiveType>[]).map(wrapPrimitive);\n\tif (hasUnresolvableExpression(...parameterExpressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\t// If there is only one parameter and it is a constant and we don't expect the context then return the constant\n\tif (parameterExpressions.length === 1 && isConstant(parameterExpressions[0]) && !contextEntityType) {\n\t\treturn parameterExpressions[0] as ConstantExpression<T>;\n\t} else if (contextEntityType) {\n\t\t// Otherwise, if the context is required and no context is provided make sure to add the default binding\n\t\tif (!parameterExpressions.some(hasReferenceToDefaultContext)) {\n\t\t\tcontextEntityType.keys.forEach((key) => parameterExpressions.push(pathInModel(key.name, \"\")));\n\t\t}\n\t}\n\toFormatOptions = _getComplexTypeFormatOptionsFromFirstParam(parameters[0], oFormatOptions);\n\n\tif (type === \"sap.ui.model.odata.type.Unit\") {\n\t\tconst uomPath = pathInModel(\"/##@@requestUnitsOfMeasure\");\n\t\tuomPath.targetType = \"any\";\n\t\tuomPath.mode = \"OneTime\";\n\t\toFormatOptions ??= {};\n\t\toFormatOptions.preserveDecimals = oConstraintOptions?.skipDecimalsValidation ?? false;\n\t\tparameterExpressions.push(uomPath);\n\t} else if (type === \"sap.ui.model.odata.type.Currency\") {\n\t\tconst currencyPath = pathInModel(\"/##@@requestCurrencyCodes\");\n\t\tcurrencyPath.targetType = \"any\";\n\t\tcurrencyPath.mode = \"OneTime\";\n\t\toFormatOptions ??= {};\n\t\tif (oConstraintOptions?.skipDecimalsValidation === true) {\n\t\t\toFormatOptions.decimals = 99; // setting to 99 to avoid rounding in currency conversion\n\t\t}\n\n\t\toFormatOptions.preserveDecimals = oConstraintOptions?.skipDecimalsValidation ?? false; // default value since we don't have a CLDR\n\t\tparameterExpressions.push(currencyPath);\n\t}\n\n\treturn {\n\t\t_type: \"ComplexType\",\n\t\ttype: type,\n\t\tformatOptions: oFormatOptions || {},\n\t\tconstraints: oConstraintOptions || {},\n\t\tparameters: {},\n\t\tbindingParameters: parameterExpressions\n\t};\n}\n\ntype ComplexTypeFormatOptions = {\n\tdecimals?: number;\n\tshowNumber?: boolean;\n\tshowMeasure?: boolean;\n\tparseAsString?: boolean;\n\tparseKeepsEmptyString?: boolean;\n\temptyString?: string | number | null;\n\tshowTime?: boolean;\n\tshowDate?: boolean;\n\tshowTimezone?: boolean;\n\tpreserveDecimals?: boolean;\n\tdecimalPadding?: number;\n};\n\nexport type ComplexTypeConstraintOptions = {\n\tskipDecimalsValidation?: boolean;\n};\n\n/**\n * Process the formatOptions for a complexType based on the first parameter.\n * @param param The first parameter of the complex type\n * @param formatOptions Initial formatOptions\n * @returns The modified formatOptions\n */\nfunction _getComplexTypeFormatOptionsFromFirstParam<T, U extends Fn<T>>(\n\tparam: Parameters<U>,\n\tformatOptions: undefined | ComplexTypeFormatOptions\n): ComplexTypeFormatOptions | undefined {\n\t// if showMeasure is set to false we want to not parse as string to see the 0\n\t// we do that also for all bindings because otherwise the mdc Field isn't editable\n\tif (\n\t\t!(formatOptions && formatOptions.showNumber === false) &&\n\t\t(param?.type?.indexOf(\"sap.ui.model.odata.type.Int\") === 0 ||\n\t\t\tparam?.type === \"sap.ui.model.odata.type.Decimal\" ||\n\t\t\tparam?.type === \"sap.ui.model.odata.type.Double\")\n\t) {\n\t\tif (param?.type === \"sap.ui.model.odata.type.Int64\" || param?.type === \"sap.ui.model.odata.type.Decimal\") {\n\t\t\t//sap.ui.model.odata.type.Int64 do not support parseAsString false\n\t\t\tformatOptions =\n\t\t\t\tformatOptions?.showMeasure === false\n\t\t\t\t\t? { showMeasure: false, decimalPadding: formatOptions.decimalPadding, emptyString: formatOptions?.emptyString }\n\t\t\t\t\t: { decimalPadding: formatOptions?.decimalPadding, emptyString: formatOptions?.emptyString };\n\t\t} else {\n\t\t\tformatOptions =\n\t\t\t\tformatOptions?.showMeasure === false\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tparseAsString: false,\n\t\t\t\t\t\t\tshowMeasure: false,\n\t\t\t\t\t\t\tdecimalPadding: formatOptions.decimalPadding,\n\t\t\t\t\t\t\temptyString: formatOptions?.emptyString\n\t\t\t\t\t  }\n\t\t\t\t\t: { parseAsString: false, decimalPadding: formatOptions?.decimalPadding, emptyString: formatOptions?.emptyString };\n\t\t}\n\t\tif (param?.constraints?.nullable !== false) {\n\t\t\tformatOptions.emptyString = null;\n\t\t} else {\n\t\t\tformatOptions.emptyString ??= 0;\n\t\t}\n\t}\n\treturn formatOptions;\n}\n/**\n * Function call, optionally with arguments.\n * @param func Function name or reference to function\n * @param parameters Arguments\n * @param on Object to call the function on\n * @param isFormattingFn\n * @returns Expression representing the function call (not the result of the function call!)\n */\nexport function fn<T, U extends FunctionOrName<T>>(\n\tfunc: U,\n\tparameters: WrappedTuple<FunctionParameters<T, U>>,\n\ton?: ExpressionOrPrimitive<object>,\n\tisFormattingFn = false\n): FunctionExpression<T> {\n\tconst functionName = typeof func === \"string\" ? func : func.__functionName;\n\treturn {\n\t\t_type: \"Function\",\n\t\tobj: on !== undefined ? wrapPrimitive(on) : undefined,\n\t\tfn: functionName,\n\t\tisFormattingFn: isFormattingFn,\n\t\tparameters: (parameters as ExpressionOrPrimitive<PrimitiveType>[]).map(wrapPrimitive)\n\t};\n}\n\n/**\n * Shortcut function to determine if a binding value is null, undefined or empty.\n * @param expression\n * @returns A Boolean expression evaluating the fact that the current element is empty\n */\nexport function isEmpty(expression: BindingToolkitExpression<string>): BindingToolkitExpression<boolean> {\n\tconst aBindings: ExpressionOrPrimitive<boolean>[] = [];\n\ttransformRecursively(expression, \"PathInModel\", (expr) => {\n\t\tconst finalExpression = { ...expr, alwaysKeepTargetType: true } as PathInModelExpression<string>;\n\t\taBindings.push(or(equal(finalExpression, \"\"), equal(expr, undefined), equal(expr, null)));\n\t\treturn expr;\n\t});\n\treturn and(...aBindings);\n}\n\nexport function concat(...inExpressions: ExpressionOrPrimitive<string>[]): BindingToolkitExpression<string> {\n\tconst expressions = inExpressions.map(wrapPrimitive);\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (expressions.every(isConstant)) {\n\t\treturn constant(\n\t\t\texpressions.reduce((concatenated: string, value) => {\n\t\t\t\tif (value.value !== undefined && value.value !== null) {\n\t\t\t\t\treturn concatenated + value.value.toString();\n\t\t\t\t}\n\t\t\t\treturn concatenated;\n\t\t\t}, \"\")\n\t\t);\n\t} else if (expressions.some(isComplexTypeExpression)) {\n\t\tlet pathIdx = 0;\n\t\tconst myConcatExpression = formatResult(expressions, \"._formatters.StandardFormatter#concat\", undefined, true);\n\t\tconst allParts = [];\n\t\ttransformRecursively(myConcatExpression, \"PathInModel\", (constantPath: PathInModelExpression<unknown>) => {\n\t\t\tallParts.push(constantPath);\n\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t});\n\t\tallParts.unshift(constant(JSON.stringify(myConcatExpression)));\n\t\treturn formatResult(allParts, \"._formatters.StandardFormatter.bind($control)#evaluateComplexExpression\", undefined, true);\n\t}\n\treturn {\n\t\t_type: \"Concat\",\n\t\texpressions: expressions\n\t};\n}\n\ntype ExpressionTypeToExpression<T extends ExpressionType, V> = T extends \"Constant\"\n\t? ConstantExpression<V>\n\t: T extends \"PathInModel\"\n\t? PathInModelExpression<V>\n\t: T extends \"Function\"\n\t? FunctionExpression<V>\n\t: T extends \"Unresolvable\"\n\t? UnresolvablePathExpression\n\t: BindingToolkitExpression<V>;\n\nexport type TransformFunction<T, V> = (expressionPart: T) => BindingToolkitExpression<V>;\nexport type ExpressionType = Pick<BindingToolkitExpression<unknown>, \"_type\">[\"_type\"];\nexport function transformRecursively<T extends PrimitiveType | unknown, ET extends ExpressionType>(\n\tinExpression: BindingToolkitExpression<T>,\n\texpressionType: ET,\n\ttransformFunction: TransformFunction<ExpressionTypeToExpression<ET, T>, T>,\n\tincludeAllExpression = false\n): BindingToolkitExpression<T> {\n\tlet expression: BindingToolkitExpression<T> = inExpression;\n\tswitch (expression._type) {\n\t\tcase \"Function\":\n\t\tcase \"Formatter\":\n\t\t\texpression.parameters = expression.parameters.map((parameter) =>\n\t\t\t\ttransformRecursively(parameter as BindingToolkitExpression<T>, expressionType, transformFunction, includeAllExpression)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase \"Concat\":\n\t\t\texpression.expressions = expression.expressions.map((subExpression) =>\n\t\t\t\ttransformRecursively(\n\t\t\t\t\tsubExpression,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, string>, string>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t)\n\t\t\t);\n\t\t\texpression = concat(...expression.expressions) as BindingToolkitExpression<T>;\n\t\t\tbreak;\n\t\tcase \"ComplexType\":\n\t\t\texpression.bindingParameters = expression.bindingParameters.map((bindingParameter) =>\n\t\t\t\ttransformRecursively(\n\t\t\t\t\tbindingParameter as BindingToolkitExpression<T>,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase \"IfElse\":\n\t\t\tconst onTrue = transformRecursively(\n\t\t\t\texpression.onTrue,\n\t\t\t\texpressionType,\n\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, unknown>, unknown>,\n\t\t\t\tincludeAllExpression\n\t\t\t);\n\t\t\tconst onFalse = transformRecursively(\n\t\t\t\texpression.onFalse,\n\t\t\t\texpressionType,\n\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, unknown>, unknown>,\n\t\t\t\tincludeAllExpression\n\t\t\t);\n\t\t\tlet condition = expression.condition;\n\t\t\tif (includeAllExpression) {\n\t\t\t\tcondition = transformRecursively(\n\t\t\t\t\texpression.condition,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t}\n\t\t\texpression = ifElse(condition, onTrue, onFalse) as BindingToolkitExpression<T>;\n\t\t\tbreak;\n\t\tcase \"Not\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operand = transformRecursively(\n\t\t\t\t\texpression.operand,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\texpression = not(operand) as BindingToolkitExpression<T>;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Truthy\":\n\t\t\tbreak;\n\t\tcase \"Set\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operands = expression.operands.map((operand) =>\n\t\t\t\t\ttransformRecursively(\n\t\t\t\t\t\toperand,\n\t\t\t\t\t\texpressionType,\n\t\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\t\tincludeAllExpression\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\texpression =\n\t\t\t\t\texpression.operator === \"||\"\n\t\t\t\t\t\t? (or(...operands) as BindingToolkitExpression<T>)\n\t\t\t\t\t\t: (and(...operands) as BindingToolkitExpression<T>);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Comparison\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operand1 = transformRecursively(\n\t\t\t\t\texpression.operand1 as BindingToolkitExpression<T>,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\tconst operand2 = transformRecursively(\n\t\t\t\t\texpression.operand2 as BindingToolkitExpression<T>,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\texpression = comparison(expression.operator, operand1, operand2) as BindingToolkitExpression<T>;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Constant\":\n\t\t\tconst constantValue: Record<string, BindingToolkitExpression<unknown>> = expression.value as Record<\n\t\t\t\tstring,\n\t\t\t\tBindingToolkitExpression<unknown>\n\t\t\t>;\n\t\t\tif (typeof constantValue === \"object\" && constantValue) {\n\t\t\t\tObject.keys(constantValue).forEach((key) => {\n\t\t\t\t\tconstantValue[key] = transformRecursively(\n\t\t\t\t\t\tconstantValue[key],\n\t\t\t\t\t\texpressionType,\n\t\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, unknown>, unknown>,\n\t\t\t\t\t\tincludeAllExpression\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Ref\":\n\t\tcase \"Length\":\n\t\tcase \"PathInModel\":\n\t\tcase \"EmbeddedBinding\":\n\t\tcase \"EmbeddedExpressionBinding\":\n\t\tcase \"Unresolvable\":\n\t\t\t// Do nothing\n\t\t\tbreak;\n\t}\n\tif (expressionType === expression._type) {\n\t\texpression = transformFunction(inExpression as ExpressionTypeToExpression<ET, T>);\n\t}\n\treturn expression;\n}\n\nexport type CompiledBindingToolkitExpression = string | undefined;\n\nconst needParenthesis = function <T extends PrimitiveType>(expr: ExpressionOrPrimitive<T>): boolean {\n\treturn (\n\t\t!isConstant(expr) &&\n\t\t!isPathInModelExpression(expr) &&\n\t\tisBindingToolkitExpression(expr) &&\n\t\texpr._type !== \"IfElse\" &&\n\t\texpr._type !== \"Function\"\n\t);\n};\n\n/**\n * Compiles a constant object to a string.\n * @param expr\n * @param isNullable\n * @returns The compiled string\n */\nfunction compileConstantObject(expr: ConstantExpression<object>, isNullable = false): string {\n\tif (isNullable && Object.keys(expr.value).length === 0) {\n\t\treturn \"\";\n\t}\n\tconst objects = expr.value as PlainExpressionObject;\n\tconst properties: string[] = [];\n\tObject.keys(objects).forEach((key) => {\n\t\tconst value = objects[key];\n\t\tconst childResult = compileExpression(value, true, false, isNullable);\n\t\tif (childResult && childResult.length > 0) {\n\t\t\tproperties.push(`${key}: ${childResult}`);\n\t\t}\n\t});\n\treturn `{${properties.join(\", \")}}`;\n}\n\n/**\n * Compiles a Constant Binding Expression.\n * @param expr\n * @param embeddedInBinding\n * @param isNullable\n * @param doNotStringify\n * @returns The compiled string\n */\nexport function compileConstant<T extends PrimitiveType>(\n\texpr: ConstantExpression<T>,\n\tembeddedInBinding: boolean,\n\tisNullable?: boolean,\n\tdoNotStringify?: false\n): CompiledBindingToolkitExpression;\nexport function compileConstant<T extends PrimitiveType>(\n\texpr: ConstantExpression<T>,\n\tembeddedInBinding: boolean,\n\tisNullable?: boolean,\n\tdoNotStringify?: true\n): PrimitiveType;\nexport function compileConstant<T extends PrimitiveType>(\n\texpr: ConstantExpression<T>,\n\tembeddedInBinding: boolean,\n\tisNullable = false,\n\tdoNotStringify = false\n): CompiledBindingToolkitExpression | PrimitiveType {\n\tif (expr.value === null) {\n\t\treturn doNotStringify ? null : \"null\";\n\t}\n\tif (expr.value === undefined) {\n\t\treturn doNotStringify ? undefined : \"undefined\";\n\t}\n\tif (typeof expr.value === \"object\") {\n\t\tif (Array.isArray(expr.value)) {\n\t\t\tconst entries = expr.value.map((expression) => compileExpression(expression, true));\n\t\t\treturn `[${entries.join(\", \")}]`;\n\t\t} else {\n\t\t\treturn compileConstantObject(expr as ConstantExpression<object>, isNullable);\n\t\t}\n\t}\n\n\tif (embeddedInBinding) {\n\t\tswitch (typeof expr.value) {\n\t\t\tcase \"number\":\n\t\t\tcase \"bigint\":\n\t\t\tcase \"boolean\":\n\t\t\t\treturn expr.value.toString();\n\t\t\tcase \"string\":\n\t\t\t\treturn `'${escapeXmlAttribute(expr.value.toString())}'`;\n\t\t\tdefault:\n\t\t\t\treturn \"\";\n\t\t}\n\t} else {\n\t\treturn doNotStringify ? expr.value : expr.value.toString();\n\t}\n}\n\n/**\n * Generates the binding string for a Binding expression.\n * @param expressionForBinding The expression to compile\n * @param embeddedInBinding Whether the expression to compile is embedded into another expression\n * @param embeddedSeparator The binding value evaluator ($ or % depending on whether we want to force the type or not)\n * @returns The corresponding expression binding\n */\nfunction compilePathInModelExpression<T extends PrimitiveType>(\n\texpressionForBinding: PathInModelExpression<T>,\n\tembeddedInBinding: boolean,\n\tembeddedSeparator: string\n): CompiledBindingToolkitExpression {\n\tif (\n\t\texpressionForBinding.type ||\n\t\texpressionForBinding.parameters ||\n\t\texpressionForBinding.targetType ||\n\t\texpressionForBinding.formatOptions ||\n\t\texpressionForBinding.constraints\n\t) {\n\t\t// This is now a complex binding definition, let's prepare for it\n\t\tconst complexBindingDefinition = {\n\t\t\tpath: compilePathInModel(expressionForBinding),\n\t\t\ttype: expressionForBinding.type,\n\t\t\ttargetType: expressionForBinding.targetType,\n\t\t\tparameters: expressionForBinding.parameters,\n\t\t\tformatOptions: expressionForBinding.formatOptions,\n\t\t\tconstraints: expressionForBinding.constraints\n\t\t};\n\t\tconst outBinding = compileExpression(complexBindingDefinition, false, false, true);\n\t\tif (embeddedInBinding) {\n\t\t\tconst separator = expressionForBinding.alwaysKeepTargetType ? \"$\" : embeddedSeparator;\n\t\t\treturn `${separator}${outBinding}`;\n\t\t}\n\t\treturn outBinding;\n\t} else if (embeddedInBinding) {\n\t\treturn `${embeddedSeparator}{${compilePathInModel(expressionForBinding)}}`;\n\t} else {\n\t\treturn `{${compilePathInModel(expressionForBinding)}}`;\n\t}\n}\n\nfunction compileComplexTypeExpression<T extends PrimitiveType>(expression: ComplexTypeExpression<T>): string {\n\tif (expression.bindingParameters.length === 1) {\n\t\treturn `{${compilePathParameter(expression.bindingParameters[0] as BindingToolkitExpression<PrimitiveType>, true)}, type: '${\n\t\t\texpression.type\n\t\t}'}`;\n\t}\n\n\tlet outputEnd = `], type: '${expression.type}'`;\n\tif (hasElements(expression.formatOptions)) {\n\t\toutputEnd += `, formatOptions: ${compileExpression(expression.formatOptions)}`;\n\t}\n\tif (hasElements(expression.constraints)) {\n\t\toutputEnd += `, constraints: ${compileExpression(expression.constraints)}`;\n\t}\n\tif (hasElements(expression.parameters)) {\n\t\toutputEnd += `, parameters: ${compileExpression(expression.parameters)}`;\n\t}\n\toutputEnd += \"}\";\n\n\treturn `{mode:'TwoWay', parts:[${expression.bindingParameters\n\t\t.map((param) => compilePathParameter(param as BindingToolkitExpression<PrimitiveType>))\n\t\t.join(\",\")}${outputEnd}`;\n}\n\n/**\n * Wrap the compiled binding string as required depending on its context.\n * @param expression The compiled expression\n * @param embeddedInBinding True if the compiled expression is to be embedded in a binding\n * @param parenthesisRequired True if the embedded binding needs to be wrapped in parethesis so that it is evaluated as one\n * @returns Finalized compiled expression\n */\nexport function wrapBindingExpression(\n\texpression: string,\n\tembeddedInBinding: boolean,\n\tparenthesisRequired = false\n): CompiledBindingToolkitExpression {\n\tif (embeddedInBinding) {\n\t\tif (parenthesisRequired) {\n\t\t\treturn `(${expression})`;\n\t\t} else {\n\t\t\treturn expression;\n\t\t}\n\t} else {\n\t\treturn `{= ${expression}}`;\n\t}\n}\n\n/**\n * Compile an expression into an expression binding.\n * @template T The target type\n * @param expression The expression to compile\n * @param embeddedInBinding Whether the expression to compile is embedded into another expression\n * @param keepTargetType Keep the target type of the embedded bindings instead of casting them to any\n * @param isNullable Whether binding expression can resolve to empty string or not\n * @returns The corresponding expression binding\n */\nexport function compileExpression<T extends PrimitiveType>(\n\texpression: ExpressionOrPrimitive<T>,\n\tembeddedInBinding = false,\n\tkeepTargetType = false,\n\tisNullable = false\n): CompiledBindingToolkitExpression {\n\tconst expr = wrapPrimitive(expression);\n\tconst embeddedSeparator = keepTargetType ? \"$\" : \"%\";\n\n\tswitch (expr._type) {\n\t\tcase \"Unresolvable\":\n\t\t\treturn undefined;\n\n\t\tcase \"Constant\":\n\t\t\treturn compileConstant(expr, embeddedInBinding, isNullable);\n\n\t\tcase \"Ref\":\n\t\t\treturn expr.ref || \"null\";\n\n\t\tcase \"Function\":\n\t\t\tlet hasEmbeddedFunctionCallOrBinding = false;\n\t\t\tif (expr.isFormattingFn) {\n\t\t\t\ttransformRecursively(\n\t\t\t\t\texpr,\n\t\t\t\t\t\"Function\",\n\t\t\t\t\t(subFn) => {\n\t\t\t\t\t\tif (subFn !== expr && subFn.obj === undefined) {\n\t\t\t\t\t\t\thasEmbeddedFunctionCallOrBinding = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn subFn;\n\t\t\t\t\t},\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t\ttransformRecursively(\n\t\t\t\t\texpr,\n\t\t\t\t\t\"Constant\",\n\t\t\t\t\t(subFn: ConstantExpression<T>) => {\n\t\t\t\t\t\tif ((subFn as unknown) !== expr && typeof subFn.value === \"object\") {\n\t\t\t\t\t\t\ttransformRecursively(subFn, \"PathInModel\", (subSubFn) => {\n\t\t\t\t\t\t\t\thasEmbeddedFunctionCallOrBinding = true;\n\t\t\t\t\t\t\t\treturn subSubFn;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn subFn;\n\t\t\t\t\t},\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst argumentString = `${expr.parameters.map((arg) => compileExpression(arg, true)).join(\", \")}`;\n\t\t\tlet fnCall =\n\t\t\t\texpr.obj === undefined\n\t\t\t\t\t? `${expr.fn}(${argumentString})`\n\t\t\t\t\t: `${compileExpression(expr.obj, true)}.${expr.fn}(${argumentString})`;\n\t\t\tif (!embeddedInBinding && hasEmbeddedFunctionCallOrBinding) {\n\t\t\t\tfnCall = `{= ${fnCall}}`;\n\t\t\t}\n\t\t\treturn fnCall;\n\n\t\tcase \"EmbeddedExpressionBinding\":\n\t\t\treturn embeddedInBinding ? `(${expr.value.substring(2, expr.value.length - 1)})` : `${expr.value}`;\n\n\t\tcase \"EmbeddedBinding\":\n\t\t\treturn embeddedInBinding ? `${embeddedSeparator}${expr.value}` : `${expr.value}`;\n\n\t\tcase \"PathInModel\":\n\t\t\treturn compilePathInModelExpression(expr, embeddedInBinding, embeddedSeparator);\n\n\t\tcase \"Comparison\":\n\t\t\tconst comparisonExpression = compileComparisonExpression(expr);\n\t\t\treturn wrapBindingExpression(comparisonExpression, embeddedInBinding);\n\n\t\tcase \"IfElse\":\n\t\t\tconst ifElseExpression = `${compileExpression(expr.condition, true)} ? ${compileExpression(\n\t\t\t\texpr.onTrue,\n\t\t\t\ttrue,\n\t\t\t\tkeepTargetType\n\t\t\t)} : ${compileExpression(expr.onFalse, true, keepTargetType)}`;\n\t\t\treturn wrapBindingExpression(ifElseExpression, embeddedInBinding, true);\n\n\t\tcase \"Set\":\n\t\t\tconst setExpression = expr.operands.map((operand) => compileExpression(operand, true)).join(` ${expr.operator} `);\n\t\t\treturn wrapBindingExpression(setExpression, embeddedInBinding, true);\n\n\t\tcase \"Concat\":\n\t\t\tconst concatExpression = expr.expressions\n\t\t\t\t.map((nestedExpression) => compileExpression(nestedExpression, true, true))\n\t\t\t\t.join(\" + \");\n\t\t\treturn wrapBindingExpression(concatExpression, embeddedInBinding);\n\n\t\tcase \"Length\":\n\t\t\tconst lengthExpression = `${compileExpression(expr.pathInModel, true)}.length`;\n\t\t\treturn wrapBindingExpression(lengthExpression, embeddedInBinding);\n\n\t\tcase \"Not\":\n\t\t\tconst notExpression = `!${compileExpression(expr.operand, true)}`;\n\t\t\treturn wrapBindingExpression(notExpression, embeddedInBinding);\n\n\t\tcase \"Truthy\":\n\t\t\tconst truthyExpression = `!!${compileExpression(expr.operand, true)}`;\n\t\t\treturn wrapBindingExpression(truthyExpression, embeddedInBinding);\n\n\t\tcase \"Formatter\":\n\t\t\tconst formatterExpression = compileFormatterExpression(expr);\n\t\t\treturn embeddedInBinding ? `$${formatterExpression}` : formatterExpression;\n\n\t\tcase \"ComplexType\":\n\t\t\tconst complexTypeExpression = compileComplexTypeExpression(expr);\n\t\t\treturn embeddedInBinding ? `$${complexTypeExpression}` : complexTypeExpression;\n\n\t\tdefault:\n\t\t\treturn \"\";\n\t}\n}\n\n/**\n * Compile a comparison expression.\n * @param expression The comparison expression.\n * @returns The compiled expression. Needs wrapping before it can be used as an expression binding.\n */\nfunction compileComparisonExpression(expression: ComparisonExpression): string {\n\tfunction compileOperand(operand: BindingToolkitExpression<unknown>): CompiledBindingToolkitExpression {\n\t\tconst compiledOperand = compileExpression(operand, true) ?? \"undefined\";\n\t\treturn wrapBindingExpression(compiledOperand, true, needParenthesis(operand));\n\t}\n\n\treturn `${compileOperand(expression.operand1)} ${expression.operator} ${compileOperand(expression.operand2)}`;\n}\n\n/**\n * Compile a formatter expression.\n * @param expression The formatter expression.\n * @returns The compiled expression.\n */\nfunction compileFormatterExpression<T extends PrimitiveType>(expression: FormatterExpression<T>): string {\n\tif (expression.parameters.length === 1) {\n\t\treturn `{${compilePathParameter(expression.parameters[0] as BindingToolkitExpression<PrimitiveType>, true)}, formatter: '${\n\t\t\texpression.fn\n\t\t}'}`;\n\t} else {\n\t\tconst parts = expression.parameters.map((param) => {\n\t\t\tif (param._type === \"ComplexType\") {\n\t\t\t\treturn compileComplexTypeExpression(param);\n\t\t\t} else {\n\t\t\t\treturn compilePathParameter(param as BindingToolkitExpression<PrimitiveType>);\n\t\t\t}\n\t\t});\n\t\treturn `{parts: [${parts.join(\", \")}], formatter: '${expression.fn}'}`;\n\t}\n}\n\n/**\n * Compile the path parameter of a formatter call.\n * @param expression The binding part to evaluate\n * @param singlePath Whether there is one or multiple path to consider\n * @returns The string snippet to include in the overall binding definition\n */\nfunction compilePathParameter(expression: BindingToolkitExpression<PrimitiveType>, singlePath = false): string {\n\tlet outValue = \"\";\n\tif (expression._type === \"Constant\") {\n\t\tif (expression.value === undefined) {\n\t\t\t// Special case otherwise the JSTokenizer complains about incorrect content\n\t\t\toutValue = `value: 'undefined'`;\n\t\t} else {\n\t\t\toutValue = `value: ${compileConstant(expression, true)}`;\n\t\t}\n\t} else if (expression._type === \"PathInModel\") {\n\t\toutValue = `path: '${compilePathInModel(expression)}'`;\n\n\t\toutValue += expression.type ? `, type: '${expression.type}'` : `, targetType: 'any'`;\n\t\tif (expression.mode) {\n\t\t\toutValue += `, mode: '${compileExpression(expression.mode)}'`;\n\t\t}\n\t\tif (hasElements(expression.constraints)) {\n\t\t\toutValue += `, constraints: ${compileExpression(expression.constraints)}`;\n\t\t}\n\t\tif (hasElements(expression.formatOptions)) {\n\t\t\toutValue += `, formatOptions: ${compileExpression(expression.formatOptions)}`;\n\t\t}\n\t\tif (hasElements(expression.parameters)) {\n\t\t\toutValue += `, parameters: ${compileExpression(expression.parameters)}`;\n\t\t}\n\t} else {\n\t\treturn \"\";\n\t}\n\treturn singlePath ? outValue : `{${outValue}}`;\n}\n\nfunction hasElements(obj: object | undefined): boolean {\n\treturn !!obj && Object.keys(obj).length > 0;\n}\n\n/**\n * Compile a binding expression path.\n * @param expression The expression to compile.\n * @returns The compiled path.\n */\nfunction compilePathInModel<T extends PrimitiveType>(expression: PathInModelExpression<T>): string {\n\treturn `${expression.modelName ? expression.modelName + \">\" : \"\"}${expression.path}`;\n}\n"],"mappings":"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","ignoreList":[]}