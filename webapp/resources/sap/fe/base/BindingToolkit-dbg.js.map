{"version":3,"names":["isProperty","serviceObject","_type","_exports","EDM_TYPE_MAPPING","type","constraints","$Precision","$V4","$Scale","$MaxLength","$Nullable","unresolvableExpression","escapeXmlAttribute","inputString","replace","hasUnresolvableExpression","_len","arguments","length","expressions","Array","_key","find","expr","undefined","_checkExpressionsAreEqual","a","b","value","operand","operator","operands","every","expression","some","otherExpression","condition","onTrue","onFalse","operand1","operand2","aExpressions","bExpressions","index","pathInModel","modelName","path","targetEntitySet","fn","parameters","bindingParameters","otherFunction","obj","ref","flattenSetExpression","reduce","result","candidatesForFlattening","forEach","candidate","e","push","hasOppositeExpressions","negatedExpressions","map","not","i","and","_len2","_key2","wrapPrimitive","isStaticFalse","nonTrivialExpression","filter","isFalse","isConstant","constant","isValid","isTrue","or","_len3","_key3","isStaticTrue","isComparison","isTruthy","bindingExpression","visitedNavigationPaths","pathVisitor","targetPath","localPath","concat","join","constantValue","isArray","isPrimitiveObject","valueOf","Object","entries","plainExpression","_ref","key","val","wrappedValue","resolveBindingString","targetType","startsWith","pathInModelRegex","pathInModelRegexMatch","exec","isNaN","Number","reference","bindState","stateObjectProp","__bindingInfo","toString","model","something","isBindingToolkitExpression","maybeConstant","isPathInModelExpression","maybeBinding","isComplexTypeExpression","isConcatExpression","isIfElseExpression","isUndefinedExpression","expressionAsExpression","objectType","constructor","name","isComplexAnnotationExpression","annotationValue","getExpressionFromAnnotation","defaultValue","annotationIfExpression","$If","parseAnnotationCondition","$Not","equal","$Eq","notEqual","$Ne","greaterThan","$Gt","greaterOrEqual","$Ge","lessThan","$Lt","lessOrEqual","$Le","$Or","orCondition","$And","andCondition","annotationApplyExpression","hasOwnProperty","$Path","$Function","$Apply","resolveEnumValue","$EnumMember","ifElse","convertSubApplyParameters","applyParam","applyParamConverted","applyExpression","parameter","template","templateParams","slice","targetObject","$Name","$LabeledElement","comparison","leftOperand","rightOperand","leftExpression","rightExpression","checkUndefined","left","right","reduced","conditionExpression","onTrueExpression","onFalseExpression","pathIdx","myIfElseExpression","formatResult","allParts","transformRecursively","constantPath","unshift","JSON","stringify","hasReferenceToDefaultContext","formatterFunction","contextEntityType","ignoreComplexType","parameterExpressions","keys","functionName","__functionName","formatterClass","formatterName","split","myFormatExpression","setUpConstraints","targetMapping","property","scale","precision","maxLength","nullable","annotations","Validation","Minimum","minimum","Maximum","maximum","Common","IsDigitSequence","isDigitSequence","V4","formatWithTypeInformation","propertyBindingExpression","ignoreConstraints","outExpression","formatOptions","indexOf","assign","parseAsString","parseKeepsEmptyString","fiscalType","getFiscalType","typesSupportingParseEmptyValueToZero","includes","parseEmptyValueToZero","emptyString","IsFiscalYear","IsFiscalPeriod","IsFiscalYearPeriod","IsFiscalQuarter","IsFiscalYearQuarter","IsFiscalWeek","IsFiscalYearWeek","IsDayOfFiscalYear","addTypeInformation","oFormatOptions","oConstraintOptions","_getComplexTypeFormatOptionsFromFirstParam","uomPath","mode","preserveDecimals","skipDecimalsValidation","currencyPath","decimals","param","showNumber","showMeasure","decimalPadding","func","on","isFormattingFn","isEmpty","aBindings","finalExpression","alwaysKeepTargetType","_len4","inExpressions","_key4","concatenated","myConcatExpression","inExpression","expressionType","transformFunction","includeAllExpression","subExpression","bindingParameter","needParenthesis","compileConstantObject","isNullable","objects","properties","childResult","compileExpression","compileConstant","embeddedInBinding","doNotStringify","compilePathInModelExpression","expressionForBinding","embeddedSeparator","complexBindingDefinition","compilePathInModel","outBinding","separator","compileComplexTypeExpression","compilePathParameter","outputEnd","hasElements","wrapBindingExpression","parenthesisRequired","keepTargetType","hasEmbeddedFunctionCallOrBinding","subFn","subSubFn","argumentString","arg","fnCall","substring","comparisonExpression","compileComparisonExpression","ifElseExpression","setExpression","concatExpression","nestedExpression","lengthExpression","notExpression","truthyExpression","formatterExpression","compileFormatterExpression","complexTypeExpression","compileOperand","compiledOperand","parts","singlePath","outValue"],"sourceRoot":".","sources":["BindingToolkit.ts"],"sourcesContent":["import type {\n\tActionParameter,\n\tAndAnnotationExpression,\n\tAndConditionalExpression,\n\tApplyAnnotationExpression,\n\tBoolean,\n\tConditionalCheckOrValue,\n\tEntitySet,\n\tEntityType,\n\tEqAnnotationExpression,\n\tEqConditionalExpression,\n\tGeAnnotationExpression,\n\tGeConditionalExpression,\n\tGtAnnotationExpression,\n\tGtConditionalExpression,\n\tIfAnnotationExpression,\n\tIfAnnotationExpressionValue,\n\tLeAnnotationExpression,\n\tLeConditionalExpression,\n\tLtAnnotationExpression,\n\tLtConditionalExpression,\n\tNeAnnotationExpression,\n\tNeConditionalExpression,\n\tNotAnnotationExpression,\n\tNotConditionalExpression,\n\tOrAnnotationExpression,\n\tOrConditionalExpression,\n\tPathAnnotationExpression,\n\tPathConditionExpression,\n\tProperty,\n\tPropertyAnnotationValue,\n\tConstantExpression as VocabConstantExpression\n} from \"@sap-ux/vocabularies-types\";\nimport { CommonAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport { resolveEnumValue } from \"sap/fe/base/AnnotationEnum\";\nimport type { BindingInfoHolder } from \"sap/fe/base/ClassSupport\";\n\nexport type PrimitiveType = string | number | bigint | boolean | object | null | undefined;\ntype DefinedPrimitiveType = string | number | bigint | boolean | object;\ntype PrimitiveTypeCast<P> = P extends String ? string : P extends Boolean ? boolean : P extends Number ? number : P;\ntype BaseExpression<_T> = {\n\t_type: string;\n};\n\nexport type FormatOptions = Partial<{\n\tcustomUnits: Record<string, object>;\n\tcustomCurrencies: Record<string, object>;\n\tdecimals: number;\n\temptyString: null | number | string;\n\tfiscalType: string;\n\tgroupingEnabled: boolean;\n\tmaxFractionDigits: number;\n\tmaxIntegerDigits: number;\n\tminFractionDigits: number;\n\tminIntegerDigits: number;\n\tparseAsString: boolean;\n\tparseKeepsEmptyString: boolean;\n\tpattern: string;\n\tprecision: number;\n\tpreserveDecimals: boolean;\n\tshortDecimals: number;\n\tshortRefNumber: number;\n\tshowMeasure: boolean;\n\tshowNumber: boolean;\n\tshowScale: boolean;\n\tstyle: string;\n}>;\n\nexport type ConstantExpression<T> = BaseExpression<T> & {\n\t_type: \"Constant\";\n\tvalue: T;\n};\n\ntype SetOperator = \"&&\" | \"||\";\nexport type SetExpression = BaseExpression<boolean> & {\n\t_type: \"Set\";\n\toperator: SetOperator;\n\toperands: BindingToolkitExpression<boolean>[];\n};\n\nexport type NotExpression = BaseExpression<boolean> & {\n\t_type: \"Not\";\n\toperand: BindingToolkitExpression<boolean>;\n};\n\nexport type TruthyExpression = BaseExpression<boolean> & {\n\t_type: \"Truthy\";\n\toperand: BindingToolkitExpression<string>;\n};\n\nexport type ReferenceExpression = BaseExpression<object> & {\n\t_type: \"Ref\";\n\tref: string | null;\n};\n\nexport type FormatterExpression<T> = BaseExpression<T> & {\n\t_type: \"Formatter\";\n\tfn: string;\n\tparameters: BindingToolkitExpression<unknown>[];\n};\n\ntype ComplexTypeExpression<T> = BaseExpression<T> & {\n\t_type: \"ComplexType\";\n\ttype: string;\n\tformatOptions: FormatOptions;\n\tconstraints: object;\n\tparameters: object;\n\tbindingParameters: BindingToolkitExpression<unknown>[];\n};\n\nexport type FunctionExpression<T> = BaseExpression<T> & {\n\t_type: \"Function\";\n\tobj?: BindingToolkitExpression<object>;\n\tfn: string;\n\tisFormattingFn: boolean;\n\tparameters: BindingToolkitExpression<unknown>[];\n};\n\nexport type ConcatExpression = BaseExpression<string> & {\n\t_type: \"Concat\";\n\texpressions: BindingToolkitExpression<string>[];\n};\n\nexport type LengthExpression = BaseExpression<string> & {\n\t_type: \"Length\";\n\tpathInModel: PathInModelExpression<unknown>;\n};\n\ntype UnresolvablePathExpression = BaseExpression<string> & {\n\t_type: \"Unresolvable\";\n};\n\n/**\n * @typedef PathInModelExpression\n */\nexport type PathInModelExpression<T> = BaseExpression<T> & {\n\t_type: \"PathInModel\";\n\tmodelName?: string;\n\tpath: string;\n\ttargetEntitySet?: EntitySet;\n\ttype?: string;\n\tconstraints?: BindingConstraints;\n\tparameters?: object;\n\ttargetType?: string;\n\tmode?: string;\n\tformatOptions?: FormatOptions;\n\talwaysKeepTargetType?: boolean;\n};\n\nexport type EmbeddedUI5BindingExpression<T> = BaseExpression<T> & {\n\t_type: \"EmbeddedBinding\";\n\tvalue: string;\n};\n\nexport type EmbeddedUI5ExpressionBindingExpression<T> = BaseExpression<T> & {\n\t_type: \"EmbeddedExpressionBinding\";\n\tvalue: string;\n};\n\nexport type ComparisonOperator = \"===\" | \"!==\" | \">=\" | \">\" | \"<=\" | \"<\";\nexport type ComparisonExpression = BaseExpression<boolean> & {\n\t_type: \"Comparison\";\n\toperator: ComparisonOperator;\n\toperand1: BindingToolkitExpression<unknown>;\n\toperand2: BindingToolkitExpression<unknown>;\n};\n\nexport type IfElseExpression<T> = BaseExpression<T> & {\n\t_type: \"IfElse\";\n\tcondition: BindingToolkitExpression<boolean>;\n\tonTrue: BindingToolkitExpression<T>;\n\tonFalse: BindingToolkitExpression<T>;\n};\nexport function isProperty(serviceObject: unknown): serviceObject is Property {\n\treturn (serviceObject as Property)?._type === \"Property\";\n}\n\n/**\n * An expression that evaluates to type T.\n * @typedef BindingToolkitExpression\n */\nexport type BindingToolkitExpression<T> =\n\t| UnresolvablePathExpression\n\t| ConstantExpression<T>\n\t| SetExpression\n\t| NotExpression\n\t| TruthyExpression\n\t| ConcatExpression\n\t| LengthExpression\n\t| PathInModelExpression<T>\n\t| EmbeddedUI5BindingExpression<T>\n\t| EmbeddedUI5ExpressionBindingExpression<T>\n\t| ComparisonExpression\n\t| IfElseExpression<T>\n\t| FormatterExpression<T>\n\t| ComplexTypeExpression<T>\n\t| ReferenceExpression\n\t| FunctionExpression<T>;\n\ntype TypeMappingDefinition = {\n\ttype: string;\n\tconstraints?: {\n\t\t$Precision?: string;\n\t\t$V4?: string;\n\t\t$Scale?: string;\n\t\t$MaxLength?: string;\n\t\t$Nullable?: string;\n\t\t\"@Org.OData.Validation.V1.Minimum/$Decimal\"?: string;\n\t\t\"@Org.OData.Validation.V1.Minimum@Org.OData.Validation.V1.Exclusive\"?: string;\n\t\t\"@Org.OData.Validation.V1.Maximum/$Decimal\"?: string;\n\t\t\"@Org.OData.Validation.V1.Maximum@Org.OData.Validation.V1.Exclusive\"?: string;\n\t\t\"@com.sap.vocabularies.Common.v1.IsDigitSequence\"?: string;\n\t};\n};\nexport const EDM_TYPE_MAPPING: Record<string, TypeMappingDefinition> = {\n\t\"Edm.Boolean\": { type: \"sap.ui.model.odata.type.Boolean\" },\n\t\"Edm.Byte\": { type: \"sap.ui.model.odata.type.Byte\" },\n\t\"Edm.Date\": { type: \"sap.ui.model.odata.type.Date\" },\n\t\"Edm.DateTimeOffset\": {\n\t\tconstraints: {\n\t\t\t$Precision: \"precision\",\n\t\t\t$V4: \"V4\"\n\t\t},\n\t\ttype: \"sap.ui.model.odata.type.DateTimeOffset\"\n\t},\n\t\"Edm.Decimal\": {\n\t\tconstraints: {\n\t\t\t\"@Org.OData.Validation.V1.Minimum/$Decimal\": \"minimum\",\n\t\t\t\"@Org.OData.Validation.V1.Minimum@Org.OData.Validation.V1.Exclusive\": \"minimumExclusive\",\n\t\t\t\"@Org.OData.Validation.V1.Maximum/$Decimal\": \"maximum\",\n\t\t\t\"@Org.OData.Validation.V1.Maximum@Org.OData.Validation.V1.Exclusive\": \"maximumExclusive\",\n\t\t\t$Precision: \"precision\",\n\t\t\t$Scale: \"scale\"\n\t\t},\n\t\ttype: \"sap.ui.model.odata.type.Decimal\"\n\t},\n\t\"Edm.Double\": { type: \"sap.ui.model.odata.type.Double\" },\n\t\"Edm.Guid\": { type: \"sap.ui.model.odata.type.Guid\" },\n\t\"Edm.Int16\": { type: \"sap.ui.model.odata.type.Int16\" },\n\t\"Edm.Int32\": { type: \"sap.ui.model.odata.type.Int32\" },\n\t\"Edm.Int64\": { type: \"sap.ui.model.odata.type.Int64\" },\n\t\"Edm.SByte\": { type: \"sap.ui.model.odata.type.SByte\" },\n\t\"Edm.Single\": { type: \"sap.ui.model.odata.type.Single\" },\n\t\"Edm.Stream\": { type: \"sap.ui.model.odata.type.Stream\" },\n\t\"Edm.Binary\": { type: \"sap.ui.model.odata.type.Stream\" },\n\t\"Edm.String\": {\n\t\tconstraints: {\n\t\t\t\"@com.sap.vocabularies.Common.v1.IsDigitSequence\": \"isDigitSequence\",\n\t\t\t$MaxLength: \"maxLength\",\n\t\t\t$Nullable: \"nullable\"\n\t\t},\n\t\ttype: \"sap.ui.model.odata.type.String\"\n\t},\n\t\"Edm.TimeOfDay\": {\n\t\tconstraints: {\n\t\t\t$Precision: \"precision\"\n\t\t},\n\t\ttype: \"sap.ui.model.odata.type.TimeOfDay\"\n\t}\n};\n\n/**\n * An expression that evaluates to type T, or a constant value of type T\n */\nexport type ExpressionOrPrimitive<T extends PrimitiveType> = BindingToolkitExpression<T> | T;\n\nexport const unresolvableExpression: UnresolvablePathExpression = {\n\t_type: \"Unresolvable\"\n};\n\nexport function escapeXmlAttribute(inputString: string): string {\n\treturn inputString.replace(/'/g, \"\\\\'\");\n}\n\nexport function hasUnresolvableExpression(...expressions: BindingToolkitExpression<unknown>[]): boolean {\n\treturn expressions.find((expr) => expr._type === \"Unresolvable\") !== undefined;\n}\n/**\n * Check two expressions for (deep) equality.\n * @param a\n * @param b\n * @returns `true` if the two expressions are equal\n */\nexport function _checkExpressionsAreEqual<T>(a: BindingToolkitExpression<T>, b: BindingToolkitExpression<T>): boolean {\n\tif (a._type !== b._type) {\n\t\treturn false;\n\t}\n\n\tswitch (a._type) {\n\t\tcase \"Unresolvable\":\n\t\t\treturn false; // Unresolvable is never equal to anything even itself\n\t\tcase \"Constant\":\n\t\tcase \"EmbeddedBinding\":\n\t\tcase \"EmbeddedExpressionBinding\":\n\t\t\treturn a.value === (b as ConstantExpression<T>).value;\n\n\t\tcase \"Not\":\n\t\t\treturn _checkExpressionsAreEqual(a.operand, (b as NotExpression).operand);\n\t\tcase \"Truthy\":\n\t\t\treturn _checkExpressionsAreEqual(a.operand, (b as TruthyExpression).operand);\n\t\tcase \"Set\":\n\t\t\treturn (\n\t\t\t\ta.operator === (b as SetExpression).operator &&\n\t\t\t\ta.operands.length === (b as SetExpression).operands.length &&\n\t\t\t\ta.operands.every((expression) =>\n\t\t\t\t\t(b as SetExpression).operands.some((otherExpression) => _checkExpressionsAreEqual(expression, otherExpression))\n\t\t\t\t)\n\t\t\t);\n\n\t\tcase \"IfElse\":\n\t\t\treturn (\n\t\t\t\t_checkExpressionsAreEqual(a.condition, (b as IfElseExpression<T>).condition) &&\n\t\t\t\t_checkExpressionsAreEqual(a.onTrue, (b as IfElseExpression<T>).onTrue) &&\n\t\t\t\t_checkExpressionsAreEqual(a.onFalse, (b as IfElseExpression<T>).onFalse)\n\t\t\t);\n\n\t\tcase \"Comparison\":\n\t\t\treturn (\n\t\t\t\ta.operator === (b as ComparisonExpression).operator &&\n\t\t\t\t_checkExpressionsAreEqual(a.operand1, (b as ComparisonExpression).operand1) &&\n\t\t\t\t_checkExpressionsAreEqual(a.operand2, (b as ComparisonExpression).operand2)\n\t\t\t);\n\n\t\tcase \"Concat\":\n\t\t\tconst aExpressions = a.expressions;\n\t\t\tconst bExpressions = (b as ConcatExpression).expressions;\n\t\t\tif (aExpressions.length !== bExpressions.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn aExpressions.every((expression, index) => {\n\t\t\t\treturn _checkExpressionsAreEqual(expression, bExpressions[index]);\n\t\t\t});\n\n\t\tcase \"Length\":\n\t\t\treturn _checkExpressionsAreEqual(a.pathInModel, (b as LengthExpression).pathInModel);\n\n\t\tcase \"PathInModel\":\n\t\t\treturn (\n\t\t\t\ta.modelName === (b as PathInModelExpression<T>).modelName &&\n\t\t\t\ta.path === (b as PathInModelExpression<T>).path &&\n\t\t\t\ta.targetEntitySet === (b as PathInModelExpression<T>).targetEntitySet\n\t\t\t);\n\n\t\tcase \"Formatter\":\n\t\t\treturn (\n\t\t\t\ta.fn === (b as FormatterExpression<T>).fn &&\n\t\t\t\ta.parameters.length === (b as FormatterExpression<T>).parameters.length &&\n\t\t\t\ta.parameters.every((value, index) => _checkExpressionsAreEqual((b as FormatterExpression<T>).parameters[index], value))\n\t\t\t);\n\t\tcase \"ComplexType\":\n\t\t\treturn (\n\t\t\t\ta.type === (b as ComplexTypeExpression<T>).type &&\n\t\t\t\ta.bindingParameters.length === (b as ComplexTypeExpression<T>).bindingParameters.length &&\n\t\t\t\ta.bindingParameters.every((value, index) =>\n\t\t\t\t\t_checkExpressionsAreEqual((b as ComplexTypeExpression<T>).bindingParameters[index], value)\n\t\t\t\t)\n\t\t\t);\n\t\tcase \"Function\":\n\t\t\tconst otherFunction = b as FunctionExpression<T>;\n\t\t\tif (a.obj === undefined || otherFunction.obj === undefined) {\n\t\t\t\treturn a.obj === otherFunction;\n\t\t\t}\n\n\t\t\treturn (\n\t\t\t\ta.fn === otherFunction.fn &&\n\t\t\t\t_checkExpressionsAreEqual(a.obj, otherFunction.obj) &&\n\t\t\t\ta.parameters.length === otherFunction.parameters.length &&\n\t\t\t\ta.parameters.every((value, index) => _checkExpressionsAreEqual(otherFunction.parameters[index], value))\n\t\t\t);\n\n\t\tcase \"Ref\":\n\t\t\treturn a.ref === (b as ReferenceExpression).ref;\n\t}\n\treturn false;\n}\n\n/**\n * Converts a nested SetExpression by inlining operands of type SetExpression with the same operator.\n * @param expression The expression to flatten\n * @returns A new SetExpression with the same operator\n */\nfunction flattenSetExpression(expression: SetExpression): SetExpression {\n\treturn expression.operands.reduce(\n\t\t(result: SetExpression, operand) => {\n\t\t\tconst candidatesForFlattening =\n\t\t\t\toperand._type === \"Set\" && operand.operator === expression.operator ? operand.operands : [operand];\n\t\t\tcandidatesForFlattening.forEach((candidate) => {\n\t\t\t\tif (result.operands.every((e) => !_checkExpressionsAreEqual(e, candidate))) {\n\t\t\t\t\tresult.operands.push(candidate);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn result;\n\t\t},\n\t\t{ _type: \"Set\", operator: expression.operator, operands: [] }\n\t);\n}\n\n/**\n * Detects whether an array of boolean expressions contains an expression and its negation.\n * @param expressions Array of expressions\n * @returns `true` if the set of expressions contains an expression and its negation\n */\nfunction hasOppositeExpressions(expressions: BindingToolkitExpression<boolean>[]): boolean {\n\tconst negatedExpressions = expressions.map(not);\n\treturn expressions.some((expression, index) => {\n\t\tfor (let i = index + 1; i < negatedExpressions.length; i++) {\n\t\t\tif (_checkExpressionsAreEqual(expression, negatedExpressions[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t});\n}\n\n/**\n * Logical `and` expression.\n *\n * The expression is simplified to false if this can be decided statically (that is, if one operand is a constant\n * false or if the expression contains an operand and its negation).\n * @param operands Expressions to connect by `and`\n * @returns Expression evaluating to boolean\n */\nexport function and(...operands: ExpressionOrPrimitive<boolean>[]): BindingToolkitExpression<boolean> {\n\tconst expressions = flattenSetExpression({\n\t\t_type: \"Set\",\n\t\toperator: \"&&\",\n\t\toperands: operands.map(wrapPrimitive)\n\t}).operands;\n\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet isStaticFalse = false;\n\tconst nonTrivialExpression = expressions.filter((expression) => {\n\t\tif (isFalse(expression)) {\n\t\t\tisStaticFalse = true;\n\t\t}\n\t\treturn !isConstant(expression);\n\t});\n\tif (isStaticFalse) {\n\t\treturn constant(false);\n\t} else if (nonTrivialExpression.length === 0) {\n\t\t// Resolve the constant then\n\t\tconst isValid = expressions.reduce((result, expression) => result && isTrue(expression), true);\n\t\treturn constant(isValid);\n\t} else if (nonTrivialExpression.length === 1) {\n\t\treturn nonTrivialExpression[0];\n\t} else if (hasOppositeExpressions(nonTrivialExpression)) {\n\t\treturn constant(false);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Set\",\n\t\t\toperator: \"&&\",\n\t\t\toperands: nonTrivialExpression\n\t\t};\n\t}\n}\n\n/**\n * Logical `or` expression.\n *\n * The expression is simplified to true if this can be decided statically (that is, if one operand is a constant\n * true or if the expression contains an operand and its negation).\n * @param operands Expressions to connect by `or`\n * @returns Expression evaluating to boolean\n */\nexport function or(...operands: ExpressionOrPrimitive<boolean>[]): BindingToolkitExpression<boolean> {\n\tconst expressions = flattenSetExpression({\n\t\t_type: \"Set\",\n\t\toperator: \"||\",\n\t\toperands: operands.map(wrapPrimitive)\n\t}).operands;\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet isStaticTrue = false;\n\tconst nonTrivialExpression = expressions.filter((expression) => {\n\t\tif (isTrue(expression)) {\n\t\t\tisStaticTrue = true;\n\t\t}\n\t\treturn !isConstant(expression) || expression.value;\n\t});\n\tif (isStaticTrue) {\n\t\treturn constant(true);\n\t} else if (nonTrivialExpression.length === 0) {\n\t\t// Resolve the constant then\n\t\tconst isValid = expressions.reduce((result, expression) => result && isTrue(expression), true);\n\t\treturn constant(isValid);\n\t} else if (nonTrivialExpression.length === 1) {\n\t\treturn nonTrivialExpression[0];\n\t} else if (hasOppositeExpressions(nonTrivialExpression)) {\n\t\treturn constant(true);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Set\",\n\t\t\toperator: \"||\",\n\t\t\toperands: nonTrivialExpression\n\t\t};\n\t}\n}\n\n/**\n * Logical `not` operator.\n * @param operand The expression to reverse\n * @returns The resulting expression that evaluates to boolean\n */\nexport function not(operand: ExpressionOrPrimitive<boolean>): BindingToolkitExpression<boolean> {\n\toperand = wrapPrimitive(operand);\n\tif (hasUnresolvableExpression(operand)) {\n\t\treturn unresolvableExpression;\n\t} else if (isConstant(operand)) {\n\t\treturn constant(!operand.value);\n\t} else if (\n\t\ttypeof operand === \"object\" &&\n\t\toperand._type === \"Set\" &&\n\t\toperand.operator === \"||\" &&\n\t\toperand.operands.every((expression) => isConstant(expression) || isComparison(expression))\n\t) {\n\t\treturn and(...operand.operands.map((expression) => not(expression)));\n\t} else if (\n\t\ttypeof operand === \"object\" &&\n\t\toperand._type === \"Set\" &&\n\t\toperand.operator === \"&&\" &&\n\t\toperand.operands.every((expression) => isConstant(expression) || isComparison(expression))\n\t) {\n\t\treturn or(...operand.operands.map((expression) => not(expression)));\n\t} else if (isComparison(operand)) {\n\t\t// Create the reverse comparison\n\t\tswitch (operand.operator) {\n\t\t\tcase \"!==\":\n\t\t\t\treturn { ...operand, operator: \"===\" };\n\t\t\tcase \"<\":\n\t\t\t\treturn { ...operand, operator: \">=\" };\n\t\t\tcase \"<=\":\n\t\t\t\treturn { ...operand, operator: \">\" };\n\t\t\tcase \"===\":\n\t\t\t\treturn { ...operand, operator: \"!==\" };\n\t\t\tcase \">\":\n\t\t\t\treturn { ...operand, operator: \"<=\" };\n\t\t\tcase \">=\":\n\t\t\t\treturn { ...operand, operator: \"<\" };\n\t\t}\n\t} else if (operand._type === \"Not\") {\n\t\treturn operand.operand;\n\t}\n\n\treturn {\n\t\t_type: \"Not\",\n\t\toperand: operand\n\t};\n}\n\n/**\n * Evaluates whether a binding expression is equal to true with a loose equality.\n * @param operand The expression to check\n * @returns The resulting expression that evaluates to boolean\n */\nexport function isTruthy(operand: BindingToolkitExpression<string>): BindingToolkitExpression<boolean> {\n\tif (isConstant(operand)) {\n\t\treturn constant(!!operand.value);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Truthy\",\n\t\t\toperand: operand\n\t\t};\n\t}\n}\n\n/**\n * Creates a binding expression that will be evaluated by the corresponding model.\n * @param path\n * @param modelName\n * @param visitedNavigationPaths\n * @param pathVisitor\n * @returns An expression representating that path in the model\n * @deprecated use pathInModel instead\n */\nexport function bindingExpression<TargetType extends PrimitiveType>(\n\tpath: string,\n\tmodelName?: string,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): PathInModelExpression<TargetType> | UnresolvablePathExpression {\n\treturn pathInModel(path, modelName, visitedNavigationPaths, pathVisitor);\n}\n\n/**\n * Creates a binding expression that will be evaluated by the corresponding model.\n * @template TargetType\n * @param path The path on the model\n * @param [modelName] The name of the model\n * @param [visitedNavigationPaths] The paths from the root entitySet\n * @param [pathVisitor] A function to modify the resulting path\n * @returns An expression representating that path in the model\n */\nexport function pathInModel(\n\tpath: undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: Function\n): UnresolvablePathExpression;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: undefined\n): PathInModelExpression<TargetType>;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string | undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: Function\n): UnresolvablePathExpression | PathInModelExpression<TargetType>;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string | undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): UnresolvablePathExpression | PathInModelExpression<TargetType> {\n\tif (path === undefined) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet targetPath;\n\tif (pathVisitor) {\n\t\ttargetPath = pathVisitor(path);\n\t\tif (targetPath === undefined) {\n\t\t\treturn unresolvableExpression;\n\t\t}\n\t} else {\n\t\tconst localPath = visitedNavigationPaths.concat();\n\t\tlocalPath.push(path);\n\t\ttargetPath = localPath.join(\"/\");\n\t}\n\treturn {\n\t\t_type: \"PathInModel\",\n\t\tmodelName: modelName,\n\t\tpath: targetPath\n\t};\n}\n\ntype PlainExpressionObject = { [index: string]: BindingToolkitExpression<unknown> };\n\n/**\n * Creates a constant expression based on a primitive value.\n * @template T\n * @param value The constant to wrap in an expression\n * @returns The constant expression\n */\nexport function constant<T extends PrimitiveType>(value: T): ConstantExpression<T> {\n\tlet constantValue: T;\n\n\tif (typeof value === \"object\" && value !== null && value !== undefined) {\n\t\tif (Array.isArray(value)) {\n\t\t\tconstantValue = value.map(wrapPrimitive) as T;\n\t\t} else if (isPrimitiveObject(value)) {\n\t\t\tconstantValue = value.valueOf() as T;\n\t\t} else {\n\t\t\tconstantValue = Object.entries(value).reduce((plainExpression, [key, val]) => {\n\t\t\t\tconst wrappedValue = wrapPrimitive(val);\n\t\t\t\tif (wrappedValue._type !== \"Constant\" || wrappedValue.value !== undefined) {\n\t\t\t\t\tplainExpression[key] = wrappedValue;\n\t\t\t\t}\n\t\t\t\treturn plainExpression;\n\t\t\t}, {} as PlainExpressionObject) as T;\n\t\t}\n\t} else {\n\t\tconstantValue = value;\n\t}\n\n\treturn { _type: \"Constant\", value: constantValue };\n}\n\nexport function resolveBindingString<T extends PrimitiveType>(\n\tvalue: string | boolean | number,\n\ttargetType?: string\n): ConstantExpression<T> | PathInModelExpression<T> | EmbeddedUI5BindingExpression<T> | EmbeddedUI5ExpressionBindingExpression<T> {\n\tif (value !== undefined && typeof value === \"string\" && value.startsWith(\"{\")) {\n\t\tconst pathInModelRegex = /^{(.*)>(.+)}$/; // Matches model paths like \"model>path\" or \">path\" (default model)\n\t\tconst pathInModelRegexMatch = pathInModelRegex.exec(value);\n\n\t\tif (value.startsWith(\"{=\")) {\n\t\t\t// Expression binding, we can just remove the outer binding things\n\t\t\treturn {\n\t\t\t\t_type: \"EmbeddedExpressionBinding\",\n\t\t\t\tvalue: value\n\t\t\t};\n\t\t} else if (pathInModelRegexMatch) {\n\t\t\treturn pathInModel(pathInModelRegexMatch[2] || \"\", pathInModelRegexMatch[1] || undefined);\n\t\t} else {\n\t\t\treturn {\n\t\t\t\t_type: \"EmbeddedBinding\",\n\t\t\t\tvalue: value\n\t\t\t};\n\t\t}\n\t} else if (targetType === \"boolean\" && typeof value === \"string\" && (value === \"true\" || value === \"false\")) {\n\t\treturn constant(value === \"true\") as ConstantExpression<T>;\n\t} else if (targetType === \"number\" && typeof value === \"string\" && (!isNaN(Number(value)) || value === \"NaN\")) {\n\t\treturn constant(Number(value)) as ConstantExpression<T>;\n\t} else {\n\t\treturn constant(value) as ConstantExpression<T>;\n\t}\n}\n\n/**\n * A named reference.\n * @see fn\n * @param reference Reference\n * @returns The object reference binding part\n */\nexport function ref(reference: string | null): ReferenceExpression {\n\treturn { _type: \"Ref\", ref: reference };\n}\n\n/**\n * Wrap a state object into a path in model expression.\n * @template T\n * @param stateObjectProp The object to evaluate, if it's a constant it will be wrapped in a constant expression, if it's a state property it will be bound\n * @param key The key of the state object to bind\n * @returns The correct binding toolkit expression\n */\nexport function bindState<T extends object, K extends PrimitiveType>(\n\tstateObjectProp: T,\n\tkey: keyof T\n): PathInModelExpression<K> | ConstantExpression<K> {\n\tif (typeof stateObjectProp === \"object\" && (stateObjectProp as BindingInfoHolder<T>).__bindingInfo) {\n\t\treturn pathInModel(\"/\" + key.toString(), (stateObjectProp as BindingInfoHolder<T>).__bindingInfo.model);\n\t} else {\n\t\treturn constant(stateObjectProp) as unknown as ConstantExpression<K>;\n\t}\n}\n/**\n * Wrap a primitive into a constant expression if it is not already an expression.\n * @template T\n * @param something The object to wrap in a Constant expression\n * @returns Either the original object or the wrapped one depending on the case\n */\nexport function wrapPrimitive<T extends PrimitiveType>(something: ExpressionOrPrimitive<T>): BindingToolkitExpression<T> {\n\tif (isBindingToolkitExpression(something)) {\n\t\treturn something as BindingToolkitExpression<T>;\n\t}\n\n\treturn constant(something);\n}\n\n/**\n * Checks if the expression or value provided is a binding tooling expression or not.\n *\n * Every object having a property named `_type` of some value is considered an expression, even if there is actually\n * no such expression type supported.\n * @param expression\n * @returns `true` if the expression is a binding toolkit expression\n */\nexport function isBindingToolkitExpression(\n\texpression: BindingToolkitExpression<unknown> | unknown\n): expression is BindingToolkitExpression<unknown> {\n\treturn (expression as BindingToolkitExpression<unknown>)?._type !== undefined;\n}\n\n/**\n * Checks if the expression or value provided is constant or not.\n * @template T The target type\n * @param  maybeConstant The expression or primitive value that is to be checked\n * @returns `true` if it is constant\n */\nexport function isConstant<T extends PrimitiveType>(maybeConstant: ExpressionOrPrimitive<T>): maybeConstant is ConstantExpression<T> {\n\treturn typeof maybeConstant !== \"object\" || (maybeConstant as BaseExpression<T>)._type === \"Constant\";\n}\n\nfunction isTrue(expression: BindingToolkitExpression<PrimitiveType>): boolean {\n\treturn isConstant(expression) && expression.value === true;\n}\n\nfunction isFalse(expression: BindingToolkitExpression<PrimitiveType>): boolean {\n\treturn isConstant(expression) && expression.value === false;\n}\n\n/**\n * Checks if the expression or value provided is a path in model expression or not.\n * @template T The target type\n * @param  maybeBinding The expression or primitive value that is to be checked\n * @returns `true` if it is a path in model expression\n */\nexport function isPathInModelExpression<T extends PrimitiveType>(\n\tmaybeBinding: ExpressionOrPrimitive<T>\n): maybeBinding is PathInModelExpression<T> {\n\treturn (maybeBinding as BaseExpression<T>)?._type === \"PathInModel\";\n}\n\n/**\n * Checks if the expression or value provided is a complex type expression.\n * @template T The target type\n * @param  maybeBinding The expression or primitive value that is to be checked\n * @returns `true` if it is a path in model expression\n */\nexport function isComplexTypeExpression<T extends PrimitiveType>(\n\tmaybeBinding: ExpressionOrPrimitive<T>\n): maybeBinding is ComplexTypeExpression<T> {\n\treturn (maybeBinding as BaseExpression<T>)?._type === \"ComplexType\";\n}\n\n/**\n * Checks if the expression or value provided is a concat expression or not.\n * @param expression\n * @returns `true` if the expression is a ConcatExpression\n */\nfunction isConcatExpression(expression: BindingToolkitExpression<PrimitiveType>): expression is ConcatExpression {\n\treturn (expression as BaseExpression<PrimitiveType>)?._type === \"Concat\";\n}\n\n/**\n * Checks if the expression or value provided is a IfElse expression or not.\n * @param expression\n * @returns `true` if the expression is a IfElseExpression\n */\nfunction isIfElseExpression(expression: BindingToolkitExpression<PrimitiveType>): expression is ConcatExpression {\n\treturn (expression as BaseExpression<PrimitiveType>)?._type === \"IfElse\";\n}\n\n/**\n * Checks if the expression provided is a comparison or not.\n * @template T The target type\n * @param expression The expression\n * @returns `true` if the expression is a ComparisonExpression\n */\nfunction isComparison<T extends PrimitiveType>(expression: BindingToolkitExpression<T>): expression is ComparisonExpression {\n\treturn expression._type === \"Comparison\";\n}\n\n/**\n * Checks whether the input parameter is a constant expression of type undefined.\n * @param expression The input expression or object in general\n * @returns `true` if the input is constant which has undefined for value\n */\nexport function isUndefinedExpression(expression: unknown): expression is ConstantExpression<undefined> {\n\tconst expressionAsExpression = expression as BindingToolkitExpression<unknown>;\n\treturn expressionAsExpression?._type === \"Constant\" && expressionAsExpression?.value === undefined;\n}\n\ntype ComplexAnnotationExpression<P> =\n\t| PathAnnotationExpression<P>\n\t| ApplyAnnotationExpression<P>\n\t| IfAnnotationExpression<P>\n\t| OrAnnotationExpression<P>\n\t| AndAnnotationExpression<P>\n\t| NeAnnotationExpression<P>\n\t| EqAnnotationExpression<P>\n\t| NotAnnotationExpression<P>\n\t| GtAnnotationExpression<P>\n\t| GeAnnotationExpression<P>\n\t| LeAnnotationExpression<P>\n\t| LtAnnotationExpression<P>\n\t| VocabConstantExpression<P>;\n\nfunction isPrimitiveObject(objectType: object): boolean {\n\tswitch (objectType.constructor.name) {\n\t\tcase \"String\":\n\t\tcase \"Number\":\n\t\tcase \"Boolean\":\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n/**\n * Check if the passed annotation annotationValue is a ComplexAnnotationExpression.\n * @template T The target type\n * @param  annotationValue The annotation annotationValue to evaluate\n * @returns `true` if the object is a {ComplexAnnotationExpression}\n */\nfunction isComplexAnnotationExpression<T>(annotationValue: PropertyAnnotationValue<T>): annotationValue is ComplexAnnotationExpression<T> {\n\treturn typeof annotationValue === \"object\" && !isPrimitiveObject(annotationValue as object);\n}\n\n/**\n * Generate the corresponding annotationValue for a given annotation annotationValue.\n * @template T The target type\n * @param annotationValue The source annotation annotationValue\n * @param visitedNavigationPaths The path from the root entity set\n * @param defaultValue Default value if the annotationValue is undefined\n * @param pathVisitor A function to modify the resulting path\n * @returns The annotationValue equivalent to that annotation annotationValue\n */\nexport function getExpressionFromAnnotation<T extends PrimitiveType>(\n\tannotationValue: PropertyAnnotationValue<T> | undefined,\n\tvisitedNavigationPaths: string[] = [],\n\tdefaultValue?: ExpressionOrPrimitive<T>,\n\tpathVisitor?: Function\n): BindingToolkitExpression<PrimitiveTypeCast<T>> {\n\tif (annotationValue === undefined) {\n\t\treturn wrapPrimitive(defaultValue as PrimitiveTypeCast<T>);\n\t}\n\tannotationValue = annotationValue?.valueOf() as PropertyAnnotationValue<T>;\n\tif (!isComplexAnnotationExpression(annotationValue)) {\n\t\treturn constant(annotationValue);\n\t}\n\n\tswitch (annotationValue.type) {\n\t\tcase \"Path\":\n\t\t\treturn pathInModel(annotationValue.path, undefined, visitedNavigationPaths, pathVisitor);\n\t\tcase \"If\":\n\t\t\treturn annotationIfExpression(annotationValue.$If, visitedNavigationPaths, pathVisitor) as BindingToolkitExpression<\n\t\t\t\tPrimitiveTypeCast<T>\n\t\t\t>;\n\t\tcase \"Not\":\n\t\t\treturn not(parseAnnotationCondition(annotationValue.$Not, visitedNavigationPaths, pathVisitor)) as BindingToolkitExpression<\n\t\t\t\tPrimitiveTypeCast<T>\n\t\t\t>;\n\t\tcase \"Eq\":\n\t\t\treturn equal(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Eq[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Eq[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Ne\":\n\t\t\treturn notEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ne[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ne[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Gt\":\n\t\t\treturn greaterThan(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Gt[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Gt[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Ge\":\n\t\t\treturn greaterOrEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ge[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ge[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Lt\":\n\t\t\treturn lessThan(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Lt[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Lt[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Le\":\n\t\t\treturn lessOrEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Le[0], visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Le[1], visitedNavigationPaths, pathVisitor)\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Or\":\n\t\t\treturn or(\n\t\t\t\t...annotationValue.$Or.map(function (orCondition) {\n\t\t\t\t\treturn parseAnnotationCondition<boolean>(orCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t\t})\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"And\":\n\t\t\treturn and(\n\t\t\t\t...annotationValue.$And.map(function (andCondition) {\n\t\t\t\t\treturn parseAnnotationCondition<boolean>(andCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t\t})\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Apply\":\n\t\t\treturn annotationApplyExpression(\n\t\t\t\tannotationValue as ApplyAnnotationExpression<string>,\n\t\t\t\tvisitedNavigationPaths,\n\t\t\t\tpathVisitor\n\t\t\t) as BindingToolkitExpression<PrimitiveTypeCast<T>>;\n\t\tcase \"Constant\":\n\t\t\t// Not a real case but the type system needs it\n\t\t\treturn constant(annotationValue.value as PrimitiveTypeCast<T>);\n\t}\n\treturn unresolvableExpression;\n}\n\n/**\n * Parse the annotation condition into an expression.\n * @template T The target type\n * @param annotationValue The condition or value from the annotation\n * @param visitedNavigationPaths The path from the root entity set\n * @param pathVisitor A function to modify the resulting path\n * @returns An equivalent expression\n */\nfunction parseAnnotationCondition<T extends PrimitiveType>(\n\tannotationValue: ConditionalCheckOrValue,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): BindingToolkitExpression<T> {\n\tif (annotationValue === null || typeof annotationValue !== \"object\") {\n\t\treturn constant(annotationValue as T);\n\t} else if (annotationValue.hasOwnProperty(\"$Or\")) {\n\t\treturn or(\n\t\t\t...((annotationValue as OrConditionalExpression).$Or.map(function (orCondition) {\n\t\t\t\treturn parseAnnotationCondition(orCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t}) as unknown as BindingToolkitExpression<boolean>[])\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$And\")) {\n\t\treturn and(\n\t\t\t...((annotationValue as AndConditionalExpression).$And.map(function (andCondition) {\n\t\t\t\treturn parseAnnotationCondition(andCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t}) as unknown as BindingToolkitExpression<boolean>[])\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Not\")) {\n\t\treturn not(\n\t\t\tparseAnnotationCondition((annotationValue as NotConditionalExpression).$Not, visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Eq\")) {\n\t\treturn equal(\n\t\t\tparseAnnotationCondition((annotationValue as EqConditionalExpression).$Eq[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as EqConditionalExpression).$Eq[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Ne\")) {\n\t\treturn notEqual(\n\t\t\tparseAnnotationCondition((annotationValue as NeConditionalExpression).$Ne[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as NeConditionalExpression).$Ne[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Gt\")) {\n\t\treturn greaterThan(\n\t\t\tparseAnnotationCondition((annotationValue as GtConditionalExpression).$Gt[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as GtConditionalExpression).$Gt[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Ge\")) {\n\t\treturn greaterOrEqual(\n\t\t\tparseAnnotationCondition((annotationValue as GeConditionalExpression).$Ge[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as GeConditionalExpression).$Ge[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Lt\")) {\n\t\treturn lessThan(\n\t\t\tparseAnnotationCondition((annotationValue as LtConditionalExpression).$Lt[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as LtConditionalExpression).$Lt[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Le\")) {\n\t\treturn lessOrEqual(\n\t\t\tparseAnnotationCondition((annotationValue as LeConditionalExpression).$Le[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as LeConditionalExpression).$Le[1], visitedNavigationPaths, pathVisitor)\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Path\")) {\n\t\treturn pathInModel((annotationValue as PathConditionExpression<T>).$Path, undefined, visitedNavigationPaths, pathVisitor);\n\t} else if (annotationValue.hasOwnProperty(\"$Apply\")) {\n\t\treturn getExpressionFromAnnotation(\n\t\t\t{\n\t\t\t\ttype: \"Apply\",\n\t\t\t\t$Function: (annotationValue as { $Function?: string }).$Function,\n\t\t\t\t$Apply: (annotationValue as { $Apply?: unknown }).$Apply\n\t\t\t} as ApplyAnnotationExpression<T>,\n\t\t\tvisitedNavigationPaths,\n\t\t\tundefined,\n\t\t\tpathVisitor\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$If\")) {\n\t\treturn getExpressionFromAnnotation(\n\t\t\t{\n\t\t\t\ttype: \"If\",\n\t\t\t\t$If: (annotationValue as { $If?: unknown }).$If\n\t\t\t} as IfAnnotationExpression<T>,\n\t\t\tvisitedNavigationPaths,\n\t\t\tundefined,\n\t\t\tpathVisitor\n\t\t) as BindingToolkitExpression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$EnumMember\")) {\n\t\treturn constant(resolveEnumValue((annotationValue as { $EnumMember?: string }).$EnumMember) as T);\n\t}\n\treturn constant(false as T);\n}\n\n/**\n * Process the {IfAnnotationExpressionValue} into an expression.\n * @template T The target type\n * @param annotationValue An If expression returning the type T\n * @param visitedNavigationPaths The path from the root entity set\n * @param pathVisitor A function to modify the resulting path\n * @returns The equivalent ifElse expression\n */\nexport function annotationIfExpression<T extends PrimitiveType>(\n\tannotationValue: IfAnnotationExpressionValue<T>,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): BindingToolkitExpression<T> {\n\treturn ifElse(\n\t\tparseAnnotationCondition(annotationValue[0], visitedNavigationPaths, pathVisitor),\n\t\tparseAnnotationCondition(annotationValue[1] as ConditionalCheckOrValue, visitedNavigationPaths, pathVisitor),\n\t\tparseAnnotationCondition(annotationValue[2] as ConditionalCheckOrValue, visitedNavigationPaths, pathVisitor)\n\t);\n}\n// This type is not recursively transformed from the metamodel content, as such we have some ugly things there\ntype SubApplyExpressionFromMetamodel = Record<string, unknown>;\nfunction convertSubApplyParameters(applyParam: SubApplyExpressionFromMetamodel): SubApplyExpressionFromMetamodel | PrimitiveType {\n\tlet applyParamConverted = applyParam;\n\tif (applyParam.hasOwnProperty(\"$Path\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"Path\",\n\t\t\tpath: applyParam.$Path\n\t\t} as PathAnnotationExpression<string>;\n\t} else if (applyParam.hasOwnProperty(\"$If\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"If\",\n\t\t\t$If: applyParam.$If\n\t\t} as IfAnnotationExpression<string>;\n\t} else if (applyParam.hasOwnProperty(\"$Apply\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"Apply\",\n\t\t\t$Function: applyParam.$Function,\n\t\t\t$Apply: applyParam.$Apply\n\t\t} as ApplyAnnotationExpression<string>;\n\t}\n\treturn applyParamConverted;\n}\n\ntype ODataFunction = \"odata.concat\" | \"odata.fillUriTemplate\" | \"odata.uriEncode\";\nexport function annotationApplyExpression(\n\tapplyExpression: ApplyAnnotationExpression<string>,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): BindingToolkitExpression<string> {\n\tswitch (applyExpression.$Function as ODataFunction) {\n\t\tcase \"odata.concat\":\n\t\t\treturn concat(\n\t\t\t\t...applyExpression.$Apply.map((applyParam) => {\n\t\t\t\t\treturn getExpressionFromAnnotation(\n\t\t\t\t\t\tconvertSubApplyParameters(applyParam) as PropertyAnnotationValue<string>,\n\t\t\t\t\t\tvisitedNavigationPaths,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tpathVisitor\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\tcase \"odata.uriEncode\":\n\t\t\tconst parameter = getExpressionFromAnnotation(\n\t\t\t\tconvertSubApplyParameters(\n\t\t\t\t\tapplyExpression.$Apply[0] as unknown as SubApplyExpressionFromMetamodel\n\t\t\t\t) as PropertyAnnotationValue<string>,\n\t\t\t\tvisitedNavigationPaths,\n\t\t\t\tundefined,\n\t\t\t\tpathVisitor\n\t\t\t);\n\t\t\t// The second parameter for uriEncode is always a string since the target evaluation is against a formatValue call in ODataUtils which expect the target type as second parameter\n\t\t\treturn fn(\"odata.uriEncode\", [parameter, \"Edm.String\"], undefined, true);\n\t\tcase \"odata.fillUriTemplate\":\n\t\t\tconst template = applyExpression.$Apply[0];\n\t\t\tconst templateParams = applyExpression.$Apply.slice(1) as unknown as SubApplyExpressionFromMetamodel[];\n\t\t\tconst targetObject: Record<string, BindingToolkitExpression<unknown>> = {};\n\t\t\ttemplateParams.forEach((applyParam) => {\n\t\t\t\ttargetObject[applyParam.$Name as string] = getExpressionFromAnnotation(\n\t\t\t\t\tconvertSubApplyParameters(\n\t\t\t\t\t\tapplyParam.$LabeledElement as SubApplyExpressionFromMetamodel\n\t\t\t\t\t) as PropertyAnnotationValue<string>,\n\t\t\t\t\tvisitedNavigationPaths,\n\t\t\t\t\tundefined,\n\t\t\t\t\tpathVisitor\n\t\t\t\t);\n\t\t\t});\n\t\t\treturn fn(\"odata.fillUriTemplate\", [template, targetObject], undefined, true);\n\t}\n\treturn unresolvableExpression;\n}\n\n/**\n * Generic helper for the comparison operations (equal, notEqual, ...).\n * @template T The target type\n * @param operator The operator to apply\n * @param leftOperand The operand on the left side of the operator\n * @param rightOperand The operand on the right side of the operator\n * @returns An expression representing the comparison\n */\nfunction comparison<T extends PrimitiveType>(\n\toperator: ComparisonOperator,\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\tconst leftExpression = wrapPrimitive(leftOperand);\n\tconst rightExpression = wrapPrimitive(rightOperand);\n\tif (hasUnresolvableExpression(leftExpression, rightExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (isConstant(leftExpression) && isConstant(rightExpression)) {\n\t\tswitch (operator) {\n\t\t\tcase \"!==\":\n\t\t\t\treturn constant(leftExpression.value !== rightExpression.value);\n\t\t\tcase \"===\":\n\t\t\t\treturn constant(leftExpression.value === rightExpression.value);\n\t\t\tcase \"<\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value < rightExpression.value);\n\t\t\tcase \"<=\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value <= rightExpression.value);\n\t\t\tcase \">\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value > rightExpression.value);\n\t\t\tcase \">=\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value >= rightExpression.value);\n\t\t}\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Comparison\",\n\t\t\toperator: operator,\n\t\t\toperand1: leftExpression,\n\t\t\toperand2: rightExpression\n\t\t};\n\t}\n}\n\n/**\n * Generic helper for the length of an expression.\n * @param expression The input expression pointing to an array\n * @param checkUndefined Is the array potentially undefined\n * @returns An expression representing the length\n */\nexport function length(\n\texpression: PathInModelExpression<unknown> | UnresolvablePathExpression,\n\tcheckUndefined = false\n): BindingToolkitExpression<number> {\n\tif (expression._type === \"Unresolvable\") {\n\t\treturn expression;\n\t}\n\tif (!checkUndefined) {\n\t\treturn {\n\t\t\t_type: \"Length\",\n\t\t\tpathInModel: expression\n\t\t};\n\t}\n\treturn ifElse(equal(expression, undefined), -1, length(expression));\n}\n\n/**\n * Comparison: \"equal\" (===).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function equal<T extends PrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\tconst leftExpression = wrapPrimitive(leftOperand);\n\tconst rightExpression = wrapPrimitive(rightOperand);\n\tif (hasUnresolvableExpression(leftExpression, rightExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (_checkExpressionsAreEqual(leftExpression, rightExpression)) {\n\t\treturn constant(true);\n\t}\n\n\tfunction reduce(left: BindingToolkitExpression<T>, right: BindingToolkitExpression<T>): BindingToolkitExpression<boolean> | undefined {\n\t\tif (left._type === \"Comparison\" && isTrue(right)) {\n\t\t\t// compare(a, b) === true ~~> compare(a, b)\n\t\t\treturn left;\n\t\t} else if (left._type === \"Comparison\" && isFalse(right)) {\n\t\t\t// compare(a, b) === false ~~> !compare(a, b)\n\t\t\treturn not(left);\n\t\t} else if (left._type === \"IfElse\" && _checkExpressionsAreEqual(left.onTrue, right)) {\n\t\t\t// (if (x) { a } else { b }) === a ~~> x || (b === a)\n\t\t\treturn or(left.condition, equal(left.onFalse, right));\n\t\t} else if (left._type === \"IfElse\" && _checkExpressionsAreEqual(left.onFalse, right)) {\n\t\t\t// (if (x) { a } else { b }) === b ~~> !x || (a === b)\n\t\t\treturn or(not(left.condition), equal(left.onTrue, right));\n\t\t} else if (\n\t\t\tleft._type === \"IfElse\" &&\n\t\t\tisConstant(left.onTrue) &&\n\t\t\tisConstant(left.onFalse) &&\n\t\t\tisConstant(right) &&\n\t\t\t!_checkExpressionsAreEqual(left.onTrue, right) &&\n\t\t\t!_checkExpressionsAreEqual(left.onFalse, right)\n\t\t) {\n\t\t\treturn constant(false);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t// exploit symmetry: a === b <~> b === a\n\tconst reduced = reduce(leftExpression, rightExpression) ?? reduce(rightExpression, leftExpression);\n\treturn reduced ?? comparison(\"===\", leftExpression, rightExpression);\n}\n\n/**\n * Comparison: \"not equal\" (!==).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function notEqual<T extends PrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn not(equal(leftOperand, rightOperand));\n}\n\n/**\n * Comparison: \"greater or equal\" (>=).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function greaterOrEqual<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn comparison(\">=\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"greater than\" (>).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function greaterThan<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn comparison(\">\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"less or equal\" (<=).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function lessOrEqual<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn comparison(\"<=\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"less than\" (<).\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function lessThan<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<boolean> {\n\treturn comparison(\"<\", leftOperand, rightOperand);\n}\n\n/**\n * If-then-else expression.\n *\n * Evaluates to onTrue if the condition evaluates to true, else evaluates to onFalse.\n * @template T The target type\n * @param condition The condition to evaluate\n * @param onTrue Expression result if the condition evaluates to true\n * @param onFalse Expression result if the condition evaluates to false\n * @returns The expression that represents this conditional check\n */\nexport function ifElse<T extends PrimitiveType>(\n\tcondition: ExpressionOrPrimitive<boolean>,\n\tonTrue: ExpressionOrPrimitive<T>,\n\tonFalse: ExpressionOrPrimitive<T>\n): BindingToolkitExpression<T> {\n\tlet conditionExpression = wrapPrimitive(condition);\n\tlet onTrueExpression = wrapPrimitive(onTrue);\n\tlet onFalseExpression = wrapPrimitive(onFalse);\n\n\t// swap branches if the condition is a negation\n\tif (conditionExpression._type === \"Not\") {\n\t\t// ifElse(not(X), a, b) --> ifElse(X, b, a)\n\t\t[onTrueExpression, onFalseExpression] = [onFalseExpression, onTrueExpression];\n\t\tconditionExpression = not(conditionExpression);\n\t}\n\n\t// inline nested if-else expressions: onTrue branch\n\t// ifElse(X, ifElse(X, a, b), c) ==> ifElse(X, a, c)\n\tif (onTrueExpression._type === \"IfElse\" && _checkExpressionsAreEqual(conditionExpression, onTrueExpression.condition)) {\n\t\tonTrueExpression = onTrueExpression.onTrue;\n\t}\n\n\t// inline nested if-else expressions: onFalse branch\n\t// ifElse(X, a, ifElse(X, b, c)) ==> ifElse(X, a, c)\n\tif (onFalseExpression._type === \"IfElse\" && _checkExpressionsAreEqual(conditionExpression, onFalseExpression.condition)) {\n\t\tonFalseExpression = onFalseExpression.onFalse;\n\t}\n\n\t// (if true then a else b)  ~~> a\n\t// (if false then a else b) ~~> b\n\tif (isConstant(conditionExpression)) {\n\t\treturn conditionExpression.value ? onTrueExpression : onFalseExpression;\n\t}\n\n\t// if (isConstantBoolean(onTrueExpression) || isConstantBoolean(onFalseExpression)) {\n\t// \treturn or(and(condition, onTrueExpression as Expression<boolean>), and(not(condition), onFalseExpression as Expression<boolean>)) as Expression<T>\n\t// }\n\n\t// (if X then a else a) ~~> a\n\tif (_checkExpressionsAreEqual(onTrueExpression, onFalseExpression)) {\n\t\treturn onTrueExpression;\n\t}\n\n\t// if X then a else false ~~> X && a\n\tif (isFalse(onFalseExpression)) {\n\t\treturn and(conditionExpression, onTrueExpression as BindingToolkitExpression<boolean>) as BindingToolkitExpression<T>;\n\t}\n\n\t// if X then a else true ~~> !X || a\n\tif (isTrue(onFalseExpression)) {\n\t\treturn or(not(conditionExpression), onTrueExpression as BindingToolkitExpression<boolean>) as BindingToolkitExpression<T>;\n\t}\n\n\t// if X then false else a ~~> !X && a\n\tif (isFalse(onTrueExpression)) {\n\t\treturn and(not(conditionExpression), onFalseExpression as BindingToolkitExpression<boolean>) as BindingToolkitExpression<T>;\n\t}\n\n\t// if X then true else a ~~> X || a\n\tif (isTrue(onTrueExpression)) {\n\t\treturn or(conditionExpression, onFalseExpression as BindingToolkitExpression<boolean>) as BindingToolkitExpression<T>;\n\t}\n\tif (hasUnresolvableExpression(conditionExpression, onTrueExpression, onFalseExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (isComplexTypeExpression(condition) || isComplexTypeExpression(onTrue) || isComplexTypeExpression(onFalse)) {\n\t\tlet pathIdx = 0;\n\t\tconst myIfElseExpression = formatResult([condition, onTrue, onFalse], \"._formatters.StandardFormatter#ifElse\");\n\t\tconst allParts = [];\n\t\ttransformRecursively(\n\t\t\tmyIfElseExpression,\n\t\t\t\"PathInModel\",\n\t\t\t(constantPath: PathInModelExpression<unknown>) => {\n\t\t\t\tallParts.push(constantPath);\n\t\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t\t},\n\t\t\ttrue\n\t\t);\n\t\tallParts.unshift(constant(JSON.stringify(myIfElseExpression)));\n\t\treturn formatResult(allParts, \"._formatters.StandardFormatter.bind($control)#evaluateComplexExpression\", undefined, true);\n\t}\n\treturn {\n\t\t_type: \"IfElse\",\n\t\tcondition: conditionExpression,\n\t\tonTrue: onTrueExpression,\n\t\tonFalse: onFalseExpression\n\t};\n}\n\n/**\n * Checks whether the current expression has a reference to the default model (undefined).\n * @param expression The expression to evaluate\n * @returns `true` if there is a reference to the default context\n */\nfunction hasReferenceToDefaultContext(expression: BindingToolkitExpression<unknown>): boolean {\n\tswitch (expression._type) {\n\t\tcase \"Constant\":\n\t\tcase \"Formatter\":\n\t\tcase \"ComplexType\":\n\t\t\treturn false;\n\t\tcase \"Set\":\n\t\t\treturn expression.operands.some(hasReferenceToDefaultContext);\n\t\tcase \"PathInModel\":\n\t\t\treturn expression.modelName === undefined;\n\t\tcase \"Comparison\":\n\t\t\treturn hasReferenceToDefaultContext(expression.operand1) || hasReferenceToDefaultContext(expression.operand2);\n\t\tcase \"IfElse\":\n\t\t\treturn (\n\t\t\t\thasReferenceToDefaultContext(expression.condition) ||\n\t\t\t\thasReferenceToDefaultContext(expression.onTrue) ||\n\t\t\t\thasReferenceToDefaultContext(expression.onFalse)\n\t\t\t);\n\t\tcase \"Not\":\n\t\tcase \"Truthy\":\n\t\t\treturn hasReferenceToDefaultContext(expression.operand);\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n// This is one case where any does make sense...\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Fn<T> = ((...params: any) => T | Promise<T>) & {\n\t__functionName: string;\n};\n\n/**\n * @typedef WrappedTuple\n */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\ntype WrappedTuple<T> = { [K in keyof T]: WrappedTuple<T[K]> | ExpressionOrPrimitive<T[K]> | undefined };\n\n// So, this works but I cannot get it to compile :D, but it still does what is expected...\n\n/**\n * A function reference or a function name.\n */\ntype FunctionOrName<T> = Fn<T> | string;\n\n/**\n * Function parameters, either derived from the function or an untyped array.\n */\ntype FunctionParameters<T, F extends FunctionOrName<T>> = F extends Fn<T> ? Parameters<F> : unknown[];\n\n/**\n * Calls a formatter function to process the parameters.\n * If requireContext is set to true and no context is passed a default context will be added automatically.\n * @template T\n * @template U\n * @param parameters The list of parameter that should match the type and number of the formatter function\n * @param formatterFunction The function to call\n * @param [contextEntityType] If no parameter refers to the context then we use this information to add a reference to the keys from the entity type.\n * @param [ignoreComplexType] Whether to ignore the transgformation to the StandardFormatter or not\n * @returns The corresponding expression\n */\nexport function formatResult<T, U extends Fn<T>>(\n\tparameters: WrappedTuple<Parameters<U>>,\n\tformatterFunction: U | string,\n\tcontextEntityType?: EntityType,\n\tignoreComplexType = false\n): BindingToolkitExpression<T> {\n\tconst parameterExpressions = (parameters as ExpressionOrPrimitive<PrimitiveType>[]).map(wrapPrimitive);\n\n\tif (hasUnresolvableExpression(...parameterExpressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (contextEntityType) {\n\t\t// Otherwise, if the context is required and no context is provided make sure to add the default binding\n\t\tif (!parameterExpressions.some(hasReferenceToDefaultContext)) {\n\t\t\tcontextEntityType.keys.forEach((key) => parameterExpressions.push(pathInModel(key.name, \"\")));\n\t\t}\n\t}\n\tlet functionName = \"\";\n\tif (typeof formatterFunction === \"string\") {\n\t\tfunctionName = formatterFunction;\n\t} else {\n\t\tfunctionName = formatterFunction.__functionName;\n\t}\n\t// FormatterName can be of format sap.fe.core.xxx#methodName to have multiple formatter in one class\n\tconst [formatterClass, formatterName] = functionName.split(\"#\");\n\n\t// In some case we also cannot call directly a function because of too complex input, in that case we need to convert to a simpler function call\n\tif (\n\t\t!ignoreComplexType &&\n\t\t(parameterExpressions.some(isComplexTypeExpression) ||\n\t\t\tparameterExpressions.some(isConcatExpression) ||\n\t\t\tparameterExpressions.some(isIfElseExpression))\n\t) {\n\t\tlet pathIdx = 0;\n\t\tconst myFormatExpression = formatResult(parameterExpressions, functionName, undefined, true);\n\t\tconst allParts = [];\n\t\ttransformRecursively(\n\t\t\tmyFormatExpression,\n\t\t\t\"PathInModel\",\n\t\t\t(constantPath: PathInModelExpression<unknown>) => {\n\t\t\t\tallParts.push(constantPath);\n\t\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t\t},\n\t\t\ttrue\n\t\t);\n\t\tallParts.unshift(constant(JSON.stringify(myFormatExpression)));\n\t\treturn formatResult(allParts, \"._formatters.StandardFormatter.bind($control)#evaluateComplexExpression\", undefined, true);\n\t} else if (!!formatterName && formatterName.length > 0) {\n\t\tparameterExpressions.unshift(constant(formatterName));\n\t}\n\n\treturn {\n\t\t_type: \"Formatter\",\n\t\tfn: formatterClass,\n\t\tparameters: parameterExpressions\n\t};\n}\n\ntype BindingConstraints = {\n\tscale?: number;\n\tprecision?: number;\n\tmaxLength?: number;\n\tnullable?: boolean;\n\tminimum?: string;\n\tmaximum?: string;\n\tisDigitSequence?: boolean;\n\tV4?: boolean;\n};\nexport function setUpConstraints(targetMapping: TypeMappingDefinition, property: Property | ActionParameter): BindingConstraints {\n\tconst constraints: BindingConstraints = {};\n\tif (targetMapping?.constraints?.$Scale && property.scale !== undefined) {\n\t\tconstraints.scale = property.scale;\n\t}\n\tif (targetMapping?.constraints?.$Precision && property.precision !== undefined) {\n\t\tconstraints.precision = property.precision;\n\t}\n\tif (targetMapping?.constraints?.$MaxLength && property.maxLength !== undefined) {\n\t\tconstraints.maxLength = property.maxLength;\n\t}\n\tif (property.nullable === false) {\n\t\tconstraints.nullable = false;\n\t}\n\tif (targetMapping?.constraints?.[\"@Org.OData.Validation.V1.Minimum/$Decimal\"] && !isNaN(property.annotations?.Validation?.Minimum)) {\n\t\tconstraints.minimum = `${property.annotations?.Validation?.Minimum}`;\n\t}\n\tif (targetMapping?.constraints?.[\"@Org.OData.Validation.V1.Maximum/$Decimal\"] && !isNaN(property.annotations?.Validation?.Maximum)) {\n\t\tconstraints.maximum = `${property.annotations?.Validation?.Maximum}`;\n\t}\n\tif (\n\t\tproperty.annotations?.Common?.IsDigitSequence &&\n\t\ttargetMapping.type === \"sap.ui.model.odata.type.String\" &&\n\t\ttargetMapping?.constraints?.[\"@com.sap.vocabularies.Common.v1.IsDigitSequence\"]\n\t) {\n\t\tconstraints.isDigitSequence = true;\n\t}\n\tif (targetMapping?.constraints?.$V4) {\n\t\tconstraints.V4 = true;\n\t}\n\treturn constraints;\n}\n\n/**\n * Generates the binding expression for the property, and sets up the formatOptions and constraints.\n * @param property The Property for which we are setting up the binding\n * @param propertyBindingExpression The BindingExpression of the property above. Serves as the basis to which information can be added\n * @param ignoreConstraints Ignore constraints of the property\n * @returns The binding expression for the property with formatOptions and constraints\n */\nexport function formatWithTypeInformation<T>(\n\tproperty: Property | ActionParameter,\n\tpropertyBindingExpression: BindingToolkitExpression<string>,\n\tignoreConstraints = false\n): PathInModelExpression<T> {\n\tconst outExpression: PathInModelExpression<unknown> = propertyBindingExpression as PathInModelExpression<unknown>;\n\tif (property._type !== \"Property\" && property._type !== \"ActionParameter\") {\n\t\treturn outExpression;\n\t}\n\tconst targetMapping = EDM_TYPE_MAPPING[property.type];\n\tif (!targetMapping) {\n\t\treturn outExpression;\n\t}\n\tif (!outExpression.formatOptions) {\n\t\toutExpression.formatOptions = {};\n\t}\n\toutExpression.constraints = {};\n\n\toutExpression.type = targetMapping.type;\n\tif (!ignoreConstraints) {\n\t\toutExpression.constraints = setUpConstraints(targetMapping, property);\n\t}\n\n\tif (\n\t\t(outExpression?.type?.indexOf(\"sap.ui.model.odata.type.Int\") === 0 && outExpression?.type !== \"sap.ui.model.odata.type.Int64\") ||\n\t\toutExpression?.type === \"sap.ui.model.odata.type.Double\"\n\t) {\n\t\toutExpression.formatOptions = Object.assign(outExpression.formatOptions, {\n\t\t\tparseAsString: false\n\t\t});\n\t}\n\tif (outExpression.type === \"sap.ui.model.odata.type.String\" && isProperty(property)) {\n\t\tif (outExpression.constraints?.isDigitSequence || (outExpression.constraints?.nullable !== false && property.nullable === true)) {\n\t\t\toutExpression.formatOptions.parseKeepsEmptyString = false;\n\t\t} else {\n\t\t\toutExpression.formatOptions.parseKeepsEmptyString = true;\n\t\t}\n\t\tconst fiscalType = getFiscalType(property);\n\t\tif (fiscalType) {\n\t\t\toutExpression.formatOptions.fiscalType = fiscalType;\n\t\t\toutExpression.type = \"sap.fe.core.type.FiscalDate\";\n\t\t}\n\t}\n\tconst typesSupportingParseEmptyValueToZero = [\n\t\t\"sap.ui.model.odata.type.Int16\",\n\t\t\"sap.ui.model.odata.type.Int32\",\n\t\t\"sap.ui.model.odata.type.Int64\",\n\t\t\"sap.ui.model.odata.type.Single\",\n\t\t\"sap.ui.model.odata.type.Double\",\n\t\t\"sap.ui.model.odata.type.Decimal\",\n\t\t\"sap.ui.model.odata.type.Byte\",\n\t\t\"sap.ui.model.odata.type.SByte\"\n\t];\n\tif (\n\t\toutExpression.constraints?.nullable === false &&\n\t\toutExpression.type &&\n\t\ttypesSupportingParseEmptyValueToZero.includes(outExpression.type)\n\t) {\n\t\toutExpression.formatOptions = Object.assign(outExpression.formatOptions, {\n\t\t\tparseEmptyValueToZero: true\n\t\t});\n\t}\n\tif (\n\t\toutExpression.constraints?.nullable !== false &&\n\t\t(outExpression.type === \"sap.ui.model.odata.type.Int64\" || outExpression.type === \"sap.ui.model.odata.type.Decimal\")\n\t) {\n\t\toutExpression.formatOptions = Object.assign(outExpression.formatOptions, {\n\t\t\temptyString: \"\"\n\t\t});\n\t}\n\n\treturn outExpression;\n}\n\nexport const getFiscalType = function (property: Property): string | undefined {\n\tif (property.annotations?.Common?.IsFiscalYear) {\n\t\treturn CommonAnnotationTerms.IsFiscalYear;\n\t}\n\tif (property.annotations?.Common?.IsFiscalPeriod) {\n\t\treturn CommonAnnotationTerms.IsFiscalPeriod;\n\t}\n\tif (property.annotations?.Common?.IsFiscalYearPeriod) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearPeriod;\n\t}\n\tif (property.annotations?.Common?.IsFiscalQuarter) {\n\t\treturn CommonAnnotationTerms.IsFiscalQuarter;\n\t}\n\tif (property.annotations?.Common?.IsFiscalYearQuarter) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearQuarter;\n\t}\n\tif (property.annotations?.Common?.IsFiscalWeek) {\n\t\treturn CommonAnnotationTerms.IsFiscalWeek;\n\t}\n\tif (property.annotations?.Common?.IsFiscalYearWeek) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearWeek;\n\t}\n\tif (property.annotations?.Common?.IsDayOfFiscalYear) {\n\t\treturn CommonAnnotationTerms.IsDayOfFiscalYear;\n\t}\n};\n\n/**\n * Calls a complex type to process the parameters.\n * If requireContext is set to true and no context is passed, a default context will be added automatically.\n * @template T\n * @template U\n * @param parameters The list of parameters that should match the type for the complex type=\n * @param type The complex type to use\n * @param [contextEntityType] The context entity type to consider\n * @param oFormatOptions\n * @param oConstraintOptions\n * @returns The corresponding expression\n */\nexport function addTypeInformation<T, U extends Fn<T>>(\n\tparameters: WrappedTuple<Parameters<U>>,\n\ttype: string,\n\tcontextEntityType?: EntityType,\n\toFormatOptions?: ComplexTypeFormatOptions,\n\toConstraintOptions?: ComplexTypeConstraintOptions\n): UnresolvablePathExpression | ComplexTypeExpression<T> | ConstantExpression<T> {\n\tconst parameterExpressions = (parameters as ExpressionOrPrimitive<PrimitiveType>[]).map(wrapPrimitive);\n\tif (hasUnresolvableExpression(...parameterExpressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\t// If there is only one parameter and it is a constant and we don't expect the context then return the constant\n\tif (parameterExpressions.length === 1 && isConstant(parameterExpressions[0]) && !contextEntityType) {\n\t\treturn parameterExpressions[0] as ConstantExpression<T>;\n\t} else if (contextEntityType) {\n\t\t// Otherwise, if the context is required and no context is provided make sure to add the default binding\n\t\tif (!parameterExpressions.some(hasReferenceToDefaultContext)) {\n\t\t\tcontextEntityType.keys.forEach((key) => parameterExpressions.push(pathInModel(key.name, \"\")));\n\t\t}\n\t}\n\toFormatOptions = _getComplexTypeFormatOptionsFromFirstParam(parameters[0], oFormatOptions);\n\n\tif (type === \"sap.ui.model.odata.type.Unit\") {\n\t\tconst uomPath = pathInModel(\"/##@@requestUnitsOfMeasure\");\n\t\tuomPath.targetType = \"any\";\n\t\tuomPath.mode = \"OneTime\";\n\t\toFormatOptions ??= {};\n\t\toFormatOptions.preserveDecimals = oConstraintOptions?.skipDecimalsValidation ?? false;\n\t\tparameterExpressions.push(uomPath);\n\t} else if (type === \"sap.ui.model.odata.type.Currency\") {\n\t\tconst currencyPath = pathInModel(\"/##@@requestCurrencyCodes\");\n\t\tcurrencyPath.targetType = \"any\";\n\t\tcurrencyPath.mode = \"OneTime\";\n\t\toFormatOptions ??= {};\n\t\tif (oConstraintOptions?.skipDecimalsValidation === true) {\n\t\t\toFormatOptions.decimals = 99; // setting to 99 to avoid rounding in currency conversion\n\t\t}\n\n\t\toFormatOptions.preserveDecimals = oConstraintOptions?.skipDecimalsValidation ?? false; // default value since we don't have a CLDR\n\t\tparameterExpressions.push(currencyPath);\n\t}\n\n\treturn {\n\t\t_type: \"ComplexType\",\n\t\ttype: type,\n\t\tformatOptions: oFormatOptions || {},\n\t\tconstraints: oConstraintOptions || {},\n\t\tparameters: {},\n\t\tbindingParameters: parameterExpressions\n\t};\n}\n\ntype ComplexTypeFormatOptions = {\n\tdecimals?: number;\n\tshowNumber?: boolean;\n\tshowMeasure?: boolean;\n\tparseAsString?: boolean;\n\tparseKeepsEmptyString?: boolean;\n\temptyString?: string | number | null;\n\tshowTime?: boolean;\n\tshowDate?: boolean;\n\tshowTimezone?: boolean;\n\tpreserveDecimals?: boolean;\n\tdecimalPadding?: number;\n};\n\nexport type ComplexTypeConstraintOptions = {\n\tskipDecimalsValidation?: boolean;\n};\n\n/**\n * Process the formatOptions for a complexType based on the first parameter.\n * @param param The first parameter of the complex type\n * @param formatOptions Initial formatOptions\n * @returns The modified formatOptions\n */\nfunction _getComplexTypeFormatOptionsFromFirstParam<T, U extends Fn<T>>(\n\tparam: Parameters<U>,\n\tformatOptions: undefined | ComplexTypeFormatOptions\n): ComplexTypeFormatOptions | undefined {\n\t// if showMeasure is set to false we want to not parse as string to see the 0\n\t// we do that also for all bindings because otherwise the mdc Field isn't editable\n\tif (\n\t\t!(formatOptions && formatOptions.showNumber === false) &&\n\t\t(param?.type?.indexOf(\"sap.ui.model.odata.type.Int\") === 0 ||\n\t\t\tparam?.type === \"sap.ui.model.odata.type.Decimal\" ||\n\t\t\tparam?.type === \"sap.ui.model.odata.type.Double\")\n\t) {\n\t\tif (param?.type === \"sap.ui.model.odata.type.Int64\" || param?.type === \"sap.ui.model.odata.type.Decimal\") {\n\t\t\t//sap.ui.model.odata.type.Int64 do not support parseAsString false\n\t\t\tformatOptions =\n\t\t\t\tformatOptions?.showMeasure === false\n\t\t\t\t\t? { showMeasure: false, decimalPadding: formatOptions.decimalPadding, emptyString: formatOptions?.emptyString }\n\t\t\t\t\t: { decimalPadding: formatOptions?.decimalPadding, emptyString: formatOptions?.emptyString };\n\t\t} else {\n\t\t\tformatOptions =\n\t\t\t\tformatOptions?.showMeasure === false\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tparseAsString: false,\n\t\t\t\t\t\t\tshowMeasure: false,\n\t\t\t\t\t\t\tdecimalPadding: formatOptions.decimalPadding,\n\t\t\t\t\t\t\temptyString: formatOptions?.emptyString\n\t\t\t\t\t  }\n\t\t\t\t\t: { parseAsString: false, decimalPadding: formatOptions?.decimalPadding, emptyString: formatOptions?.emptyString };\n\t\t}\n\t\tif (param?.constraints?.nullable !== false) {\n\t\t\tformatOptions.emptyString = null;\n\t\t} else {\n\t\t\tformatOptions.emptyString ??= 0;\n\t\t}\n\t}\n\treturn formatOptions;\n}\n/**\n * Function call, optionally with arguments.\n * @param func Function name or reference to function\n * @param parameters Arguments\n * @param on Object to call the function on\n * @param isFormattingFn\n * @returns Expression representing the function call (not the result of the function call!)\n */\nexport function fn<T, U extends FunctionOrName<T>>(\n\tfunc: U,\n\tparameters: WrappedTuple<FunctionParameters<T, U>>,\n\ton?: ExpressionOrPrimitive<object>,\n\tisFormattingFn = false\n): FunctionExpression<T> {\n\tconst functionName = typeof func === \"string\" ? func : func.__functionName;\n\treturn {\n\t\t_type: \"Function\",\n\t\tobj: on !== undefined ? wrapPrimitive(on) : undefined,\n\t\tfn: functionName,\n\t\tisFormattingFn: isFormattingFn,\n\t\tparameters: (parameters as ExpressionOrPrimitive<PrimitiveType>[]).map(wrapPrimitive)\n\t};\n}\n\n/**\n * Shortcut function to determine if a binding value is null, undefined or empty.\n * @param expression\n * @returns A Boolean expression evaluating the fact that the current element is empty\n */\nexport function isEmpty(expression: BindingToolkitExpression<string>): BindingToolkitExpression<boolean> {\n\tconst aBindings: ExpressionOrPrimitive<boolean>[] = [];\n\ttransformRecursively(expression, \"PathInModel\", (expr) => {\n\t\tconst finalExpression = { ...expr, alwaysKeepTargetType: true } as PathInModelExpression<string>;\n\t\taBindings.push(or(equal(finalExpression, \"\"), equal(expr, undefined), equal(expr, null)));\n\t\treturn expr;\n\t});\n\treturn and(...aBindings);\n}\n\nexport function concat(...inExpressions: ExpressionOrPrimitive<string>[]): BindingToolkitExpression<string> {\n\tconst expressions = inExpressions.map(wrapPrimitive);\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (expressions.every(isConstant)) {\n\t\treturn constant(\n\t\t\texpressions.reduce((concatenated: string, value) => {\n\t\t\t\tif (value.value !== undefined && value.value !== null) {\n\t\t\t\t\treturn concatenated + value.value.toString();\n\t\t\t\t}\n\t\t\t\treturn concatenated;\n\t\t\t}, \"\")\n\t\t);\n\t} else if (expressions.some(isComplexTypeExpression)) {\n\t\tlet pathIdx = 0;\n\t\tconst myConcatExpression = formatResult(expressions, \"._formatters.StandardFormatter#concat\", undefined, true);\n\t\tconst allParts = [];\n\t\ttransformRecursively(myConcatExpression, \"PathInModel\", (constantPath: PathInModelExpression<unknown>) => {\n\t\t\tallParts.push(constantPath);\n\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t});\n\t\tallParts.unshift(constant(JSON.stringify(myConcatExpression)));\n\t\treturn formatResult(allParts, \"._formatters.StandardFormatter.bind($control)#evaluateComplexExpression\", undefined, true);\n\t}\n\treturn {\n\t\t_type: \"Concat\",\n\t\texpressions: expressions\n\t};\n}\n\ntype ExpressionTypeToExpression<T extends ExpressionType, V> = T extends \"Constant\"\n\t? ConstantExpression<V>\n\t: T extends \"PathInModel\"\n\t? PathInModelExpression<V>\n\t: T extends \"Function\"\n\t? FunctionExpression<V>\n\t: T extends \"Unresolvable\"\n\t? UnresolvablePathExpression\n\t: BindingToolkitExpression<V>;\n\nexport type TransformFunction<T, V> = (expressionPart: T) => BindingToolkitExpression<V>;\nexport type ExpressionType = Pick<BindingToolkitExpression<unknown>, \"_type\">[\"_type\"];\nexport function transformRecursively<T extends PrimitiveType | unknown, ET extends ExpressionType>(\n\tinExpression: BindingToolkitExpression<T>,\n\texpressionType: ET,\n\ttransformFunction: TransformFunction<ExpressionTypeToExpression<ET, T>, T>,\n\tincludeAllExpression = false\n): BindingToolkitExpression<T> {\n\tlet expression: BindingToolkitExpression<T> = inExpression;\n\tswitch (expression._type) {\n\t\tcase \"Function\":\n\t\tcase \"Formatter\":\n\t\t\texpression.parameters = expression.parameters.map((parameter) =>\n\t\t\t\ttransformRecursively(parameter as BindingToolkitExpression<T>, expressionType, transformFunction, includeAllExpression)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase \"Concat\":\n\t\t\texpression.expressions = expression.expressions.map((subExpression) =>\n\t\t\t\ttransformRecursively(\n\t\t\t\t\tsubExpression,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, string>, string>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t)\n\t\t\t);\n\t\t\texpression = concat(...expression.expressions) as BindingToolkitExpression<T>;\n\t\t\tbreak;\n\t\tcase \"ComplexType\":\n\t\t\texpression.bindingParameters = expression.bindingParameters.map((bindingParameter) =>\n\t\t\t\ttransformRecursively(\n\t\t\t\t\tbindingParameter as BindingToolkitExpression<T>,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase \"IfElse\":\n\t\t\tconst onTrue = transformRecursively(\n\t\t\t\texpression.onTrue,\n\t\t\t\texpressionType,\n\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, unknown>, unknown>,\n\t\t\t\tincludeAllExpression\n\t\t\t);\n\t\t\tconst onFalse = transformRecursively(\n\t\t\t\texpression.onFalse,\n\t\t\t\texpressionType,\n\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, unknown>, unknown>,\n\t\t\t\tincludeAllExpression\n\t\t\t);\n\t\t\tlet condition = expression.condition;\n\t\t\tif (includeAllExpression) {\n\t\t\t\tcondition = transformRecursively(\n\t\t\t\t\texpression.condition,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t}\n\t\t\texpression = ifElse(condition, onTrue, onFalse) as BindingToolkitExpression<T>;\n\t\t\tbreak;\n\t\tcase \"Not\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operand = transformRecursively(\n\t\t\t\t\texpression.operand,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\texpression = not(operand) as BindingToolkitExpression<T>;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Truthy\":\n\t\t\tbreak;\n\t\tcase \"Set\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operands = expression.operands.map((operand) =>\n\t\t\t\t\ttransformRecursively(\n\t\t\t\t\t\toperand,\n\t\t\t\t\t\texpressionType,\n\t\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\t\tincludeAllExpression\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\texpression =\n\t\t\t\t\texpression.operator === \"||\"\n\t\t\t\t\t\t? (or(...operands) as BindingToolkitExpression<T>)\n\t\t\t\t\t\t: (and(...operands) as BindingToolkitExpression<T>);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Comparison\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operand1 = transformRecursively(\n\t\t\t\t\texpression.operand1 as BindingToolkitExpression<T>,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\tconst operand2 = transformRecursively(\n\t\t\t\t\texpression.operand2 as BindingToolkitExpression<T>,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\texpression = comparison(expression.operator, operand1, operand2) as BindingToolkitExpression<T>;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Constant\":\n\t\t\tconst constantValue: Record<string, BindingToolkitExpression<unknown>> = expression.value as Record<\n\t\t\t\tstring,\n\t\t\t\tBindingToolkitExpression<unknown>\n\t\t\t>;\n\t\t\tif (typeof constantValue === \"object\" && constantValue) {\n\t\t\t\tObject.keys(constantValue).forEach((key) => {\n\t\t\t\t\tconstantValue[key] = transformRecursively(\n\t\t\t\t\t\tconstantValue[key],\n\t\t\t\t\t\texpressionType,\n\t\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, unknown>, unknown>,\n\t\t\t\t\t\tincludeAllExpression\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Ref\":\n\t\tcase \"Length\":\n\t\tcase \"PathInModel\":\n\t\tcase \"EmbeddedBinding\":\n\t\tcase \"EmbeddedExpressionBinding\":\n\t\tcase \"Unresolvable\":\n\t\t\t// Do nothing\n\t\t\tbreak;\n\t}\n\tif (expressionType === expression._type) {\n\t\texpression = transformFunction(inExpression as ExpressionTypeToExpression<ET, T>);\n\t}\n\treturn expression;\n}\n\nexport type CompiledBindingToolkitExpression = string | undefined;\n\nconst needParenthesis = function <T extends PrimitiveType>(expr: ExpressionOrPrimitive<T>): boolean {\n\treturn (\n\t\t!isConstant(expr) &&\n\t\t!isPathInModelExpression(expr) &&\n\t\tisBindingToolkitExpression(expr) &&\n\t\texpr._type !== \"IfElse\" &&\n\t\texpr._type !== \"Function\"\n\t);\n};\n\n/**\n * Compiles a constant object to a string.\n * @param expr\n * @param isNullable\n * @returns The compiled string\n */\nfunction compileConstantObject(expr: ConstantExpression<object>, isNullable = false): string {\n\tif (isNullable && Object.keys(expr.value).length === 0) {\n\t\treturn \"\";\n\t}\n\tconst objects = expr.value as PlainExpressionObject;\n\tconst properties: string[] = [];\n\tObject.keys(objects).forEach((key) => {\n\t\tconst value = objects[key];\n\t\tconst childResult = compileExpression(value, true, false, isNullable);\n\t\tif (childResult && childResult.length > 0) {\n\t\t\tproperties.push(`${key}: ${childResult}`);\n\t\t}\n\t});\n\treturn `{${properties.join(\", \")}}`;\n}\n\n/**\n * Compiles a Constant Binding Expression.\n * @param expr\n * @param embeddedInBinding\n * @param isNullable\n * @param doNotStringify\n * @returns The compiled string\n */\nexport function compileConstant<T extends PrimitiveType>(\n\texpr: ConstantExpression<T>,\n\tembeddedInBinding: boolean,\n\tisNullable?: boolean,\n\tdoNotStringify?: false\n): CompiledBindingToolkitExpression;\nexport function compileConstant<T extends PrimitiveType>(\n\texpr: ConstantExpression<T>,\n\tembeddedInBinding: boolean,\n\tisNullable?: boolean,\n\tdoNotStringify?: true\n): PrimitiveType;\nexport function compileConstant<T extends PrimitiveType>(\n\texpr: ConstantExpression<T>,\n\tembeddedInBinding: boolean,\n\tisNullable = false,\n\tdoNotStringify = false\n): CompiledBindingToolkitExpression | PrimitiveType {\n\tif (expr.value === null) {\n\t\treturn doNotStringify ? null : \"null\";\n\t}\n\tif (expr.value === undefined) {\n\t\treturn doNotStringify ? undefined : \"undefined\";\n\t}\n\tif (typeof expr.value === \"object\") {\n\t\tif (Array.isArray(expr.value)) {\n\t\t\tconst entries = expr.value.map((expression) => compileExpression(expression, true));\n\t\t\treturn `[${entries.join(\", \")}]`;\n\t\t} else {\n\t\t\treturn compileConstantObject(expr as ConstantExpression<object>, isNullable);\n\t\t}\n\t}\n\n\tif (embeddedInBinding) {\n\t\tswitch (typeof expr.value) {\n\t\t\tcase \"number\":\n\t\t\tcase \"bigint\":\n\t\t\tcase \"boolean\":\n\t\t\t\treturn expr.value.toString();\n\t\t\tcase \"string\":\n\t\t\t\treturn `'${escapeXmlAttribute(expr.value.toString())}'`;\n\t\t\tdefault:\n\t\t\t\treturn \"\";\n\t\t}\n\t} else {\n\t\treturn doNotStringify ? expr.value : expr.value.toString();\n\t}\n}\n\n/**\n * Generates the binding string for a Binding expression.\n * @param expressionForBinding The expression to compile\n * @param embeddedInBinding Whether the expression to compile is embedded into another expression\n * @param embeddedSeparator The binding value evaluator ($ or % depending on whether we want to force the type or not)\n * @returns The corresponding expression binding\n */\nfunction compilePathInModelExpression<T extends PrimitiveType>(\n\texpressionForBinding: PathInModelExpression<T>,\n\tembeddedInBinding: boolean,\n\tembeddedSeparator: string\n): CompiledBindingToolkitExpression {\n\tif (\n\t\texpressionForBinding.type ||\n\t\texpressionForBinding.parameters ||\n\t\texpressionForBinding.targetType ||\n\t\texpressionForBinding.formatOptions ||\n\t\texpressionForBinding.constraints\n\t) {\n\t\t// This is now a complex binding definition, let's prepare for it\n\t\tconst complexBindingDefinition = {\n\t\t\tpath: compilePathInModel(expressionForBinding),\n\t\t\ttype: expressionForBinding.type,\n\t\t\ttargetType: expressionForBinding.targetType,\n\t\t\tparameters: expressionForBinding.parameters,\n\t\t\tformatOptions: expressionForBinding.formatOptions,\n\t\t\tconstraints: expressionForBinding.constraints\n\t\t};\n\t\tconst outBinding = compileExpression(complexBindingDefinition, false, false, true);\n\t\tif (embeddedInBinding) {\n\t\t\tconst separator = expressionForBinding.alwaysKeepTargetType ? \"$\" : embeddedSeparator;\n\t\t\treturn `${separator}${outBinding}`;\n\t\t}\n\t\treturn outBinding;\n\t} else if (embeddedInBinding) {\n\t\treturn `${embeddedSeparator}{${compilePathInModel(expressionForBinding)}}`;\n\t} else {\n\t\treturn `{${compilePathInModel(expressionForBinding)}}`;\n\t}\n}\n\nfunction compileComplexTypeExpression<T extends PrimitiveType>(expression: ComplexTypeExpression<T>): string {\n\tif (expression.bindingParameters.length === 1) {\n\t\treturn `{${compilePathParameter(expression.bindingParameters[0] as BindingToolkitExpression<PrimitiveType>, true)}, type: '${\n\t\t\texpression.type\n\t\t}'}`;\n\t}\n\n\tlet outputEnd = `], type: '${expression.type}'`;\n\tif (hasElements(expression.formatOptions)) {\n\t\toutputEnd += `, formatOptions: ${compileExpression(expression.formatOptions)}`;\n\t}\n\tif (hasElements(expression.constraints)) {\n\t\toutputEnd += `, constraints: ${compileExpression(expression.constraints)}`;\n\t}\n\tif (hasElements(expression.parameters)) {\n\t\toutputEnd += `, parameters: ${compileExpression(expression.parameters)}`;\n\t}\n\toutputEnd += \"}\";\n\n\treturn `{mode:'TwoWay', parts:[${expression.bindingParameters\n\t\t.map((param) => compilePathParameter(param as BindingToolkitExpression<PrimitiveType>))\n\t\t.join(\",\")}${outputEnd}`;\n}\n\n/**\n * Wrap the compiled binding string as required depending on its context.\n * @param expression The compiled expression\n * @param embeddedInBinding True if the compiled expression is to be embedded in a binding\n * @param parenthesisRequired True if the embedded binding needs to be wrapped in parethesis so that it is evaluated as one\n * @returns Finalized compiled expression\n */\nexport function wrapBindingExpression(\n\texpression: string,\n\tembeddedInBinding: boolean,\n\tparenthesisRequired = false\n): CompiledBindingToolkitExpression {\n\tif (embeddedInBinding) {\n\t\tif (parenthesisRequired) {\n\t\t\treturn `(${expression})`;\n\t\t} else {\n\t\t\treturn expression;\n\t\t}\n\t} else {\n\t\treturn `{= ${expression}}`;\n\t}\n}\n\n/**\n * Compile an expression into an expression binding.\n * @template T The target type\n * @param expression The expression to compile\n * @param embeddedInBinding Whether the expression to compile is embedded into another expression\n * @param keepTargetType Keep the target type of the embedded bindings instead of casting them to any\n * @param isNullable Whether binding expression can resolve to empty string or not\n * @returns The corresponding expression binding\n */\nexport function compileExpression<T extends PrimitiveType>(\n\texpression: ExpressionOrPrimitive<T>,\n\tembeddedInBinding = false,\n\tkeepTargetType = false,\n\tisNullable = false\n): CompiledBindingToolkitExpression {\n\tconst expr = wrapPrimitive(expression);\n\tconst embeddedSeparator = keepTargetType ? \"$\" : \"%\";\n\n\tswitch (expr._type) {\n\t\tcase \"Unresolvable\":\n\t\t\treturn undefined;\n\n\t\tcase \"Constant\":\n\t\t\treturn compileConstant(expr, embeddedInBinding, isNullable);\n\n\t\tcase \"Ref\":\n\t\t\treturn expr.ref || \"null\";\n\n\t\tcase \"Function\":\n\t\t\tlet hasEmbeddedFunctionCallOrBinding = false;\n\t\t\tif (expr.isFormattingFn) {\n\t\t\t\ttransformRecursively(\n\t\t\t\t\texpr,\n\t\t\t\t\t\"Function\",\n\t\t\t\t\t(subFn) => {\n\t\t\t\t\t\tif (subFn !== expr && subFn.obj === undefined) {\n\t\t\t\t\t\t\thasEmbeddedFunctionCallOrBinding = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn subFn;\n\t\t\t\t\t},\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t\ttransformRecursively(\n\t\t\t\t\texpr,\n\t\t\t\t\t\"Constant\",\n\t\t\t\t\t(subFn: ConstantExpression<T>) => {\n\t\t\t\t\t\tif ((subFn as unknown) !== expr && typeof subFn.value === \"object\") {\n\t\t\t\t\t\t\ttransformRecursively(subFn, \"PathInModel\", (subSubFn) => {\n\t\t\t\t\t\t\t\thasEmbeddedFunctionCallOrBinding = true;\n\t\t\t\t\t\t\t\treturn subSubFn;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn subFn;\n\t\t\t\t\t},\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst argumentString = `${expr.parameters.map((arg) => compileExpression(arg, true)).join(\", \")}`;\n\t\t\tlet fnCall =\n\t\t\t\texpr.obj === undefined\n\t\t\t\t\t? `${expr.fn}(${argumentString})`\n\t\t\t\t\t: `${compileExpression(expr.obj, true)}.${expr.fn}(${argumentString})`;\n\t\t\tif (!embeddedInBinding && hasEmbeddedFunctionCallOrBinding) {\n\t\t\t\tfnCall = `{= ${fnCall}}`;\n\t\t\t}\n\t\t\treturn fnCall;\n\n\t\tcase \"EmbeddedExpressionBinding\":\n\t\t\treturn embeddedInBinding ? `(${expr.value.substring(2, expr.value.length - 1)})` : `${expr.value}`;\n\n\t\tcase \"EmbeddedBinding\":\n\t\t\treturn embeddedInBinding ? `${embeddedSeparator}${expr.value}` : `${expr.value}`;\n\n\t\tcase \"PathInModel\":\n\t\t\treturn compilePathInModelExpression(expr, embeddedInBinding, embeddedSeparator);\n\n\t\tcase \"Comparison\":\n\t\t\tconst comparisonExpression = compileComparisonExpression(expr);\n\t\t\treturn wrapBindingExpression(comparisonExpression, embeddedInBinding);\n\n\t\tcase \"IfElse\":\n\t\t\tconst ifElseExpression = `${compileExpression(expr.condition, true)} ? ${compileExpression(\n\t\t\t\texpr.onTrue,\n\t\t\t\ttrue,\n\t\t\t\tkeepTargetType\n\t\t\t)} : ${compileExpression(expr.onFalse, true, keepTargetType)}`;\n\t\t\treturn wrapBindingExpression(ifElseExpression, embeddedInBinding, true);\n\n\t\tcase \"Set\":\n\t\t\tconst setExpression = expr.operands.map((operand) => compileExpression(operand, true)).join(` ${expr.operator} `);\n\t\t\treturn wrapBindingExpression(setExpression, embeddedInBinding, true);\n\n\t\tcase \"Concat\":\n\t\t\tconst concatExpression = expr.expressions\n\t\t\t\t.map((nestedExpression) => compileExpression(nestedExpression, true, true))\n\t\t\t\t.join(\" + \");\n\t\t\treturn wrapBindingExpression(concatExpression, embeddedInBinding);\n\n\t\tcase \"Length\":\n\t\t\tconst lengthExpression = `${compileExpression(expr.pathInModel, true)}.length`;\n\t\t\treturn wrapBindingExpression(lengthExpression, embeddedInBinding);\n\n\t\tcase \"Not\":\n\t\t\tconst notExpression = `!${compileExpression(expr.operand, true)}`;\n\t\t\treturn wrapBindingExpression(notExpression, embeddedInBinding);\n\n\t\tcase \"Truthy\":\n\t\t\tconst truthyExpression = `!!${compileExpression(expr.operand, true)}`;\n\t\t\treturn wrapBindingExpression(truthyExpression, embeddedInBinding);\n\n\t\tcase \"Formatter\":\n\t\t\tconst formatterExpression = compileFormatterExpression(expr);\n\t\t\treturn embeddedInBinding ? `$${formatterExpression}` : formatterExpression;\n\n\t\tcase \"ComplexType\":\n\t\t\tconst complexTypeExpression = compileComplexTypeExpression(expr);\n\t\t\treturn embeddedInBinding ? `$${complexTypeExpression}` : complexTypeExpression;\n\n\t\tdefault:\n\t\t\treturn \"\";\n\t}\n}\n\n/**\n * Compile a comparison expression.\n * @param expression The comparison expression.\n * @returns The compiled expression. Needs wrapping before it can be used as an expression binding.\n */\nfunction compileComparisonExpression(expression: ComparisonExpression): string {\n\tfunction compileOperand(operand: BindingToolkitExpression<unknown>): CompiledBindingToolkitExpression {\n\t\tconst compiledOperand = compileExpression(operand, true) ?? \"undefined\";\n\t\treturn wrapBindingExpression(compiledOperand, true, needParenthesis(operand));\n\t}\n\n\treturn `${compileOperand(expression.operand1)} ${expression.operator} ${compileOperand(expression.operand2)}`;\n}\n\n/**\n * Compile a formatter expression.\n * @param expression The formatter expression.\n * @returns The compiled expression.\n */\nfunction compileFormatterExpression<T extends PrimitiveType>(expression: FormatterExpression<T>): string {\n\tif (expression.parameters.length === 1) {\n\t\treturn `{${compilePathParameter(expression.parameters[0] as BindingToolkitExpression<PrimitiveType>, true)}, formatter: '${\n\t\t\texpression.fn\n\t\t}'}`;\n\t} else {\n\t\tconst parts = expression.parameters.map((param) => {\n\t\t\tif (param._type === \"ComplexType\") {\n\t\t\t\treturn compileComplexTypeExpression(param);\n\t\t\t} else {\n\t\t\t\treturn compilePathParameter(param as BindingToolkitExpression<PrimitiveType>);\n\t\t\t}\n\t\t});\n\t\treturn `{parts: [${parts.join(\", \")}], formatter: '${expression.fn}'}`;\n\t}\n}\n\n/**\n * Compile the path parameter of a formatter call.\n * @param expression The binding part to evaluate\n * @param singlePath Whether there is one or multiple path to consider\n * @returns The string snippet to include in the overall binding definition\n */\nfunction compilePathParameter(expression: BindingToolkitExpression<PrimitiveType>, singlePath = false): string {\n\tlet outValue = \"\";\n\tif (expression._type === \"Constant\") {\n\t\tif (expression.value === undefined) {\n\t\t\t// Special case otherwise the JSTokenizer complains about incorrect content\n\t\t\toutValue = `value: 'undefined'`;\n\t\t} else {\n\t\t\toutValue = `value: ${compileConstant(expression, true)}`;\n\t\t}\n\t} else if (expression._type === \"PathInModel\") {\n\t\toutValue = `path: '${compilePathInModel(expression)}'`;\n\n\t\toutValue += expression.type ? `, type: '${expression.type}'` : `, targetType: 'any'`;\n\t\tif (expression.mode) {\n\t\t\toutValue += `, mode: '${compileExpression(expression.mode)}'`;\n\t\t}\n\t\tif (hasElements(expression.constraints)) {\n\t\t\toutValue += `, constraints: ${compileExpression(expression.constraints)}`;\n\t\t}\n\t\tif (hasElements(expression.formatOptions)) {\n\t\t\toutValue += `, formatOptions: ${compileExpression(expression.formatOptions)}`;\n\t\t}\n\t\tif (hasElements(expression.parameters)) {\n\t\t\toutValue += `, parameters: ${compileExpression(expression.parameters)}`;\n\t\t}\n\t} else {\n\t\treturn \"\";\n\t}\n\treturn singlePath ? outValue : `{${outValue}}`;\n}\n\nfunction hasElements(obj: object | undefined): boolean {\n\treturn !!obj && Object.keys(obj).length > 0;\n}\n\n/**\n * Compile a binding expression path.\n * @param expression The expression to compile.\n * @returns The compiled path.\n */\nfunction compilePathInModel<T extends PrimitiveType>(expression: PathInModelExpression<T>): string {\n\treturn `${expression.modelName ? expression.modelName + \">\" : \"\"}${expression.path}`;\n}\n"],"mappings":";;;;;;;;;EAoIA;AACA;AACA;;EAuCO,SAASA,UAAUA,CAACC,aAAsB,EAA6B;IAC7E,OAAQA,aAAa,EAAeC,KAAK,KAAK,UAAU;EACzD;;EAEA;AACA;AACA;AACA;EAHAC,QAAA,CAAAH,UAAA,GAAAA,UAAA;EAqCO,MAAMI,gBAAuD,GAAG;IACtE,aAAa,EAAE;MAAEC,IAAI,EAAE;IAAkC,CAAC;IAC1D,UAAU,EAAE;MAAEA,IAAI,EAAE;IAA+B,CAAC;IACpD,UAAU,EAAE;MAAEA,IAAI,EAAE;IAA+B,CAAC;IACpD,oBAAoB,EAAE;MACrBC,WAAW,EAAE;QACZC,UAAU,EAAE,WAAW;QACvBC,GAAG,EAAE;MACN,CAAC;MACDH,IAAI,EAAE;IACP,CAAC;IACD,aAAa,EAAE;MACdC,WAAW,EAAE;QACZ,2CAA2C,EAAE,SAAS;QACtD,oEAAoE,EAAE,kBAAkB;QACxF,2CAA2C,EAAE,SAAS;QACtD,oEAAoE,EAAE,kBAAkB;QACxFC,UAAU,EAAE,WAAW;QACvBE,MAAM,EAAE;MACT,CAAC;MACDJ,IAAI,EAAE;IACP,CAAC;IACD,YAAY,EAAE;MAAEA,IAAI,EAAE;IAAiC,CAAC;IACxD,UAAU,EAAE;MAAEA,IAAI,EAAE;IAA+B,CAAC;IACpD,WAAW,EAAE;MAAEA,IAAI,EAAE;IAAgC,CAAC;IACtD,WAAW,EAAE;MAAEA,IAAI,EAAE;IAAgC,CAAC;IACtD,WAAW,EAAE;MAAEA,IAAI,EAAE;IAAgC,CAAC;IACtD,WAAW,EAAE;MAAEA,IAAI,EAAE;IAAgC,CAAC;IACtD,YAAY,EAAE;MAAEA,IAAI,EAAE;IAAiC,CAAC;IACxD,YAAY,EAAE;MAAEA,IAAI,EAAE;IAAiC,CAAC;IACxD,YAAY,EAAE;MAAEA,IAAI,EAAE;IAAiC,CAAC;IACxD,YAAY,EAAE;MACbC,WAAW,EAAE;QACZ,iDAAiD,EAAE,iBAAiB;QACpEI,UAAU,EAAE,WAAW;QACvBC,SAAS,EAAE;MACZ,CAAC;MACDN,IAAI,EAAE;IACP,CAAC;IACD,eAAe,EAAE;MAChBC,WAAW,EAAE;QACZC,UAAU,EAAE;MACb,CAAC;MACDF,IAAI,EAAE;IACP;EACD,CAAC;;EAED;AACA;AACA;EAFAF,QAAA,CAAAC,gBAAA,GAAAA,gBAAA;EAKO,MAAMQ,sBAAkD,GAAG;IACjEV,KAAK,EAAE;EACR,CAAC;EAACC,QAAA,CAAAS,sBAAA,GAAAA,sBAAA;EAEK,SAASC,kBAAkBA,CAACC,WAAmB,EAAU;IAC/D,OAAOA,WAAW,CAACC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC;EACxC;EAACZ,QAAA,CAAAU,kBAAA,GAAAA,kBAAA;EAEM,SAASG,yBAAyBA,CAAA,EAA+D;IAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAA3DC,WAAW,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;MAAXF,WAAW,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;IAAA;IACvD,OAAOF,WAAW,CAACG,IAAI,CAAEC,IAAI,IAAKA,IAAI,CAACtB,KAAK,KAAK,cAAc,CAAC,KAAKuB,SAAS;EAC/E;EACA;AACA;AACA;AACA;AACA;AACA;EALAtB,QAAA,CAAAa,yBAAA,GAAAA,yBAAA;EAMO,SAASU,yBAAyBA,CAAIC,CAA8B,EAAEC,CAA8B,EAAW;IACrH,IAAID,CAAC,CAACzB,KAAK,KAAK0B,CAAC,CAAC1B,KAAK,EAAE;MACxB,OAAO,KAAK;IACb;IAEA,QAAQyB,CAAC,CAACzB,KAAK;MACd,KAAK,cAAc;QAClB,OAAO,KAAK;MAAE;MACf,KAAK,UAAU;MACf,KAAK,iBAAiB;MACtB,KAAK,2BAA2B;QAC/B,OAAOyB,CAAC,CAACE,KAAK,KAAMD,CAAC,CAA2BC,KAAK;MAEtD,KAAK,KAAK;QACT,OAAOH,yBAAyB,CAACC,CAAC,CAACG,OAAO,EAAGF,CAAC,CAAmBE,OAAO,CAAC;MAC1E,KAAK,QAAQ;QACZ,OAAOJ,yBAAyB,CAACC,CAAC,CAACG,OAAO,EAAGF,CAAC,CAAsBE,OAAO,CAAC;MAC7E,KAAK,KAAK;QACT,OACCH,CAAC,CAACI,QAAQ,KAAMH,CAAC,CAAmBG,QAAQ,IAC5CJ,CAAC,CAACK,QAAQ,CAACb,MAAM,KAAMS,CAAC,CAAmBI,QAAQ,CAACb,MAAM,IAC1DQ,CAAC,CAACK,QAAQ,CAACC,KAAK,CAAEC,UAAU,IAC1BN,CAAC,CAAmBI,QAAQ,CAACG,IAAI,CAAEC,eAAe,IAAKV,yBAAyB,CAACQ,UAAU,EAAEE,eAAe,CAAC,CAC/G,CAAC;MAGH,KAAK,QAAQ;QACZ,OACCV,yBAAyB,CAACC,CAAC,CAACU,SAAS,EAAGT,CAAC,CAAyBS,SAAS,CAAC,IAC5EX,yBAAyB,CAACC,CAAC,CAACW,MAAM,EAAGV,CAAC,CAAyBU,MAAM,CAAC,IACtEZ,yBAAyB,CAACC,CAAC,CAACY,OAAO,EAAGX,CAAC,CAAyBW,OAAO,CAAC;MAG1E,KAAK,YAAY;QAChB,OACCZ,CAAC,CAACI,QAAQ,KAAMH,CAAC,CAA0BG,QAAQ,IACnDL,yBAAyB,CAACC,CAAC,CAACa,QAAQ,EAAGZ,CAAC,CAA0BY,QAAQ,CAAC,IAC3Ed,yBAAyB,CAACC,CAAC,CAACc,QAAQ,EAAGb,CAAC,CAA0Ba,QAAQ,CAAC;MAG7E,KAAK,QAAQ;QACZ,MAAMC,YAAY,GAAGf,CAAC,CAACP,WAAW;QAClC,MAAMuB,YAAY,GAAIf,CAAC,CAAsBR,WAAW;QACxD,IAAIsB,YAAY,CAACvB,MAAM,KAAKwB,YAAY,CAACxB,MAAM,EAAE;UAChD,OAAO,KAAK;QACb;QACA,OAAOuB,YAAY,CAACT,KAAK,CAAC,CAACC,UAAU,EAAEU,KAAK,KAAK;UAChD,OAAOlB,yBAAyB,CAACQ,UAAU,EAAES,YAAY,CAACC,KAAK,CAAC,CAAC;QAClE,CAAC,CAAC;MAEH,KAAK,QAAQ;QACZ,OAAOlB,yBAAyB,CAACC,CAAC,CAACkB,WAAW,EAAGjB,CAAC,CAAsBiB,WAAW,CAAC;MAErF,KAAK,aAAa;QACjB,OACClB,CAAC,CAACmB,SAAS,KAAMlB,CAAC,CAA8BkB,SAAS,IACzDnB,CAAC,CAACoB,IAAI,KAAMnB,CAAC,CAA8BmB,IAAI,IAC/CpB,CAAC,CAACqB,eAAe,KAAMpB,CAAC,CAA8BoB,eAAe;MAGvE,KAAK,WAAW;QACf,OACCrB,CAAC,CAACsB,EAAE,KAAMrB,CAAC,CAA4BqB,EAAE,IACzCtB,CAAC,CAACuB,UAAU,CAAC/B,MAAM,KAAMS,CAAC,CAA4BsB,UAAU,CAAC/B,MAAM,IACvEQ,CAAC,CAACuB,UAAU,CAACjB,KAAK,CAAC,CAACJ,KAAK,EAAEe,KAAK,KAAKlB,yBAAyB,CAAEE,CAAC,CAA4BsB,UAAU,CAACN,KAAK,CAAC,EAAEf,KAAK,CAAC,CAAC;MAEzH,KAAK,aAAa;QACjB,OACCF,CAAC,CAACtB,IAAI,KAAMuB,CAAC,CAA8BvB,IAAI,IAC/CsB,CAAC,CAACwB,iBAAiB,CAAChC,MAAM,KAAMS,CAAC,CAA8BuB,iBAAiB,CAAChC,MAAM,IACvFQ,CAAC,CAACwB,iBAAiB,CAAClB,KAAK,CAAC,CAACJ,KAAK,EAAEe,KAAK,KACtClB,yBAAyB,CAAEE,CAAC,CAA8BuB,iBAAiB,CAACP,KAAK,CAAC,EAAEf,KAAK,CAC1F,CAAC;MAEH,KAAK,UAAU;QACd,MAAMuB,aAAa,GAAGxB,CAA0B;QAChD,IAAID,CAAC,CAAC0B,GAAG,KAAK5B,SAAS,IAAI2B,aAAa,CAACC,GAAG,KAAK5B,SAAS,EAAE;UAC3D,OAAOE,CAAC,CAAC0B,GAAG,KAAKD,aAAa;QAC/B;QAEA,OACCzB,CAAC,CAACsB,EAAE,KAAKG,aAAa,CAACH,EAAE,IACzBvB,yBAAyB,CAACC,CAAC,CAAC0B,GAAG,EAAED,aAAa,CAACC,GAAG,CAAC,IACnD1B,CAAC,CAACuB,UAAU,CAAC/B,MAAM,KAAKiC,aAAa,CAACF,UAAU,CAAC/B,MAAM,IACvDQ,CAAC,CAACuB,UAAU,CAACjB,KAAK,CAAC,CAACJ,KAAK,EAAEe,KAAK,KAAKlB,yBAAyB,CAAC0B,aAAa,CAACF,UAAU,CAACN,KAAK,CAAC,EAAEf,KAAK,CAAC,CAAC;MAGzG,KAAK,KAAK;QACT,OAAOF,CAAC,CAAC2B,GAAG,KAAM1B,CAAC,CAAyB0B,GAAG;IACjD;IACA,OAAO,KAAK;EACb;;EAEA;AACA;AACA;AACA;AACA;EAJAnD,QAAA,CAAAuB,yBAAA,GAAAA,yBAAA;EAKA,SAAS6B,oBAAoBA,CAACrB,UAAyB,EAAiB;IACvE,OAAOA,UAAU,CAACF,QAAQ,CAACwB,MAAM,CAChC,CAACC,MAAqB,EAAE3B,OAAO,KAAK;MACnC,MAAM4B,uBAAuB,GAC5B5B,OAAO,CAAC5B,KAAK,KAAK,KAAK,IAAI4B,OAAO,CAACC,QAAQ,KAAKG,UAAU,CAACH,QAAQ,GAAGD,OAAO,CAACE,QAAQ,GAAG,CAACF,OAAO,CAAC;MACnG4B,uBAAuB,CAACC,OAAO,CAAEC,SAAS,IAAK;QAC9C,IAAIH,MAAM,CAACzB,QAAQ,CAACC,KAAK,CAAE4B,CAAC,IAAK,CAACnC,yBAAyB,CAACmC,CAAC,EAAED,SAAS,CAAC,CAAC,EAAE;UAC3EH,MAAM,CAACzB,QAAQ,CAAC8B,IAAI,CAACF,SAAS,CAAC;QAChC;MACD,CAAC,CAAC;MACF,OAAOH,MAAM;IACd,CAAC,EACD;MAAEvD,KAAK,EAAE,KAAK;MAAE6B,QAAQ,EAAEG,UAAU,CAACH,QAAQ;MAAEC,QAAQ,EAAE;IAAG,CAC7D,CAAC;EACF;;EAEA;AACA;AACA;AACA;AACA;EACA,SAAS+B,sBAAsBA,CAAC3C,WAAgD,EAAW;IAC1F,MAAM4C,kBAAkB,GAAG5C,WAAW,CAAC6C,GAAG,CAACC,GAAG,CAAC;IAC/C,OAAO9C,WAAW,CAACe,IAAI,CAAC,CAACD,UAAU,EAAEU,KAAK,KAAK;MAC9C,KAAK,IAAIuB,CAAC,GAAGvB,KAAK,GAAG,CAAC,EAAEuB,CAAC,GAAGH,kBAAkB,CAAC7C,MAAM,EAAEgD,CAAC,EAAE,EAAE;QAC3D,IAAIzC,yBAAyB,CAACQ,UAAU,EAAE8B,kBAAkB,CAACG,CAAC,CAAC,CAAC,EAAE;UACjE,OAAO,IAAI;QACZ;MACD;MACA,OAAO,KAAK;IACb,CAAC,CAAC;EACH;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACO,SAASC,GAAGA,CAAA,EAAmF;IAAA,SAAAC,KAAA,GAAAnD,SAAA,CAAAC,MAAA,EAA/Ea,QAAQ,OAAAX,KAAA,CAAAgD,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAARtC,QAAQ,CAAAsC,KAAA,IAAApD,SAAA,CAAAoD,KAAA;IAAA;IAC9B,MAAMlD,WAAW,GAAGmC,oBAAoB,CAAC;MACxCrD,KAAK,EAAE,KAAK;MACZ6B,QAAQ,EAAE,IAAI;MACdC,QAAQ,EAAEA,QAAQ,CAACiC,GAAG,CAACM,aAAa;IACrC,CAAC,CAAC,CAACvC,QAAQ;IAEX,IAAIhB,yBAAyB,CAAC,GAAGI,WAAW,CAAC,EAAE;MAC9C,OAAOR,sBAAsB;IAC9B;IACA,IAAI4D,aAAa,GAAG,KAAK;IACzB,MAAMC,oBAAoB,GAAGrD,WAAW,CAACsD,MAAM,CAAExC,UAAU,IAAK;MAC/D,IAAIyC,OAAO,CAACzC,UAAU,CAAC,EAAE;QACxBsC,aAAa,GAAG,IAAI;MACrB;MACA,OAAO,CAACI,UAAU,CAAC1C,UAAU,CAAC;IAC/B,CAAC,CAAC;IACF,IAAIsC,aAAa,EAAE;MAClB,OAAOK,QAAQ,CAAC,KAAK,CAAC;IACvB,CAAC,MAAM,IAAIJ,oBAAoB,CAACtD,MAAM,KAAK,CAAC,EAAE;MAC7C;MACA,MAAM2D,OAAO,GAAG1D,WAAW,CAACoC,MAAM,CAAC,CAACC,MAAM,EAAEvB,UAAU,KAAKuB,MAAM,IAAIsB,MAAM,CAAC7C,UAAU,CAAC,EAAE,IAAI,CAAC;MAC9F,OAAO2C,QAAQ,CAACC,OAAO,CAAC;IACzB,CAAC,MAAM,IAAIL,oBAAoB,CAACtD,MAAM,KAAK,CAAC,EAAE;MAC7C,OAAOsD,oBAAoB,CAAC,CAAC,CAAC;IAC/B,CAAC,MAAM,IAAIV,sBAAsB,CAACU,oBAAoB,CAAC,EAAE;MACxD,OAAOI,QAAQ,CAAC,KAAK,CAAC;IACvB,CAAC,MAAM;MACN,OAAO;QACN3E,KAAK,EAAE,KAAK;QACZ6B,QAAQ,EAAE,IAAI;QACdC,QAAQ,EAAEyC;MACX,CAAC;IACF;EACD;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAPAtE,QAAA,CAAAiE,GAAA,GAAAA,GAAA;EAQO,SAASY,EAAEA,CAAA,EAAmF;IAAA,SAAAC,KAAA,GAAA/D,SAAA,CAAAC,MAAA,EAA/Ea,QAAQ,OAAAX,KAAA,CAAA4D,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAARlD,QAAQ,CAAAkD,KAAA,IAAAhE,SAAA,CAAAgE,KAAA;IAAA;IAC7B,MAAM9D,WAAW,GAAGmC,oBAAoB,CAAC;MACxCrD,KAAK,EAAE,KAAK;MACZ6B,QAAQ,EAAE,IAAI;MACdC,QAAQ,EAAEA,QAAQ,CAACiC,GAAG,CAACM,aAAa;IACrC,CAAC,CAAC,CAACvC,QAAQ;IACX,IAAIhB,yBAAyB,CAAC,GAAGI,WAAW,CAAC,EAAE;MAC9C,OAAOR,sBAAsB;IAC9B;IACA,IAAIuE,YAAY,GAAG,KAAK;IACxB,MAAMV,oBAAoB,GAAGrD,WAAW,CAACsD,MAAM,CAAExC,UAAU,IAAK;MAC/D,IAAI6C,MAAM,CAAC7C,UAAU,CAAC,EAAE;QACvBiD,YAAY,GAAG,IAAI;MACpB;MACA,OAAO,CAACP,UAAU,CAAC1C,UAAU,CAAC,IAAIA,UAAU,CAACL,KAAK;IACnD,CAAC,CAAC;IACF,IAAIsD,YAAY,EAAE;MACjB,OAAON,QAAQ,CAAC,IAAI,CAAC;IACtB,CAAC,MAAM,IAAIJ,oBAAoB,CAACtD,MAAM,KAAK,CAAC,EAAE;MAC7C;MACA,MAAM2D,OAAO,GAAG1D,WAAW,CAACoC,MAAM,CAAC,CAACC,MAAM,EAAEvB,UAAU,KAAKuB,MAAM,IAAIsB,MAAM,CAAC7C,UAAU,CAAC,EAAE,IAAI,CAAC;MAC9F,OAAO2C,QAAQ,CAACC,OAAO,CAAC;IACzB,CAAC,MAAM,IAAIL,oBAAoB,CAACtD,MAAM,KAAK,CAAC,EAAE;MAC7C,OAAOsD,oBAAoB,CAAC,CAAC,CAAC;IAC/B,CAAC,MAAM,IAAIV,sBAAsB,CAACU,oBAAoB,CAAC,EAAE;MACxD,OAAOI,QAAQ,CAAC,IAAI,CAAC;IACtB,CAAC,MAAM;MACN,OAAO;QACN3E,KAAK,EAAE,KAAK;QACZ6B,QAAQ,EAAE,IAAI;QACdC,QAAQ,EAAEyC;MACX,CAAC;IACF;EACD;;EAEA;AACA;AACA;AACA;AACA;EAJAtE,QAAA,CAAA6E,EAAA,GAAAA,EAAA;EAKO,SAASd,GAAGA,CAACpC,OAAuC,EAAqC;IAC/FA,OAAO,GAAGyC,aAAa,CAACzC,OAAO,CAAC;IAChC,IAAId,yBAAyB,CAACc,OAAO,CAAC,EAAE;MACvC,OAAOlB,sBAAsB;IAC9B,CAAC,MAAM,IAAIgE,UAAU,CAAC9C,OAAO,CAAC,EAAE;MAC/B,OAAO+C,QAAQ,CAAC,CAAC/C,OAAO,CAACD,KAAK,CAAC;IAChC,CAAC,MAAM,IACN,OAAOC,OAAO,KAAK,QAAQ,IAC3BA,OAAO,CAAC5B,KAAK,KAAK,KAAK,IACvB4B,OAAO,CAACC,QAAQ,KAAK,IAAI,IACzBD,OAAO,CAACE,QAAQ,CAACC,KAAK,CAAEC,UAAU,IAAK0C,UAAU,CAAC1C,UAAU,CAAC,IAAIkD,YAAY,CAAClD,UAAU,CAAC,CAAC,EACzF;MACD,OAAOkC,GAAG,CAAC,GAAGtC,OAAO,CAACE,QAAQ,CAACiC,GAAG,CAAE/B,UAAU,IAAKgC,GAAG,CAAChC,UAAU,CAAC,CAAC,CAAC;IACrE,CAAC,MAAM,IACN,OAAOJ,OAAO,KAAK,QAAQ,IAC3BA,OAAO,CAAC5B,KAAK,KAAK,KAAK,IACvB4B,OAAO,CAACC,QAAQ,KAAK,IAAI,IACzBD,OAAO,CAACE,QAAQ,CAACC,KAAK,CAAEC,UAAU,IAAK0C,UAAU,CAAC1C,UAAU,CAAC,IAAIkD,YAAY,CAAClD,UAAU,CAAC,CAAC,EACzF;MACD,OAAO8C,EAAE,CAAC,GAAGlD,OAAO,CAACE,QAAQ,CAACiC,GAAG,CAAE/B,UAAU,IAAKgC,GAAG,CAAChC,UAAU,CAAC,CAAC,CAAC;IACpE,CAAC,MAAM,IAAIkD,YAAY,CAACtD,OAAO,CAAC,EAAE;MACjC;MACA,QAAQA,OAAO,CAACC,QAAQ;QACvB,KAAK,KAAK;UACT,OAAO;YAAE,GAAGD,OAAO;YAAEC,QAAQ,EAAE;UAAM,CAAC;QACvC,KAAK,GAAG;UACP,OAAO;YAAE,GAAGD,OAAO;YAAEC,QAAQ,EAAE;UAAK,CAAC;QACtC,KAAK,IAAI;UACR,OAAO;YAAE,GAAGD,OAAO;YAAEC,QAAQ,EAAE;UAAI,CAAC;QACrC,KAAK,KAAK;UACT,OAAO;YAAE,GAAGD,OAAO;YAAEC,QAAQ,EAAE;UAAM,CAAC;QACvC,KAAK,GAAG;UACP,OAAO;YAAE,GAAGD,OAAO;YAAEC,QAAQ,EAAE;UAAK,CAAC;QACtC,KAAK,IAAI;UACR,OAAO;YAAE,GAAGD,OAAO;YAAEC,QAAQ,EAAE;UAAI,CAAC;MACtC;IACD,CAAC,MAAM,IAAID,OAAO,CAAC5B,KAAK,KAAK,KAAK,EAAE;MACnC,OAAO4B,OAAO,CAACA,OAAO;IACvB;IAEA,OAAO;MACN5B,KAAK,EAAE,KAAK;MACZ4B,OAAO,EAAEA;IACV,CAAC;EACF;;EAEA;AACA;AACA;AACA;AACA;EAJA3B,QAAA,CAAA+D,GAAA,GAAAA,GAAA;EAKO,SAASmB,QAAQA,CAACvD,OAAyC,EAAqC;IACtG,IAAI8C,UAAU,CAAC9C,OAAO,CAAC,EAAE;MACxB,OAAO+C,QAAQ,CAAC,CAAC,CAAC/C,OAAO,CAACD,KAAK,CAAC;IACjC,CAAC,MAAM;MACN,OAAO;QACN3B,KAAK,EAAE,QAAQ;QACf4B,OAAO,EAAEA;MACV,CAAC;IACF;EACD;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EARA3B,QAAA,CAAAkF,QAAA,GAAAA,QAAA;EASO,SAASC,iBAAiBA,CAChCvC,IAAY,EACZD,SAAkB,EAG+C;IAAA,IAFjEyC,sBAAgC,GAAArE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,EAAE;IAAA,IACrCsE,WAAsB,GAAAtE,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAO,SAAA;IAEtB,OAAOoB,WAAW,CAACE,IAAI,EAAED,SAAS,EAAEyC,sBAAsB,EAAEC,WAAW,CAAC;EACzE;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EARArF,QAAA,CAAAmF,iBAAA,GAAAA,iBAAA;EA2BO,SAASzC,WAAWA,CAC1BE,IAAwB,EACxBD,SAAkB,EAG+C;IAAA,IAFjEyC,sBAAgC,GAAArE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,EAAE;IAAA,IACrCsE,WAAsB,GAAAtE,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAO,SAAA;IAEtB,IAAIsB,IAAI,KAAKtB,SAAS,EAAE;MACvB,OAAOb,sBAAsB;IAC9B;IACA,IAAI6E,UAAU;IACd,IAAID,WAAW,EAAE;MAChBC,UAAU,GAAGD,WAAW,CAACzC,IAAI,CAAC;MAC9B,IAAI0C,UAAU,KAAKhE,SAAS,EAAE;QAC7B,OAAOb,sBAAsB;MAC9B;IACD,CAAC,MAAM;MACN,MAAM8E,SAAS,GAAGH,sBAAsB,CAACI,MAAM,CAAC,CAAC;MACjDD,SAAS,CAAC5B,IAAI,CAACf,IAAI,CAAC;MACpB0C,UAAU,GAAGC,SAAS,CAACE,IAAI,CAAC,GAAG,CAAC;IACjC;IACA,OAAO;MACN1F,KAAK,EAAE,aAAa;MACpB4C,SAAS,EAAEA,SAAS;MACpBC,IAAI,EAAE0C;IACP,CAAC;EACF;EAACtF,QAAA,CAAA0C,WAAA,GAAAA,WAAA;EAID;AACA;AACA;AACA;AACA;AACA;EACO,SAASgC,QAAQA,CAA0BhD,KAAQ,EAAyB;IAClF,IAAIgE,aAAgB;IAEpB,IAAI,OAAOhE,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKJ,SAAS,EAAE;MACvE,IAAIJ,KAAK,CAACyE,OAAO,CAACjE,KAAK,CAAC,EAAE;QACzBgE,aAAa,GAAGhE,KAAK,CAACoC,GAAG,CAACM,aAAa,CAAM;MAC9C,CAAC,MAAM,IAAIwB,iBAAiB,CAAClE,KAAK,CAAC,EAAE;QACpCgE,aAAa,GAAGhE,KAAK,CAACmE,OAAO,CAAC,CAAM;MACrC,CAAC,MAAM;QACNH,aAAa,GAAGI,MAAM,CAACC,OAAO,CAACrE,KAAK,CAAC,CAAC2B,MAAM,CAAC,CAAC2C,eAAe,EAAAC,IAAA,KAAiB;UAAA,IAAf,CAACC,GAAG,EAAEC,GAAG,CAAC,GAAAF,IAAA;UACxE,MAAMG,YAAY,GAAGhC,aAAa,CAAC+B,GAAG,CAAC;UACvC,IAAIC,YAAY,CAACrG,KAAK,KAAK,UAAU,IAAIqG,YAAY,CAAC1E,KAAK,KAAKJ,SAAS,EAAE;YAC1E0E,eAAe,CAACE,GAAG,CAAC,GAAGE,YAAY;UACpC;UACA,OAAOJ,eAAe;QACvB,CAAC,EAAE,CAAC,CAA0B,CAAM;MACrC;IACD,CAAC,MAAM;MACNN,aAAa,GAAGhE,KAAK;IACtB;IAEA,OAAO;MAAE3B,KAAK,EAAE,UAAU;MAAE2B,KAAK,EAAEgE;IAAc,CAAC;EACnD;EAAC1F,QAAA,CAAA0E,QAAA,GAAAA,QAAA;EAEM,SAAS2B,oBAAoBA,CACnC3E,KAAgC,EAChC4E,UAAmB,EAC8G;IACjI,IAAI5E,KAAK,KAAKJ,SAAS,IAAI,OAAOI,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAAC6E,UAAU,CAAC,GAAG,CAAC,EAAE;MAC9E,MAAMC,gBAAgB,GAAG,eAAe,CAAC,CAAC;MAC1C,MAAMC,qBAAqB,GAAGD,gBAAgB,CAACE,IAAI,CAAChF,KAAK,CAAC;MAE1D,IAAIA,KAAK,CAAC6E,UAAU,CAAC,IAAI,CAAC,EAAE;QAC3B;QACA,OAAO;UACNxG,KAAK,EAAE,2BAA2B;UAClC2B,KAAK,EAAEA;QACR,CAAC;MACF,CAAC,MAAM,IAAI+E,qBAAqB,EAAE;QACjC,OAAO/D,WAAW,CAAC+D,qBAAqB,CAAC,CAAC,CAAC,IAAI,EAAE,EAAEA,qBAAqB,CAAC,CAAC,CAAC,IAAInF,SAAS,CAAC;MAC1F,CAAC,MAAM;QACN,OAAO;UACNvB,KAAK,EAAE,iBAAiB;UACxB2B,KAAK,EAAEA;QACR,CAAC;MACF;IACD,CAAC,MAAM,IAAI4E,UAAU,KAAK,SAAS,IAAI,OAAO5E,KAAK,KAAK,QAAQ,KAAKA,KAAK,KAAK,MAAM,IAAIA,KAAK,KAAK,OAAO,CAAC,EAAE;MAC5G,OAAOgD,QAAQ,CAAChD,KAAK,KAAK,MAAM,CAAC;IAClC,CAAC,MAAM,IAAI4E,UAAU,KAAK,QAAQ,IAAI,OAAO5E,KAAK,KAAK,QAAQ,KAAK,CAACiF,KAAK,CAACC,MAAM,CAAClF,KAAK,CAAC,CAAC,IAAIA,KAAK,KAAK,KAAK,CAAC,EAAE;MAC9G,OAAOgD,QAAQ,CAACkC,MAAM,CAAClF,KAAK,CAAC,CAAC;IAC/B,CAAC,MAAM;MACN,OAAOgD,QAAQ,CAAChD,KAAK,CAAC;IACvB;EACD;;EAEA;AACA;AACA;AACA;AACA;AACA;EALA1B,QAAA,CAAAqG,oBAAA,GAAAA,oBAAA;EAMO,SAASlD,GAAGA,CAAC0D,SAAwB,EAAuB;IAClE,OAAO;MAAE9G,KAAK,EAAE,KAAK;MAAEoD,GAAG,EAAE0D;IAAU,CAAC;EACxC;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;EANA7G,QAAA,CAAAmD,GAAA,GAAAA,GAAA;EAOO,SAAS2D,SAASA,CACxBC,eAAkB,EAClBb,GAAY,EACuC;IACnD,IAAI,OAAOa,eAAe,KAAK,QAAQ,IAAKA,eAAe,CAA0BC,aAAa,EAAE;MACnG,OAAOtE,WAAW,CAAC,GAAG,GAAGwD,GAAG,CAACe,QAAQ,CAAC,CAAC,EAAGF,eAAe,CAA0BC,aAAa,CAACE,KAAK,CAAC;IACxG,CAAC,MAAM;MACN,OAAOxC,QAAQ,CAACqC,eAAe,CAAC;IACjC;EACD;EACA;AACA;AACA;AACA;AACA;AACA;EALA/G,QAAA,CAAA8G,SAAA,GAAAA,SAAA;EAMO,SAAS1C,aAAaA,CAA0B+C,SAAmC,EAA+B;IACxH,IAAIC,0BAA0B,CAACD,SAAS,CAAC,EAAE;MAC1C,OAAOA,SAAS;IACjB;IAEA,OAAOzC,QAAQ,CAACyC,SAAS,CAAC;EAC3B;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAPAnH,QAAA,CAAAoE,aAAA,GAAAA,aAAA;EAQO,SAASgD,0BAA0BA,CACzCrF,UAAuD,EACL;IAClD,OAAQA,UAAU,EAAwChC,KAAK,KAAKuB,SAAS;EAC9E;;EAEA;AACA;AACA;AACA;AACA;AACA;EALAtB,QAAA,CAAAoH,0BAAA,GAAAA,0BAAA;EAMO,SAAS3C,UAAUA,CAA0B4C,aAAuC,EAA0C;IACpI,OAAO,OAAOA,aAAa,KAAK,QAAQ,IAAKA,aAAa,CAAuBtH,KAAK,KAAK,UAAU;EACtG;EAACC,QAAA,CAAAyE,UAAA,GAAAA,UAAA;EAED,SAASG,MAAMA,CAAC7C,UAAmD,EAAW;IAC7E,OAAO0C,UAAU,CAAC1C,UAAU,CAAC,IAAIA,UAAU,CAACL,KAAK,KAAK,IAAI;EAC3D;EAEA,SAAS8C,OAAOA,CAACzC,UAAmD,EAAW;IAC9E,OAAO0C,UAAU,CAAC1C,UAAU,CAAC,IAAIA,UAAU,CAACL,KAAK,KAAK,KAAK;EAC5D;;EAEA;AACA;AACA;AACA;AACA;AACA;EACO,SAAS4F,uBAAuBA,CACtCC,YAAsC,EACK;IAC3C,OAAQA,YAAY,EAAwBxH,KAAK,KAAK,aAAa;EACpE;;EAEA;AACA;AACA;AACA;AACA;AACA;EALAC,QAAA,CAAAsH,uBAAA,GAAAA,uBAAA;EAMO,SAASE,uBAAuBA,CACtCD,YAAsC,EACK;IAC3C,OAAQA,YAAY,EAAwBxH,KAAK,KAAK,aAAa;EACpE;;EAEA;AACA;AACA;AACA;AACA;EAJAC,QAAA,CAAAwH,uBAAA,GAAAA,uBAAA;EAKA,SAASC,kBAAkBA,CAAC1F,UAAmD,EAAkC;IAChH,OAAQA,UAAU,EAAoChC,KAAK,KAAK,QAAQ;EACzE;;EAEA;AACA;AACA;AACA;AACA;EACA,SAAS2H,kBAAkBA,CAAC3F,UAAmD,EAAkC;IAChH,OAAQA,UAAU,EAAoChC,KAAK,KAAK,QAAQ;EACzE;;EAEA;AACA;AACA;AACA;AACA;AACA;EACA,SAASkF,YAAYA,CAA0BlD,UAAuC,EAAsC;IAC3H,OAAOA,UAAU,CAAChC,KAAK,KAAK,YAAY;EACzC;;EAEA;AACA;AACA;AACA;AACA;EACO,SAAS4H,qBAAqBA,CAAC5F,UAAmB,EAA+C;IACvG,MAAM6F,sBAAsB,GAAG7F,UAA+C;IAC9E,OAAO6F,sBAAsB,EAAE7H,KAAK,KAAK,UAAU,IAAI6H,sBAAsB,EAAElG,KAAK,KAAKJ,SAAS;EACnG;EAACtB,QAAA,CAAA2H,qBAAA,GAAAA,qBAAA;EAiBD,SAAS/B,iBAAiBA,CAACiC,UAAkB,EAAW;IACvD,QAAQA,UAAU,CAACC,WAAW,CAACC,IAAI;MAClC,KAAK,QAAQ;MACb,KAAK,QAAQ;MACb,KAAK,SAAS;QACb,OAAO,IAAI;MACZ;QACC,OAAO,KAAK;IACd;EACD;EACA;AACA;AACA;AACA;AACA;AACA;EACA,SAASC,6BAA6BA,CAAIC,eAA2C,EAAqD;IACzI,OAAO,OAAOA,eAAe,KAAK,QAAQ,IAAI,CAACrC,iBAAiB,CAACqC,eAAyB,CAAC;EAC5F;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACO,SAASC,2BAA2BA,CAC1CD,eAAuD,EAIN;IAAA,IAHjD7C,sBAAgC,GAAArE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,EAAE;IAAA,IACrCoH,YAAuC,GAAApH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAO,SAAA;IAAA,IACvC+D,WAAsB,GAAAtE,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAO,SAAA;IAEtB,IAAI2G,eAAe,KAAK3G,SAAS,EAAE;MAClC,OAAO8C,aAAa,CAAC+D,YAAoC,CAAC;IAC3D;IACAF,eAAe,GAAGA,eAAe,EAAEpC,OAAO,CAAC,CAA+B;IAC1E,IAAI,CAACmC,6BAA6B,CAACC,eAAe,CAAC,EAAE;MACpD,OAAOvD,QAAQ,CAACuD,eAAe,CAAC;IACjC;IAEA,QAAQA,eAAe,CAAC/H,IAAI;MAC3B,KAAK,MAAM;QACV,OAAOwC,WAAW,CAACuF,eAAe,CAACrF,IAAI,EAAEtB,SAAS,EAAE8D,sBAAsB,EAAEC,WAAW,CAAC;MACzF,KAAK,IAAI;QACR,OAAO+C,sBAAsB,CAACH,eAAe,CAACI,GAAG,EAAEjD,sBAAsB,EAAEC,WAAW,CAAC;MAGxF,KAAK,KAAK;QACT,OAAOtB,GAAG,CAACuE,wBAAwB,CAACL,eAAe,CAACM,IAAI,EAAEnD,sBAAsB,EAAEC,WAAW,CAAC,CAAC;MAGhG,KAAK,IAAI;QACR,OAAOmD,KAAK,CACXF,wBAAwB,CAACL,eAAe,CAACQ,GAAG,CAAC,CAAC,CAAC,EAAErD,sBAAsB,EAAEC,WAAW,CAAC,EACrFiD,wBAAwB,CAACL,eAAe,CAACQ,GAAG,CAAC,CAAC,CAAC,EAAErD,sBAAsB,EAAEC,WAAW,CACrF,CAAC;MACF,KAAK,IAAI;QACR,OAAOqD,QAAQ,CACdJ,wBAAwB,CAACL,eAAe,CAACU,GAAG,CAAC,CAAC,CAAC,EAAEvD,sBAAsB,EAAEC,WAAW,CAAC,EACrFiD,wBAAwB,CAACL,eAAe,CAACU,GAAG,CAAC,CAAC,CAAC,EAAEvD,sBAAsB,EAAEC,WAAW,CACrF,CAAC;MACF,KAAK,IAAI;QACR,OAAOuD,WAAW,CACjBN,wBAAwB,CAACL,eAAe,CAACY,GAAG,CAAC,CAAC,CAAC,EAAEzD,sBAAsB,EAAEC,WAAW,CAAC,EACrFiD,wBAAwB,CAACL,eAAe,CAACY,GAAG,CAAC,CAAC,CAAC,EAAEzD,sBAAsB,EAAEC,WAAW,CACrF,CAAC;MACF,KAAK,IAAI;QACR,OAAOyD,cAAc,CACpBR,wBAAwB,CAACL,eAAe,CAACc,GAAG,CAAC,CAAC,CAAC,EAAE3D,sBAAsB,EAAEC,WAAW,CAAC,EACrFiD,wBAAwB,CAACL,eAAe,CAACc,GAAG,CAAC,CAAC,CAAC,EAAE3D,sBAAsB,EAAEC,WAAW,CACrF,CAAC;MACF,KAAK,IAAI;QACR,OAAO2D,QAAQ,CACdV,wBAAwB,CAACL,eAAe,CAACgB,GAAG,CAAC,CAAC,CAAC,EAAE7D,sBAAsB,EAAEC,WAAW,CAAC,EACrFiD,wBAAwB,CAACL,eAAe,CAACgB,GAAG,CAAC,CAAC,CAAC,EAAE7D,sBAAsB,EAAEC,WAAW,CACrF,CAAC;MACF,KAAK,IAAI;QACR,OAAO6D,WAAW,CACjBZ,wBAAwB,CAACL,eAAe,CAACkB,GAAG,CAAC,CAAC,CAAC,EAAE/D,sBAAsB,EAAEC,WAAW,CAAC,EACrFiD,wBAAwB,CAACL,eAAe,CAACkB,GAAG,CAAC,CAAC,CAAC,EAAE/D,sBAAsB,EAAEC,WAAW,CACrF,CAAC;MACF,KAAK,IAAI;QACR,OAAOR,EAAE,CACR,GAAGoD,eAAe,CAACmB,GAAG,CAACtF,GAAG,CAAC,UAAUuF,WAAW,EAAE;UACjD,OAAOf,wBAAwB,CAAUe,WAAW,EAAEjE,sBAAsB,EAAEC,WAAW,CAAC;QAC3F,CAAC,CACF,CAAC;MACF,KAAK,KAAK;QACT,OAAOpB,GAAG,CACT,GAAGgE,eAAe,CAACqB,IAAI,CAACxF,GAAG,CAAC,UAAUyF,YAAY,EAAE;UACnD,OAAOjB,wBAAwB,CAAUiB,YAAY,EAAEnE,sBAAsB,EAAEC,WAAW,CAAC;QAC5F,CAAC,CACF,CAAC;MACF,KAAK,OAAO;QACX,OAAOmE,yBAAyB,CAC/BvB,eAAe,EACf7C,sBAAsB,EACtBC,WACD,CAAC;MACF,KAAK,UAAU;QACd;QACA,OAAOX,QAAQ,CAACuD,eAAe,CAACvG,KAA6B,CAAC;IAChE;IACA,OAAOjB,sBAAsB;EAC9B;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAPAT,QAAA,CAAAkI,2BAAA,GAAAA,2BAAA;EAQA,SAASI,wBAAwBA,CAChCL,eAAwC,EAGV;IAAA,IAF9B7C,sBAAgC,GAAArE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,EAAE;IAAA,IACrCsE,WAAsB,GAAAtE,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAO,SAAA;IAEtB,IAAI2G,eAAe,KAAK,IAAI,IAAI,OAAOA,eAAe,KAAK,QAAQ,EAAE;MACpE,OAAOvD,QAAQ,CAACuD,eAAoB,CAAC;IACtC,CAAC,MAAM,IAAIA,eAAe,CAACwB,cAAc,CAAC,KAAK,CAAC,EAAE;MACjD,OAAO5E,EAAE,CACR,GAAKoD,eAAe,CAA6BmB,GAAG,CAACtF,GAAG,CAAC,UAAUuF,WAAW,EAAE;QAC/E,OAAOf,wBAAwB,CAACe,WAAW,EAAEjE,sBAAsB,EAAEC,WAAW,CAAC;MAClF,CAAC,CACF,CAAC;IACF,CAAC,MAAM,IAAI4C,eAAe,CAACwB,cAAc,CAAC,MAAM,CAAC,EAAE;MAClD,OAAOxF,GAAG,CACT,GAAKgE,eAAe,CAA8BqB,IAAI,CAACxF,GAAG,CAAC,UAAUyF,YAAY,EAAE;QAClF,OAAOjB,wBAAwB,CAACiB,YAAY,EAAEnE,sBAAsB,EAAEC,WAAW,CAAC;MACnF,CAAC,CACF,CAAC;IACF,CAAC,MAAM,IAAI4C,eAAe,CAACwB,cAAc,CAAC,MAAM,CAAC,EAAE;MAClD,OAAO1F,GAAG,CACTuE,wBAAwB,CAAEL,eAAe,CAA8BM,IAAI,EAAEnD,sBAAsB,EAAEC,WAAW,CACjH,CAAC;IACF,CAAC,MAAM,IAAI4C,eAAe,CAACwB,cAAc,CAAC,KAAK,CAAC,EAAE;MACjD,OAAOjB,KAAK,CACXF,wBAAwB,CAAEL,eAAe,CAA6BQ,GAAG,CAAC,CAAC,CAAC,EAAErD,sBAAsB,EAAEC,WAAW,CAAC,EAClHiD,wBAAwB,CAAEL,eAAe,CAA6BQ,GAAG,CAAC,CAAC,CAAC,EAAErD,sBAAsB,EAAEC,WAAW,CAClH,CAAC;IACF,CAAC,MAAM,IAAI4C,eAAe,CAACwB,cAAc,CAAC,KAAK,CAAC,EAAE;MACjD,OAAOf,QAAQ,CACdJ,wBAAwB,CAAEL,eAAe,CAA6BU,GAAG,CAAC,CAAC,CAAC,EAAEvD,sBAAsB,EAAEC,WAAW,CAAC,EAClHiD,wBAAwB,CAAEL,eAAe,CAA6BU,GAAG,CAAC,CAAC,CAAC,EAAEvD,sBAAsB,EAAEC,WAAW,CAClH,CAAC;IACF,CAAC,MAAM,IAAI4C,eAAe,CAACwB,cAAc,CAAC,KAAK,CAAC,EAAE;MACjD,OAAOb,WAAW,CACjBN,wBAAwB,CAAEL,eAAe,CAA6BY,GAAG,CAAC,CAAC,CAAC,EAAEzD,sBAAsB,EAAEC,WAAW,CAAC,EAClHiD,wBAAwB,CAAEL,eAAe,CAA6BY,GAAG,CAAC,CAAC,CAAC,EAAEzD,sBAAsB,EAAEC,WAAW,CAClH,CAAC;IACF,CAAC,MAAM,IAAI4C,eAAe,CAACwB,cAAc,CAAC,KAAK,CAAC,EAAE;MACjD,OAAOX,cAAc,CACpBR,wBAAwB,CAAEL,eAAe,CAA6Bc,GAAG,CAAC,CAAC,CAAC,EAAE3D,sBAAsB,EAAEC,WAAW,CAAC,EAClHiD,wBAAwB,CAAEL,eAAe,CAA6Bc,GAAG,CAAC,CAAC,CAAC,EAAE3D,sBAAsB,EAAEC,WAAW,CAClH,CAAC;IACF,CAAC,MAAM,IAAI4C,eAAe,CAACwB,cAAc,CAAC,KAAK,CAAC,EAAE;MACjD,OAAOT,QAAQ,CACdV,wBAAwB,CAAEL,eAAe,CAA6BgB,GAAG,CAAC,CAAC,CAAC,EAAE7D,sBAAsB,EAAEC,WAAW,CAAC,EAClHiD,wBAAwB,CAAEL,eAAe,CAA6BgB,GAAG,CAAC,CAAC,CAAC,EAAE7D,sBAAsB,EAAEC,WAAW,CAClH,CAAC;IACF,CAAC,MAAM,IAAI4C,eAAe,CAACwB,cAAc,CAAC,KAAK,CAAC,EAAE;MACjD,OAAOP,WAAW,CACjBZ,wBAAwB,CAAEL,eAAe,CAA6BkB,GAAG,CAAC,CAAC,CAAC,EAAE/D,sBAAsB,EAAEC,WAAW,CAAC,EAClHiD,wBAAwB,CAAEL,eAAe,CAA6BkB,GAAG,CAAC,CAAC,CAAC,EAAE/D,sBAAsB,EAAEC,WAAW,CAClH,CAAC;IACF,CAAC,MAAM,IAAI4C,eAAe,CAACwB,cAAc,CAAC,OAAO,CAAC,EAAE;MACnD,OAAO/G,WAAW,CAAEuF,eAAe,CAAgCyB,KAAK,EAAEpI,SAAS,EAAE8D,sBAAsB,EAAEC,WAAW,CAAC;IAC1H,CAAC,MAAM,IAAI4C,eAAe,CAACwB,cAAc,CAAC,QAAQ,CAAC,EAAE;MACpD,OAAOvB,2BAA2B,CACjC;QACChI,IAAI,EAAE,OAAO;QACbyJ,SAAS,EAAG1B,eAAe,CAA4B0B,SAAS;QAChEC,MAAM,EAAG3B,eAAe,CAA0B2B;MACnD,CAAC,EACDxE,sBAAsB,EACtB9D,SAAS,EACT+D,WACD,CAAC;IACF,CAAC,MAAM,IAAI4C,eAAe,CAACwB,cAAc,CAAC,KAAK,CAAC,EAAE;MACjD,OAAOvB,2BAA2B,CACjC;QACChI,IAAI,EAAE,IAAI;QACVmI,GAAG,EAAGJ,eAAe,CAAuBI;MAC7C,CAAC,EACDjD,sBAAsB,EACtB9D,SAAS,EACT+D,WACD,CAAC;IACF,CAAC,MAAM,IAAI4C,eAAe,CAACwB,cAAc,CAAC,aAAa,CAAC,EAAE;MACzD,OAAO/E,QAAQ,CAACmF,gBAAgB,CAAE5B,eAAe,CAA8B6B,WAAW,CAAM,CAAC;IAClG;IACA,OAAOpF,QAAQ,CAAC,KAAU,CAAC;EAC5B;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACO,SAAS0D,sBAAsBA,CACrCH,eAA+C,EAGjB;IAAA,IAF9B7C,sBAAgC,GAAArE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,EAAE;IAAA,IACrCsE,WAAsB,GAAAtE,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAO,SAAA;IAEtB,OAAOyI,MAAM,CACZzB,wBAAwB,CAACL,eAAe,CAAC,CAAC,CAAC,EAAE7C,sBAAsB,EAAEC,WAAW,CAAC,EACjFiD,wBAAwB,CAACL,eAAe,CAAC,CAAC,CAAC,EAA6B7C,sBAAsB,EAAEC,WAAW,CAAC,EAC5GiD,wBAAwB,CAACL,eAAe,CAAC,CAAC,CAAC,EAA6B7C,sBAAsB,EAAEC,WAAW,CAC5G,CAAC;EACF;EACA;EAAArF,QAAA,CAAAoI,sBAAA,GAAAA,sBAAA;EAEA,SAAS4B,yBAAyBA,CAACC,UAA2C,EAAmD;IAChI,IAAIC,mBAAmB,GAAGD,UAAU;IACpC,IAAIA,UAAU,CAACR,cAAc,CAAC,OAAO,CAAC,EAAE;MACvCS,mBAAmB,GAAG;QACrBhK,IAAI,EAAE,MAAM;QACZ0C,IAAI,EAAEqH,UAAU,CAACP;MAClB,CAAqC;IACtC,CAAC,MAAM,IAAIO,UAAU,CAACR,cAAc,CAAC,KAAK,CAAC,EAAE;MAC5CS,mBAAmB,GAAG;QACrBhK,IAAI,EAAE,IAAI;QACVmI,GAAG,EAAE4B,UAAU,CAAC5B;MACjB,CAAmC;IACpC,CAAC,MAAM,IAAI4B,UAAU,CAACR,cAAc,CAAC,QAAQ,CAAC,EAAE;MAC/CS,mBAAmB,GAAG;QACrBhK,IAAI,EAAE,OAAO;QACbyJ,SAAS,EAAEM,UAAU,CAACN,SAAS;QAC/BC,MAAM,EAAEK,UAAU,CAACL;MACpB,CAAsC;IACvC;IACA,OAAOM,mBAAmB;EAC3B;EAGO,SAASV,yBAAyBA,CACxCW,eAAkD,EAGf;IAAA,IAFnC/E,sBAAgC,GAAArE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,EAAE;IAAA,IACrCsE,WAAsB,GAAAtE,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAO,SAAA;IAEtB,QAAQ6I,eAAe,CAACR,SAAS;MAChC,KAAK,cAAc;QAClB,OAAOnE,MAAM,CACZ,GAAG2E,eAAe,CAACP,MAAM,CAAC9F,GAAG,CAAEmG,UAAU,IAAK;UAC7C,OAAO/B,2BAA2B,CACjC8B,yBAAyB,CAACC,UAAU,CAAC,EACrC7E,sBAAsB,EACtB9D,SAAS,EACT+D,WACD,CAAC;QACF,CAAC,CACF,CAAC;MACF,KAAK,iBAAiB;QACrB,MAAM+E,SAAS,GAAGlC,2BAA2B,CAC5C8B,yBAAyB,CACxBG,eAAe,CAACP,MAAM,CAAC,CAAC,CACzB,CAAC,EACDxE,sBAAsB,EACtB9D,SAAS,EACT+D,WACD,CAAC;QACD;QACA,OAAOvC,EAAE,CAAC,iBAAiB,EAAE,CAACsH,SAAS,EAAE,YAAY,CAAC,EAAE9I,SAAS,EAAE,IAAI,CAAC;MACzE,KAAK,uBAAuB;QAC3B,MAAM+I,QAAQ,GAAGF,eAAe,CAACP,MAAM,CAAC,CAAC,CAAC;QAC1C,MAAMU,cAAc,GAAGH,eAAe,CAACP,MAAM,CAACW,KAAK,CAAC,CAAC,CAAiD;QACtG,MAAMC,YAA+D,GAAG,CAAC,CAAC;QAC1EF,cAAc,CAAC9G,OAAO,CAAEyG,UAAU,IAAK;UACtCO,YAAY,CAACP,UAAU,CAACQ,KAAK,CAAW,GAAGvC,2BAA2B,CACrE8B,yBAAyB,CACxBC,UAAU,CAACS,eACZ,CAAC,EACDtF,sBAAsB,EACtB9D,SAAS,EACT+D,WACD,CAAC;QACF,CAAC,CAAC;QACF,OAAOvC,EAAE,CAAC,uBAAuB,EAAE,CAACuH,QAAQ,EAAEG,YAAY,CAAC,EAAElJ,SAAS,EAAE,IAAI,CAAC;IAC/E;IACA,OAAOb,sBAAsB;EAC9B;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAPAT,QAAA,CAAAwJ,yBAAA,GAAAA,yBAAA;EAQA,SAASmB,UAAUA,CAClB/I,QAA4B,EAC5BgJ,WAAqC,EACrCC,YAAsC,EACF;IACpC,MAAMC,cAAc,GAAG1G,aAAa,CAACwG,WAAW,CAAC;IACjD,MAAMG,eAAe,GAAG3G,aAAa,CAACyG,YAAY,CAAC;IACnD,IAAIhK,yBAAyB,CAACiK,cAAc,EAAEC,eAAe,CAAC,EAAE;MAC/D,OAAOtK,sBAAsB;IAC9B;IACA,IAAIgE,UAAU,CAACqG,cAAc,CAAC,IAAIrG,UAAU,CAACsG,eAAe,CAAC,EAAE;MAC9D,QAAQnJ,QAAQ;QACf,KAAK,KAAK;UACT,OAAO8C,QAAQ,CAACoG,cAAc,CAACpJ,KAAK,KAAKqJ,eAAe,CAACrJ,KAAK,CAAC;QAChE,KAAK,KAAK;UACT,OAAOgD,QAAQ,CAACoG,cAAc,CAACpJ,KAAK,KAAKqJ,eAAe,CAACrJ,KAAK,CAAC;QAChE,KAAK,GAAG;UACP,IACCoJ,cAAc,CAACpJ,KAAK,KAAK,IAAI,IAC7BoJ,cAAc,CAACpJ,KAAK,KAAKJ,SAAS,IAClCyJ,eAAe,CAACrJ,KAAK,KAAK,IAAI,IAC9BqJ,eAAe,CAACrJ,KAAK,KAAKJ,SAAS,EAClC;YACD,OAAOoD,QAAQ,CAAC,KAAK,CAAC;UACvB;UACA,OAAOA,QAAQ,CAACoG,cAAc,CAACpJ,KAAK,GAAGqJ,eAAe,CAACrJ,KAAK,CAAC;QAC9D,KAAK,IAAI;UACR,IACCoJ,cAAc,CAACpJ,KAAK,KAAK,IAAI,IAC7BoJ,cAAc,CAACpJ,KAAK,KAAKJ,SAAS,IAClCyJ,eAAe,CAACrJ,KAAK,KAAK,IAAI,IAC9BqJ,eAAe,CAACrJ,KAAK,KAAKJ,SAAS,EAClC;YACD,OAAOoD,QAAQ,CAAC,KAAK,CAAC;UACvB;UACA,OAAOA,QAAQ,CAACoG,cAAc,CAACpJ,KAAK,IAAIqJ,eAAe,CAACrJ,KAAK,CAAC;QAC/D,KAAK,GAAG;UACP,IACCoJ,cAAc,CAACpJ,KAAK,KAAK,IAAI,IAC7BoJ,cAAc,CAACpJ,KAAK,KAAKJ,SAAS,IAClCyJ,eAAe,CAACrJ,KAAK,KAAK,IAAI,IAC9BqJ,eAAe,CAACrJ,KAAK,KAAKJ,SAAS,EAClC;YACD,OAAOoD,QAAQ,CAAC,KAAK,CAAC;UACvB;UACA,OAAOA,QAAQ,CAACoG,cAAc,CAACpJ,KAAK,GAAGqJ,eAAe,CAACrJ,KAAK,CAAC;QAC9D,KAAK,IAAI;UACR,IACCoJ,cAAc,CAACpJ,KAAK,KAAK,IAAI,IAC7BoJ,cAAc,CAACpJ,KAAK,KAAKJ,SAAS,IAClCyJ,eAAe,CAACrJ,KAAK,KAAK,IAAI,IAC9BqJ,eAAe,CAACrJ,KAAK,KAAKJ,SAAS,EAClC;YACD,OAAOoD,QAAQ,CAAC,KAAK,CAAC;UACvB;UACA,OAAOA,QAAQ,CAACoG,cAAc,CAACpJ,KAAK,IAAIqJ,eAAe,CAACrJ,KAAK,CAAC;MAChE;IACD,CAAC,MAAM;MACN,OAAO;QACN3B,KAAK,EAAE,YAAY;QACnB6B,QAAQ,EAAEA,QAAQ;QAClBS,QAAQ,EAAEyI,cAAc;QACxBxI,QAAQ,EAAEyI;MACX,CAAC;IACF;EACD;;EAEA;AACA;AACA;AACA;AACA;AACA;EACO,SAAS/J,MAAMA,CACrBe,UAAuE,EAEpC;IAAA,IADnCiJ,cAAc,GAAAjK,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,KAAK;IAEtB,IAAIgB,UAAU,CAAChC,KAAK,KAAK,cAAc,EAAE;MACxC,OAAOgC,UAAU;IAClB;IACA,IAAI,CAACiJ,cAAc,EAAE;MACpB,OAAO;QACNjL,KAAK,EAAE,QAAQ;QACf2C,WAAW,EAAEX;MACd,CAAC;IACF;IACA,OAAOgI,MAAM,CAACvB,KAAK,CAACzG,UAAU,EAAET,SAAS,CAAC,EAAE,CAAC,CAAC,EAAEN,MAAM,CAACe,UAAU,CAAC,CAAC;EACpE;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;EANA/B,QAAA,CAAAgB,MAAA,GAAAA,MAAA;EAOO,SAASwH,KAAKA,CACpBoC,WAAqC,EACrCC,YAAsC,EACF;IACpC,MAAMC,cAAc,GAAG1G,aAAa,CAACwG,WAAW,CAAC;IACjD,MAAMG,eAAe,GAAG3G,aAAa,CAACyG,YAAY,CAAC;IACnD,IAAIhK,yBAAyB,CAACiK,cAAc,EAAEC,eAAe,CAAC,EAAE;MAC/D,OAAOtK,sBAAsB;IAC9B;IACA,IAAIc,yBAAyB,CAACuJ,cAAc,EAAEC,eAAe,CAAC,EAAE;MAC/D,OAAOrG,QAAQ,CAAC,IAAI,CAAC;IACtB;IAEA,SAASrB,MAAMA,CAAC4H,IAAiC,EAAEC,KAAkC,EAAiD;MACrI,IAAID,IAAI,CAAClL,KAAK,KAAK,YAAY,IAAI6E,MAAM,CAACsG,KAAK,CAAC,EAAE;QACjD;QACA,OAAOD,IAAI;MACZ,CAAC,MAAM,IAAIA,IAAI,CAAClL,KAAK,KAAK,YAAY,IAAIyE,OAAO,CAAC0G,KAAK,CAAC,EAAE;QACzD;QACA,OAAOnH,GAAG,CAACkH,IAAI,CAAC;MACjB,CAAC,MAAM,IAAIA,IAAI,CAAClL,KAAK,KAAK,QAAQ,IAAIwB,yBAAyB,CAAC0J,IAAI,CAAC9I,MAAM,EAAE+I,KAAK,CAAC,EAAE;QACpF;QACA,OAAOrG,EAAE,CAACoG,IAAI,CAAC/I,SAAS,EAAEsG,KAAK,CAACyC,IAAI,CAAC7I,OAAO,EAAE8I,KAAK,CAAC,CAAC;MACtD,CAAC,MAAM,IAAID,IAAI,CAAClL,KAAK,KAAK,QAAQ,IAAIwB,yBAAyB,CAAC0J,IAAI,CAAC7I,OAAO,EAAE8I,KAAK,CAAC,EAAE;QACrF;QACA,OAAOrG,EAAE,CAACd,GAAG,CAACkH,IAAI,CAAC/I,SAAS,CAAC,EAAEsG,KAAK,CAACyC,IAAI,CAAC9I,MAAM,EAAE+I,KAAK,CAAC,CAAC;MAC1D,CAAC,MAAM,IACND,IAAI,CAAClL,KAAK,KAAK,QAAQ,IACvB0E,UAAU,CAACwG,IAAI,CAAC9I,MAAM,CAAC,IACvBsC,UAAU,CAACwG,IAAI,CAAC7I,OAAO,CAAC,IACxBqC,UAAU,CAACyG,KAAK,CAAC,IACjB,CAAC3J,yBAAyB,CAAC0J,IAAI,CAAC9I,MAAM,EAAE+I,KAAK,CAAC,IAC9C,CAAC3J,yBAAyB,CAAC0J,IAAI,CAAC7I,OAAO,EAAE8I,KAAK,CAAC,EAC9C;QACD,OAAOxG,QAAQ,CAAC,KAAK,CAAC;MACvB;MACA,OAAOpD,SAAS;IACjB;;IAEA;IACA,MAAM6J,OAAO,GAAG9H,MAAM,CAACyH,cAAc,EAAEC,eAAe,CAAC,IAAI1H,MAAM,CAAC0H,eAAe,EAAED,cAAc,CAAC;IAClG,OAAOK,OAAO,IAAIR,UAAU,CAAC,KAAK,EAAEG,cAAc,EAAEC,eAAe,CAAC;EACrE;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;EANA/K,QAAA,CAAAwI,KAAA,GAAAA,KAAA;EAOO,SAASE,QAAQA,CACvBkC,WAAqC,EACrCC,YAAsC,EACF;IACpC,OAAO9G,GAAG,CAACyE,KAAK,CAACoC,WAAW,EAAEC,YAAY,CAAC,CAAC;EAC7C;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;EANA7K,QAAA,CAAA0I,QAAA,GAAAA,QAAA;EAOO,SAASI,cAAcA,CAC7B8B,WAAqC,EACrCC,YAAsC,EACF;IACpC,OAAOF,UAAU,CAAC,IAAI,EAAEC,WAAW,EAAEC,YAAY,CAAC;EACnD;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;EANA7K,QAAA,CAAA8I,cAAA,GAAAA,cAAA;EAOO,SAASF,WAAWA,CAC1BgC,WAAqC,EACrCC,YAAsC,EACF;IACpC,OAAOF,UAAU,CAAC,GAAG,EAAEC,WAAW,EAAEC,YAAY,CAAC;EAClD;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;EANA7K,QAAA,CAAA4I,WAAA,GAAAA,WAAA;EAOO,SAASM,WAAWA,CAC1B0B,WAAqC,EACrCC,YAAsC,EACF;IACpC,OAAOF,UAAU,CAAC,IAAI,EAAEC,WAAW,EAAEC,YAAY,CAAC;EACnD;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;EANA7K,QAAA,CAAAkJ,WAAA,GAAAA,WAAA;EAOO,SAASF,QAAQA,CACvB4B,WAAqC,EACrCC,YAAsC,EACF;IACpC,OAAOF,UAAU,CAAC,GAAG,EAAEC,WAAW,EAAEC,YAAY,CAAC;EAClD;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EATA7K,QAAA,CAAAgJ,QAAA,GAAAA,QAAA;EAUO,SAASe,MAAMA,CACrB7H,SAAyC,EACzCC,MAAgC,EAChCC,OAAiC,EACH;IAC9B,IAAIgJ,mBAAmB,GAAGhH,aAAa,CAAClC,SAAS,CAAC;IAClD,IAAImJ,gBAAgB,GAAGjH,aAAa,CAACjC,MAAM,CAAC;IAC5C,IAAImJ,iBAAiB,GAAGlH,aAAa,CAAChC,OAAO,CAAC;;IAE9C;IACA,IAAIgJ,mBAAmB,CAACrL,KAAK,KAAK,KAAK,EAAE;MACxC;MACA,CAACsL,gBAAgB,EAAEC,iBAAiB,CAAC,GAAG,CAACA,iBAAiB,EAAED,gBAAgB,CAAC;MAC7ED,mBAAmB,GAAGrH,GAAG,CAACqH,mBAAmB,CAAC;IAC/C;;IAEA;IACA;IACA,IAAIC,gBAAgB,CAACtL,KAAK,KAAK,QAAQ,IAAIwB,yBAAyB,CAAC6J,mBAAmB,EAAEC,gBAAgB,CAACnJ,SAAS,CAAC,EAAE;MACtHmJ,gBAAgB,GAAGA,gBAAgB,CAAClJ,MAAM;IAC3C;;IAEA;IACA;IACA,IAAImJ,iBAAiB,CAACvL,KAAK,KAAK,QAAQ,IAAIwB,yBAAyB,CAAC6J,mBAAmB,EAAEE,iBAAiB,CAACpJ,SAAS,CAAC,EAAE;MACxHoJ,iBAAiB,GAAGA,iBAAiB,CAAClJ,OAAO;IAC9C;;IAEA;IACA;IACA,IAAIqC,UAAU,CAAC2G,mBAAmB,CAAC,EAAE;MACpC,OAAOA,mBAAmB,CAAC1J,KAAK,GAAG2J,gBAAgB,GAAGC,iBAAiB;IACxE;;IAEA;IACA;IACA;;IAEA;IACA,IAAI/J,yBAAyB,CAAC8J,gBAAgB,EAAEC,iBAAiB,CAAC,EAAE;MACnE,OAAOD,gBAAgB;IACxB;;IAEA;IACA,IAAI7G,OAAO,CAAC8G,iBAAiB,CAAC,EAAE;MAC/B,OAAOrH,GAAG,CAACmH,mBAAmB,EAAEC,gBAAqD,CAAC;IACvF;;IAEA;IACA,IAAIzG,MAAM,CAAC0G,iBAAiB,CAAC,EAAE;MAC9B,OAAOzG,EAAE,CAACd,GAAG,CAACqH,mBAAmB,CAAC,EAAEC,gBAAqD,CAAC;IAC3F;;IAEA;IACA,IAAI7G,OAAO,CAAC6G,gBAAgB,CAAC,EAAE;MAC9B,OAAOpH,GAAG,CAACF,GAAG,CAACqH,mBAAmB,CAAC,EAAEE,iBAAsD,CAAC;IAC7F;;IAEA;IACA,IAAI1G,MAAM,CAACyG,gBAAgB,CAAC,EAAE;MAC7B,OAAOxG,EAAE,CAACuG,mBAAmB,EAAEE,iBAAsD,CAAC;IACvF;IACA,IAAIzK,yBAAyB,CAACuK,mBAAmB,EAAEC,gBAAgB,EAAEC,iBAAiB,CAAC,EAAE;MACxF,OAAO7K,sBAAsB;IAC9B;IACA,IAAI+G,uBAAuB,CAACtF,SAAS,CAAC,IAAIsF,uBAAuB,CAACrF,MAAM,CAAC,IAAIqF,uBAAuB,CAACpF,OAAO,CAAC,EAAE;MAC9G,IAAImJ,OAAO,GAAG,CAAC;MACf,MAAMC,kBAAkB,GAAGC,YAAY,CAAC,CAACvJ,SAAS,EAAEC,MAAM,EAAEC,OAAO,CAAC,EAAE,uCAAuC,CAAC;MAC9G,MAAMsJ,QAAQ,GAAG,EAAE;MACnBC,oBAAoB,CACnBH,kBAAkB,EAClB,aAAa,EACZI,YAA4C,IAAK;QACjDF,QAAQ,CAAC/H,IAAI,CAACiI,YAAY,CAAC;QAC3B,OAAOlJ,WAAW,CAAC,IAAI6I,OAAO,EAAE,EAAE,EAAE,GAAG,CAAC;MACzC,CAAC,EACD,IACD,CAAC;MACDG,QAAQ,CAACG,OAAO,CAACnH,QAAQ,CAACoH,IAAI,CAACC,SAAS,CAACP,kBAAkB,CAAC,CAAC,CAAC;MAC9D,OAAOC,YAAY,CAACC,QAAQ,EAAE,yEAAyE,EAAEpK,SAAS,EAAE,IAAI,CAAC;IAC1H;IACA,OAAO;MACNvB,KAAK,EAAE,QAAQ;MACfmC,SAAS,EAAEkJ,mBAAmB;MAC9BjJ,MAAM,EAAEkJ,gBAAgB;MACxBjJ,OAAO,EAAEkJ;IACV,CAAC;EACF;;EAEA;AACA;AACA;AACA;AACA;EAJAtL,QAAA,CAAA+J,MAAA,GAAAA,MAAA;EAKA,SAASiC,4BAA4BA,CAACjK,UAA6C,EAAW;IAC7F,QAAQA,UAAU,CAAChC,KAAK;MACvB,KAAK,UAAU;MACf,KAAK,WAAW;MAChB,KAAK,aAAa;QACjB,OAAO,KAAK;MACb,KAAK,KAAK;QACT,OAAOgC,UAAU,CAACF,QAAQ,CAACG,IAAI,CAACgK,4BAA4B,CAAC;MAC9D,KAAK,aAAa;QACjB,OAAOjK,UAAU,CAACY,SAAS,KAAKrB,SAAS;MAC1C,KAAK,YAAY;QAChB,OAAO0K,4BAA4B,CAACjK,UAAU,CAACM,QAAQ,CAAC,IAAI2J,4BAA4B,CAACjK,UAAU,CAACO,QAAQ,CAAC;MAC9G,KAAK,QAAQ;QACZ,OACC0J,4BAA4B,CAACjK,UAAU,CAACG,SAAS,CAAC,IAClD8J,4BAA4B,CAACjK,UAAU,CAACI,MAAM,CAAC,IAC/C6J,4BAA4B,CAACjK,UAAU,CAACK,OAAO,CAAC;MAElD,KAAK,KAAK;MACV,KAAK,QAAQ;QACZ,OAAO4J,4BAA4B,CAACjK,UAAU,CAACJ,OAAO,CAAC;MACxD;QACC,OAAO,KAAK;IACd;EACD;;EAEA;EACA;;EAKA;AACA;AACA;EACA;EACA;;EAGA;;EAEA;AACA;AACA;;EAGA;AACA;AACA;;EAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACO,SAAS8J,YAAYA,CAC3B1I,UAAuC,EACvCkJ,iBAA6B,EAC7BC,iBAA8B,EAEA;IAAA,IAD9BC,iBAAiB,GAAApL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,KAAK;IAEzB,MAAMqL,oBAAoB,GAAIrJ,UAAU,CAA4Ce,GAAG,CAACM,aAAa,CAAC;IAEtG,IAAIvD,yBAAyB,CAAC,GAAGuL,oBAAoB,CAAC,EAAE;MACvD,OAAO3L,sBAAsB;IAC9B;IACA,IAAIyL,iBAAiB,EAAE;MACtB;MACA,IAAI,CAACE,oBAAoB,CAACpK,IAAI,CAACgK,4BAA4B,CAAC,EAAE;QAC7DE,iBAAiB,CAACG,IAAI,CAAC7I,OAAO,CAAE0C,GAAG,IAAKkG,oBAAoB,CAACzI,IAAI,CAACjB,WAAW,CAACwD,GAAG,CAAC6B,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC;MAC9F;IACD;IACA,IAAIuE,YAAY,GAAG,EAAE;IACrB,IAAI,OAAOL,iBAAiB,KAAK,QAAQ,EAAE;MAC1CK,YAAY,GAAGL,iBAAiB;IACjC,CAAC,MAAM;MACNK,YAAY,GAAGL,iBAAiB,CAACM,cAAc;IAChD;IACA;IACA,MAAM,CAACC,cAAc,EAAEC,aAAa,CAAC,GAAGH,YAAY,CAACI,KAAK,CAAC,GAAG,CAAC;;IAE/D;IACA,IACC,CAACP,iBAAiB,KACjBC,oBAAoB,CAACpK,IAAI,CAACwF,uBAAuB,CAAC,IAClD4E,oBAAoB,CAACpK,IAAI,CAACyF,kBAAkB,CAAC,IAC7C2E,oBAAoB,CAACpK,IAAI,CAAC0F,kBAAkB,CAAC,CAAC,EAC9C;MACD,IAAI6D,OAAO,GAAG,CAAC;MACf,MAAMoB,kBAAkB,GAAGlB,YAAY,CAACW,oBAAoB,EAAEE,YAAY,EAAEhL,SAAS,EAAE,IAAI,CAAC;MAC5F,MAAMoK,QAAQ,GAAG,EAAE;MACnBC,oBAAoB,CACnBgB,kBAAkB,EAClB,aAAa,EACZf,YAA4C,IAAK;QACjDF,QAAQ,CAAC/H,IAAI,CAACiI,YAAY,CAAC;QAC3B,OAAOlJ,WAAW,CAAC,IAAI6I,OAAO,EAAE,EAAE,EAAE,GAAG,CAAC;MACzC,CAAC,EACD,IACD,CAAC;MACDG,QAAQ,CAACG,OAAO,CAACnH,QAAQ,CAACoH,IAAI,CAACC,SAAS,CAACY,kBAAkB,CAAC,CAAC,CAAC;MAC9D,OAAOlB,YAAY,CAACC,QAAQ,EAAE,yEAAyE,EAAEpK,SAAS,EAAE,IAAI,CAAC;IAC1H,CAAC,MAAM,IAAI,CAAC,CAACmL,aAAa,IAAIA,aAAa,CAACzL,MAAM,GAAG,CAAC,EAAE;MACvDoL,oBAAoB,CAACP,OAAO,CAACnH,QAAQ,CAAC+H,aAAa,CAAC,CAAC;IACtD;IAEA,OAAO;MACN1M,KAAK,EAAE,WAAW;MAClB+C,EAAE,EAAE0J,cAAc;MAClBzJ,UAAU,EAAEqJ;IACb,CAAC;EACF;EAACpM,QAAA,CAAAyL,YAAA,GAAAA,YAAA;EAYM,SAASmB,gBAAgBA,CAACC,aAAoC,EAAEC,QAAoC,EAAsB;IAChI,MAAM3M,WAA+B,GAAG,CAAC,CAAC;IAC1C,IAAI0M,aAAa,EAAE1M,WAAW,EAAEG,MAAM,IAAIwM,QAAQ,CAACC,KAAK,KAAKzL,SAAS,EAAE;MACvEnB,WAAW,CAAC4M,KAAK,GAAGD,QAAQ,CAACC,KAAK;IACnC;IACA,IAAIF,aAAa,EAAE1M,WAAW,EAAEC,UAAU,IAAI0M,QAAQ,CAACE,SAAS,KAAK1L,SAAS,EAAE;MAC/EnB,WAAW,CAAC6M,SAAS,GAAGF,QAAQ,CAACE,SAAS;IAC3C;IACA,IAAIH,aAAa,EAAE1M,WAAW,EAAEI,UAAU,IAAIuM,QAAQ,CAACG,SAAS,KAAK3L,SAAS,EAAE;MAC/EnB,WAAW,CAAC8M,SAAS,GAAGH,QAAQ,CAACG,SAAS;IAC3C;IACA,IAAIH,QAAQ,CAACI,QAAQ,KAAK,KAAK,EAAE;MAChC/M,WAAW,CAAC+M,QAAQ,GAAG,KAAK;IAC7B;IACA,IAAIL,aAAa,EAAE1M,WAAW,GAAG,2CAA2C,CAAC,IAAI,CAACwG,KAAK,CAACmG,QAAQ,CAACK,WAAW,EAAEC,UAAU,EAAEC,OAAO,CAAC,EAAE;MACnIlN,WAAW,CAACmN,OAAO,GAAG,GAAGR,QAAQ,CAACK,WAAW,EAAEC,UAAU,EAAEC,OAAO,EAAE;IACrE;IACA,IAAIR,aAAa,EAAE1M,WAAW,GAAG,2CAA2C,CAAC,IAAI,CAACwG,KAAK,CAACmG,QAAQ,CAACK,WAAW,EAAEC,UAAU,EAAEG,OAAO,CAAC,EAAE;MACnIpN,WAAW,CAACqN,OAAO,GAAG,GAAGV,QAAQ,CAACK,WAAW,EAAEC,UAAU,EAAEG,OAAO,EAAE;IACrE;IACA,IACCT,QAAQ,CAACK,WAAW,EAAEM,MAAM,EAAEC,eAAe,IAC7Cb,aAAa,CAAC3M,IAAI,KAAK,gCAAgC,IACvD2M,aAAa,EAAE1M,WAAW,GAAG,iDAAiD,CAAC,EAC9E;MACDA,WAAW,CAACwN,eAAe,GAAG,IAAI;IACnC;IACA,IAAId,aAAa,EAAE1M,WAAW,EAAEE,GAAG,EAAE;MACpCF,WAAW,CAACyN,EAAE,GAAG,IAAI;IACtB;IACA,OAAOzN,WAAW;EACnB;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;EANAH,QAAA,CAAA4M,gBAAA,GAAAA,gBAAA;EAOO,SAASiB,yBAAyBA,CACxCf,QAAoC,EACpCgB,yBAA2D,EAEhC;IAAA,IAD3BC,iBAAiB,GAAAhN,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,KAAK;IAEzB,MAAMiN,aAA6C,GAAGF,yBAA2D;IACjH,IAAIhB,QAAQ,CAAC/M,KAAK,KAAK,UAAU,IAAI+M,QAAQ,CAAC/M,KAAK,KAAK,iBAAiB,EAAE;MAC1E,OAAOiO,aAAa;IACrB;IACA,MAAMnB,aAAa,GAAG5M,gBAAgB,CAAC6M,QAAQ,CAAC5M,IAAI,CAAC;IACrD,IAAI,CAAC2M,aAAa,EAAE;MACnB,OAAOmB,aAAa;IACrB;IACA,IAAI,CAACA,aAAa,CAACC,aAAa,EAAE;MACjCD,aAAa,CAACC,aAAa,GAAG,CAAC,CAAC;IACjC;IACAD,aAAa,CAAC7N,WAAW,GAAG,CAAC,CAAC;IAE9B6N,aAAa,CAAC9N,IAAI,GAAG2M,aAAa,CAAC3M,IAAI;IACvC,IAAI,CAAC6N,iBAAiB,EAAE;MACvBC,aAAa,CAAC7N,WAAW,GAAGyM,gBAAgB,CAACC,aAAa,EAAEC,QAAQ,CAAC;IACtE;IAEA,IACEkB,aAAa,EAAE9N,IAAI,EAAEgO,OAAO,CAAC,6BAA6B,CAAC,KAAK,CAAC,IAAIF,aAAa,EAAE9N,IAAI,KAAK,+BAA+B,IAC7H8N,aAAa,EAAE9N,IAAI,KAAK,gCAAgC,EACvD;MACD8N,aAAa,CAACC,aAAa,GAAGnI,MAAM,CAACqI,MAAM,CAACH,aAAa,CAACC,aAAa,EAAE;QACxEG,aAAa,EAAE;MAChB,CAAC,CAAC;IACH;IACA,IAAIJ,aAAa,CAAC9N,IAAI,KAAK,gCAAgC,IAAIL,UAAU,CAACiN,QAAQ,CAAC,EAAE;MACpF,IAAIkB,aAAa,CAAC7N,WAAW,EAAEwN,eAAe,IAAKK,aAAa,CAAC7N,WAAW,EAAE+M,QAAQ,KAAK,KAAK,IAAIJ,QAAQ,CAACI,QAAQ,KAAK,IAAK,EAAE;QAChIc,aAAa,CAACC,aAAa,CAACI,qBAAqB,GAAG,KAAK;MAC1D,CAAC,MAAM;QACNL,aAAa,CAACC,aAAa,CAACI,qBAAqB,GAAG,IAAI;MACzD;MACA,MAAMC,UAAU,GAAGC,aAAa,CAACzB,QAAQ,CAAC;MAC1C,IAAIwB,UAAU,EAAE;QACfN,aAAa,CAACC,aAAa,CAACK,UAAU,GAAGA,UAAU;QACnDN,aAAa,CAAC9N,IAAI,GAAG,6BAA6B;MACnD;IACD;IACA,MAAMsO,oCAAoC,GAAG,CAC5C,+BAA+B,EAC/B,+BAA+B,EAC/B,+BAA+B,EAC/B,gCAAgC,EAChC,gCAAgC,EAChC,iCAAiC,EACjC,8BAA8B,EAC9B,+BAA+B,CAC/B;IACD,IACCR,aAAa,CAAC7N,WAAW,EAAE+M,QAAQ,KAAK,KAAK,IAC7Cc,aAAa,CAAC9N,IAAI,IAClBsO,oCAAoC,CAACC,QAAQ,CAACT,aAAa,CAAC9N,IAAI,CAAC,EAChE;MACD8N,aAAa,CAACC,aAAa,GAAGnI,MAAM,CAACqI,MAAM,CAACH,aAAa,CAACC,aAAa,EAAE;QACxES,qBAAqB,EAAE;MACxB,CAAC,CAAC;IACH;IACA,IACCV,aAAa,CAAC7N,WAAW,EAAE+M,QAAQ,KAAK,KAAK,KAC5Cc,aAAa,CAAC9N,IAAI,KAAK,+BAA+B,IAAI8N,aAAa,CAAC9N,IAAI,KAAK,iCAAiC,CAAC,EACnH;MACD8N,aAAa,CAACC,aAAa,GAAGnI,MAAM,CAACqI,MAAM,CAACH,aAAa,CAACC,aAAa,EAAE;QACxEU,WAAW,EAAE;MACd,CAAC,CAAC;IACH;IAEA,OAAOX,aAAa;EACrB;EAAChO,QAAA,CAAA6N,yBAAA,GAAAA,yBAAA;EAEM,MAAMU,aAAa,GAAG,SAAAA,CAAUzB,QAAkB,EAAsB;IAC9E,IAAIA,QAAQ,CAACK,WAAW,EAAEM,MAAM,EAAEmB,YAAY,EAAE;MAC/C;IACD;IACA,IAAI9B,QAAQ,CAACK,WAAW,EAAEM,MAAM,EAAEoB,cAAc,EAAE;MACjD;IACD;IACA,IAAI/B,QAAQ,CAACK,WAAW,EAAEM,MAAM,EAAEqB,kBAAkB,EAAE;MACrD;IACD;IACA,IAAIhC,QAAQ,CAACK,WAAW,EAAEM,MAAM,EAAEsB,eAAe,EAAE;MAClD;IACD;IACA,IAAIjC,QAAQ,CAACK,WAAW,EAAEM,MAAM,EAAEuB,mBAAmB,EAAE;MACtD;IACD;IACA,IAAIlC,QAAQ,CAACK,WAAW,EAAEM,MAAM,EAAEwB,YAAY,EAAE;MAC/C;IACD;IACA,IAAInC,QAAQ,CAACK,WAAW,EAAEM,MAAM,EAAEyB,gBAAgB,EAAE;MACnD;IACD;IACA,IAAIpC,QAAQ,CAACK,WAAW,EAAEM,MAAM,EAAE0B,iBAAiB,EAAE;MACpD;IACD;EACD,CAAC;;EAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAXAnP,QAAA,CAAAuO,aAAA,GAAAA,aAAA;EAYO,SAASa,kBAAkBA,CACjCrM,UAAuC,EACvC7C,IAAY,EACZgM,iBAA8B,EAC9BmD,cAAyC,EACzCC,kBAAiD,EAC+B;IAChF,MAAMlD,oBAAoB,GAAIrJ,UAAU,CAA4Ce,GAAG,CAACM,aAAa,CAAC;IACtG,IAAIvD,yBAAyB,CAAC,GAAGuL,oBAAoB,CAAC,EAAE;MACvD,OAAO3L,sBAAsB;IAC9B;IACA;IACA,IAAI2L,oBAAoB,CAACpL,MAAM,KAAK,CAAC,IAAIyD,UAAU,CAAC2H,oBAAoB,CAAC,CAAC,CAAC,CAAC,IAAI,CAACF,iBAAiB,EAAE;MACnG,OAAOE,oBAAoB,CAAC,CAAC,CAAC;IAC/B,CAAC,MAAM,IAAIF,iBAAiB,EAAE;MAC7B;MACA,IAAI,CAACE,oBAAoB,CAACpK,IAAI,CAACgK,4BAA4B,CAAC,EAAE;QAC7DE,iBAAiB,CAACG,IAAI,CAAC7I,OAAO,CAAE0C,GAAG,IAAKkG,oBAAoB,CAACzI,IAAI,CAACjB,WAAW,CAACwD,GAAG,CAAC6B,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC;MAC9F;IACD;IACAsH,cAAc,GAAGE,0CAA0C,CAACxM,UAAU,CAAC,CAAC,CAAC,EAAEsM,cAAc,CAAC;IAE1F,IAAInP,IAAI,KAAK,8BAA8B,EAAE;MAC5C,MAAMsP,OAAO,GAAG9M,WAAW,CAAC,4BAA4B,CAAC;MACzD8M,OAAO,CAAClJ,UAAU,GAAG,KAAK;MAC1BkJ,OAAO,CAACC,IAAI,GAAG,SAAS;MACxBJ,cAAc,KAAK,CAAC,CAAC;MACrBA,cAAc,CAACK,gBAAgB,GAAGJ,kBAAkB,EAAEK,sBAAsB,IAAI,KAAK;MACrFvD,oBAAoB,CAACzI,IAAI,CAAC6L,OAAO,CAAC;IACnC,CAAC,MAAM,IAAItP,IAAI,KAAK,kCAAkC,EAAE;MACvD,MAAM0P,YAAY,GAAGlN,WAAW,CAAC,2BAA2B,CAAC;MAC7DkN,YAAY,CAACtJ,UAAU,GAAG,KAAK;MAC/BsJ,YAAY,CAACH,IAAI,GAAG,SAAS;MAC7BJ,cAAc,KAAK,CAAC,CAAC;MACrB,IAAIC,kBAAkB,EAAEK,sBAAsB,KAAK,IAAI,EAAE;QACxDN,cAAc,CAACQ,QAAQ,GAAG,EAAE,CAAC,CAAC;MAC/B;MAEAR,cAAc,CAACK,gBAAgB,GAAGJ,kBAAkB,EAAEK,sBAAsB,IAAI,KAAK,CAAC,CAAC;MACvFvD,oBAAoB,CAACzI,IAAI,CAACiM,YAAY,CAAC;IACxC;IAEA,OAAO;MACN7P,KAAK,EAAE,aAAa;MACpBG,IAAI,EAAEA,IAAI;MACV+N,aAAa,EAAEoB,cAAc,IAAI,CAAC,CAAC;MACnClP,WAAW,EAAEmP,kBAAkB,IAAI,CAAC,CAAC;MACrCvM,UAAU,EAAE,CAAC,CAAC;MACdC,iBAAiB,EAAEoJ;IACpB,CAAC;EACF;EAACpM,QAAA,CAAAoP,kBAAA,GAAAA,kBAAA;EAoBD;AACA;AACA;AACA;AACA;AACA;EACA,SAASG,0CAA0CA,CAClDO,KAAoB,EACpB7B,aAAmD,EACZ;IACvC;IACA;IACA,IACC,EAAEA,aAAa,IAAIA,aAAa,CAAC8B,UAAU,KAAK,KAAK,CAAC,KACrDD,KAAK,EAAE5P,IAAI,EAAEgO,OAAO,CAAC,6BAA6B,CAAC,KAAK,CAAC,IACzD4B,KAAK,EAAE5P,IAAI,KAAK,iCAAiC,IACjD4P,KAAK,EAAE5P,IAAI,KAAK,gCAAgC,CAAC,EACjD;MACD,IAAI4P,KAAK,EAAE5P,IAAI,KAAK,+BAA+B,IAAI4P,KAAK,EAAE5P,IAAI,KAAK,iCAAiC,EAAE;QACzG;QACA+N,aAAa,GACZA,aAAa,EAAE+B,WAAW,KAAK,KAAK,GACjC;UAAEA,WAAW,EAAE,KAAK;UAAEC,cAAc,EAAEhC,aAAa,CAACgC,cAAc;UAAEtB,WAAW,EAAEV,aAAa,EAAEU;QAAY,CAAC,GAC7G;UAAEsB,cAAc,EAAEhC,aAAa,EAAEgC,cAAc;UAAEtB,WAAW,EAAEV,aAAa,EAAEU;QAAY,CAAC;MAC/F,CAAC,MAAM;QACNV,aAAa,GACZA,aAAa,EAAE+B,WAAW,KAAK,KAAK,GACjC;UACA5B,aAAa,EAAE,KAAK;UACpB4B,WAAW,EAAE,KAAK;UAClBC,cAAc,EAAEhC,aAAa,CAACgC,cAAc;UAC5CtB,WAAW,EAAEV,aAAa,EAAEU;QAC5B,CAAC,GACD;UAAEP,aAAa,EAAE,KAAK;UAAE6B,cAAc,EAAEhC,aAAa,EAAEgC,cAAc;UAAEtB,WAAW,EAAEV,aAAa,EAAEU;QAAY,CAAC;MACrH;MACA,IAAImB,KAAK,EAAE3P,WAAW,EAAE+M,QAAQ,KAAK,KAAK,EAAE;QAC3Ce,aAAa,CAACU,WAAW,GAAG,IAAI;MACjC,CAAC,MAAM;QACNV,aAAa,CAACU,WAAW,KAAK,CAAC;MAChC;IACD;IACA,OAAOV,aAAa;EACrB;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACO,SAASnL,EAAEA,CACjBoN,IAAO,EACPnN,UAAkD,EAClDoN,EAAkC,EAEV;IAAA,IADxBC,cAAc,GAAArP,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,KAAK;IAEtB,MAAMuL,YAAY,GAAG,OAAO4D,IAAI,KAAK,QAAQ,GAAGA,IAAI,GAAGA,IAAI,CAAC3D,cAAc;IAC1E,OAAO;MACNxM,KAAK,EAAE,UAAU;MACjBmD,GAAG,EAAEiN,EAAE,KAAK7O,SAAS,GAAG8C,aAAa,CAAC+L,EAAE,CAAC,GAAG7O,SAAS;MACrDwB,EAAE,EAAEwJ,YAAY;MAChB8D,cAAc,EAAEA,cAAc;MAC9BrN,UAAU,EAAGA,UAAU,CAA4Ce,GAAG,CAACM,aAAa;IACrF,CAAC;EACF;;EAEA;AACA;AACA;AACA;AACA;EAJApE,QAAA,CAAA8C,EAAA,GAAAA,EAAA;EAKO,SAASuN,OAAOA,CAACtO,UAA4C,EAAqC;IACxG,MAAMuO,SAA2C,GAAG,EAAE;IACtD3E,oBAAoB,CAAC5J,UAAU,EAAE,aAAa,EAAGV,IAAI,IAAK;MACzD,MAAMkP,eAAe,GAAG;QAAE,GAAGlP,IAAI;QAAEmP,oBAAoB,EAAE;MAAK,CAAkC;MAChGF,SAAS,CAAC3M,IAAI,CAACkB,EAAE,CAAC2D,KAAK,CAAC+H,eAAe,EAAE,EAAE,CAAC,EAAE/H,KAAK,CAACnH,IAAI,EAAEC,SAAS,CAAC,EAAEkH,KAAK,CAACnH,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;MACzF,OAAOA,IAAI;IACZ,CAAC,CAAC;IACF,OAAO4C,GAAG,CAAC,GAAGqM,SAAS,CAAC;EACzB;EAACtQ,QAAA,CAAAqQ,OAAA,GAAAA,OAAA;EAEM,SAAS7K,MAAMA,CAAA,EAAsF;IAAA,SAAAiL,KAAA,GAAA1P,SAAA,CAAAC,MAAA,EAAlF0P,aAAa,OAAAxP,KAAA,CAAAuP,KAAA,GAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;MAAbD,aAAa,CAAAC,KAAA,IAAA5P,SAAA,CAAA4P,KAAA;IAAA;IACtC,MAAM1P,WAAW,GAAGyP,aAAa,CAAC5M,GAAG,CAACM,aAAa,CAAC;IACpD,IAAIvD,yBAAyB,CAAC,GAAGI,WAAW,CAAC,EAAE;MAC9C,OAAOR,sBAAsB;IAC9B;IACA,IAAIQ,WAAW,CAACa,KAAK,CAAC2C,UAAU,CAAC,EAAE;MAClC,OAAOC,QAAQ,CACdzD,WAAW,CAACoC,MAAM,CAAC,CAACuN,YAAoB,EAAElP,KAAK,KAAK;QACnD,IAAIA,KAAK,CAACA,KAAK,KAAKJ,SAAS,IAAII,KAAK,CAACA,KAAK,KAAK,IAAI,EAAE;UACtD,OAAOkP,YAAY,GAAGlP,KAAK,CAACA,KAAK,CAACuF,QAAQ,CAAC,CAAC;QAC7C;QACA,OAAO2J,YAAY;MACpB,CAAC,EAAE,EAAE,CACN,CAAC;IACF,CAAC,MAAM,IAAI3P,WAAW,CAACe,IAAI,CAACwF,uBAAuB,CAAC,EAAE;MACrD,IAAI+D,OAAO,GAAG,CAAC;MACf,MAAMsF,kBAAkB,GAAGpF,YAAY,CAACxK,WAAW,EAAE,uCAAuC,EAAEK,SAAS,EAAE,IAAI,CAAC;MAC9G,MAAMoK,QAAQ,GAAG,EAAE;MACnBC,oBAAoB,CAACkF,kBAAkB,EAAE,aAAa,EAAGjF,YAA4C,IAAK;QACzGF,QAAQ,CAAC/H,IAAI,CAACiI,YAAY,CAAC;QAC3B,OAAOlJ,WAAW,CAAC,IAAI6I,OAAO,EAAE,EAAE,EAAE,GAAG,CAAC;MACzC,CAAC,CAAC;MACFG,QAAQ,CAACG,OAAO,CAACnH,QAAQ,CAACoH,IAAI,CAACC,SAAS,CAAC8E,kBAAkB,CAAC,CAAC,CAAC;MAC9D,OAAOpF,YAAY,CAACC,QAAQ,EAAE,yEAAyE,EAAEpK,SAAS,EAAE,IAAI,CAAC;IAC1H;IACA,OAAO;MACNvB,KAAK,EAAE,QAAQ;MACfkB,WAAW,EAAEA;IACd,CAAC;EACF;EAACjB,QAAA,CAAAwF,MAAA,GAAAA,MAAA;EAcM,SAASmG,oBAAoBA,CACnCmF,YAAyC,EACzCC,cAAkB,EAClBC,iBAA0E,EAE5C;IAAA,IAD9BC,oBAAoB,GAAAlQ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,KAAK;IAE5B,IAAIgB,UAAuC,GAAG+O,YAAY;IAC1D,QAAQ/O,UAAU,CAAChC,KAAK;MACvB,KAAK,UAAU;MACf,KAAK,WAAW;QACfgC,UAAU,CAACgB,UAAU,GAAGhB,UAAU,CAACgB,UAAU,CAACe,GAAG,CAAEsG,SAAS,IAC3DuB,oBAAoB,CAACvB,SAAS,EAAiC2G,cAAc,EAAEC,iBAAiB,EAAEC,oBAAoB,CACvH,CAAC;QACD;MACD,KAAK,QAAQ;QACZlP,UAAU,CAACd,WAAW,GAAGc,UAAU,CAACd,WAAW,CAAC6C,GAAG,CAAEoN,aAAa,IACjEvF,oBAAoB,CACnBuF,aAAa,EACbH,cAAc,EACdC,iBAAiB,EACjBC,oBACD,CACD,CAAC;QACDlP,UAAU,GAAGyD,MAAM,CAAC,GAAGzD,UAAU,CAACd,WAAW,CAAgC;QAC7E;MACD,KAAK,aAAa;QACjBc,UAAU,CAACiB,iBAAiB,GAAGjB,UAAU,CAACiB,iBAAiB,CAACc,GAAG,CAAEqN,gBAAgB,IAChFxF,oBAAoB,CACnBwF,gBAAgB,EAChBJ,cAAc,EACdC,iBAAiB,EACjBC,oBACD,CACD,CAAC;QACD;MACD,KAAK,QAAQ;QACZ,MAAM9O,MAAM,GAAGwJ,oBAAoB,CAClC5J,UAAU,CAACI,MAAM,EACjB4O,cAAc,EACdC,iBAAiB,EACjBC,oBACD,CAAC;QACD,MAAM7O,OAAO,GAAGuJ,oBAAoB,CACnC5J,UAAU,CAACK,OAAO,EAClB2O,cAAc,EACdC,iBAAiB,EACjBC,oBACD,CAAC;QACD,IAAI/O,SAAS,GAAGH,UAAU,CAACG,SAAS;QACpC,IAAI+O,oBAAoB,EAAE;UACzB/O,SAAS,GAAGyJ,oBAAoB,CAC/B5J,UAAU,CAACG,SAAS,EACpB6O,cAAc,EACdC,iBAAiB,EACjBC,oBACD,CAAC;QACF;QACAlP,UAAU,GAAGgI,MAAM,CAAC7H,SAAS,EAAEC,MAAM,EAAEC,OAAO,CAAgC;QAC9E;MACD,KAAK,KAAK;QACT,IAAI6O,oBAAoB,EAAE;UACzB,MAAMtP,OAAO,GAAGgK,oBAAoB,CACnC5J,UAAU,CAACJ,OAAO,EAClBoP,cAAc,EACdC,iBAAiB,EACjBC,oBACD,CAAC;UACDlP,UAAU,GAAGgC,GAAG,CAACpC,OAAO,CAAgC;QACzD;QACA;MACD,KAAK,QAAQ;QACZ;MACD,KAAK,KAAK;QACT,IAAIsP,oBAAoB,EAAE;UACzB,MAAMpP,QAAQ,GAAGE,UAAU,CAACF,QAAQ,CAACiC,GAAG,CAAEnC,OAAO,IAChDgK,oBAAoB,CACnBhK,OAAO,EACPoP,cAAc,EACdC,iBAAiB,EACjBC,oBACD,CACD,CAAC;UACDlP,UAAU,GACTA,UAAU,CAACH,QAAQ,KAAK,IAAI,GACxBiD,EAAE,CAAC,GAAGhD,QAAQ,CAAC,GACfoC,GAAG,CAAC,GAAGpC,QAAQ,CAAiC;QACtD;QACA;MACD,KAAK,YAAY;QAChB,IAAIoP,oBAAoB,EAAE;UACzB,MAAM5O,QAAQ,GAAGsJ,oBAAoB,CACpC5J,UAAU,CAACM,QAAQ,EACnB0O,cAAc,EACdC,iBAAiB,EACjBC,oBACD,CAAC;UACD,MAAM3O,QAAQ,GAAGqJ,oBAAoB,CACpC5J,UAAU,CAACO,QAAQ,EACnByO,cAAc,EACdC,iBAAiB,EACjBC,oBACD,CAAC;UACDlP,UAAU,GAAG4I,UAAU,CAAC5I,UAAU,CAACH,QAAQ,EAAES,QAAQ,EAAEC,QAAQ,CAAgC;QAChG;QACA;MACD,KAAK,UAAU;QACd,MAAMoD,aAAgE,GAAG3D,UAAU,CAACL,KAGnF;QACD,IAAI,OAAOgE,aAAa,KAAK,QAAQ,IAAIA,aAAa,EAAE;UACvDI,MAAM,CAACuG,IAAI,CAAC3G,aAAa,CAAC,CAAClC,OAAO,CAAE0C,GAAG,IAAK;YAC3CR,aAAa,CAACQ,GAAG,CAAC,GAAGyF,oBAAoB,CACxCjG,aAAa,CAACQ,GAAG,CAAC,EAClB6K,cAAc,EACdC,iBAAiB,EACjBC,oBACD,CAAC;UACF,CAAC,CAAC;QACH;QACA;MACD,KAAK,KAAK;MACV,KAAK,QAAQ;MACb,KAAK,aAAa;MAClB,KAAK,iBAAiB;MACtB,KAAK,2BAA2B;MAChC,KAAK,cAAc;QAClB;QACA;IACF;IACA,IAAIF,cAAc,KAAKhP,UAAU,CAAChC,KAAK,EAAE;MACxCgC,UAAU,GAAGiP,iBAAiB,CAACF,YAAiD,CAAC;IAClF;IACA,OAAO/O,UAAU;EAClB;EAAC/B,QAAA,CAAA2L,oBAAA,GAAAA,oBAAA;EAID,MAAMyF,eAAe,GAAG,SAAAA,CAAmC/P,IAA8B,EAAW;IACnG,OACC,CAACoD,UAAU,CAACpD,IAAI,CAAC,IACjB,CAACiG,uBAAuB,CAACjG,IAAI,CAAC,IAC9B+F,0BAA0B,CAAC/F,IAAI,CAAC,IAChCA,IAAI,CAACtB,KAAK,KAAK,QAAQ,IACvBsB,IAAI,CAACtB,KAAK,KAAK,UAAU;EAE3B,CAAC;;EAED;AACA;AACA;AACA;AACA;AACA;EACA,SAASsR,qBAAqBA,CAAChQ,IAAgC,EAA8B;IAAA,IAA5BiQ,UAAU,GAAAvQ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,KAAK;IAClF,IAAIuQ,UAAU,IAAIxL,MAAM,CAACuG,IAAI,CAAChL,IAAI,CAACK,KAAK,CAAC,CAACV,MAAM,KAAK,CAAC,EAAE;MACvD,OAAO,EAAE;IACV;IACA,MAAMuQ,OAAO,GAAGlQ,IAAI,CAACK,KAA8B;IACnD,MAAM8P,UAAoB,GAAG,EAAE;IAC/B1L,MAAM,CAACuG,IAAI,CAACkF,OAAO,CAAC,CAAC/N,OAAO,CAAE0C,GAAG,IAAK;MACrC,MAAMxE,KAAK,GAAG6P,OAAO,CAACrL,GAAG,CAAC;MAC1B,MAAMuL,WAAW,GAAGC,iBAAiB,CAAChQ,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE4P,UAAU,CAAC;MACrE,IAAIG,WAAW,IAAIA,WAAW,CAACzQ,MAAM,GAAG,CAAC,EAAE;QAC1CwQ,UAAU,CAAC7N,IAAI,CAAC,GAAGuC,GAAG,KAAKuL,WAAW,EAAE,CAAC;MAC1C;IACD,CAAC,CAAC;IACF,OAAO,IAAID,UAAU,CAAC/L,IAAI,CAAC,IAAI,CAAC,GAAG;EACpC;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAaO,SAASkM,eAAeA,CAC9BtQ,IAA2B,EAC3BuQ,iBAA0B,EAGyB;IAAA,IAFnDN,UAAU,GAAAvQ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,KAAK;IAAA,IAClB8Q,cAAc,GAAA9Q,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,KAAK;IAEtB,IAAIM,IAAI,CAACK,KAAK,KAAK,IAAI,EAAE;MACxB,OAAOmQ,cAAc,GAAG,IAAI,GAAG,MAAM;IACtC;IACA,IAAIxQ,IAAI,CAACK,KAAK,KAAKJ,SAAS,EAAE;MAC7B,OAAOuQ,cAAc,GAAGvQ,SAAS,GAAG,WAAW;IAChD;IACA,IAAI,OAAOD,IAAI,CAACK,KAAK,KAAK,QAAQ,EAAE;MACnC,IAAIR,KAAK,CAACyE,OAAO,CAACtE,IAAI,CAACK,KAAK,CAAC,EAAE;QAC9B,MAAMqE,OAAO,GAAG1E,IAAI,CAACK,KAAK,CAACoC,GAAG,CAAE/B,UAAU,IAAK2P,iBAAiB,CAAC3P,UAAU,EAAE,IAAI,CAAC,CAAC;QACnF,OAAO,IAAIgE,OAAO,CAACN,IAAI,CAAC,IAAI,CAAC,GAAG;MACjC,CAAC,MAAM;QACN,OAAO4L,qBAAqB,CAAChQ,IAAI,EAAgCiQ,UAAU,CAAC;MAC7E;IACD;IAEA,IAAIM,iBAAiB,EAAE;MACtB,QAAQ,OAAOvQ,IAAI,CAACK,KAAK;QACxB,KAAK,QAAQ;QACb,KAAK,QAAQ;QACb,KAAK,SAAS;UACb,OAAOL,IAAI,CAACK,KAAK,CAACuF,QAAQ,CAAC,CAAC;QAC7B,KAAK,QAAQ;UACZ,OAAO,IAAIvG,kBAAkB,CAACW,IAAI,CAACK,KAAK,CAACuF,QAAQ,CAAC,CAAC,CAAC,GAAG;QACxD;UACC,OAAO,EAAE;MACX;IACD,CAAC,MAAM;MACN,OAAO4K,cAAc,GAAGxQ,IAAI,CAACK,KAAK,GAAGL,IAAI,CAACK,KAAK,CAACuF,QAAQ,CAAC,CAAC;IAC3D;EACD;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;EANAjH,QAAA,CAAA2R,eAAA,GAAAA,eAAA;EAOA,SAASG,4BAA4BA,CACpCC,oBAA8C,EAC9CH,iBAA0B,EAC1BI,iBAAyB,EACU;IACnC,IACCD,oBAAoB,CAAC7R,IAAI,IACzB6R,oBAAoB,CAAChP,UAAU,IAC/BgP,oBAAoB,CAACzL,UAAU,IAC/ByL,oBAAoB,CAAC9D,aAAa,IAClC8D,oBAAoB,CAAC5R,WAAW,EAC/B;MACD;MACA,MAAM8R,wBAAwB,GAAG;QAChCrP,IAAI,EAAEsP,kBAAkB,CAACH,oBAAoB,CAAC;QAC9C7R,IAAI,EAAE6R,oBAAoB,CAAC7R,IAAI;QAC/BoG,UAAU,EAAEyL,oBAAoB,CAACzL,UAAU;QAC3CvD,UAAU,EAAEgP,oBAAoB,CAAChP,UAAU;QAC3CkL,aAAa,EAAE8D,oBAAoB,CAAC9D,aAAa;QACjD9N,WAAW,EAAE4R,oBAAoB,CAAC5R;MACnC,CAAC;MACD,MAAMgS,UAAU,GAAGT,iBAAiB,CAACO,wBAAwB,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC;MAClF,IAAIL,iBAAiB,EAAE;QACtB,MAAMQ,SAAS,GAAGL,oBAAoB,CAACvB,oBAAoB,GAAG,GAAG,GAAGwB,iBAAiB;QACrF,OAAO,GAAGI,SAAS,GAAGD,UAAU,EAAE;MACnC;MACA,OAAOA,UAAU;IAClB,CAAC,MAAM,IAAIP,iBAAiB,EAAE;MAC7B,OAAO,GAAGI,iBAAiB,IAAIE,kBAAkB,CAACH,oBAAoB,CAAC,GAAG;IAC3E,CAAC,MAAM;MACN,OAAO,IAAIG,kBAAkB,CAACH,oBAAoB,CAAC,GAAG;IACvD;EACD;EAEA,SAASM,4BAA4BA,CAA0BtQ,UAAoC,EAAU;IAC5G,IAAIA,UAAU,CAACiB,iBAAiB,CAAChC,MAAM,KAAK,CAAC,EAAE;MAC9C,OAAO,IAAIsR,oBAAoB,CAACvQ,UAAU,CAACiB,iBAAiB,CAAC,CAAC,CAAC,EAA6C,IAAI,CAAC,YAChHjB,UAAU,CAAC7B,IAAI,IACZ;IACL;IAEA,IAAIqS,SAAS,GAAG,aAAaxQ,UAAU,CAAC7B,IAAI,GAAG;IAC/C,IAAIsS,WAAW,CAACzQ,UAAU,CAACkM,aAAa,CAAC,EAAE;MAC1CsE,SAAS,IAAI,oBAAoBb,iBAAiB,CAAC3P,UAAU,CAACkM,aAAa,CAAC,EAAE;IAC/E;IACA,IAAIuE,WAAW,CAACzQ,UAAU,CAAC5B,WAAW,CAAC,EAAE;MACxCoS,SAAS,IAAI,kBAAkBb,iBAAiB,CAAC3P,UAAU,CAAC5B,WAAW,CAAC,EAAE;IAC3E;IACA,IAAIqS,WAAW,CAACzQ,UAAU,CAACgB,UAAU,CAAC,EAAE;MACvCwP,SAAS,IAAI,iBAAiBb,iBAAiB,CAAC3P,UAAU,CAACgB,UAAU,CAAC,EAAE;IACzE;IACAwP,SAAS,IAAI,GAAG;IAEhB,OAAO,0BAA0BxQ,UAAU,CAACiB,iBAAiB,CAC3Dc,GAAG,CAAEgM,KAAK,IAAKwC,oBAAoB,CAACxC,KAAgD,CAAC,CAAC,CACtFrK,IAAI,CAAC,GAAG,CAAC,GAAG8M,SAAS,EAAE;EAC1B;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;EACO,SAASE,qBAAqBA,CACpC1Q,UAAkB,EAClB6P,iBAA0B,EAES;IAAA,IADnCc,mBAAmB,GAAA3R,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,KAAK;IAE3B,IAAI6Q,iBAAiB,EAAE;MACtB,IAAIc,mBAAmB,EAAE;QACxB,OAAO,IAAI3Q,UAAU,GAAG;MACzB,CAAC,MAAM;QACN,OAAOA,UAAU;MAClB;IACD,CAAC,MAAM;MACN,OAAO,MAAMA,UAAU,GAAG;IAC3B;EACD;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EARA/B,QAAA,CAAAyS,qBAAA,GAAAA,qBAAA;EASO,SAASf,iBAAiBA,CAChC3P,UAAoC,EAID;IAAA,IAHnC6P,iBAAiB,GAAA7Q,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,KAAK;IAAA,IACzB4R,cAAc,GAAA5R,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,KAAK;IAAA,IACtBuQ,UAAU,GAAAvQ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,KAAK;IAElB,MAAMM,IAAI,GAAG+C,aAAa,CAACrC,UAAU,CAAC;IACtC,MAAMiQ,iBAAiB,GAAGW,cAAc,GAAG,GAAG,GAAG,GAAG;IAEpD,QAAQtR,IAAI,CAACtB,KAAK;MACjB,KAAK,cAAc;QAClB,OAAOuB,SAAS;MAEjB,KAAK,UAAU;QACd,OAAOqQ,eAAe,CAACtQ,IAAI,EAAEuQ,iBAAiB,EAAEN,UAAU,CAAC;MAE5D,KAAK,KAAK;QACT,OAAOjQ,IAAI,CAAC8B,GAAG,IAAI,MAAM;MAE1B,KAAK,UAAU;QACd,IAAIyP,gCAAgC,GAAG,KAAK;QAC5C,IAAIvR,IAAI,CAAC+O,cAAc,EAAE;UACxBzE,oBAAoB,CACnBtK,IAAI,EACJ,UAAU,EACTwR,KAAK,IAAK;YACV,IAAIA,KAAK,KAAKxR,IAAI,IAAIwR,KAAK,CAAC3P,GAAG,KAAK5B,SAAS,EAAE;cAC9CsR,gCAAgC,GAAG,IAAI;YACxC;YACA,OAAOC,KAAK;UACb,CAAC,EACD,IACD,CAAC;UACDlH,oBAAoB,CACnBtK,IAAI,EACJ,UAAU,EACTwR,KAA4B,IAAK;YACjC,IAAKA,KAAK,KAAiBxR,IAAI,IAAI,OAAOwR,KAAK,CAACnR,KAAK,KAAK,QAAQ,EAAE;cACnEiK,oBAAoB,CAACkH,KAAK,EAAE,aAAa,EAAGC,QAAQ,IAAK;gBACxDF,gCAAgC,GAAG,IAAI;gBACvC,OAAOE,QAAQ;cAChB,CAAC,CAAC;YACH;YAEA,OAAOD,KAAK;UACb,CAAC,EACD,IACD,CAAC;QACF;QACA,MAAME,cAAc,GAAG,GAAG1R,IAAI,CAAC0B,UAAU,CAACe,GAAG,CAAEkP,GAAG,IAAKtB,iBAAiB,CAACsB,GAAG,EAAE,IAAI,CAAC,CAAC,CAACvN,IAAI,CAAC,IAAI,CAAC,EAAE;QACjG,IAAIwN,MAAM,GACT5R,IAAI,CAAC6B,GAAG,KAAK5B,SAAS,GACnB,GAAGD,IAAI,CAACyB,EAAE,IAAIiQ,cAAc,GAAG,GAC/B,GAAGrB,iBAAiB,CAACrQ,IAAI,CAAC6B,GAAG,EAAE,IAAI,CAAC,IAAI7B,IAAI,CAACyB,EAAE,IAAIiQ,cAAc,GAAG;QACxE,IAAI,CAACnB,iBAAiB,IAAIgB,gCAAgC,EAAE;UAC3DK,MAAM,GAAG,MAAMA,MAAM,GAAG;QACzB;QACA,OAAOA,MAAM;MAEd,KAAK,2BAA2B;QAC/B,OAAOrB,iBAAiB,GAAG,IAAIvQ,IAAI,CAACK,KAAK,CAACwR,SAAS,CAAC,CAAC,EAAE7R,IAAI,CAACK,KAAK,CAACV,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG,GAAGK,IAAI,CAACK,KAAK,EAAE;MAEnG,KAAK,iBAAiB;QACrB,OAAOkQ,iBAAiB,GAAG,GAAGI,iBAAiB,GAAG3Q,IAAI,CAACK,KAAK,EAAE,GAAG,GAAGL,IAAI,CAACK,KAAK,EAAE;MAEjF,KAAK,aAAa;QACjB,OAAOoQ,4BAA4B,CAACzQ,IAAI,EAAEuQ,iBAAiB,EAAEI,iBAAiB,CAAC;MAEhF,KAAK,YAAY;QAChB,MAAMmB,oBAAoB,GAAGC,2BAA2B,CAAC/R,IAAI,CAAC;QAC9D,OAAOoR,qBAAqB,CAACU,oBAAoB,EAAEvB,iBAAiB,CAAC;MAEtE,KAAK,QAAQ;QACZ,MAAMyB,gBAAgB,GAAG,GAAG3B,iBAAiB,CAACrQ,IAAI,CAACa,SAAS,EAAE,IAAI,CAAC,MAAMwP,iBAAiB,CACzFrQ,IAAI,CAACc,MAAM,EACX,IAAI,EACJwQ,cACD,CAAC,MAAMjB,iBAAiB,CAACrQ,IAAI,CAACe,OAAO,EAAE,IAAI,EAAEuQ,cAAc,CAAC,EAAE;QAC9D,OAAOF,qBAAqB,CAACY,gBAAgB,EAAEzB,iBAAiB,EAAE,IAAI,CAAC;MAExE,KAAK,KAAK;QACT,MAAM0B,aAAa,GAAGjS,IAAI,CAACQ,QAAQ,CAACiC,GAAG,CAAEnC,OAAO,IAAK+P,iBAAiB,CAAC/P,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC8D,IAAI,CAAC,IAAIpE,IAAI,CAACO,QAAQ,GAAG,CAAC;QACjH,OAAO6Q,qBAAqB,CAACa,aAAa,EAAE1B,iBAAiB,EAAE,IAAI,CAAC;MAErE,KAAK,QAAQ;QACZ,MAAM2B,gBAAgB,GAAGlS,IAAI,CAACJ,WAAW,CACvC6C,GAAG,CAAE0P,gBAAgB,IAAK9B,iBAAiB,CAAC8B,gBAAgB,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC,CAC1E/N,IAAI,CAAC,KAAK,CAAC;QACb,OAAOgN,qBAAqB,CAACc,gBAAgB,EAAE3B,iBAAiB,CAAC;MAElE,KAAK,QAAQ;QACZ,MAAM6B,gBAAgB,GAAG,GAAG/B,iBAAiB,CAACrQ,IAAI,CAACqB,WAAW,EAAE,IAAI,CAAC,SAAS;QAC9E,OAAO+P,qBAAqB,CAACgB,gBAAgB,EAAE7B,iBAAiB,CAAC;MAElE,KAAK,KAAK;QACT,MAAM8B,aAAa,GAAG,IAAIhC,iBAAiB,CAACrQ,IAAI,CAACM,OAAO,EAAE,IAAI,CAAC,EAAE;QACjE,OAAO8Q,qBAAqB,CAACiB,aAAa,EAAE9B,iBAAiB,CAAC;MAE/D,KAAK,QAAQ;QACZ,MAAM+B,gBAAgB,GAAG,KAAKjC,iBAAiB,CAACrQ,IAAI,CAACM,OAAO,EAAE,IAAI,CAAC,EAAE;QACrE,OAAO8Q,qBAAqB,CAACkB,gBAAgB,EAAE/B,iBAAiB,CAAC;MAElE,KAAK,WAAW;QACf,MAAMgC,mBAAmB,GAAGC,0BAA0B,CAACxS,IAAI,CAAC;QAC5D,OAAOuQ,iBAAiB,GAAG,IAAIgC,mBAAmB,EAAE,GAAGA,mBAAmB;MAE3E,KAAK,aAAa;QACjB,MAAME,qBAAqB,GAAGzB,4BAA4B,CAAChR,IAAI,CAAC;QAChE,OAAOuQ,iBAAiB,GAAG,IAAIkC,qBAAqB,EAAE,GAAGA,qBAAqB;MAE/E;QACC,OAAO,EAAE;IACX;EACD;;EAEA;AACA;AACA;AACA;AACA;EAJA9T,QAAA,CAAA0R,iBAAA,GAAAA,iBAAA;EAKA,SAAS0B,2BAA2BA,CAACrR,UAAgC,EAAU;IAC9E,SAASgS,cAAcA,CAACpS,OAA0C,EAAoC;MACrG,MAAMqS,eAAe,GAAGtC,iBAAiB,CAAC/P,OAAO,EAAE,IAAI,CAAC,IAAI,WAAW;MACvE,OAAO8Q,qBAAqB,CAACuB,eAAe,EAAE,IAAI,EAAE5C,eAAe,CAACzP,OAAO,CAAC,CAAC;IAC9E;IAEA,OAAO,GAAGoS,cAAc,CAAChS,UAAU,CAACM,QAAQ,CAAC,IAAIN,UAAU,CAACH,QAAQ,IAAImS,cAAc,CAAChS,UAAU,CAACO,QAAQ,CAAC,EAAE;EAC9G;;EAEA;AACA;AACA;AACA;AACA;EACA,SAASuR,0BAA0BA,CAA0B9R,UAAkC,EAAU;IACxG,IAAIA,UAAU,CAACgB,UAAU,CAAC/B,MAAM,KAAK,CAAC,EAAE;MACvC,OAAO,IAAIsR,oBAAoB,CAACvQ,UAAU,CAACgB,UAAU,CAAC,CAAC,CAAC,EAA6C,IAAI,CAAC,iBACzGhB,UAAU,CAACe,EAAE,IACV;IACL,CAAC,MAAM;MACN,MAAMmR,KAAK,GAAGlS,UAAU,CAACgB,UAAU,CAACe,GAAG,CAAEgM,KAAK,IAAK;QAClD,IAAIA,KAAK,CAAC/P,KAAK,KAAK,aAAa,EAAE;UAClC,OAAOsS,4BAA4B,CAACvC,KAAK,CAAC;QAC3C,CAAC,MAAM;UACN,OAAOwC,oBAAoB,CAACxC,KAAgD,CAAC;QAC9E;MACD,CAAC,CAAC;MACF,OAAO,YAAYmE,KAAK,CAACxO,IAAI,CAAC,IAAI,CAAC,kBAAkB1D,UAAU,CAACe,EAAE,IAAI;IACvE;EACD;;EAEA;AACA;AACA;AACA;AACA;AACA;EACA,SAASwP,oBAAoBA,CAACvQ,UAAmD,EAA8B;IAAA,IAA5BmS,UAAU,GAAAnT,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAO,SAAA,GAAAP,SAAA,MAAG,KAAK;IACpG,IAAIoT,QAAQ,GAAG,EAAE;IACjB,IAAIpS,UAAU,CAAChC,KAAK,KAAK,UAAU,EAAE;MACpC,IAAIgC,UAAU,CAACL,KAAK,KAAKJ,SAAS,EAAE;QACnC;QACA6S,QAAQ,GAAG,oBAAoB;MAChC,CAAC,MAAM;QACNA,QAAQ,GAAG,UAAUxC,eAAe,CAAC5P,UAAU,EAAE,IAAI,CAAC,EAAE;MACzD;IACD,CAAC,MAAM,IAAIA,UAAU,CAAChC,KAAK,KAAK,aAAa,EAAE;MAC9CoU,QAAQ,GAAG,UAAUjC,kBAAkB,CAACnQ,UAAU,CAAC,GAAG;MAEtDoS,QAAQ,IAAIpS,UAAU,CAAC7B,IAAI,GAAG,YAAY6B,UAAU,CAAC7B,IAAI,GAAG,GAAG,qBAAqB;MACpF,IAAI6B,UAAU,CAAC0N,IAAI,EAAE;QACpB0E,QAAQ,IAAI,YAAYzC,iBAAiB,CAAC3P,UAAU,CAAC0N,IAAI,CAAC,GAAG;MAC9D;MACA,IAAI+C,WAAW,CAACzQ,UAAU,CAAC5B,WAAW,CAAC,EAAE;QACxCgU,QAAQ,IAAI,kBAAkBzC,iBAAiB,CAAC3P,UAAU,CAAC5B,WAAW,CAAC,EAAE;MAC1E;MACA,IAAIqS,WAAW,CAACzQ,UAAU,CAACkM,aAAa,CAAC,EAAE;QAC1CkG,QAAQ,IAAI,oBAAoBzC,iBAAiB,CAAC3P,UAAU,CAACkM,aAAa,CAAC,EAAE;MAC9E;MACA,IAAIuE,WAAW,CAACzQ,UAAU,CAACgB,UAAU,CAAC,EAAE;QACvCoR,QAAQ,IAAI,iBAAiBzC,iBAAiB,CAAC3P,UAAU,CAACgB,UAAU,CAAC,EAAE;MACxE;IACD,CAAC,MAAM;MACN,OAAO,EAAE;IACV;IACA,OAAOmR,UAAU,GAAGC,QAAQ,GAAG,IAAIA,QAAQ,GAAG;EAC/C;EAEA,SAAS3B,WAAWA,CAACtP,GAAuB,EAAW;IACtD,OAAO,CAAC,CAACA,GAAG,IAAI4C,MAAM,CAACuG,IAAI,CAACnJ,GAAG,CAAC,CAAClC,MAAM,GAAG,CAAC;EAC5C;;EAEA;AACA;AACA;AACA;AACA;EACA,SAASkR,kBAAkBA,CAA0BnQ,UAAoC,EAAU;IAClG,OAAO,GAAGA,UAAU,CAACY,SAAS,GAAGZ,UAAU,CAACY,SAAS,GAAG,GAAG,GAAG,EAAE,GAAGZ,UAAU,CAACa,IAAI,EAAE;EACrF;EAAC,OAAA5C,QAAA;AAAA","ignoreList":[],"file":"BindingToolkit-dbg.js"}