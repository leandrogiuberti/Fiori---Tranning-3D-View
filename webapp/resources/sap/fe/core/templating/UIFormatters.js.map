{"version":3,"file":"UIFormatters.js","names":["FieldEditMode","Disabled","Display","Editable","EditableDisplay","EditableReadOnly","ReadOnly","_exports","getDisplayMode","oDataModelObjectPath","DisplayModeFormatter","targetObject","getEditableExpressionAsObject","oPropertyPath","oDataFieldConverted","isEditable","arguments","length","undefined","UI","IsEditable","considerUpdateRestrictions","getEditableExpression","bAsObject","relativePath","getRelativePaths","compileExpression","dataFieldEditableExpression","constant","isProperty","ifElse","isNonEditableExpression","oProperty","isPathAnnotationExpression","$target","isPathUpdatableExpression","isPathUpdatable","propertyPath","pathVisitor","path","navigationPaths","singletonPathVisitor","convertedTypes","editableExpression","or","and","not","isComputed","isKey","isImmutable","IsTransientBinding","unresolvableExpression","getCollaborationExpression","dataModelObjectPath","formatter","objectPath","getTargetObjectPath","activityExpression","pathInModel","keys","contextLocation","targetEntityType","keysExpressions","forEach","key","keyExpression","name","push","formatResult","getEnabledExpressionAsObject","getEnabledExpression","dataFieldEnabledExpression","isDisabledExpression","enabledExpression","getEditMode","measureReadOnly","asObject","dataFieldConverted","$Type","property","associatedCurrencyProperty","getAssociatedCurrencyProperty","unitProperty","getAssociatedUnitProperty","resultExpression","isUnitReadOnly","isReadOnlyExpression","isConstant","annotations","Measures","ISOCurrency","Unit","readOnlyExpression","editModeExpression","hasValidAnalyticalCurrencyOrUnit","oPropertyDataModelObjectPath","oPropertyDefinition","getExpressionForMeasureUnit","currency","measure","isTruthy","getExpressionFromAnnotation","IsTotal","getFieldDisplay","sTargetDisplayMode","oComputedEditMode","hasTextAnnotation","Common","Text","hasValueHelp","equal","getTypeConfig","dataType","oTargetMapping","EDM_TYPE_MAPPING","type","propertyTypeConfig","constraints","formatOptions","scale","$Scale","precision","$Precision","maxLength","$MaxLength","nullable","$Nullable","minimum","isNaN","Validation","Minimum","maximum","Maximum","isDigitSequence","IsDigitSequence","V4","$V4","parseAsString","indexOf","emptyString","parseKeepsEmptyString","getConstraintOptions","DoNotCheckScaleOfMeasuredQuantity","valueOf","skipDecimalsValidation","getBindingWithUnitOrCurrency","oPropertyDataModelPath","propertyBindingExpression","ignoreUnitConstraint","forDisplayMode","showOnlyUnitDecimals","preserveDecimalsForCurrency","unit","relativeLocation","formatWithTypeInformation","complexType","unitBindingExpression","constraintOptions","addTypeInformation","getBindingForDatePicker","minDate","$Date","maxDate","minExpression","maxExpression","getBindingForUnitOrCurrency","hasStaticPercentUnit","getContextRelativeTargetObjectPath","showNumber","getBindingWithTimezone","hideTimezoneForEmptyValues","fieldFormatOptions","timezone","Timezone","style","DateTimeStyle","showTimezoneForEmptyValues","dateTimeStyle","dateTimePattern","pattern","showTime","showDate","showTimezone","getBindingForDateFormat","propertyDataModelPath","formatOptionsDateFormat","toString","getBindingForTimezone","propertyDefinition","getAlignmentExpression","sAlignDisplay","sAlignEdit","getConverterContext","oContext","oInterface","context","convertMetaModelContext","requiresIContext","getDataModelObjectPath","getInvolvedDataModelObjects","isMultiValueField","oDataModelPath","navigationProperties","hasOneToManyNavigation","findIndex","oNav","isMultipleNavigationProperty","oContextNav","getRequiredExpressionAsObject","forceEditMode","getRequiredExpression","oRequiredProperties","aRequiredPropertiesFromInsertRestrictions","requiredPropertiesFromInsertRestrictions","aRequiredPropertiesFromUpdateRestrictions","requiredPropertiesFromUpdateRestrictions","dataFieldRequiredExpression","isRequiredExpression","requiredPropertyFromInsertRestrictionsExpression","requiredPropertyFromUpdateRestrictionsExpression","requiredExpression","editMode","includes","IsCreateMode","returnExpression","getRequiredExpressionForFieldGroup","dataFieldObjectPath","getRequiredExpressionForConnectedDataField","data","Data","Target","Object","dataFields","isRequiredExpressions","dataField","Value","isAnnotationOfType","isVisible","Hidden","isMultiLine","isMultiLineText","getActionEnabledExpression","actionTarget","pathFromContextLocation","operationAvailableIsAnnotated","Core","OperationAvailable","term","prefix","sourceEntityType","navigations","sourceActionDataModelObject","enhanceDataModelPath","nav","join","bindingParameterFullName","isBound","parameters","fullyQualifiedName","operationAvailableExpression","bindingContextPathVisitor","isQuickViewFacetVisible","facetModelPath","targetVisible","getVisibleExpressionForBreadcrumbs","viewData","breadcrumbsHierarchyMode","fclEnabled"],"sources":["./UIFormatters.ts"],"sourcesContent":["import type { Action, ActionParameter, ConvertedMetadata, PathAnnotationExpression, Property } from \"@sap-ux/vocabularies-types\";\nimport type { AnnotationPath, AnnotationTerm } from \"@sap-ux/vocabularies-types/Edm\";\nimport { CoreAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/Core\";\nimport type { Unit } from \"@sap-ux/vocabularies-types/vocabularies/Measures\";\nimport type {\n\tCollectionFacet,\n\tConnectedFieldsType,\n\tConnectedFieldsTypeTypes,\n\tDataField,\n\tDataFieldAbstractTypes,\n\tDataFieldForActionTypes,\n\tDataFieldForAnnotation,\n\tDataFieldTypes,\n\tDataPointType,\n\tDataPointTypeTypes,\n\tFieldGroup,\n\tFieldGroupType,\n\tReferenceFacet\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type {\n\tBindingToolkitExpression,\n\tCompiledBindingToolkitExpression,\n\tComplexTypeConstraintOptions,\n\tFn\n} from \"sap/fe/base/BindingToolkit\";\nimport {\n\tEDM_TYPE_MAPPING,\n\taddTypeInformation,\n\tand,\n\tcompileExpression,\n\tconstant,\n\tequal,\n\tformatResult,\n\tformatWithTypeInformation,\n\tgetExpressionFromAnnotation,\n\tifElse,\n\tisConstant,\n\tisTruthy,\n\tnot,\n\tor,\n\tpathInModel,\n\tunresolvableExpression\n} from \"sap/fe/base/BindingToolkit\";\nimport { convertMetaModelContext, getInvolvedDataModelObjects } from \"sap/fe/core/converters/MetaModelConverter\";\nimport type { PageContextPathTarget } from \"sap/fe/core/converters/TemplateConverter\";\nimport { UI, bindingContextPathVisitor, singletonPathVisitor } from \"sap/fe/core/helpers/BindingHelper\";\nimport { isAnnotationOfType, isMultipleNavigationProperty, isPathAnnotationExpression, isProperty } from \"sap/fe/core/helpers/TypeGuards\";\nimport type { DataModelObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport {\n\tenhanceDataModelPath,\n\tgetContextRelativeTargetObjectPath,\n\tgetRelativePaths,\n\tgetTargetObjectPath,\n\tisPathUpdatable\n} from \"sap/fe/core/templating/DataModelPathHelper\";\nimport * as DisplayModeFormatter from \"sap/fe/core/templating/DisplayModeFormatter\";\nimport {\n\tisDisabledExpression,\n\tisNonEditableExpression,\n\tisReadOnlyExpression,\n\tisRequiredExpression\n} from \"sap/fe/core/templating/FieldControlHelper\";\nimport {\n\tgetAssociatedCurrencyProperty,\n\tgetAssociatedUnitProperty,\n\thasStaticPercentUnit,\n\thasValueHelp,\n\tisComputed,\n\tisImmutable,\n\tisKey,\n\tisMultiLineText\n} from \"sap/fe/core/templating/PropertyHelper\";\nimport type FieldFormatOptions from \"sap/fe/macros/field/FieldFormatOptions\";\nimport type { DataPointFormatOptions } from \"sap/fe/macros/internal/helpers/DataPointTemplating\";\nimport type Context from \"sap/ui/model/Context\";\nimport type { ViewData } from \"../services/TemplatedViewServiceFactory\";\n\n// Import-export method used by the converter to use them in the templating through the UIFormatters.\nexport type DisplayMode = DisplayModeFormatter.DisplayMode;\n\nexport type FieldEditStyle = \"RadioButtons\";\n\nexport type PropertyOrPath<P> = string | P | PathAnnotationExpression<P>;\nexport type MetaModelContext = {\n\t$kind: string;\n\t$Type: string;\n\t$Nullable?: boolean;\n};\n\n/**\n * Interface representing the structure returned by the ODataMetaModel when using the @@ operator in XML templates.\n */\nexport type ComputedAnnotationInterface = {\n\tcontext: Context;\n\targuments?: unknown[];\n\t$$valueAsPromise?: boolean;\n};\n\nexport type configTypeConstraints = {\n\tscale?: number;\n\tprecision?: number;\n\tmaxLength?: number;\n\tnullable?: boolean;\n\tminimum?: string;\n\tmaximum?: string;\n\tisDigitSequence?: boolean;\n\tV4?: boolean;\n};\n\nexport type configTypeformatOptions = {\n\tparseAsString?: boolean;\n\temptyString?: string;\n\tparseKeepsEmptyString?: boolean;\n};\n\nexport type ConfigType = {\n\ttype: string;\n\tconstraints: configTypeConstraints;\n\tformatOptions: configTypeformatOptions;\n};\n\nexport type DateTimeStyle = \"short\" | \"medium\" | \"long\" | \"full\";\n\nexport type FormatOptionsDateFormat = FieldFormatOptions | DataPointFormatOptions;\n\nexport const FieldEditMode = {\n\t/**\n\t * {@link sap.ui.mdc.Field Field}, {@link sap.ui.mdc.FilterField FilterField} or {@link sap.ui.mdc.MultiValueField MultiValueField }\n\t * is rendered in disabled mode\n\t */\n\tDisabled: \"Disabled\",\n\t/**\n\t * {@link sap.ui.mdc.Field Field}, {@link sap.ui.mdc.FilterField FilterField} or {@link sap.ui.mdc.MultiValueField MultiValueField }\n\t * is rendered in display mode\n\t */\n\tDisplay: \"Display\",\n\t/**\n\t * {@link sap.ui.mdc.Field Field}, {@link sap.ui.mdc.FilterField FilterField} or {@link sap.ui.mdc.MultiValueField MultiValueField }\n\t * is rendered in editable mode\n\t */\n\tEditable: \"Editable\",\n\t/**\n\t * If more than one control is rendered by the {@link sap.ui.mdc.Field Field}, {@link sap.ui.mdc.FilterField FilterField }\n\t * or {@link sap.ui.mdc.MultiValueField MultiValueField} control, the first part is editable, and the other\n\t * parts are in display mode.\n\t */\n\tEditableDisplay: \"EditableDisplay\",\n\t/**\n\t * If more than one control is rendered by the {@link sap.ui.mdc.Field Field}, {@link sap.ui.mdc.FilterField FilterField }\n\t * or {@link sap.ui.mdc.MultiValueField MultiValueField} control, the first part is editable, and the other\n\t * parts are read-only.\n\t */\n\tEditableReadOnly: \"EditableReadOnly\",\n\t/**\n\t * {@link sap.ui.mdc.Field Field}, {@link sap.ui.mdc.FilterField FilterField} or {@link sap.ui.mdc.MultiValueField MultiValueField }\n\t * is rendered in read-only mode\n\t */\n\tReadOnly: \"ReadOnly\"\n};\n\nexport const getDisplayMode = function (\n\toDataModelObjectPath: DataModelObjectPath<Property | DataFieldAbstractTypes | DataPointTypeTypes>\n): DisplayMode {\n\treturn DisplayModeFormatter.getDisplayMode(oDataModelObjectPath.targetObject, oDataModelObjectPath);\n};\nexport const getEditableExpressionAsObject = function (\n\toPropertyPath: PropertyOrPath<Property>,\n\toDataFieldConverted: Property | DataFieldAbstractTypes | DataPointTypeTypes | undefined,\n\toDataModelObjectPath: DataModelObjectPath<unknown>,\n\tisEditable: BindingToolkitExpression<boolean> = UI.IsEditable,\n\tconsiderUpdateRestrictions = true\n): BindingToolkitExpression<boolean> {\n\treturn getEditableExpression(\n\t\toPropertyPath,\n\t\toDataFieldConverted,\n\t\toDataModelObjectPath,\n\t\ttrue,\n\t\tisEditable,\n\t\tconsiderUpdateRestrictions\n\t) as BindingToolkitExpression<boolean>;\n};\n\n/**\n * Create the expression to generate an \"editable\" Boolean value.\n * @param oPropertyPath The input property\n * @param oDataFieldConverted The DataFieldConverted object to read the fieldControl annotation\n * @param oDataModelObjectPath The path to this property object\n * @param bAsObject Whether or not this should be returned as an object or a binding string\n * @param isEditable Whether or not UI.IsEditable be considered.\n * @param considerUpdateRestrictions Whether we want to take into account UpdateRestrictions to compute the editable\n * @returns The binding expression used to determine if a property is editable or not\n */\nexport const getEditableExpression = function (\n\toPropertyPath: PropertyOrPath<Property>,\n\toDataFieldConverted: Property | DataFieldAbstractTypes | DataPointTypeTypes | undefined = undefined,\n\toDataModelObjectPath: DataModelObjectPath<unknown>,\n\tbAsObject = false,\n\tisEditable: BindingToolkitExpression<boolean> = UI.IsEditable,\n\tconsiderUpdateRestrictions = true\n): CompiledBindingToolkitExpression | BindingToolkitExpression<boolean> {\n\tconst relativePath = getRelativePaths(oDataModelObjectPath);\n\tif (!oPropertyPath || typeof oPropertyPath === \"string\") {\n\t\treturn compileExpression(false);\n\t}\n\tlet dataFieldEditableExpression: BindingToolkitExpression<boolean> = constant(true);\n\tif (oDataFieldConverted !== undefined && !isProperty(oDataFieldConverted)) {\n\t\tdataFieldEditableExpression = ifElse(isNonEditableExpression(oDataFieldConverted), false, isEditable);\n\t} else if (oDataFieldConverted !== undefined) {\n\t\tdataFieldEditableExpression = isEditable;\n\t}\n\n\tconst oProperty = isPathAnnotationExpression(oPropertyPath) ? oPropertyPath.$target : oPropertyPath;\n\n\t// Editability depends on the field control expression\n\t// If the Field control is statically in ReadOnly or Inapplicable (disabled) -> not editable\n\t// If the property is a key -> not editable except in creation if not computed\n\t// If the property is computed -> not editable\n\t// If the property is not updatable -> not editable\n\t// If the property is immutable -> not editable except in creation\n\t// If the Field control is a path resolving to ReadOnly or Inapplicable (disabled) (<= 1) -> not editable\n\t// Else, to be editable you need\n\t// immutable and key while in the creation row\n\t// ui/isEditable\n\tconst isPathUpdatableExpression = isPathUpdatable(oDataModelObjectPath, {\n\t\tpropertyPath: oPropertyPath,\n\t\tpathVisitor: (path: string, navigationPaths: string[]) =>\n\t\t\tsingletonPathVisitor(path, oDataModelObjectPath.convertedTypes, navigationPaths)\n\t});\n\tif (compileExpression(isPathUpdatableExpression) === \"false\" && considerUpdateRestrictions) {\n\t\treturn bAsObject ? isPathUpdatableExpression : \"false\";\n\t}\n\tconst editableExpression =\n\t\toProperty !== undefined\n\t\t\t? ifElse(\n\t\t\t\t\tor(\n\t\t\t\t\t\tand(not(isPathUpdatableExpression), considerUpdateRestrictions),\n\t\t\t\t\t\tisComputed(oProperty),\n\t\t\t\t\t\tisKey(oProperty),\n\t\t\t\t\t\tisImmutable(oProperty),\n\t\t\t\t\t\tisNonEditableExpression(oProperty, relativePath)\n\t\t\t\t\t),\n\t\t\t\t\tifElse(or(isComputed(oProperty), isNonEditableExpression(oProperty, relativePath)), false, UI.IsTransientBinding),\n\t\t\t\t\tisEditable\n\t\t\t  )\n\t\t\t: unresolvableExpression;\n\tif (bAsObject) {\n\t\treturn and(editableExpression, dataFieldEditableExpression);\n\t}\n\treturn compileExpression(and(editableExpression, dataFieldEditableExpression));\n};\n\nexport const getCollaborationExpression = function <T>(\n\tdataModelObjectPath: DataModelObjectPath<Property>,\n\tformatter: Fn<T>\n): BindingToolkitExpression<T> {\n\tconst objectPath = getTargetObjectPath(dataModelObjectPath);\n\tconst activityExpression = pathInModel(`/collaboration/activities${objectPath}`, \"internal\");\n\tconst keys = dataModelObjectPath?.contextLocation?.targetEntityType?.keys;\n\tconst keysExpressions: BindingToolkitExpression<unknown>[] = [];\n\tkeys?.forEach(function (key) {\n\t\tconst keyExpression = pathInModel(key.name);\n\t\tkeysExpressions.push(keyExpression);\n\t});\n\treturn formatResult([activityExpression, ...keysExpressions], formatter);\n};\nexport const getEnabledExpressionAsObject = function (\n\toPropertyPath: PropertyOrPath<Property>,\n\toDataFieldConverted?: Property | DataFieldAbstractTypes | DataPointTypeTypes,\n\toDataModelObjectPath?: DataModelObjectPath<unknown>\n): BindingToolkitExpression<boolean> {\n\treturn getEnabledExpression(oPropertyPath, oDataFieldConverted, true, oDataModelObjectPath) as BindingToolkitExpression<boolean>;\n};\n/**\n * Create the expression to generate an \"enabled\" Boolean value.\n * @param oPropertyPath The input property\n * @param oDataFieldConverted The DataFieldConverted Object to read the fieldControl annotation\n * @param bAsObject Whether or not this should be returned as an object or a binding string\n * @param oDataModelObjectPath\n * @returns The binding expression to determine if a property is enabled or not\n */\nexport const getEnabledExpression = function (\n\toPropertyPath: PropertyOrPath<Property>,\n\toDataFieldConverted?: Property | DataFieldAbstractTypes | DataPointTypeTypes,\n\tbAsObject = false,\n\toDataModelObjectPath?: DataModelObjectPath<unknown>\n): CompiledBindingToolkitExpression | BindingToolkitExpression<boolean> {\n\tif (!oPropertyPath || typeof oPropertyPath === \"string\") {\n\t\treturn compileExpression(true);\n\t}\n\tlet relativePath;\n\tif (oDataModelObjectPath) {\n\t\trelativePath = getRelativePaths(oDataModelObjectPath);\n\t}\n\tlet dataFieldEnabledExpression: BindingToolkitExpression<boolean> = constant(true);\n\tif (oDataFieldConverted !== undefined && !isProperty(oDataFieldConverted)) {\n\t\tdataFieldEnabledExpression = ifElse(isDisabledExpression(oDataFieldConverted), false, true);\n\t}\n\n\tconst oProperty = isPathAnnotationExpression(oPropertyPath) ? oPropertyPath.$target : oPropertyPath;\n\t// Enablement depends on the field control expression\n\t// If the Field control is statically in Inapplicable (disabled) -> not enabled\n\tconst enabledExpression =\n\t\toProperty !== undefined ? ifElse(isDisabledExpression(oProperty, relativePath), false, true) : unresolvableExpression;\n\tif (bAsObject) {\n\t\treturn and(enabledExpression, dataFieldEnabledExpression);\n\t}\n\treturn compileExpression(and(enabledExpression, dataFieldEnabledExpression));\n};\n\n/**\n * Create the expression to generate an \"editMode\" enum value.\n * @param propertyPath The input property\n * @param dataModelObjectPath The list of data model objects that are involved to reach that property\n * @param measureReadOnly Whether we should set UoM / currency field mode to read only\n * @param asObject Whether we should return this as an expression or as a string\n * @param dataFieldConverted The dataField object\n * @param isEditable Whether or not UI.IsEditable be considered.\n * @returns The binding expression representing the current property edit mode, compliant with the MDC Field definition of editMode.\n */\nexport const getEditMode = function (\n\tpropertyPath: PropertyOrPath<Property>,\n\tdataModelObjectPath: DataModelObjectPath<unknown>,\n\tmeasureReadOnly = false,\n\tasObject = false,\n\tdataFieldConverted: Property | DataFieldAbstractTypes | DataPointTypeTypes | undefined = undefined,\n\tisEditable: BindingToolkitExpression<boolean> = UI.IsEditable\n): CompiledBindingToolkitExpression | BindingToolkitExpression<string> {\n\tif (\n\t\t!propertyPath ||\n\t\ttypeof propertyPath === \"string\" ||\n\t\t(!isProperty(dataFieldConverted) && dataFieldConverted?.$Type === UIAnnotationTypes.DataFieldWithNavigationPath)\n\t) {\n\t\treturn FieldEditMode.Display;\n\t}\n\tconst property = isPathAnnotationExpression(propertyPath) ? propertyPath.$target : propertyPath;\n\tif (!isProperty(property)) {\n\t\treturn FieldEditMode.Display;\n\t}\n\tconst relativePath = getRelativePaths(dataModelObjectPath);\n\tconst isPathUpdatableExpression = isPathUpdatable(dataModelObjectPath, {\n\t\tpropertyPath: property,\n\t\tpathVisitor: (path: string, navigationPaths: string[]) =>\n\t\t\tsingletonPathVisitor(path, dataModelObjectPath.convertedTypes, navigationPaths)\n\t});\n\n\t// we get the editable Expression without considering update Restrictions because they are handled separately\n\tconst editableExpression = getEditableExpressionAsObject(propertyPath, dataFieldConverted, dataModelObjectPath, isEditable, false);\n\n\tconst enabledExpression = getEnabledExpressionAsObject(propertyPath, dataFieldConverted, dataModelObjectPath);\n\tconst associatedCurrencyProperty = getAssociatedCurrencyProperty(property);\n\tconst unitProperty = associatedCurrencyProperty || getAssociatedUnitProperty(property);\n\tlet resultExpression: BindingToolkitExpression<string> = constant(FieldEditMode.Editable);\n\tif (unitProperty) {\n\t\tconst isUnitReadOnly = isReadOnlyExpression(unitProperty, relativePath);\n\t\tresultExpression = ifElse(\n\t\t\tor(isUnitReadOnly, isComputed(unitProperty), and(isImmutable(unitProperty), not(UI.IsTransientBinding)), measureReadOnly),\n\t\t\tifElse(!isConstant(isUnitReadOnly) && isUnitReadOnly, FieldEditMode.EditableReadOnly, FieldEditMode.EditableDisplay),\n\t\t\tFieldEditMode.Editable\n\t\t);\n\t}\n\tif (!unitProperty && (property?.annotations?.Measures?.ISOCurrency || property?.annotations?.Measures?.Unit)) {\n\t\t// no unit property associated means this is a static unit\n\t\tresultExpression = constant(FieldEditMode.EditableDisplay);\n\t}\n\tlet readOnlyExpression;\n\tif (dataFieldConverted != undefined && !isProperty(dataFieldConverted)) {\n\t\treadOnlyExpression = or(isReadOnlyExpression(property, relativePath), isReadOnlyExpression(dataFieldConverted));\n\t} else {\n\t\treadOnlyExpression = isReadOnlyExpression(property, relativePath);\n\t}\n\n\t// if there are update Restrictions it is always display mode\n\tconst editModeExpression = ifElse(\n\t\tor(isPathUpdatableExpression, UI.IsTransientBinding),\n\t\tifElse(\n\t\t\tenabledExpression,\n\t\t\tifElse(\n\t\t\t\teditableExpression,\n\t\t\t\tresultExpression,\n\t\t\t\tifElse(\n\t\t\t\t\tand(!isConstant(readOnlyExpression) && readOnlyExpression, isEditable),\n\t\t\t\t\tFieldEditMode.ReadOnly,\n\t\t\t\t\tFieldEditMode.Display\n\t\t\t\t)\n\t\t\t),\n\t\t\tifElse(isEditable, FieldEditMode.Disabled, FieldEditMode.Display)\n\t\t),\n\t\tFieldEditMode.Display\n\t);\n\tif (asObject) {\n\t\treturn editModeExpression;\n\t}\n\treturn compileExpression(editModeExpression);\n};\n\nexport const hasValidAnalyticalCurrencyOrUnit = function (\n\toPropertyDataModelObjectPath: DataModelObjectPath<Property> | undefined\n): CompiledBindingToolkitExpression {\n\tconst oPropertyDefinition = oPropertyDataModelObjectPath?.targetObject;\n\treturn oPropertyDefinition && getExpressionForMeasureUnit(oPropertyDefinition);\n};\n\nexport const getExpressionForMeasureUnit = function (oPropertyDefinition: Property): CompiledBindingToolkitExpression {\n\tconst currency = oPropertyDefinition?.annotations?.Measures?.ISOCurrency;\n\tconst measure = currency ? currency : oPropertyDefinition?.annotations?.Measures?.Unit;\n\tif (measure) {\n\t\treturn compileExpression(or(isTruthy(getExpressionFromAnnotation(measure)), not(UI.IsTotal)));\n\t} else {\n\t\treturn compileExpression(constant(true));\n\t}\n};\n\n/**\n * Create the binding expression for the fieldDisplay.\n * @param oPropertyPath\n * @param sTargetDisplayMode\n * @param oComputedEditMode\n * @returns The binding expression representing the current property display mode, compliant with the MDC Field definition of displayMode.\n */\nexport const getFieldDisplay = function (\n\toPropertyPath: PropertyOrPath<Property>,\n\tsTargetDisplayMode: string,\n\toComputedEditMode: BindingToolkitExpression<string>\n): CompiledBindingToolkitExpression {\n\tconst oProperty = (isPathAnnotationExpression(oPropertyPath) && oPropertyPath.$target) || (oPropertyPath as Property);\n\tconst hasTextAnnotation = oProperty.annotations?.Common?.Text !== undefined;\n\n\tif (hasValueHelp(oProperty)) {\n\t\treturn compileExpression(sTargetDisplayMode);\n\t} else {\n\t\treturn hasTextAnnotation ? compileExpression(ifElse(equal(oComputedEditMode, \"Editable\"), \"Value\", sTargetDisplayMode)) : \"Value\";\n\t}\n};\n\nexport const getTypeConfig = function (oProperty: Property | DataFieldAbstractTypes, dataType: string | undefined): ConfigType {\n\tconst oTargetMapping = EDM_TYPE_MAPPING[(oProperty as Property)?.type] || (dataType ? EDM_TYPE_MAPPING[dataType] : undefined);\n\tconst propertyTypeConfig: ConfigType = {\n\t\ttype: oTargetMapping.type,\n\t\tconstraints: {},\n\t\tformatOptions: {}\n\t};\n\tif (isProperty(oProperty)) {\n\t\tpropertyTypeConfig.constraints = {\n\t\t\tscale: oTargetMapping.constraints?.$Scale ? oProperty.scale : undefined,\n\t\t\tprecision: oTargetMapping.constraints?.$Precision ? oProperty.precision : undefined,\n\t\t\tmaxLength: oTargetMapping.constraints?.$MaxLength ? oProperty.maxLength : undefined,\n\t\t\tnullable: oTargetMapping.constraints?.$Nullable ? oProperty.nullable : undefined,\n\t\t\tminimum:\n\t\t\t\toTargetMapping.constraints?.[\"@Org.OData.Validation.V1.Minimum/$Decimal\"] &&\n\t\t\t\t!isNaN(oProperty.annotations?.Validation?.Minimum)\n\t\t\t\t\t? `${oProperty.annotations?.Validation?.Minimum}`\n\t\t\t\t\t: undefined,\n\t\t\tmaximum:\n\t\t\t\toTargetMapping.constraints?.[\"@Org.OData.Validation.V1.Maximum/$Decimal\"] &&\n\t\t\t\t!isNaN(oProperty.annotations?.Validation?.Maximum)\n\t\t\t\t\t? `${oProperty.annotations?.Validation?.Maximum}`\n\t\t\t\t\t: undefined,\n\t\t\tisDigitSequence:\n\t\t\t\tpropertyTypeConfig.type === \"sap.ui.model.odata.type.String\" &&\n\t\t\t\toTargetMapping.constraints?.[\"@com.sap.vocabularies.Common.v1.IsDigitSequence\"] &&\n\t\t\t\toProperty.annotations?.Common?.IsDigitSequence\n\t\t\t\t\t? true\n\t\t\t\t\t: undefined,\n\t\t\tV4: oTargetMapping.constraints?.$V4 ? true : undefined\n\t\t};\n\t}\n\tpropertyTypeConfig.formatOptions = {\n\t\tparseAsString:\n\t\t\tpropertyTypeConfig?.type?.indexOf(\"sap.ui.model.odata.type.Int\") === 0 ||\n\t\t\tpropertyTypeConfig?.type?.indexOf(\"sap.ui.model.odata.type.Double\") === 0\n\t\t\t\t? false\n\t\t\t\t: undefined,\n\t\temptyString:\n\t\t\tpropertyTypeConfig?.type?.indexOf(\"sap.ui.model.odata.type.Int\") === 0 ||\n\t\t\tpropertyTypeConfig?.type?.indexOf(\"sap.ui.model.odata.type.Double\") === 0\n\t\t\t\t? \"\"\n\t\t\t\t: undefined,\n\t\tparseKeepsEmptyString: propertyTypeConfig.type === \"sap.ui.model.odata.type.String\" ? true : undefined\n\t};\n\treturn propertyTypeConfig;\n};\n\nexport const getConstraintOptions = function (property: Property | undefined): ComplexTypeConstraintOptions {\n\treturn property?.annotations?.UI?.DoNotCheckScaleOfMeasuredQuantity &&\n\t\tproperty?.annotations?.UI.DoNotCheckScaleOfMeasuredQuantity?.valueOf()\n\t\t? { skipDecimalsValidation: true }\n\t\t: {};\n};\n\nexport const getBindingWithUnitOrCurrency = function (\n\toPropertyDataModelPath: DataModelObjectPath<Property>,\n\tpropertyBindingExpression: BindingToolkitExpression<string>,\n\tignoreUnitConstraint?: boolean,\n\tformatOptions?: {\n\t\tshowMeasure?: boolean;\n\t\tdecimalPadding?: number;\n\t\temptyString?: string | number;\n\t},\n\tforDisplayMode?: boolean,\n\tshowOnlyUnitDecimals?: boolean,\n\tpreserveDecimalsForCurrency?: boolean\n): BindingToolkitExpression<string> {\n\tconst oPropertyDefinition = oPropertyDataModelPath.targetObject as Property;\n\tlet unit = oPropertyDefinition.annotations?.Measures?.Unit;\n\tconst relativeLocation = getRelativePaths(oPropertyDataModelPath);\n\tpropertyBindingExpression = formatWithTypeInformation(oPropertyDefinition, propertyBindingExpression);\n\tconst complexType = unit ? \"sap.ui.model.odata.type.Unit\" : \"sap.ui.model.odata.type.Currency\";\n\tunit = unit ? unit : (oPropertyDefinition.annotations?.Measures?.ISOCurrency as unknown as Unit | undefined);\n\tconst unitBindingExpression =\n\t\tisPathAnnotationExpression(unit) && unit.$target\n\t\t\t? formatWithTypeInformation(unit.$target, getExpressionFromAnnotation(unit, relativeLocation), ignoreUnitConstraint)\n\t\t\t: getExpressionFromAnnotation(unit, relativeLocation);\n\tlet constraintOptions: ComplexTypeConstraintOptions | undefined;\n\tif (complexType === \"sap.ui.model.odata.type.Unit\") {\n\t\tif (forDisplayMode && !showOnlyUnitDecimals) {\n\t\t\tconstraintOptions = { skipDecimalsValidation: true };\n\t\t} else if (!forDisplayMode) {\n\t\t\t// Consider annotation only in edit mode\n\t\t\tconstraintOptions = getConstraintOptions(oPropertyDataModelPath.targetObject);\n\t\t}\n\t}\n\tif (complexType === \"sap.ui.model.odata.type.Currency\") {\n\t\tif (preserveDecimalsForCurrency) {\n\t\t\tconstraintOptions = { skipDecimalsValidation: true };\n\t\t}\n\t}\n\tif (forDisplayMode) {\n\t\tformatOptions = { ...formatOptions, emptyString: \"\" };\n\t}\n\n\treturn addTypeInformation([propertyBindingExpression, unitBindingExpression], complexType, undefined, formatOptions, constraintOptions);\n};\n\n/**\n * Create the binding expression for the date picker with minimum and maximum value present.\n * @param oPropertyDataModelPath The list of data model objects that are involved to reach that property\n * @param propertyBindingExpression Binding expression for the property\n * @returns The binding expression representing the date property with minimum and maximum value for the same\n */\nexport const getBindingForDatePicker = function (\n\toPropertyDataModelPath: DataModelObjectPath<Property | DataFieldTypes>,\n\tpropertyBindingExpression: BindingToolkitExpression<string>\n): BindingToolkitExpression<string> | CompiledBindingToolkitExpression {\n\tconst oPropertyDefinition = oPropertyDataModelPath.targetObject as Property;\n\tconst relativeLocation = getRelativePaths(oPropertyDataModelPath);\n\tconst formatOptions = {};\n\tpropertyBindingExpression = formatWithTypeInformation(oPropertyDefinition, propertyBindingExpression);\n\tconst complexType = \"sap.fe.core.type.Date\";\n\tconst minDate = oPropertyDefinition?.annotations?.Validation?.Minimum?.$Date\n\t\t? oPropertyDefinition?.annotations?.Validation?.Minimum?.$Date\n\t\t: oPropertyDefinition?.annotations?.Validation?.Minimum;\n\tconst maxDate = oPropertyDefinition?.annotations?.Validation?.Maximum?.$Date\n\t\t? oPropertyDefinition?.annotations?.Validation?.Maximum?.$Date\n\t\t: oPropertyDefinition?.annotations?.Validation?.Maximum;\n\tconst minExpression =\n\t\tminDate && isPathAnnotationExpression(minDate)\n\t\t\t? formatWithTypeInformation(\n\t\t\t\t\toPropertyDefinition?.annotations?.Validation?.Minimum,\n\t\t\t\t\tgetExpressionFromAnnotation(oPropertyDefinition?.annotations?.Validation?.Minimum, relativeLocation)\n\t\t\t  )\n\t\t\t: minDate;\n\tconst maxExpression =\n\t\tmaxDate && isPathAnnotationExpression(maxDate)\n\t\t\t? formatWithTypeInformation(\n\t\t\t\t\toPropertyDefinition?.annotations?.Validation?.Maximum,\n\t\t\t\t\tgetExpressionFromAnnotation(oPropertyDefinition?.annotations?.Validation?.Maximum, relativeLocation)\n\t\t\t  )\n\t\t\t: maxDate;\n\n\treturn (\n\t\t(minExpression || maxExpression) &&\n\t\taddTypeInformation([propertyBindingExpression, minExpression, maxExpression], complexType, undefined, formatOptions)\n\t);\n};\n\nexport const getBindingForUnitOrCurrency = function (\n\toPropertyDataModelPath: DataModelObjectPath<Property> | undefined,\n\tforDisplayMode: boolean,\n\tshowOnlyUnitDecimals: boolean,\n\tpreserveDecimalsForCurrency: boolean\n): BindingToolkitExpression<string> | string {\n\tconst oPropertyDefinition = oPropertyDataModelPath?.targetObject;\n\tif (!oPropertyDefinition) {\n\t\treturn \"\";\n\t}\n\n\tlet unit = oPropertyDefinition.annotations?.Measures?.Unit;\n\tif (hasStaticPercentUnit(oPropertyDefinition)) {\n\t\treturn constant(\"%\");\n\t}\n\tconst relativeLocation = getRelativePaths(oPropertyDataModelPath);\n\n\tconst complexType = unit ? \"sap.ui.model.odata.type.Unit\" : \"sap.ui.model.odata.type.Currency\";\n\tunit = unit ? unit : (oPropertyDefinition.annotations?.Measures?.ISOCurrency as unknown as Unit | undefined);\n\tconst unitBindingExpression =\n\t\tisPathAnnotationExpression(unit) && unit.$target\n\t\t\t? formatWithTypeInformation(unit.$target, getExpressionFromAnnotation(unit, relativeLocation))\n\t\t\t: getExpressionFromAnnotation(unit, relativeLocation);\n\n\tlet propertyBindingExpression = pathInModel(\n\t\tgetContextRelativeTargetObjectPath(oPropertyDataModelPath)\n\t) as BindingToolkitExpression<string>;\n\tpropertyBindingExpression = formatWithTypeInformation(oPropertyDefinition, propertyBindingExpression, true);\n\tlet constraintOptions: ComplexTypeConstraintOptions | undefined;\n\tif (complexType === \"sap.ui.model.odata.type.Unit\") {\n\t\tif (forDisplayMode && !showOnlyUnitDecimals) {\n\t\t\tconstraintOptions = { skipDecimalsValidation: true };\n\t\t} else if (!forDisplayMode) {\n\t\t\tconstraintOptions = getConstraintOptions(oPropertyDefinition);\n\t\t}\n\t} else if (complexType === \"sap.ui.model.odata.type.Currency\") {\n\t\tif (preserveDecimalsForCurrency) {\n\t\t\tconstraintOptions = { skipDecimalsValidation: true };\n\t\t}\n\t}\n\treturn addTypeInformation(\n\t\t[propertyBindingExpression, unitBindingExpression],\n\t\tcomplexType,\n\t\tundefined,\n\t\t{\n\t\t\tparseKeepsEmptyString: true,\n\t\t\tshowNumber: false\n\t\t},\n\t\tconstraintOptions\n\t);\n};\nexport const getBindingWithTimezone = function (\n\toPropertyDataModelPath: DataModelObjectPath<Property>,\n\tpropertyBindingExpression: BindingToolkitExpression<string>,\n\tignoreUnitConstraint = false,\n\thideTimezoneForEmptyValues = false,\n\tfieldFormatOptions?: FieldFormatOptions\n): BindingToolkitExpression<string> {\n\tconst oPropertyDefinition = oPropertyDataModelPath.targetObject as Property;\n\tconst timezone = oPropertyDefinition.annotations?.Common?.Timezone;\n\tconst style = oPropertyDefinition.annotations?.UI?.DateTimeStyle;\n\tconst relativeLocation = getRelativePaths(oPropertyDataModelPath);\n\tpropertyBindingExpression = formatWithTypeInformation(oPropertyDefinition, propertyBindingExpression);\n\n\tconst complexType = \"sap.fe.core.type.DateTimeWithTimezone\";\n\tconst unitBindingExpression =\n\t\tisPathAnnotationExpression(timezone) && timezone.$target\n\t\t\t? formatWithTypeInformation(\n\t\t\t\t\t(timezone as PathAnnotationExpression<unknown>).$target as Property,\n\t\t\t\t\tgetExpressionFromAnnotation(timezone, relativeLocation),\n\t\t\t\t\tignoreUnitConstraint\n\t\t\t  )\n\t\t\t: getExpressionFromAnnotation(timezone, relativeLocation);\n\tlet formatOptions = {};\n\tif (hideTimezoneForEmptyValues) {\n\t\tformatOptions = {\n\t\t\tshowTimezoneForEmptyValues: false\n\t\t};\n\t}\n\t// if style or pattern is also set\n\tif (style) {\n\t\tformatOptions = { ...formatOptions, ...{ style: style } };\n\t} else if (fieldFormatOptions?.dateTimeStyle !== undefined) {\n\t\tformatOptions = { ...formatOptions, ...{ style: fieldFormatOptions.dateTimeStyle } };\n\t}\n\n\tif (fieldFormatOptions?.dateTimePattern !== undefined) {\n\t\tformatOptions = { ...formatOptions, ...{ pattern: fieldFormatOptions.dateTimePattern } };\n\t}\n\n\tif (fieldFormatOptions?.showTime !== undefined) {\n\t\tformatOptions = { ...formatOptions, ...{ showTime: fieldFormatOptions.showTime } };\n\t}\n\tif (fieldFormatOptions?.showDate !== undefined) {\n\t\tformatOptions = { ...formatOptions, ...{ showDate: fieldFormatOptions.showDate } };\n\t}\n\tif (fieldFormatOptions?.showTimezone !== undefined) {\n\t\tformatOptions = { ...formatOptions, ...{ showTimezone: fieldFormatOptions.showTimezone } };\n\t}\n\n\treturn addTypeInformation([propertyBindingExpression, unitBindingExpression], complexType, undefined, formatOptions);\n};\n\n/**\n * Creates the binding expression for the date format of a date, time or dateTime.\n * @param propertyDataModelPath The list of data model objects that are involved to reach that property\n * @param propertyBindingExpression Binding expression for the property\n * @param formatOptionsDateFormat Format options which contain the style or pattern property\n * @returns The binding expression representing a date, time, or date-time, with the given pattern or style property\n */\nexport const getBindingForDateFormat = function (\n\tpropertyDataModelPath: DataModelObjectPath<Property>,\n\tpropertyBindingExpression: BindingToolkitExpression<string>,\n\tformatOptionsDateFormat?: FormatOptionsDateFormat\n): BindingToolkitExpression<string> {\n\tconst oPropertyDefinition = propertyDataModelPath.targetObject as Property;\n\tconst pattern = formatOptionsDateFormat?.dateTimePattern;\n\tconst style = oPropertyDefinition.annotations?.UI?.DateTimeStyle ?? formatOptionsDateFormat?.dateTimeStyle;\n\tpropertyBindingExpression = formatWithTypeInformation(oPropertyDefinition, propertyBindingExpression);\n\tpropertyBindingExpression.type = EDM_TYPE_MAPPING[oPropertyDefinition.type].type;\n\tpropertyBindingExpression.formatOptions = {\n\t\t...(style && { style: style.toString() }),\n\t\t...(pattern && { pattern: pattern })\n\t};\n\n\treturn propertyBindingExpression;\n};\n\nexport const getBindingForTimezone = function (\n\tpropertyDataModelPath: DataModelObjectPath<Property>,\n\tpropertyBindingExpression: BindingToolkitExpression<string>\n): BindingToolkitExpression<string> {\n\tconst propertyDefinition = propertyDataModelPath.targetObject as Property;\n\tpropertyBindingExpression = formatWithTypeInformation(propertyDefinition, propertyBindingExpression);\n\tconst complexType = \"sap.ui.model.odata.type.DateTimeWithTimezone\";\n\tconst formatOptions = { showTime: false, showDate: false, showTimezone: true, parseKeepsEmptyString: true };\n\n\t// null is required by formatter when there is just a timezone\n\treturn addTypeInformation([null, propertyBindingExpression], complexType, undefined, formatOptions);\n};\n\nexport const getAlignmentExpression = function (\n\toComputedEditMode: BindingToolkitExpression<string>,\n\tsAlignDisplay = \"Begin\",\n\tsAlignEdit = \"Begin\"\n): CompiledBindingToolkitExpression {\n\treturn compileExpression(ifElse(equal(oComputedEditMode, \"Display\"), sAlignDisplay, sAlignEdit));\n};\n\n/**\n * Formatter helper to retrieve the converterContext from the metamodel context.\n * @param oContext The original metamodel context\n * @param oInterface The current templating context\n * @returns The ConverterContext representing that object\n */\nexport const getConverterContext = function (oContext: MetaModelContext, oInterface: ComputedAnnotationInterface): object | null {\n\tif (oInterface && oInterface.context) {\n\t\treturn convertMetaModelContext(oInterface.context) as object;\n\t}\n\treturn null;\n};\ngetConverterContext.requiresIContext = true;\n\n/**\n * Formatter helper to retrieve the data model objects that are involved from the metamodel context.\n * @param oContext The original ODataMetaModel context\n * @param oInterface The current templating context\n * @returns An array of entitysets and navproperties that are involved to get to a specific object in the metamodel\n */\nexport const getDataModelObjectPath = function <T>(\n\toContext: MetaModelContext,\n\toInterface: ComputedAnnotationInterface\n): DataModelObjectPath<T> | null {\n\tif (oInterface && oInterface.context) {\n\t\treturn getInvolvedDataModelObjects(oInterface.context);\n\t}\n\treturn null;\n};\ngetDataModelObjectPath.requiresIContext = true;\n\n/**\n * Checks if the referenced property is part of a 1..n navigation.\n * @param oDataModelPath The data model path to check\n * @returns True if the property is part of a 1..n navigation\n */\nexport const isMultiValueField = function (oDataModelPath: DataModelObjectPath<unknown>): boolean {\n\tif (oDataModelPath.navigationProperties?.length) {\n\t\tconst hasOneToManyNavigation =\n\t\t\toDataModelPath?.navigationProperties.findIndex((oNav) => {\n\t\t\t\tif (isMultipleNavigationProperty(oNav)) {\n\t\t\t\t\tif (oDataModelPath.contextLocation?.navigationProperties?.length) {\n\t\t\t\t\t\t//we check the one to many nav is not already part of the context\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\toDataModelPath.contextLocation?.navigationProperties.findIndex(\n\t\t\t\t\t\t\t\t(oContextNav) => oContextNav.name === oNav.name\n\t\t\t\t\t\t\t) === -1\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}) > -1;\n\t\tif (hasOneToManyNavigation) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\nexport const getRequiredExpressionAsObject = function (\n\toPropertyPath: PropertyOrPath<Property>,\n\toDataFieldConverted?: Property | DataFieldAbstractTypes | DataPointTypeTypes,\n\tforceEditMode = false\n): BindingToolkitExpression<boolean> {\n\treturn getRequiredExpression(oPropertyPath, oDataFieldConverted, forceEditMode, true) as BindingToolkitExpression<boolean>;\n};\nexport const getRequiredExpression = function (\n\toPropertyPath: PropertyOrPath<Property>,\n\toDataFieldConverted?: Property | DataFieldAbstractTypes | DataPointTypeTypes,\n\tforceEditMode = false,\n\tbAsObject = false,\n\toRequiredProperties: {\n\t\trequiredPropertiesFromInsertRestrictions?: unknown[];\n\t\trequiredPropertiesFromUpdateRestrictions?: unknown[];\n\t} = {},\n\tdataModelObjectPath?: DataModelObjectPath<unknown>\n): CompiledBindingToolkitExpression | BindingToolkitExpression<boolean> {\n\tconst aRequiredPropertiesFromInsertRestrictions = oRequiredProperties.requiredPropertiesFromInsertRestrictions;\n\tconst aRequiredPropertiesFromUpdateRestrictions = oRequiredProperties.requiredPropertiesFromUpdateRestrictions;\n\tif (!oPropertyPath || typeof oPropertyPath === \"string\") {\n\t\tif (bAsObject) {\n\t\t\treturn constant(false);\n\t\t}\n\t\treturn compileExpression(constant(false));\n\t}\n\tlet relativePath;\n\tif (dataModelObjectPath) {\n\t\trelativePath = getRelativePaths(dataModelObjectPath);\n\t}\n\tlet dataFieldRequiredExpression: BindingToolkitExpression<boolean> = constant(false);\n\tif (oDataFieldConverted !== undefined && !isProperty(oDataFieldConverted)) {\n\t\t// For the datafield expression we should not  consider the relative path\n\t\tdataFieldRequiredExpression = isRequiredExpression(oDataFieldConverted);\n\t}\n\tlet requiredPropertyFromInsertRestrictionsExpression: BindingToolkitExpression<boolean> = constant(false);\n\tlet requiredPropertyFromUpdateRestrictionsExpression: BindingToolkitExpression<boolean> = constant(false);\n\n\tconst oProperty: Property = (isPathAnnotationExpression(oPropertyPath) && oPropertyPath.$target) || (oPropertyPath as Property);\n\t// Enablement depends on the field control expression\n\t// If the Field control is statically in Inapplicable (disabled) -> not enabled\n\tconst requiredExpression = isRequiredExpression(oProperty, relativePath);\n\tconst editMode = forceEditMode || UI.IsEditable;\n\tif (aRequiredPropertiesFromInsertRestrictions?.includes(oProperty.name)) {\n\t\trequiredPropertyFromInsertRestrictionsExpression = UI.IsCreateMode;\n\t}\n\tif (aRequiredPropertiesFromUpdateRestrictions?.includes(oProperty.name)) {\n\t\trequiredPropertyFromUpdateRestrictionsExpression = and(UI.IsEditable, not(UI.IsCreateMode));\n\t}\n\tconst returnExpression = or(\n\t\tand(or(requiredExpression, dataFieldRequiredExpression), editMode),\n\t\trequiredPropertyFromInsertRestrictionsExpression,\n\t\trequiredPropertyFromUpdateRestrictionsExpression\n\t);\n\tif (bAsObject) {\n\t\treturn returnExpression;\n\t}\n\treturn compileExpression(returnExpression);\n};\n\nexport const getRequiredExpressionForFieldGroup = function (\n\tdataFieldObjectPath: DataModelObjectPath<AnnotationPath<FieldGroupType>>\n): CompiledBindingToolkitExpression | BindingToolkitExpression<boolean> {\n\treturn compileExpression(and(UI.IsEditable, isRequiredExpression(dataFieldObjectPath.targetObject?.$target)));\n};\n\nexport const getRequiredExpressionForConnectedDataField = function (\n\tdataFieldObjectPath: DataModelObjectPath<AnnotationPath<ConnectedFieldsType>>\n): CompiledBindingToolkitExpression {\n\tconst targetObject = dataFieldObjectPath?.targetObject as DataFieldForAnnotation | undefined;\n\tconst data: Record<string, DataFieldAbstractTypes> = (dataFieldObjectPath?.targetObject?.$target?.Data ??\n\t\t(targetObject?.Target.$target as unknown as AnnotationTerm<ConnectedFieldsTypeTypes>)?.Data ??\n\t\t{}) as unknown as Record<string, DataFieldAbstractTypes>;\n\tconst keys: Array<string> = Object.keys(data);\n\tconst dataFields = [];\n\tlet propertyPath;\n\tconst isRequiredExpressions: (CompiledBindingToolkitExpression | BindingToolkitExpression<boolean>)[] | undefined = [];\n\tfor (const key of keys) {\n\t\tif (data[key]?.[\"$Type\"] && data[key][\"$Type\"]?.includes(\"DataField\")) {\n\t\t\tdataFields.push(data[key]);\n\t\t}\n\t}\n\tfor (const dataField of dataFields) {\n\t\tswitch (dataField.$Type) {\n\t\t\tcase UIAnnotationTypes.DataField:\n\t\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\t\tcase UIAnnotationTypes.DataFieldWithIntentBasedNavigation:\n\t\t\tcase UIAnnotationTypes.DataFieldWithAction:\n\t\t\t\tif (typeof dataField.Value === \"object\") {\n\t\t\t\t\tpropertyPath = dataField.Value.$target;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\t\t\tif (dataField.Target?.$target) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tisAnnotationOfType<DataField | DataPointType>(dataField.Target.$target, [\n\t\t\t\t\t\t\tUIAnnotationTypes.DataField,\n\t\t\t\t\t\t\tUIAnnotationTypes.DataPointType\n\t\t\t\t\t\t])\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (typeof dataField.Target.$target.Value === \"object\") {\n\t\t\t\t\t\t\tpropertyPath = dataField.Target.$target.Value.$target;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (typeof dataField.Target === \"object\") {\n\t\t\t\t\t\t\tpropertyPath = dataField.Target.$target;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t// no default\n\t\t}\n\t\tisRequiredExpressions.push(getRequiredExpressionAsObject(propertyPath, dataField, false));\n\t}\n\treturn compileExpression(or(...(isRequiredExpressions as BindingToolkitExpression<boolean>[])));\n};\n\n/**\n * Check if header facet or action is visible.\n * @param targetObject Header facets or Actions\n * @param navigationProperties Navigation properties to be considered\n * @returns BindingToolkitExpression<boolean>\n */\nexport function isVisible(\n\ttargetObject:\n\t\t| DataFieldAbstractTypes\n\t\t| DataPointTypeTypes\n\t\t| ReferenceFacet\n\t\t| CollectionFacet\n\t\t| DataFieldForActionTypes\n\t\t| FieldGroup\n\t\t| Property\n\t\t| undefined,\n\tnavigationProperties?: string[]\n): BindingToolkitExpression<boolean> {\n\treturn not(equal(getExpressionFromAnnotation(targetObject?.annotations?.UI?.Hidden, navigationProperties), true));\n}\n\n/**\n * Checks whether action parameter is supports multi line input.\n * @param dataModelObjectPath Object path to the action parameter.\n * @returns Boolean\n */\nexport const isMultiLine = function (dataModelObjectPath: DataModelObjectPath<ActionParameter>): boolean {\n\treturn isMultiLineText(dataModelObjectPath.targetObject);\n};\n\n/**\n * Check if the action is enabled.\n * @param actionTarget Action\n * @param convertedTypes ConvertedMetadata\n * @param dataModelObjectPath DataModelObjectPath\n * @param pathFromContextLocation Boolean\n * @returns BindingToolkitExpression\n */\nexport function getActionEnabledExpression(\n\tactionTarget: Action,\n\tconvertedTypes: ConvertedMetadata,\n\tdataModelObjectPath?: DataModelObjectPath<PageContextPathTarget>,\n\tpathFromContextLocation?: boolean\n): BindingToolkitExpression<boolean> {\n\tconst operationAvailableIsAnnotated =\n\t\tactionTarget.annotations.Core?.OperationAvailable?.term === CoreAnnotationTerms.OperationAvailable;\n\n\tif (!operationAvailableIsAnnotated) {\n\t\t// OperationAvailable term doesn't exist for the action\n\t\treturn constant(true);\n\t}\n\n\tlet prefix = \"\";\n\tif (\n\t\tdataModelObjectPath &&\n\t\tpathFromContextLocation &&\n\t\tpathFromContextLocation === true &&\n\t\tdataModelObjectPath.contextLocation?.targetEntityType &&\n\t\tdataModelObjectPath.contextLocation.targetEntityType !== actionTarget.sourceEntityType\n\t) {\n\t\tconst navigations = getRelativePaths(dataModelObjectPath);\n\t\tlet sourceActionDataModelObject = enhanceDataModelPath(dataModelObjectPath.contextLocation);\n\t\t//Start from contextLocation and navigate until the source entityType of the action to get the right prefix\n\t\tfor (const nav of navigations) {\n\t\t\tsourceActionDataModelObject = enhanceDataModelPath(sourceActionDataModelObject, nav);\n\t\t\tif (sourceActionDataModelObject.targetEntityType === actionTarget.sourceEntityType) {\n\t\t\t\tprefix = `${getRelativePaths(sourceActionDataModelObject).join(\"/\")}/`;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tconst bindingParameterFullName = actionTarget.isBound ? actionTarget.parameters[0]?.fullyQualifiedName : undefined;\n\tconst operationAvailableExpression = getExpressionFromAnnotation(\n\t\tactionTarget.annotations.Core?.OperationAvailable,\n\t\t[],\n\t\tundefined,\n\t\t(path: string) => `${prefix}${bindingContextPathVisitor(path, convertedTypes, bindingParameterFullName)}`\n\t);\n\n\treturn equal(operationAvailableExpression, true);\n}\n\n/**\n * Generates the expression to check if the quickView facet is visible.\n * @param facetModelPath\n * @returns BindingToolkitExpression The binding expression of the visibility\n */\nexport function isQuickViewFacetVisible(facetModelPath: DataModelObjectPath<ReferenceFacet>): CompiledBindingToolkitExpression {\n\tlet targetVisible: BindingToolkitExpression<boolean> = constant(true);\n\tif (isAnnotationOfType<FieldGroup>(facetModelPath.targetObject?.Target?.$target, UIAnnotationTypes.FieldGroupType)) {\n\t\ttargetVisible = isVisible(facetModelPath.targetObject?.Target?.$target);\n\t}\n\treturn compileExpression(and(isVisible(facetModelPath.targetObject), targetVisible));\n}\n\n/*\n * Get visiblity of breadcrumbs.\n *\n * @function\n * @param {Object} [oViewData] ViewData model\n * returns {*} Expression or a Boolean value\n */\nexport const getVisibleExpressionForBreadcrumbs = function (viewData: ViewData): string | boolean | undefined {\n\treturn viewData.breadcrumbsHierarchyMode && viewData.fclEnabled === true\n\t\t? \"{fclhelper>/breadCrumbIsVisible}\"\n\t\t: !!viewData.breadcrumbsHierarchyMode;\n};\n"],"mappings":"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","ignoreList":[]}