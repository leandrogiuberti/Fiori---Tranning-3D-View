{"version":3,"file":"DataModelPathHelper.js","names":["getRelativePaths","contextPath","skipCleanup","getPathRelativeLocation","contextLocation","navigationProperties","map","np","name","_exports","visitedNavProps","arguments","length","undefined","cleanUpNavProp","navProps","currentIdx","currentNav","nextNavProp","isNavigationProperty","partner","splice","getAdditionalNavProp","referenceProps","otherProps","keepReference","additionalNavProps","forEach","navProp","navIndex","push","remainingNavProps","concat","slice","extraNavProp","targetType","find","enhanceDataModelPath","dataModelObjectPath","propertyPath","sPropertyPath","isPathAnnotationExpression","path","target","$target","containsAComplexType","convertedTypes","resolvePath","getTargetNavigationPath","startsWith","substring","targetEntityType","pathSplits","split","newDataModelObjectPath","pathPart","enhanceFromPath","targetObject","targetEntitySet","navigationIndex","referenceEntityType","isEntityType","isComplexType","currentEntitySet","potentialNavProp","navigationPathFromPreviousEntitySet","getNavigationBindingFromPreviousEntitySet","navigationPropertyBinding","hasOwnProperty","potentialComplexType","entityProperties","properties","_type","startingEntitySet","navigation","navigationPropertyLength","lastNavigation","isComplexTypeLastNavigation","navigationPath","i","navigationProperty","getTargetEntitySetPath","initialPath","targetEntitySetPath","replace","bRelative","setTrailingSlash","join","getTargetObjectPath","isServiceObject","isEntitySet","isProperty","isAnnotationTerm","term","qualifier","getContextRelativeTargetObjectPath","forBindingExpression","forFilterConditionPath","_getContextRelativeTargetObjectPath","navProperties","some","isMultipleNavigationProperty","isCollection","isPropertyPathExpression","value","getContextPropertyRestriction","checkFunction","onContext","source","lastNavProp","annotations","Capabilities","isPathUpdatable","extractionParametersOnPath","checkOnPath","annotationObject","UpdateRestrictions","Updatable","getHierarchyParentNavigationPropertyPath","hierarchyQualifier","Aggregation","ParentNavigationProperty","fullyQualifiedName","getNonUpdatableNavigationProperties","nonUpdatableNavigationProperties","NonUpdatableNavigationProperties","nonUpdatableNavigationProperty","navigationPropertyPath","isPathSearchable","SearchRestrictions","Searchable","isPathDeletable","DeleteRestrictions","Deletable","isPathInsertable","InsertRestrictions","Insertable","isPathFilterable","FilterRestrictions","Filterable","checkFilterExpressionRestrictions","allowedExpression","filterExpressionRestrictions","FilterExpressionRestrictions","currentObjectRestriction","restriction","Property","includes","AllowedExpressions","toString","getTargetEntitySetInfo","resetVisitedNavProps","visitedNavigationPropsName","parentEntitySet","parentNavigationPath","containsTarget","checkOnParentNavigation","navigationProps","restrictions","restrictedNavProp","NavigationRestrictions","RestrictedProperties","NavigationProperty","restrictionDefinition","valueOf","isConstant","getExpressionFromAnnotation","constant","_navigationProps","pathRelativeLocation","pathVisitorFunction","pathVisitor","getPathVisitorForSingleton","equal","checkOnTarget","targetRestrictions","ignoreTargetCollection","authorizeUnresolvable","unresolvableExpression","endsWith"],"sources":["./DataModelPathHelper.ts"],"sourcesContent":["import type {\n\tComplexType,\n\tConvertedMetadata,\n\tEntitySet,\n\tEntityType,\n\tNavigationProperty,\n\tProperty,\n\tPropertyPath,\n\tServiceObject,\n\tSingleton\n} from \"@sap-ux/vocabularies-types\";\nimport type { NavigationPropertyPath } from \"@sap-ux/vocabularies-types/Edm\";\nimport type {\n\tFilterExpressionRestrictionTypeTypes,\n\tNavigationPropertyRestriction\n} from \"@sap-ux/vocabularies-types/vocabularies/Capabilities\";\nimport type {\n\tEntitySetAnnotations_Capabilities,\n\tEntityTypeAnnotations_Capabilities,\n\tSingletonAnnotations_Capabilities\n} from \"@sap-ux/vocabularies-types/vocabularies/Capabilities_Edm\";\nimport type { BindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport { constant, equal, getExpressionFromAnnotation, isConstant, unresolvableExpression } from \"sap/fe/base/BindingToolkit\";\nimport type { PageContextPathTarget } from \"sap/fe/core/converters/TemplateConverter\";\nimport {\n\tisAnnotationTerm,\n\tisComplexType,\n\tisEntitySet,\n\tisEntityType,\n\tisMultipleNavigationProperty,\n\tisNavigationProperty,\n\tisPathAnnotationExpression,\n\tisProperty,\n\tisPropertyPathExpression,\n\tisServiceObject\n} from \"sap/fe/core/helpers/TypeGuards\";\nimport type { PropertyOrPath } from \"sap/fe/core/templating/DisplayModeFormatter\";\n\nexport type DataModelObjectContext = {\n\tstartingEntitySet: Singleton | EntitySet;\n\tnavigationProperties: (NavigationProperty | Property)[];\n\ttargetEntitySet?: Singleton | EntitySet;\n\ttargetEntityType: EntityType;\n\tconvertedTypes: ConvertedMetadata;\n};\n\nexport type DataModelObjectPath<T> = DataModelObjectContext & {\n\tcontextLocation?: DataModelObjectContext;\n\ttargetObject?: T;\n};\n\ntype ExtractionParametersOnPath = {\n\tpropertyPath?: PropertyOrPath<Property>;\n\tpathVisitor?: Function;\n\tignoreTargetCollection?: boolean;\n\tauthorizeUnresolvable?: boolean;\n};\n\n/**\n * Function that returns the relative path to the property from the DataModelObjectPath.\n * @param contextPath The DataModelObjectPath object to the property\n * @param skipCleanup Don't clean up circular navigation properties\n * @returns The path from the root entity set\n */\nexport const getRelativePaths = function (contextPath: DataModelObjectPath<unknown> | undefined, skipCleanup?: boolean): string[] {\n\treturn getPathRelativeLocation(contextPath?.contextLocation, contextPath?.navigationProperties, skipCleanup).map((np) => np.name);\n};\n\n/**\n * Gets the navigation properties from a dataModelObjectPath to the targeted navigation properties.\n * @param contextPath The dataModelObjectPath\n * @param visitedNavProps The targeted navigation properties\n * @param skipCleanup Don't clean up circular navigation properties\n * @returns An array of navigation properties to reach the targeted navigation properties\n */\nexport const getPathRelativeLocation = function (\n\tcontextPath?: DataModelObjectContext,\n\tvisitedNavProps: (NavigationProperty | Property)[] = [],\n\tskipCleanup = false\n): (NavigationProperty | Property)[] {\n\tconst cleanUpNavProp = (navProps: (NavigationProperty | Property)[]): (NavigationProperty | Property)[] => {\n\t\tlet currentIdx = 0;\n\t\twhile (navProps.length > 1 && currentIdx != navProps.length - 1) {\n\t\t\tconst currentNav = navProps[currentIdx];\n\t\t\tconst nextNavProp = navProps[currentIdx + 1];\n\t\t\tif (isNavigationProperty(currentNav) && currentNav.partner === nextNavProp.name) {\n\t\t\t\tnavProps.splice(currentIdx, 2);\n\t\t\t} else {\n\t\t\t\tcurrentIdx++;\n\t\t\t}\n\t\t}\n\t\treturn navProps;\n\t};\n\n\tconst getAdditionalNavProp = (\n\t\treferenceProps: (NavigationProperty | Property)[],\n\t\totherProps: (NavigationProperty | Property)[],\n\t\tkeepReference: boolean\n\t): (NavigationProperty | Property)[] => {\n\t\tconst additionalNavProps: (NavigationProperty | Property)[] = [];\n\t\treferenceProps.forEach((navProp, navIndex) => {\n\t\t\tif (otherProps[navIndex] !== navProp) {\n\t\t\t\tadditionalNavProps.push(keepReference ? navProp : otherProps[navIndex]);\n\t\t\t}\n\t\t});\n\t\treturn additionalNavProps;\n\t};\n\n\tif (!contextPath) {\n\t\treturn visitedNavProps;\n\t}\n\tif (visitedNavProps.length >= contextPath.navigationProperties.length) {\n\t\tlet remainingNavProps = getAdditionalNavProp(contextPath.navigationProperties, visitedNavProps, false);\n\t\tremainingNavProps = remainingNavProps.concat(visitedNavProps.slice(contextPath.navigationProperties.length));\n\t\treturn skipCleanup ? remainingNavProps : cleanUpNavProp(remainingNavProps);\n\t}\n\tlet extraNavProp = getAdditionalNavProp(visitedNavProps, contextPath.navigationProperties, true);\n\textraNavProp = extraNavProp.concat(contextPath.navigationProperties.slice(visitedNavProps.length));\n\tif (!skipCleanup) {\n\t\tcleanUpNavProp(extraNavProp);\n\t}\n\textraNavProp = extraNavProp.map((navProp) => {\n\t\treturn isNavigationProperty(navProp)\n\t\t\t? (navProp.targetType.navigationProperties.find((np) => np.name === navProp.partner) as NavigationProperty)\n\t\t\t: navProp;\n\t});\n\treturn extraNavProp;\n};\n\n/**\n * Gets a new enhanced dataModelObjectPath matching with the provided property.\n * @param dataModelObjectPath The initial dataModelObjectPath\n * @param propertyPath The property path or property to reach\n * @returns A new dataModelObjectPath\n */\nexport const enhanceDataModelPath = function <T>(\n\tdataModelObjectPath: DataModelObjectPath<unknown> | DataModelObjectContext,\n\tpropertyPath?: PropertyOrPath<Property>\n): DataModelObjectPath<T> {\n\tlet sPropertyPath = \"\";\n\tif (isPathAnnotationExpression(propertyPath)) {\n\t\tsPropertyPath = propertyPath.path;\n\t} else if (typeof propertyPath === \"string\") {\n\t\tsPropertyPath = propertyPath;\n\t}\n\tlet target;\n\tif (isPathAnnotationExpression(propertyPath)) {\n\t\ttarget = propertyPath.$target;\n\t} else if (containsAComplexType(dataModelObjectPath)) {\n\t\ttarget = dataModelObjectPath.convertedTypes.resolvePath(`${getTargetNavigationPath(dataModelObjectPath)}/${sPropertyPath}`)?.target;\n\t} else {\n\t\tif (sPropertyPath.startsWith(\"/\")) {\n\t\t\t// remove the leading \"/\" because the path is going to be resolved from the entity type, so it should not be absolute\n\t\t\tsPropertyPath = sPropertyPath.substring(1);\n\t\t}\n\t\ttarget = dataModelObjectPath.targetEntityType.resolvePath(sPropertyPath);\n\t}\n\n\tconst pathSplits = sPropertyPath.split(\"/\");\n\n\tlet newDataModelObjectPath: DataModelObjectPath<T> = dataModelObjectPath as DataModelObjectPath<T>;\n\tfor (const pathPart of pathSplits) {\n\t\tnewDataModelObjectPath = enhanceFromPath(newDataModelObjectPath, pathPart);\n\t}\n\tnewDataModelObjectPath.targetObject = target;\n\treturn newDataModelObjectPath;\n};\n\n/**\n * Gets a new enhanced dataModelObjectPath matching with the provided path\n * The targetObject is not updated by this internal function.\n * @param dataModelObjectPath The initial dataModelObjectPath\n * @param path The object path to reach\n * @returns A new dataModelObjectPath\n */\n\nconst enhanceFromPath = function <T>(dataModelObjectPath: DataModelObjectPath<unknown>, path: string): DataModelObjectPath<T> {\n\tlet targetEntitySet: EntitySet | undefined;\n\tlet targetEntityType: EntityType | undefined;\n\tconst navigationProperties = dataModelObjectPath.navigationProperties.concat();\n\tconst navigationIndex = navigationProperties.length;\n\tconst referenceEntityType = navigationIndex\n\t\t? navigationProperties[navigationIndex - 1].targetType\n\t\t: dataModelObjectPath.targetEntityType;\n\tif (!referenceEntityType) {\n\t\treturn dataModelObjectPath as DataModelObjectPath<T>;\n\t} else if (isEntityType(referenceEntityType) || isComplexType(referenceEntityType)) {\n\t\tconst currentEntitySet = dataModelObjectPath.targetEntitySet;\n\t\tconst potentialNavProp = referenceEntityType.navigationProperties.find((navProp) => navProp.name === path);\n\t\tif (potentialNavProp) {\n\t\t\tnavigationProperties.push(potentialNavProp);\n\t\t\ttargetEntityType = potentialNavProp.targetType;\n\n\t\t\tconst navigationPathFromPreviousEntitySet = getNavigationBindingFromPreviousEntitySet(navigationProperties);\n\t\t\tif (\n\t\t\t\tnavigationPathFromPreviousEntitySet &&\n\t\t\t\tcurrentEntitySet?.navigationPropertyBinding.hasOwnProperty(navigationPathFromPreviousEntitySet)\n\t\t\t) {\n\t\t\t\ttargetEntitySet = currentEntitySet.navigationPropertyBinding[navigationPathFromPreviousEntitySet] as EntitySet;\n\t\t\t}\n\t\t} else {\n\t\t\tconst potentialComplexType = (\n\t\t\t\t(referenceEntityType as EntityType).entityProperties || (referenceEntityType as ComplexType).properties\n\t\t\t).find((navProp) => navProp.name === path);\n\t\t\tif (potentialComplexType?.targetType?._type === \"ComplexType\") {\n\t\t\t\tnavigationProperties.push(potentialComplexType);\n\t\t\t}\n\t\t}\n\t}\n\treturn {\n\t\tstartingEntitySet: dataModelObjectPath.startingEntitySet,\n\t\tnavigationProperties: navigationProperties,\n\t\tcontextLocation: dataModelObjectPath.contextLocation,\n\t\ttargetEntitySet: targetEntitySet ?? dataModelObjectPath.targetEntitySet,\n\t\ttargetEntityType: targetEntityType ?? dataModelObjectPath.targetEntityType,\n\t\ttargetObject: dataModelObjectPath.targetObject as T,\n\t\tconvertedTypes: dataModelObjectPath.convertedTypes\n\t};\n};\n\n/**\n * Detects if the DataModelObjectPath has navigated threw a complexType.\n * @param dataModelObjectPath The dataModelObjectPath\n * @returns Is there a complexType into the DataModelObjectPath.\n */\nconst containsAComplexType = function (dataModelObjectPath: DataModelObjectContext): boolean {\n\treturn dataModelObjectPath.navigationProperties.find((navigation) => isComplexType(navigation?.targetType)) !== undefined;\n};\n\n/**\n * Gets the navigation binding from the previous entitySet listed into the navigation properties.\n * @param navigationProperties The navigation properties\n * @returns A new dataModelObjectPath.\n */\nconst getNavigationBindingFromPreviousEntitySet = function (navigationProperties: (NavigationProperty | Property)[]): string {\n\tconst navigationPropertyLength = navigationProperties.length;\n\tif (navigationPropertyLength) {\n\t\tconst lastNavigation = navigationProperties[navigationPropertyLength - 1];\n\t\tconst isComplexTypeLastNavigation = isComplexType(lastNavigation.targetType);\n\t\tlet navigationPath = \"\";\n\t\tif (navigationPropertyLength > 1 && !isComplexTypeLastNavigation) {\n\t\t\tfor (let i = 0; i < navigationPropertyLength - 1; i++) {\n\t\t\t\tconst navigationProperty = navigationProperties[i];\n\t\t\t\tif (isComplexType(navigationProperty.targetType)) {\n\t\t\t\t\tnavigationPath += `${navigationProperty.name}/`;\n\t\t\t\t} else {\n\t\t\t\t\tnavigationPath = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn isComplexTypeLastNavigation ? \"\" : `${navigationPath}${lastNavigation.name}`;\n\t}\n\treturn \"\";\n};\n\n/**\n * Gets the path of the targeted entitySet.\n * @param dataModelObjectPath The dataModelObjectPath\n * @returns The path.\n */\nexport const getTargetEntitySetPath = function (dataModelObjectPath: DataModelObjectPath<unknown>): string {\n\tconst initialPath = `/${dataModelObjectPath.startingEntitySet.name}`;\n\tlet targetEntitySetPath = initialPath;\n\tlet currentEntitySet = dataModelObjectPath.startingEntitySet;\n\tconst navigationProperties = dataModelObjectPath.navigationProperties;\n\tlet navigationPath: string;\n\tfor (let i = 0; i < navigationProperties.length; i++) {\n\t\tnavigationPath = getNavigationBindingFromPreviousEntitySet(navigationProperties.slice(0, i + 1));\n\t\tif (currentEntitySet && currentEntitySet.navigationPropertyBinding.hasOwnProperty(navigationPath)) {\n\t\t\ttargetEntitySetPath += `/$NavigationPropertyBinding/${navigationPath.replace(\"/\", \"%2F\")}`;\n\t\t\tcurrentEntitySet = currentEntitySet.navigationPropertyBinding[navigationPath] as EntitySet;\n\t\t}\n\t}\n\n\ttargetEntitySetPath += \"/$\";\n\treturn targetEntitySetPath;\n};\n\n/**\n * Gets the path of the targeted navigation.\n * @param dataModelObjectPath The dataModelObjectPath\n * @param bRelative\n * @returns The path.\n */\n\nexport const getTargetNavigationPath = function (dataModelObjectPath: DataModelObjectPath<unknown>, bRelative = false): string {\n\tlet path = \"\";\n\tif (!dataModelObjectPath.startingEntitySet) {\n\t\treturn \"/\";\n\t}\n\tif (!bRelative) {\n\t\tpath += `/${dataModelObjectPath.startingEntitySet.name}`;\n\t}\n\tif (dataModelObjectPath.navigationProperties.length > 0) {\n\t\tpath = setTrailingSlash(path);\n\t\tpath += dataModelObjectPath.navigationProperties.map((navProp) => navProp.name).join(\"/\");\n\t}\n\treturn path;\n};\n\n/**\n * Gets the path of the targeted object.\n * @param dataModelObjectPath The dataModelObjectPath\n * @param bRelative\n * @returns The path.\n */\nexport const getTargetObjectPath = function (dataModelObjectPath: DataModelObjectPath<unknown>, bRelative = false): string {\n\tlet path = getTargetNavigationPath(dataModelObjectPath, bRelative);\n\tif (\n\t\tisServiceObject(dataModelObjectPath.targetObject) &&\n\t\t!isNavigationProperty(dataModelObjectPath.targetObject) &&\n\t\t!isEntityType(dataModelObjectPath.targetObject) &&\n\t\t!isEntitySet(dataModelObjectPath.targetObject) &&\n\t\t(!isProperty(dataModelObjectPath.targetObject) || !isComplexType(dataModelObjectPath.targetObject?.targetType)) &&\n\t\tdataModelObjectPath.targetObject !== dataModelObjectPath.startingEntitySet\n\t) {\n\t\tpath = setTrailingSlash(path);\n\t\tpath += `${dataModelObjectPath.targetObject.name}`;\n\t} else if (dataModelObjectPath.targetObject && isAnnotationTerm(dataModelObjectPath.targetObject)) {\n\t\tpath = setTrailingSlash(path);\n\t\tpath += `@${dataModelObjectPath.targetObject.term}`;\n\t\tif (dataModelObjectPath.targetObject.hasOwnProperty(\"qualifier\") && !!dataModelObjectPath.targetObject.qualifier) {\n\t\t\tpath += `#${dataModelObjectPath.targetObject.qualifier}`;\n\t\t}\n\t}\n\treturn path;\n};\n\nexport const getContextRelativeTargetObjectPath = function (\n\tdataModelObjectPath: DataModelObjectPath<unknown>,\n\tforBindingExpression = false,\n\tforFilterConditionPath = false\n): string | undefined {\n\tif (dataModelObjectPath.contextLocation?.startingEntitySet !== dataModelObjectPath.startingEntitySet) {\n\t\treturn getTargetObjectPath(dataModelObjectPath);\n\t}\n\treturn _getContextRelativeTargetObjectPath(dataModelObjectPath, forBindingExpression, forFilterConditionPath);\n};\n\nconst _getContextRelativeTargetObjectPath = function (\n\tdataModelObjectPath: DataModelObjectPath<unknown>,\n\tforBindingExpression = false,\n\tforFilterConditionPath = false\n): string | undefined {\n\tif (!dataModelObjectPath.targetObject) {\n\t\treturn undefined;\n\t}\n\tconst navProperties = getPathRelativeLocation(dataModelObjectPath.contextLocation, dataModelObjectPath.navigationProperties);\n\tif (forBindingExpression) {\n\t\tif (navProperties.some(isMultipleNavigationProperty)) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\tlet path = forFilterConditionPath\n\t\t? navProperties\n\t\t\t\t.map((navProp) => {\n\t\t\t\t\tconst isCollection = isMultipleNavigationProperty(navProp);\n\t\t\t\t\treturn isCollection ? `${navProp.name}*` : navProp.name;\n\t\t\t\t})\n\t\t\t\t.join(\"/\")\n\t\t: navProperties.map((navProp) => navProp.name).join(\"/\");\n\n\tif (\n\t\t((isServiceObject(dataModelObjectPath.targetObject) && dataModelObjectPath.targetObject.name) ||\n\t\t\t(isPropertyPathExpression(dataModelObjectPath.targetObject) && dataModelObjectPath.targetObject.value)) &&\n\t\t!isNavigationProperty(dataModelObjectPath.targetObject) &&\n\t\t!isEntityType(dataModelObjectPath.targetObject) &&\n\t\t!isEntitySet(dataModelObjectPath.targetObject) &&\n\t\t(!isProperty(dataModelObjectPath.targetObject) || !isComplexType(dataModelObjectPath.targetObject?.targetType)) &&\n\t\tdataModelObjectPath.targetObject !== dataModelObjectPath.startingEntitySet\n\t) {\n\t\tpath = setTrailingSlash(path);\n\t\tpath += isPropertyPathExpression(dataModelObjectPath.targetObject)\n\t\t\t? `${dataModelObjectPath.targetObject.value}`\n\t\t\t: `${dataModelObjectPath.targetObject.name}`;\n\t} else if (isAnnotationTerm(dataModelObjectPath.targetObject)) {\n\t\tpath = setTrailingSlash(path);\n\t\tpath += `@${dataModelObjectPath.targetObject.term}`;\n\t\tif (dataModelObjectPath.targetObject.hasOwnProperty(\"qualifier\") && !!dataModelObjectPath.targetObject.qualifier) {\n\t\t\tpath += `#${dataModelObjectPath.targetObject.qualifier}`;\n\t\t}\n\t}\n\treturn path;\n};\n\n/**\n * Gets an array of properties where a specific restriction is applied.\n * @param dataModelObjectPath The dataModelObjectPath\n * @param checkFunction The function testing the restriction and returning the array of properties\n * @param onContext Is the restriction tested on the target object or its context\n * @returns The properties.\n */\nexport const getContextPropertyRestriction = (\n\tdataModelObjectPath: DataModelObjectPath<unknown>,\n\tcheckFunction: (\n\t\tcapabilities: EntitySetAnnotations_Capabilities | SingletonAnnotations_Capabilities | undefined\n\t) => PropertyPath[] | undefined,\n\tonContext = true\n): PropertyPath[] => {\n\tconst source = onContext ? dataModelObjectPath.contextLocation : dataModelObjectPath;\n\tconst lastNavProp = source?.navigationProperties?.slice(-1)[0];\n\tconst properties = checkFunction(lastNavProp?.annotations?.Capabilities);\n\treturn properties?.length ? properties : checkFunction(source?.targetEntitySet?.annotations?.Capabilities) || [];\n};\n\nexport const isPathUpdatable = function (\n\tdataModelObjectPath: DataModelObjectPath<unknown> | undefined,\n\textractionParametersOnPath?: ExtractionParametersOnPath\n): BindingToolkitExpression<boolean> {\n\treturn checkOnPath(\n\t\tdataModelObjectPath,\n\t\t(annotationObject: NavigationPropertyRestriction | EntitySetAnnotations_Capabilities) => {\n\t\t\treturn annotationObject?.UpdateRestrictions?.Updatable;\n\t\t},\n\t\textractionParametersOnPath\n\t);\n};\n\n/**\n * Gets the parent navigation property of the given node hierarchy.\n * @param dataModelObjectPath The dataModelObjectPath\n * @param hierarchyQualifier The qualifier of the hierarchy set in the manifest\n * @returns The parent navigation property.\n */\nexport const getHierarchyParentNavigationPropertyPath = function (\n\tdataModelObjectPath: DataModelObjectPath<unknown>,\n\thierarchyQualifier: string\n): string | undefined {\n\treturn dataModelObjectPath.targetEntityType.annotations.Aggregation?.[`RecursiveHierarchy#${hierarchyQualifier}`]\n\t\t?.ParentNavigationProperty.$target?.fullyQualifiedName;\n};\n\n/**\n * Gets an array of navigation properties where an update restriction is applied.\n * @param dataModelObjectPath The dataModelObjectPath\n * @returns The navigation properties with the restriction.\n */\nexport const getNonUpdatableNavigationProperties = function (\n\tdataModelObjectPath: DataModelObjectPath<PageContextPathTarget>\n): (string | undefined)[] | undefined {\n\t// UpdateRestrictions.NonUpdatableNavigationProperties on the parent navigation:\n\t// REVIEW: This is wrong ? the updateRestriction annotation needs to be on entityset but our test sometimes put it on the navigation property\n\tconst nonUpdatableNavigationProperties = (dataModelObjectPath.targetObject as EntitySet)?.annotations?.Capabilities?.UpdateRestrictions\n\t\t?.NonUpdatableNavigationProperties;\n\tif (nonUpdatableNavigationProperties && nonUpdatableNavigationProperties?.length > 0) {\n\t\treturn nonUpdatableNavigationProperties.map(\n\t\t\t(nonUpdatableNavigationProperty: NavigationPropertyPath) =>\n\t\t\t\tdataModelObjectPath.contextLocation &&\n\t\t\t\tenhanceDataModelPath<ServiceObject>(dataModelObjectPath.contextLocation, nonUpdatableNavigationProperty.value).targetObject!\n\t\t\t\t\t.fullyQualifiedName\n\t\t);\n\t}\n\t// UpdateRestrictions.NonUpdatableNavigationProperties on the entitySet (or entityType):\n\treturn dataModelObjectPath.targetEntitySet?.annotations.Capabilities?.UpdateRestrictions?.NonUpdatableNavigationProperties?.map(\n\t\t(navigationPropertyPath) => navigationPropertyPath.$target?.fullyQualifiedName\n\t);\n};\n\nexport const isPathSearchable = function (\n\tdataModelObjectPath: DataModelObjectPath<unknown> | undefined,\n\textractionParametersOnPath?: ExtractionParametersOnPath\n): BindingToolkitExpression<boolean> {\n\treturn checkOnPath(\n\t\tdataModelObjectPath,\n\t\t(annotationObject: NavigationPropertyRestriction | EntitySetAnnotations_Capabilities) => {\n\t\t\treturn annotationObject?.SearchRestrictions?.Searchable;\n\t\t},\n\t\textractionParametersOnPath\n\t);\n};\n\nexport const isPathDeletable = function (\n\tdataModelObjectPath: DataModelObjectPath<unknown> | undefined,\n\textractionParametersOnPath?: ExtractionParametersOnPath\n): BindingToolkitExpression<boolean> {\n\treturn checkOnPath(\n\t\tdataModelObjectPath,\n\t\t(annotationObject: NavigationPropertyRestriction | EntitySetAnnotations_Capabilities) => {\n\t\t\treturn annotationObject?.DeleteRestrictions?.Deletable;\n\t\t},\n\t\textractionParametersOnPath\n\t);\n};\n\nexport const isPathInsertable = function (\n\tdataModelObjectPath: DataModelObjectPath<unknown> | undefined,\n\textractionParametersOnPath?: ExtractionParametersOnPath\n): BindingToolkitExpression<boolean> {\n\treturn checkOnPath(\n\t\tdataModelObjectPath,\n\t\t(annotationObject: NavigationPropertyRestriction | EntitySetAnnotations_Capabilities) => {\n\t\t\treturn annotationObject?.InsertRestrictions?.Insertable;\n\t\t},\n\t\textractionParametersOnPath\n\t);\n};\n\nexport const isPathFilterable = function (\n\tdataModelObjectPath: DataModelObjectPath<unknown> | undefined,\n\textractionParametersOnPath?: ExtractionParametersOnPath\n): BindingToolkitExpression<boolean> {\n\treturn checkOnPath(\n\t\tdataModelObjectPath,\n\t\t(annotationObject: NavigationPropertyRestriction | EntitySetAnnotations_Capabilities) => {\n\t\t\treturn annotationObject?.FilterRestrictions?.Filterable;\n\t\t},\n\t\textractionParametersOnPath\n\t);\n};\n\nexport const checkFilterExpressionRestrictions = function (\n\tdataModelObjectPath: DataModelObjectPath<unknown>,\n\tallowedExpression: (string | undefined)[]\n): BindingToolkitExpression<boolean> {\n\treturn checkOnPath(\n\t\tdataModelObjectPath,\n\t\t(annotationObject: NavigationPropertyRestriction | EntitySetAnnotations_Capabilities | EntityTypeAnnotations_Capabilities) => {\n\t\t\tif (annotationObject && \"FilterRestrictions\" in annotationObject) {\n\t\t\t\tconst filterExpressionRestrictions: FilterExpressionRestrictionTypeTypes[] =\n\t\t\t\t\t(annotationObject?.FilterRestrictions?.FilterExpressionRestrictions as FilterExpressionRestrictionTypeTypes[]) || [];\n\t\t\t\tconst currentObjectRestriction = filterExpressionRestrictions.find((restriction) => {\n\t\t\t\t\treturn (restriction.Property as PropertyPath).$target === dataModelObjectPath.targetObject;\n\t\t\t\t});\n\t\t\t\tif (currentObjectRestriction) {\n\t\t\t\t\treturn allowedExpression.includes(currentObjectRestriction?.AllowedExpressions?.toString());\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t);\n};\n\ntype EntityOrSingleton = Singleton | EntitySet | null;\n/**\n * Gets the target entitySet, its parent and the navigation path from the parent to the target entitySet\n * The target entitySet pointing to either null (in case of containment navprop a last part), or the actual target (non containment as target)\n * The parent entitySet pointing to the previous entitySet used in the path.\n * @param dataModelObjectPath The dataModelObjectPath\n * @returns The target entityset, its parent and the navigation path\n */\nexport const getTargetEntitySetInfo = (\n\tdataModelObjectPath: DataModelObjectPath<unknown>\n): {\n\tparentEntitySet: EntityOrSingleton;\n\ttargetEntitySet: EntityOrSingleton;\n\tparentNavigationPath: string;\n} => {\n\tlet resetVisitedNavProps = false;\n\tlet visitedNavigationPropsName: string[] = [];\n\tlet currentEntitySet: EntityOrSingleton = dataModelObjectPath.startingEntitySet;\n\tlet parentEntitySet: EntityOrSingleton = null;\n\tlet targetEntitySet: EntityOrSingleton = currentEntitySet;\n\tlet parentNavigationPath = \"\";\n\n\tfor (const navigationProperty of dataModelObjectPath.navigationProperties) {\n\t\tif (resetVisitedNavProps) {\n\t\t\tvisitedNavigationPropsName = [];\n\t\t}\n\t\tvisitedNavigationPropsName.push(navigationProperty.name);\n\t\tparentNavigationPath = visitedNavigationPropsName.join(\"/\");\n\t\tif (isProperty(navigationProperty) || !navigationProperty.containsTarget) {\n\t\t\t// We should have a navigationPropertyBinding associated with the path so far which can consist of ([ContainmentNavProp]/)*[NavProp]\n\t\t\tif (currentEntitySet && currentEntitySet.navigationPropertyBinding.hasOwnProperty(parentNavigationPath)) {\n\t\t\t\tparentEntitySet = currentEntitySet;\n\t\t\t\tcurrentEntitySet = currentEntitySet.navigationPropertyBinding[parentNavigationPath];\n\t\t\t\ttargetEntitySet = currentEntitySet;\n\t\t\t\t// If we reached a navigation property with a navigationpropertybinding, we need to reset the visited path on the next iteration (if there is one)\n\t\t\t\tresetVisitedNavProps = true;\n\t\t\t} else {\n\t\t\t\t// We really should not end up here but at least let's try to avoid incorrect behavior\n\t\t\t\tparentEntitySet = currentEntitySet;\n\t\t\t\tcurrentEntitySet = null;\n\t\t\t\tresetVisitedNavProps = true;\n\t\t\t}\n\t\t} else {\n\t\t\tparentEntitySet = currentEntitySet;\n\t\t\ttargetEntitySet = null;\n\t\t}\n\t}\n\n\treturn { parentEntitySet, targetEntitySet, parentNavigationPath };\n};\n\n/**\n * Gets the restrictions set on the parent navigation.\n * @param dataModelObjectPath The dataModelObjectPath\n * @param checkFunction The function to check the annotation\n * @param extractionParametersOnPath The extraction parameters\n * @returns The binding expression.\n */\nconst checkOnParentNavigation = (\n\tdataModelObjectPath: DataModelObjectPath<unknown>,\n\tcheckFunction: Function,\n\textractionParametersOnPath?: ExtractionParametersOnPath\n): BindingToolkitExpression<boolean> | undefined => {\n\tconst navigationProps = dataModelObjectPath.navigationProperties;\n\tconst { parentEntitySet, parentNavigationPath } = getTargetEntitySetInfo(dataModelObjectPath);\n\tlet restrictions: BindingToolkitExpression<boolean> | undefined, visitedNavProps: (Property | NavigationProperty)[];\n\tfor (const restrictedNavProp of parentEntitySet?.annotations?.Capabilities?.NavigationRestrictions?.RestrictedProperties ?? []) {\n\t\tif (parentNavigationPath === restrictedNavProp.NavigationProperty.value) {\n\t\t\tconst restrictionDefinition = checkFunction(restrictedNavProp)?.valueOf();\n\t\t\tif (restrictionDefinition !== undefined) {\n\t\t\t\tif (isConstant(getExpressionFromAnnotation(restrictionDefinition))) {\n\t\t\t\t\trestrictions = constant(restrictionDefinition);\n\t\t\t\t} else {\n\t\t\t\t\tconst _navigationProps = navigationProps.slice(0, -1);\n\t\t\t\t\tvisitedNavProps = _navigationProps;\n\t\t\t\t\tif (\n\t\t\t\t\t\tdataModelObjectPath.contextLocation &&\n\t\t\t\t\t\tvisitedNavProps.length < dataModelObjectPath.contextLocation?.navigationProperties.length && // We need to go backward to get the relative path\n\t\t\t\t\t\t!(navigationProps[navigationProps.length - 1] as NavigationProperty).partner\n\t\t\t\t\t) {\n\t\t\t\t\t\t// To go backward we need the partner\n\t\t\t\t\t\trestrictions = undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pathRelativeLocation = getPathRelativeLocation(dataModelObjectPath.contextLocation, visitedNavProps).map(\n\t\t\t\t\t\t\t(np) => np.name\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst pathVisitorFunction = extractionParametersOnPath?.pathVisitor\n\t\t\t\t\t\t\t? getPathVisitorForSingleton(extractionParametersOnPath.pathVisitor, pathRelativeLocation)\n\t\t\t\t\t\t\t: undefined; // send pathVisitor function only when it is defined and only send function or defined as a parameter\n\t\t\t\t\t\trestrictions = equal(\n\t\t\t\t\t\t\tgetExpressionFromAnnotation(restrictionDefinition, pathRelativeLocation, undefined, pathVisitorFunction),\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn restrictions;\n};\n\n/**\n * Gets the restrictions set on the target entitySet.\n * @param dataModelObjectPath The dataModelObjectPath\n * @param checkFunction The function to check the annotation\n * @param extractionParametersOnPath The extraction parameters\n * @returns The binding expression.\n */\nconst checkOnTarget = (\n\tdataModelObjectPath: DataModelObjectPath<unknown>,\n\tcheckFunction: Function,\n\textractionParametersOnPath?: ExtractionParametersOnPath\n): BindingToolkitExpression<boolean> | undefined => {\n\tconst targetEntityType: EntityType | null = dataModelObjectPath.targetEntityType;\n\tlet targetRestrictions;\n\tconst { targetEntitySet } = getTargetEntitySetInfo(dataModelObjectPath);\n\tlet restrictionDefinition = checkFunction(targetEntitySet?.annotations?.Capabilities);\n\tif (targetEntitySet === null && restrictionDefinition === undefined) {\n\t\trestrictionDefinition = checkFunction(targetEntityType?.annotations?.Capabilities);\n\t}\n\tif (restrictionDefinition !== undefined) {\n\t\tconst pathRelativeLocation = getRelativePaths(dataModelObjectPath);\n\t\tconst pathVisitorFunction = extractionParametersOnPath?.pathVisitor\n\t\t\t? getPathVisitorForSingleton(extractionParametersOnPath.pathVisitor, pathRelativeLocation)\n\t\t\t: undefined;\n\t\ttargetRestrictions = equal(\n\t\t\tgetExpressionFromAnnotation(restrictionDefinition, pathRelativeLocation, undefined, pathVisitorFunction),\n\t\t\ttrue\n\t\t);\n\t}\n\treturn targetRestrictions;\n};\n\n/**\n * Gets the restrictions applied on the target\n * The restriction is caluclated according to the parent and the target.\n * @param dataModelObjectPath The dataModelObjectPath\n * @param checkFunction The function to check the annotation\n * @param extractionParametersOnPath The extraction parameters\n * @returns The binding expression.\n */\nexport const checkOnPath = function (\n\tdataModelObjectPath: DataModelObjectPath<unknown> | undefined,\n\tcheckFunction: Function,\n\textractionParametersOnPath?: ExtractionParametersOnPath\n): BindingToolkitExpression<boolean> {\n\tif (!dataModelObjectPath || !dataModelObjectPath.startingEntitySet) {\n\t\treturn constant(true);\n\t}\n\n\tdataModelObjectPath = enhanceDataModelPath(dataModelObjectPath, extractionParametersOnPath?.propertyPath);\n\n\t// Restrictions should be evaluated as ParentEntitySet.NavRestrictions[NavPropertyPath] || TargetEntitySet.Restrictions\n\tconst restrictions = checkOnParentNavigation(dataModelObjectPath, checkFunction, extractionParametersOnPath);\n\tconst targetRestrictions = extractionParametersOnPath?.ignoreTargetCollection\n\t\t? undefined\n\t\t: checkOnTarget(dataModelObjectPath, checkFunction, extractionParametersOnPath);\n\n\treturn (\n\t\trestrictions || targetRestrictions || (extractionParametersOnPath?.authorizeUnresolvable ? unresolvableExpression : constant(true))\n\t);\n};\n\n/**\n * Set a trailing slash to a path if not already set.\n * @param path The path\n * @returns The path with a trailing slash\n */\nconst setTrailingSlash = function (path: string): string {\n\tif (path.length && !path.endsWith(\"/\")) {\n\t\treturn `${path}/`;\n\t}\n\treturn path;\n};\n\n// This helper method is used to add relative path location argument to singletonPathVisitorFunction i.e. pathVisitor\n// pathVisitor method is used later to get the correct bindings for singleton entity\n// method is invoked later in pathInModel() method to get the correct binding.\nconst getPathVisitorForSingleton = function (pathVisitor: Function, pathRelativeLocation: string[]): Function {\n\treturn function (path: string) {\n\t\treturn pathVisitor(path, pathRelativeLocation);\n\t};\n};\n"],"mappings":"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","ignoreList":[]}