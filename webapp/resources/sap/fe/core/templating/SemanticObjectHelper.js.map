{"version":3,"file":"SemanticObjectHelper.js","names":["getDynamicPathFromSemanticObject","semanticObject","dynamicSemObjectRegex","match","startsWith","length","_exports","hasSemanticObject","property","_propertyCommonAnnotations","annotations","Common","key","term","getSemanticObjects","semanticObjects","annotation","isAnnotationOfTerm","push","getSemanticObjectMappings","semanticObjectMappings","getSemanticObjectUnavailableActions","semanticObjectUnavailableActions","getPropertyWithSemanticObject","dataModelObjectPath","propertyWithSemanticObject","targetObject","navigationProperties","navProperty","contextLocation","find","contextNavProp","fullyQualifiedName","getSemanticObjectsAndQualifierMap","qualifierMap","semanticObjectsList","semanticObjectsExpressionList","undefined","semanticObjectExpression","getExpressionFromAnnotation","compiledSemanticObject","compileExpression","includes","qualifier","getReachableSemanticObjectsSettings","semanticObjectsCurrentUserCanNavigateTo","semanticObjectList","dynamicSemanticObjectsList","result","actualSemanticObject","forEach","_type","hasReachableStaticSemanticObject","dynamicSemanticObjects","manageSemanticObjectsForCurrentUser","dataModelPath","internalDataModel","getProperty","propertySemanticObjectList","propertyWithSemanticObjectFromNavigation","isNavigationProperty","SemanticObject","semanticObjectValue","customSemanticObjects","JSON","parse","internalSemanticObject","semanticObjectExpressionFromField","resolveBindingString"],"sources":["./SemanticObjectHelper.ts"],"sourcesContent":["import type { NavigationProperty, Property } from \"@sap-ux/vocabularies-types\";\nimport type {\n\tSemanticObject,\n\tSemanticObjectMapping,\n\tSemanticObjectUnavailableActions\n} from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport { CommonAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport type { DataFieldAbstractTypes, DataPointType } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport {\n\tcompileExpression,\n\tgetExpressionFromAnnotation,\n\tresolveBindingString,\n\ttype BindingToolkitExpression,\n\ttype CompiledBindingToolkitExpression\n} from \"sap/fe/base/BindingToolkit\";\nimport { isAnnotationOfTerm, isNavigationProperty } from \"sap/fe/core/helpers/TypeGuards\";\nimport type { DataModelObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport type { PropertyBindingInfo } from \"sap/ui/base/ManagedObject\";\nimport type JSONModel from \"sap/ui/model/json/JSONModel\";\n\ntype PropertyOrNavigationProperty = Property | NavigationProperty | undefined;\n\n/**\n * Get the path of the semantic object if it is a dynamic SemanticObject.\n * @param semanticObject The value of the Common.SemanticObject annotation.\n * @returns  The path of the semantic object if it is a dynamic SemanticObject, null otherwise.\n */\nexport const getDynamicPathFromSemanticObject = (semanticObject: string): string | null => {\n\tconst dynamicSemObjectRegex = semanticObject?.match(/{(.*?)}/);\n\tif (semanticObject?.startsWith(\"{=\")) {\n\t\treturn semanticObject;\n\t}\n\tif (dynamicSemObjectRegex?.length && dynamicSemObjectRegex.length > 1) {\n\t\treturn dynamicSemObjectRegex[1];\n\t}\n\treturn null;\n};\n\n/**\n * Check whether a property or a NavigationProperty has a semantic object defined or not.\n * @param property The target property\n * @returns `true` if it has a semantic object\n */\nexport const hasSemanticObject = function (property: Property | NavigationProperty | DataFieldAbstractTypes | DataPointType): boolean {\n\tconst _propertyCommonAnnotations = property.annotations?.Common as Record<string, { term?: CommonAnnotationTerms; qualifier?: string }>;\n\tif (_propertyCommonAnnotations) {\n\t\tfor (const key in _propertyCommonAnnotations) {\n\t\t\tif (_propertyCommonAnnotations[key]?.term === CommonAnnotationTerms.SemanticObject) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n};\n\nexport const getSemanticObjects = function (property: Property | NavigationProperty): SemanticObject[] {\n\tconst semanticObjects: SemanticObject[] = [];\n\tconst _propertyCommonAnnotations = property.annotations?.Common as Record<string, { term?: CommonAnnotationTerms; qualifier?: string }>;\n\tif (_propertyCommonAnnotations) {\n\t\tfor (const key in _propertyCommonAnnotations) {\n\t\t\tconst annotation = _propertyCommonAnnotations[key];\n\t\t\tif (isAnnotationOfTerm<SemanticObject>(annotation, CommonAnnotationTerms.SemanticObject)) {\n\t\t\t\tsemanticObjects.push(annotation);\n\t\t\t}\n\t\t}\n\t}\n\treturn semanticObjects;\n};\n\nexport const getSemanticObjectMappings = function (property: Property | NavigationProperty): SemanticObjectMapping[] {\n\tconst semanticObjectMappings: SemanticObjectMapping[] = [];\n\tconst _propertyCommonAnnotations = property.annotations?.Common as Record<string, { term?: CommonAnnotationTerms; qualifier?: string }>;\n\tif (_propertyCommonAnnotations) {\n\t\tfor (const key in _propertyCommonAnnotations) {\n\t\t\tconst annotation = _propertyCommonAnnotations[key];\n\t\t\tif (isAnnotationOfTerm<SemanticObjectMapping>(annotation, CommonAnnotationTerms.SemanticObjectMapping)) {\n\t\t\t\tsemanticObjectMappings.push(annotation);\n\t\t\t}\n\t\t}\n\t}\n\treturn semanticObjectMappings;\n};\n\nexport const getSemanticObjectUnavailableActions = function (property: Property | NavigationProperty): SemanticObjectUnavailableActions[] {\n\tconst semanticObjectUnavailableActions: SemanticObjectUnavailableActions[] = [];\n\tconst _propertyCommonAnnotations = property.annotations?.Common as Record<string, { term?: CommonAnnotationTerms; qualifier?: string }>;\n\tif (_propertyCommonAnnotations) {\n\t\tfor (const key in _propertyCommonAnnotations) {\n\t\t\tconst annotation = _propertyCommonAnnotations[key];\n\t\t\tif (isAnnotationOfTerm<SemanticObjectUnavailableActions>(annotation, CommonAnnotationTerms.SemanticObjectUnavailableActions)) {\n\t\t\t\tsemanticObjectUnavailableActions.push(annotation);\n\t\t\t}\n\t\t}\n\t}\n\treturn semanticObjectUnavailableActions;\n};\n\n/**\n * Get the property or the navigation property in  its relative path that holds semanticObject annotation if it exists.\n * @param dataModelObjectPath\n * @returns A property or a NavProperty or undefined\n */\nexport const getPropertyWithSemanticObject = function (\n\tdataModelObjectPath: DataModelObjectPath<Property | NavigationProperty | DataFieldAbstractTypes | DataPointType>\n): PropertyOrNavigationProperty {\n\tlet propertyWithSemanticObject: PropertyOrNavigationProperty;\n\tif (dataModelObjectPath.targetObject && hasSemanticObject(dataModelObjectPath.targetObject)) {\n\t\tpropertyWithSemanticObject = dataModelObjectPath.targetObject as Property | NavigationProperty;\n\t} else if (dataModelObjectPath.navigationProperties.length > 0) {\n\t\t// there are no semantic objects on the property itself so we look for some on nav properties\n\t\tfor (const navProperty of dataModelObjectPath.navigationProperties) {\n\t\t\tif (\n\t\t\t\t!dataModelObjectPath.contextLocation?.navigationProperties.find(\n\t\t\t\t\t(contextNavProp) => contextNavProp.fullyQualifiedName === navProperty.fullyQualifiedName\n\t\t\t\t) &&\n\t\t\t\t!propertyWithSemanticObject &&\n\t\t\t\thasSemanticObject(navProperty)\n\t\t\t) {\n\t\t\t\tpropertyWithSemanticObject = navProperty;\n\t\t\t}\n\t\t}\n\t}\n\treturn propertyWithSemanticObject;\n};\n\n/**\n * Get the semanticObject compile binding from metadata and a map to the qualifiers.\n * @param propertyWithSemanticObject The property that holds semanticObject annotataions if it exists\n * @returns An object containing semanticObjectList and qualifierMap\n */\nexport const getSemanticObjectsAndQualifierMap = function (propertyWithSemanticObject: PropertyOrNavigationProperty): {\n\tsemanticObjectsList: string[];\n\tsemanticObjectsExpressionList: BindingToolkitExpression<string>[];\n\tqualifierMap: Record<string, CompiledBindingToolkitExpression>;\n} {\n\tconst qualifierMap: Record<string, CompiledBindingToolkitExpression> = {};\n\tconst semanticObjectsList: string[] = [];\n\tconst semanticObjectsExpressionList: BindingToolkitExpression<string>[] = [];\n\tif (propertyWithSemanticObject !== undefined) {\n\t\tfor (const semanticObject of getSemanticObjects(propertyWithSemanticObject)) {\n\t\t\tconst semanticObjectExpression = getExpressionFromAnnotation(semanticObject);\n\t\t\tconst compiledSemanticObject = compileExpression(semanticObjectExpression);\n\t\t\t// this should not happen, but we make sure not to add twice the semanticObject otherwise the mdcLink crashes\n\t\t\tif (compiledSemanticObject && !semanticObjectsList.includes(compiledSemanticObject)) {\n\t\t\t\tqualifierMap[semanticObject.qualifier || \"\"] = compiledSemanticObject;\n\t\t\t\tsemanticObjectsList.push(compiledSemanticObject);\n\t\t\t\tsemanticObjectsExpressionList.push(semanticObjectExpression);\n\t\t\t}\n\t\t}\n\t}\n\treturn { semanticObjectsList, semanticObjectsExpressionList, qualifierMap };\n};\n\n/**\n * Determines if the current user can navigate to semantic objects based on the provided lists.\n * @param semanticObjectsCurrentUserCanNavigateTo The list of semantic objects the current user can navigate to.\n * @param semanticObjectList An object containing lists and maps of semantic objects.\n * @param semanticObjectList.semanticObjectsList The list of all semantic objects.\n * @param semanticObjectList.semanticObjectsExpressionList The list of expressions for semantic objects.\n * @param semanticObjectList.qualifierMap A map of qualifiers to compiled expressions.\n * @returns An object containing information about static and dynamic semantic objects.\n */\nexport const getReachableSemanticObjectsSettings = function (\n\tsemanticObjectsCurrentUserCanNavigateTo: string[],\n\tsemanticObjectList: {\n\t\tsemanticObjectsList: string[];\n\t\tsemanticObjectsExpressionList: BindingToolkitExpression<string>[];\n\t\tqualifierMap: Record<string, CompiledBindingToolkitExpression>;\n\t}\n): { hasReachableStaticSemanticObject: boolean; dynamicSemanticObjects: BindingToolkitExpression<string>[] } {\n\tconst dynamicSemanticObjectsList: BindingToolkitExpression<string>[] = [];\n\tlet result = false;\n\tif (semanticObjectsCurrentUserCanNavigateTo) {\n\t\tfor (const semanticObject of semanticObjectsCurrentUserCanNavigateTo) {\n\t\t\tfor (const actualSemanticObject of semanticObjectList.semanticObjectsList) {\n\t\t\t\tif (semanticObject === actualSemanticObject) {\n\t\t\t\t\tresult = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsemanticObjectList.semanticObjectsExpressionList.forEach((semanticObjectExpression) => {\n\t\t\tif (semanticObjectExpression._type !== \"Constant\") {\n\t\t\t\tdynamicSemanticObjectsList.push(semanticObjectExpression);\n\t\t\t}\n\t\t});\n\t}\n\treturn { hasReachableStaticSemanticObject: result, dynamicSemanticObjects: dynamicSemanticObjectsList };\n};\n\n/**\n * Check the user rights to navigate to the semantic objects.\n * @param semanticObject The semantic object name\n * @param dataModelPath The DataModelObjectPath of the property\n * @param settings The TemplateProcessorSettings of the internal field\n * @returns An object containing semanticObjectList and qualifierMap\n */\nexport const manageSemanticObjectsForCurrentUser = function (\n\tsemanticObject: PropertyBindingInfo | undefined,\n\tdataModelPath: DataModelObjectPath<Property>,\n\tinternalDataModel: JSONModel\n): { hasReachableStaticSemanticObject: boolean; dynamicSemanticObjects: BindingToolkitExpression<string>[] } {\n\tconst property: Property = dataModelPath.targetObject!;\n\tconst semanticObjectsCurrentUserCanNavigateTo = internalDataModel?.getProperty(\"/semanticObjects\");\n\tconst propertySemanticObjectList = getSemanticObjectsAndQualifierMap(property);\n\n\t// semantic object is in navigation\n\tconst propertyWithSemanticObjectFromNavigation = getPropertyWithSemanticObject(dataModelPath);\n\tif (isNavigationProperty(propertyWithSemanticObjectFromNavigation)) {\n\t\tconst semanticObjectExpression = getExpressionFromAnnotation(\n\t\t\tpropertyWithSemanticObjectFromNavigation?.annotations?.Common?.SemanticObject\n\t\t);\n\t\tconst semanticObjectValue = compileExpression(semanticObjectExpression);\n\t\tpropertySemanticObjectList.semanticObjectsExpressionList.push(semanticObjectExpression);\n\t\tpropertySemanticObjectList.semanticObjectsList.push(semanticObjectValue as string);\n\t}\n\n\t// custom semanticObject from field property\n\n\tif (semanticObject !== undefined && semanticObject !== \"\") {\n\t\tif (semanticObject[0] === \"[\") {\n\t\t\tconst customSemanticObjects = JSON.parse(semanticObject);\n\t\t\tcustomSemanticObjects.forEach((internalSemanticObject: string) => {\n\t\t\t\tpropertySemanticObjectList.semanticObjectsList.push(internalSemanticObject);\n\t\t\t});\n\t\t} else {\n\t\t\tpropertySemanticObjectList.semanticObjectsList.push(semanticObject);\n\t\t\t// The semanticObject property of the field contains a formatter or a binding expression\n\t\t\tif (semanticObject.startsWith(\"{\") || semanticObject.startsWith(\"{=\")) {\n\t\t\t\tconst semanticObjectExpressionFromField = resolveBindingString(semanticObject) as BindingToolkitExpression<string>;\n\t\t\t\tpropertySemanticObjectList.semanticObjectsExpressionList.push(semanticObjectExpressionFromField);\n\t\t\t}\n\t\t}\n\t}\n\treturn getReachableSemanticObjectsSettings(semanticObjectsCurrentUserCanNavigateTo, propertySemanticObjectList);\n};\n"],"mappings":"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","ignoreList":[]}