{"version":3,"file":"FieldControlHelper.js","names":["isReadOnlyExpression","oTarget","relativePath","fieldControlExpression","getExpressionFromAnnotation","annotations","Common","FieldControl","isConstant","or","equal","_exports","isDisabledExpression","isNonEditableExpression","hasFieldControlNotMandatory","dataFieldForAnnotation","fieldControl","toString","isStaticallyMandatory","target","isMandatory","fc","value","fieldFieldControl","isProperty","isDataFieldForAnnotation","isDataField","undefined","Value","$target","isRequiredExpression","oFieldControlValue","fieldControlValue","_isRequiredExpression","isActionParameterRequiredExpression","actionParameter","actionTarget","convertedTypes","bindingParameterFullName","isBound","parameters","fullyQualifiedName","fieldControlExp","path","bindingContextPathVisitor"],"sources":["./FieldControlHelper.ts"],"sourcesContent":["import type { Action, ActionParameter, ConvertedMetadata, Property } from \"@sap-ux/vocabularies-types\";\nimport type { FieldControl } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport type {\n\tDataField,\n\tDataFieldAbstractTypes,\n\tDataFieldForAnnotation,\n\tDataPoint,\n\tDataPointType,\n\tDataPointTypeTypes,\n\tFieldGroupType\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type { BindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport { equal, getExpressionFromAnnotation, isConstant, or } from \"sap/fe/base/BindingToolkit\";\nimport { isDataField, isDataFieldForAnnotation } from \"../converters/annotations/DataField\";\nimport { bindingContextPathVisitor } from \"../helpers/BindingHelper\";\nimport { isProperty } from \"../helpers/TypeGuards\";\n\n/**\n * Create the binding expression to check if the property is read only or not.\n * @param oTarget The target property or DataField\n * @param relativePath Array of navigation properties pointing to the location of field control property\n * @returns The binding expression resolving to a Boolean being true if it's read only\n */\nexport const isReadOnlyExpression = function (\n\toTarget: Property | DataFieldAbstractTypes | DataPointTypeTypes | ActionParameter | undefined,\n\trelativePath?: string[]\n): BindingToolkitExpression<boolean> {\n\tconst fieldControlExpression = getExpressionFromAnnotation(oTarget?.annotations?.Common?.FieldControl, relativePath);\n\tif (!isConstant(fieldControlExpression)) {\n\t\treturn or(equal(fieldControlExpression, 1), equal(fieldControlExpression, \"1\"));\n\t} else {\n\t\treturn or(\n\t\t\tequal(fieldControlExpression, \"Common.FieldControlType/ReadOnly\"),\n\t\t\tequal(fieldControlExpression, 1),\n\t\t\tequal(fieldControlExpression, \"1\")\n\t\t);\n\t}\n};\n\n/**\n * Create the binding expression to check if the property is disabled or not.\n * @param oTarget The target property or DataField\n * @param relativePath Array of navigation properties pointing to the location of field control property\n * @returns The binding expression resolving to a Boolean being true if it's disabled\n */\nexport const isDisabledExpression = function (\n\toTarget: Property | DataFieldAbstractTypes | DataPointTypeTypes | ActionParameter | undefined,\n\trelativePath?: string[]\n): BindingToolkitExpression<boolean> {\n\tconst fieldControlExpression = getExpressionFromAnnotation(oTarget?.annotations?.Common?.FieldControl, relativePath);\n\tif (!isConstant(fieldControlExpression)) {\n\t\treturn or(equal(fieldControlExpression, 0), equal(fieldControlExpression, \"0\"));\n\t} else {\n\t\treturn or(\n\t\t\tequal(fieldControlExpression, \"Common.FieldControlType/Hidden\"), // deprecated version but still used by stakeholders\n\t\t\tequal(fieldControlExpression, \"Common.FieldControlType/Inapplicable\"),\n\t\t\tequal(fieldControlExpression, 0),\n\t\t\tequal(fieldControlExpression, \"0\")\n\t\t);\n\t}\n};\n\n/**\n * Create the binding expression to check if the property is editable or not.\n * @param oTarget The target property or DataField\n * @param relativePath Array of navigation properties pointing to the location of field control property\n * @returns The binding expression resolving to a Boolean being true if it's not editable\n */\nexport const isNonEditableExpression = function (\n\toTarget: Property | DataFieldAbstractTypes | DataPointTypeTypes | undefined,\n\trelativePath?: string[]\n): BindingToolkitExpression<boolean> {\n\treturn or(isReadOnlyExpression(oTarget, relativePath), isDisabledExpression(oTarget, relativePath));\n};\n\n/**\n * Determines if the dataFieldForAnnotation has a fieldControl that is not set to Mandatory.\n * @param dataFieldForAnnotation The dataFieldForAnnotation being processed\n * @returns True if it has a fieldControl set and not Mandatory.\n */\nexport const hasFieldControlNotMandatory = function (dataFieldForAnnotation: DataFieldForAnnotation): boolean {\n\tconst fieldControl = dataFieldForAnnotation.annotations?.Common?.FieldControl;\n\treturn fieldControl && fieldControl.toString() !== \"Common.FieldControlType/Mandatory\" ? true : false;\n};\n\n/**\n * Determines if the target has a field control annotation with static value mandatory .\n * @param target The target to be processed\n * @returns True if it has a static mandatory field control.\n */\nexport function isStaticallyMandatory(target: DataField | DataFieldForAnnotation | DataPoint | Property | undefined): boolean {\n\tconst isMandatory = (fc: FieldControl | undefined): boolean => {\n\t\tconst value = fc?.toString?.();\n\t\treturn value === \"7\" || value === \"Common.FieldControlType/Mandatory\";\n\t};\n\tconst fieldFieldControl = target?.annotations?.Common?.FieldControl;\n\tif (isProperty(target) || isDataFieldForAnnotation(target as DataFieldForAnnotation)) {\n\t\treturn isMandatory(fieldFieldControl);\n\t}\n\tif (isDataField(target)) {\n\t\tif (isMandatory(fieldFieldControl)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (fieldFieldControl?.toString() !== undefined) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn isMandatory(target?.Value?.$target?.annotations?.Common?.FieldControl);\n\t\t}\n\t}\n\treturn isMandatory((target as DataPoint)?.Value?.$target?.annotations?.Common?.FieldControl);\n}\n\n/**\n * Create the binding expression to check if the property is read only or not.\n * @param oTarget The target property or DataField\n * @param relativePath Array of navigation properties pointing to the location of field control property\n * @returns The binding expression resolving to a Boolean being true if it's read only\n */\nexport const isRequiredExpression = function (\n\toTarget: Property | DataFieldAbstractTypes | DataPointType | FieldGroupType | undefined,\n\trelativePath?: string[]\n): BindingToolkitExpression<boolean> {\n\tconst oFieldControlValue = oTarget?.annotations?.Common?.FieldControl;\n\tconst fieldControlValue = getExpressionFromAnnotation(oFieldControlValue, relativePath);\n\treturn _isRequiredExpression(fieldControlValue);\n};\n\n/**\n * Create the binding expression to check if action parameter is required.\n * @param actionParameter Action parameter\n * @param actionTarget Action definition\n * @param convertedTypes Converted Metadata\n * @returns Is required binding expression for parameter.\n */\nexport const isActionParameterRequiredExpression = function (\n\tactionParameter: ActionParameter,\n\tactionTarget: Action,\n\tconvertedTypes: ConvertedMetadata\n): BindingToolkitExpression<boolean> {\n\tconst bindingParameterFullName = actionTarget.isBound ? actionTarget.parameters[0]?.fullyQualifiedName : undefined;\n\tconst fieldControlValue = actionParameter.annotations?.Common?.FieldControl;\n\tconst fieldControlExp = getExpressionFromAnnotation(fieldControlValue, [], undefined, (path: string) =>\n\t\tbindingContextPathVisitor(path, convertedTypes, bindingParameterFullName)\n\t);\n\n\treturn _isRequiredExpression(fieldControlExp);\n};\n\nconst _isRequiredExpression = (fieldControlExp: BindingToolkitExpression<string | number>): BindingToolkitExpression<boolean> => {\n\treturn or(\n\t\tisConstant(fieldControlExp) && equal(fieldControlExp, \"Common.FieldControlType/Mandatory\"),\n\t\tequal(fieldControlExp, 7),\n\t\tequal(fieldControlExp, \"7\")\n\t);\n};\n"],"mappings":";;;;wWAuBO,MAAMA,EAAuB,SACnCC,EACAC,GAEA,MAAMC,EAAyBC,EAA4BH,GAASI,aAAaC,QAAQC,aAAcL,GACvG,IAAKM,EAAWL,GAAyB,CACxC,OAAOM,EAAGC,EAAMP,EAAwB,GAAIO,EAAMP,EAAwB,KAC3E,KAAO,CACN,OAAOM,EACNC,EAAMP,EAAwB,oCAC9BO,EAAMP,EAAwB,GAC9BO,EAAMP,EAAwB,KAEhC,CACD,EAEAQ,EAAAX,uBAMO,MAAMY,EAAuB,SACnCX,EACAC,GAEA,MAAMC,EAAyBC,EAA4BH,GAASI,aAAaC,QAAQC,aAAcL,GACvG,IAAKM,EAAWL,GAAyB,CACxC,OAAOM,EAAGC,EAAMP,EAAwB,GAAIO,EAAMP,EAAwB,KAC3E,KAAO,CACN,OAAOM,EACNC,EAAMP,EAAwB,kCAC9BO,EAAMP,EAAwB,wCAC9BO,EAAMP,EAAwB,GAC9BO,EAAMP,EAAwB,KAEhC,CACD,EAEAQ,EAAAC,uBAMO,MAAMC,EAA0B,SACtCZ,EACAC,GAEA,OAAOO,EAAGT,EAAqBC,EAASC,GAAeU,EAAqBX,EAASC,GACtF,EAEAS,EAAAE,0BAKO,MAAMC,EAA8B,SAAUC,GACpD,MAAMC,EAAeD,EAAuBV,aAAaC,QAAQC,aACjE,OAAOS,GAAgBA,EAAaC,aAAe,oCAAsC,KAAO,KACjG,EAEAN,EAAAG,8BAKO,SAASI,EAAsBC,GACrC,MAAMC,EAAeC,IACpB,MAAMC,EAAQD,GAAIJ,aAClB,OAAOK,IAAU,KAAOA,IAAU,qCAEnC,MAAMC,EAAoBJ,GAAQd,aAAaC,QAAQC,aACvD,GAAIiB,EAAWL,IAAWM,EAAyBN,GAAmC,CACrF,OAAOC,EAAYG,EACpB,CACA,GAAIG,EAAYP,GAAS,CACxB,GAAIC,EAAYG,GAAoB,CACnC,OAAO,IACR,CACA,GAAIA,GAAmBN,aAAeU,UAAW,CAChD,OAAO,KACR,KAAO,CACN,OAAOP,EAAYD,GAAQS,OAAOC,SAASxB,aAAaC,QAAQC,aACjE,CACD,CACA,OAAOa,EAAaD,GAAsBS,OAAOC,SAASxB,aAAaC,QAAQC,aAChF,CAEAI,EAAAO,wBAMO,MAAMY,EAAuB,SACnC7B,EACAC,GAEA,MAAM6B,EAAqB9B,GAASI,aAAaC,QAAQC,aACzD,MAAMyB,EAAoB5B,EAA4B2B,EAAoB7B,GAC1E,OAAO+B,EAAsBD,EAC9B,EAEArB,EAAAmB,uBAOO,MAAMI,EAAsC,SAClDC,EACAC,EACAC,GAEA,MAAMC,EAA2BF,EAAaG,QAAUH,EAAaI,WAAW,IAAIC,mBAAqBd,UACzG,MAAMK,EAAoBG,EAAgB9B,aAAaC,QAAQC,aAC/D,MAAMmC,EAAkBtC,EAA4B4B,EAAmB,GAAIL,UAAYgB,GACtFC,EAA0BD,EAAMN,EAAgBC,IAGjD,OAAOL,EAAsBS,EAC9B,EAAE/B,EAAAuB,sCAEF,MAAMD,EAAyBS,GACvBjC,EACND,EAAWkC,IAAoBhC,EAAMgC,EAAiB,qCACtDhC,EAAMgC,EAAiB,GACvBhC,EAAMgC,EAAiB,MAEvB,OAAA/B,CAAA","ignoreList":[]}