{"version":3,"file":"DataFieldFormatters.js","names":["getDataField","oContext","oInterface","sPath","context","getPath","Error","hasOwnProperty","$kind","oConverterContext","getConverterContext","isAnnotationPath","isPathAnnotationExpression","$target","_exports","getDataFieldObjectPath","involvedDataModelObjects","getInvolvedDataModelObjects","targetObject","enhanceDataModelPath","path","value","endsWith","isSemanticallyConnectedFields","oDataField","$Type","isFieldGroup","isBooleanFieldGroupItem","Value","type","isMultiLineText","annotations","UI","MultiLineText","valueOf","connectedFieldsTemplateRegex","connectedFieldsTemplateSubRegex","getLabelForConnectedFields","connectedFieldsPath","getTextBindingExpression","compileBindingExpression","arguments","length","undefined","connectedFields","templateMatches","Template","toString","match","partsToConcat","reduce","subPartsToConcat","subMatch","targetValue","targetData","Data","dataFieldPath","fullyQualifiedName","replace","targetEntityType","push","constant","compileExpression","concat","generateVisibleExpression","dataFieldModelPath","formatOptions","propertyValue","targetModelPath","isProperty","Target","isAnalyticalGroupHeaderExpanded","isAnalytics","IsExpanded","isAnalyticalLeaf","equal","NodeLevel","and","isVisible","getRelativePaths","ifElse","or","not"],"sources":["./DataFieldFormatters.ts"],"sourcesContent":["import type { AnnotationPath, PathAnnotationExpression, Property } from \"@sap-ux/vocabularies-types/Edm\";\nimport type {\n\tConnectedFieldsTypeTypes,\n\tDataFieldAbstractTypes,\n\tDataFieldTypes,\n\tDataPointTypeTypes,\n\tFieldGroupTypeTypes\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type { PropertyAnnotations_UI } from \"@sap-ux/vocabularies-types/vocabularies/UI_Edm\";\nimport type { BindingToolkitExpression, CompiledBindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport { and, compileExpression, concat, constant, equal, ifElse, not, or } from \"sap/fe/base/BindingToolkit\";\nimport { getInvolvedDataModelObjects } from \"sap/fe/core/converters/MetaModelConverter\";\nimport { UI } from \"sap/fe/core/helpers/BindingHelper\";\nimport { isAnnotationPath, isPathAnnotationExpression, isProperty } from \"sap/fe/core/helpers/TypeGuards\";\nimport type { DataModelObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport { enhanceDataModelPath, getRelativePaths } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport type { ComputedAnnotationInterface, MetaModelContext } from \"sap/fe/core/templating/UIFormatters\";\nimport { getConverterContext, isVisible } from \"sap/fe/core/templating/UIFormatters\";\n\nexport const getDataField = function (\n\toContext: MetaModelContext,\n\toInterface: ComputedAnnotationInterface\n): DataFieldTypes | ConnectedFieldsTypeTypes | FieldGroupTypeTypes | Property {\n\tconst sPath = oInterface.context.getPath();\n\tif (!oContext) {\n\t\tthrow new Error(`Unresolved context path ${sPath}`);\n\t}\n\tif (typeof oContext === \"object\" && oContext.hasOwnProperty(\"$kind\") && oContext.$kind !== \"Property\") {\n\t\tthrow new Error(`Context does not resolve to a DataField object but to a ${oContext.$kind}`);\n\t}\n\tlet oConverterContext = getConverterContext(oContext, oInterface) as\n\t\t| DataFieldTypes\n\t\t| Property\n\t\t| ConnectedFieldsTypeTypes\n\t\t| AnnotationPath<DataFieldTypes | ConnectedFieldsTypeTypes>\n\t\t| PathAnnotationExpression<DataFieldTypes | ConnectedFieldsTypeTypes>;\n\tif (isAnnotationPath(oConverterContext) || isPathAnnotationExpression(oConverterContext)) {\n\t\toConverterContext = oConverterContext.$target!;\n\t}\n\treturn oConverterContext;\n};\n\nexport const getDataFieldObjectPath = function (\n\toContext: MetaModelContext | string,\n\toInterface: ComputedAnnotationInterface\n): DataModelObjectPath<DataFieldTypes> {\n\tconst sPath = oInterface.context.getPath();\n\tif (!oContext) {\n\t\tthrow new Error(`Unresolved context path ${sPath}`);\n\t}\n\tif (typeof oContext === \"object\" && oContext.hasOwnProperty(\"$kind\") && oContext.$kind !== \"Property\") {\n\t\tthrow new Error(`Context does not resolve to a Property object but to a ${oContext.$kind}`);\n\t}\n\tlet involvedDataModelObjects = getInvolvedDataModelObjects<DataFieldTypes>(oInterface.context);\n\tif (involvedDataModelObjects.targetObject && isPathAnnotationExpression(involvedDataModelObjects.targetObject)) {\n\t\tinvolvedDataModelObjects = enhanceDataModelPath<DataFieldTypes>(\n\t\t\tinvolvedDataModelObjects,\n\t\t\tinvolvedDataModelObjects.targetObject.path\n\t\t);\n\t}\n\tif (involvedDataModelObjects.targetObject && isAnnotationPath<DataFieldTypes>(involvedDataModelObjects.targetObject)) {\n\t\t// REVIEW -> The code below was never correct, i'm changing it to something that makes sense type wise\n\t\tinvolvedDataModelObjects = enhanceDataModelPath<DataFieldTypes>(\n\t\t\tinvolvedDataModelObjects,\n\t\t\tinvolvedDataModelObjects.targetObject.value\n\t\t);\n\t}\n\tif (sPath.endsWith(\"$Path\") || sPath.endsWith(\"$AnnotationPath\")) {\n\t\tinvolvedDataModelObjects = enhanceDataModelPath<DataFieldTypes>(involvedDataModelObjects, oContext as string);\n\t}\n\treturn involvedDataModelObjects;\n};\n\nexport const isSemanticallyConnectedFields = function (oContext: MetaModelContext, oInterface: ComputedAnnotationInterface): boolean {\n\tconst oDataField = getDataField(oContext, oInterface);\n\treturn (oDataField as ConnectedFieldsTypeTypes).$Type === UIAnnotationTypes.ConnectedFieldsType;\n};\n\n/**\n * Returns true if the DataField is a FieldGroupType.\n * FieldGroupType is a special type of DataField that groups multiple fields together.\n * @param oContext The Context of the property\n * @param oInterface The interface instance\n * @returns True if the DataField is a FieldGroupType\n * @internal\n */\nexport const isFieldGroup = function (oContext: MetaModelContext, oInterface: ComputedAnnotationInterface): boolean {\n\tconst oDataField = getDataField(oContext, oInterface);\n\treturn (oDataField as FieldGroupTypeTypes).$Type === UIAnnotationTypes.FieldGroupType;\n};\n\n/**\n * This method is used inside a FieldGroup to check, if the data field is a boolean FieldGroupItem.\n * @param oContext The Context of the property\n * @param oInterface The interface instance\n * @returns True if the DataField is a boolean FieldGroupItem\n * @internal\n */\nexport const isBooleanFieldGroupItem = function (oContext: MetaModelContext, oInterface: ComputedAnnotationInterface): boolean {\n\tconst oDataField = getDataField(oContext, oInterface);\n\treturn (oDataField as DataFieldTypes).Value?.$target?.type === \"Edm.Boolean\";\n};\n\n/**\n *\n * @param oContext The Context of the property\n * @param oInterface The interface instance\n * @returns True if the property has MultiLineText annotation\n */\nexport const isMultiLineText = function (oContext: MetaModelContext, oInterface: ComputedAnnotationInterface): boolean {\n\tconst oDataField = getDataField(oContext, oInterface);\n\treturn (oDataField.annotations?.UI as PropertyAnnotations_UI)?.MultiLineText?.valueOf() === true;\n};\n\nconst connectedFieldsTemplateRegex = /(?:({[^}]+})[^{]*)/g;\nconst connectedFieldsTemplateSubRegex = /{([^}]+)}(.*)/;\nexport const getLabelForConnectedFields = function (\n\tconnectedFieldsPath: DataModelObjectPath<ConnectedFieldsTypeTypes>,\n\tgetTextBindingExpression: Function,\n\tcompileBindingExpression = true\n): BindingToolkitExpression<string> | CompiledBindingToolkitExpression {\n\tconst connectedFields: ConnectedFieldsTypeTypes = connectedFieldsPath.targetObject!;\n\t// First we separate each group of `{TemplatePart} xxx`\n\tconst templateMatches = connectedFields.Template.toString().match(connectedFieldsTemplateRegex);\n\tif (!templateMatches) {\n\t\treturn \"\";\n\t}\n\tconst partsToConcat = templateMatches.reduce((subPartsToConcat: BindingToolkitExpression<string>[], match) => {\n\t\t// Then for each sub-group, we retrieve the name of the data object and the remaining text, if it exists\n\t\tconst subMatch = match.match(connectedFieldsTemplateSubRegex);\n\t\tif (subMatch && subMatch.length > 1) {\n\t\t\tconst targetValue = subMatch[1];\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst targetData = (connectedFields.Data as any)[targetValue];\n\t\t\tif (targetData) {\n\t\t\t\tconst dataFieldPath = enhanceDataModelPath<DataFieldTypes>(\n\t\t\t\t\tconnectedFieldsPath,\n\t\t\t\t\t// TODO Better type for the Edm.Dictionary\n\t\t\t\t\ttargetData.fullyQualifiedName.replace(connectedFieldsPath.targetEntityType.fullyQualifiedName, \"\")\n\t\t\t\t);\n\t\t\t\tdataFieldPath.targetObject = dataFieldPath.targetObject!.Value;\n\t\t\t\tsubPartsToConcat.push(getTextBindingExpression(dataFieldPath, {}));\n\t\t\t\tif (subMatch.length > 2) {\n\t\t\t\t\tsubPartsToConcat.push(constant(subMatch[2]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn subPartsToConcat;\n\t}, []);\n\treturn compileBindingExpression ? compileExpression(concat(...partsToConcat)) : concat(...partsToConcat);\n};\n\n/**\n * Returns the binding expression to evaluate the visibility of a DataField or DataPoint annotation.\n *\n * SAP Fiori elements will evaluate either the UI.Hidden annotation defined on the annotation itself or on the target property.\n * @param dataFieldModelPath The metapath referring to the annotation we are evaluating.\n * @param [formatOptions] FormatOptions optional.\n * @param formatOptions.isAnalytics This flag is set when using an analytical table.\n * @returns An expression that you can bind to the UI.\n */\nexport const generateVisibleExpression = function (\n\tdataFieldModelPath: DataModelObjectPath<DataFieldAbstractTypes | DataPointTypeTypes | Property>,\n\tformatOptions?: { isAnalytics?: boolean }\n): BindingToolkitExpression<boolean> {\n\tlet propertyValue;\n\tlet targetModelPath;\n\tconst targetObject = dataFieldModelPath.targetObject;\n\tif (targetObject && !isProperty(targetObject)) {\n\t\tswitch (targetObject.$Type) {\n\t\t\tcase UIAnnotationTypes.DataField:\n\t\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\t\tcase UIAnnotationTypes.DataFieldWithIntentBasedNavigation:\n\t\t\tcase UIAnnotationTypes.DataFieldWithAction:\n\t\t\tcase UIAnnotationTypes.DataPointType:\n\t\t\t\tpropertyValue = targetObject.Value.$target;\n\t\t\t\ttargetModelPath = enhanceDataModelPath(dataFieldModelPath, targetObject.Value.path);\n\t\t\t\tbreak;\n\t\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\t\t\t// if it is a DataFieldForAnnotation pointing to a DataPoint we look at the dataPoint's value\n\t\t\t\tif (targetObject?.Target?.$target?.$Type === UIAnnotationTypes.DataPointType) {\n\t\t\t\t\tpropertyValue = targetObject.Target.$target?.Value.$target;\n\t\t\t\t\ttargetModelPath = enhanceDataModelPath(dataFieldModelPath, targetObject.Target.value);\n\t\t\t\t\ttargetModelPath = enhanceDataModelPath(targetModelPath, targetObject.Target.$target?.Value.path);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t// eslint-disable-next-line no-fallthrough\n\t\t\tcase UIAnnotationTypes.DataFieldForIntentBasedNavigation:\n\t\t\tcase UIAnnotationTypes.DataFieldForAction:\n\t\t\tdefault:\n\t\t\t\tpropertyValue = undefined;\n\t\t}\n\t} else if (targetObject && isProperty(targetObject)) {\n\t\ttargetModelPath = enhanceDataModelPath(dataFieldModelPath, targetObject);\n\t}\n\n\tconst isAnalyticalGroupHeaderExpanded = formatOptions?.isAnalytics ? UI.IsExpanded : constant(false);\n\tconst isAnalyticalLeaf = formatOptions?.isAnalytics ? equal(UI.NodeLevel, 0) : constant(false);\n\t// A data field is visible if:\n\t// - the UI.Hidden expression in the original annotation does not evaluate to 'true'\n\t// - the UI.Hidden expression in the target property does not evaluate to 'true'\n\t// - in case of Analytics it's not visible for an expanded GroupHeader\n\treturn and(\n\t\t...[\n\t\t\tisVisible(dataFieldModelPath.targetObject, getRelativePaths(dataFieldModelPath)),\n\t\t\tifElse(!!propertyValue, propertyValue && isVisible(propertyValue, getRelativePaths(targetModelPath)), true),\n\t\t\tor(not(isAnalyticalGroupHeaderExpanded), isAnalyticalLeaf)\n\t\t]\n\t);\n};\n"],"mappings":"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","ignoreList":[]}