{"version":3,"file":"InputMask.js","names":["InputMaskType","_dec","defineUI5Class","_class","_ODataStringType","oFormatOptions","call","this","_inheritsLoose","_proto","prototype","validateValue","value","maskedValue","formatValue","includes","placeholderSymbol","text","Library","getResourceBundleFor","getText","ValidateException","parseValue","parsedValue","parsedValueIndex","mask","i","length","doesMakingRuleExists","maskRule","find","rule","symbol","match","RegExp","regex","maskCharacter","maskRulesPerCharacter","valueIndex","formattedValue","ODataStringType"],"sources":["./InputMask.ts"],"sourcesContent":["import { defineUI5Class } from \"sap/fe/base/ClassSupport\";\nimport Library from \"sap/ui/core/Lib\";\nimport ValidateException from \"sap/ui/model/ValidateException\";\nimport ODataStringType from \"sap/ui/model/odata/type/String\";\n\nexport type InputMaskRule = {\n\tsymbol: string;\n\tregex: string;\n};\nexport type InputMaskFormatOptions = {\n\tmask: string;\n\tplaceholderSymbol: string;\n\tmaskRule: InputMaskRule[];\n};\n\n@defineUI5Class(\"sap.fe.core.type.InputMask\")\nclass InputMaskType extends ODataStringType {\n\tconstructor(oFormatOptions: InputMaskFormatOptions & { parseKeepsEmptyString?: boolean }) {\n\t\tsuper(oFormatOptions);\n\t}\n\n\toFormatOptions!: InputMaskFormatOptions;\n\n\t/**\n\t * Validates the value against the mask. If the value is not provided for any of the mask characters, it throws an error.\n\t * @param value String value received from the parseValue method without the mask.\n\t */\n\n\tvalidateValue(value: string): void {\n\t\t// Reuse the formatValue to validate if the value does not match the mask and throw an error in that case\n\t\tconst maskedValue = this.formatValue(value);\n\t\tif (maskedValue.includes(this.oFormatOptions.placeholderSymbol)) {\n\t\t\tlet text = Library.getResourceBundleFor(\"sap.fe.core\")!.getText(\"T_MASKEDINPUT_INVALID_VALUE\");\n\t\t\tif (!text) {\n\t\t\t\ttext = \"\";\n\t\t\t}\n\t\t\tthrow new ValidateException(text);\n\t\t}\n\t\tsuper.validateValue(value);\n\t}\n\t/**\n\t * Parse the value by removing the mask characters.\n\t * @param value String value from the control with the mask\n\t * @returns String value without the mask\n\t */\n\n\tparseValue(value: string): string {\n\t\t// Remove the mask characters from the value\n\t\tlet parsedValue = \"\";\n\t\tlet parsedValueIndex = 0;\n\t\tconst mask = this.oFormatOptions?.mask;\n\t\tif (mask) {\n\t\t\tfor (let i = 0; i <= mask.length; i++) {\n\t\t\t\tif (this.doesMakingRuleExists(this.oFormatOptions.maskRule, mask[i])) {\n\t\t\t\t\tconst maskRule = this.oFormatOptions.maskRule.find((rule) => rule.symbol === mask[i]);\n\t\t\t\t\tif (value[parsedValueIndex] && maskRule && value[parsedValueIndex].match(new RegExp(maskRule.regex))) {\n\t\t\t\t\t\tparsedValue += value[parsedValueIndex++];\n\t\t\t\t\t}\n\t\t\t\t} else if (mask[i] === \"^\") {\n\t\t\t\t\t// check if the character is ^, then skip the next character in value and increment the loop i++ as we don't want to add the escaped character to the parsed value\n\t\t\t\t\ti++;\n\t\t\t\t\tparsedValueIndex++;\n\t\t\t\t} else {\n\t\t\t\t\tparsedValueIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn parsedValue;\n\t}\n\t/**\n\t * Checks if the mask rule exists for the given mask character.\n\t * @param maskRule Array of mask rules\n\t * @param maskCharacter Single mask character\n\t * @returns True or False based on the result\n\t */\n\n\tdoesMakingRuleExists(maskRule: InputMaskRule[], maskCharacter: string): boolean {\n\t\tfor (const rule of maskRule) {\n\t\t\tif (rule.symbol === maskCharacter) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t/**\n\t * Format the value by applying the mask.\n\t * @param value String value from the model without the mask\n\t * @returns String value with the mask\n\t */\n\n\tformatValue(value: string): string {\n\t\tif (!value) return value;\n\n\t\tconst maskRulesPerCharacter: Record<string, string> = {};\n\t\tlet formatValue = \"\";\n\t\t// Create a map of mask rules per character\n\t\tif (this.oFormatOptions.maskRule) {\n\t\t\tfor (const rule of this.oFormatOptions.maskRule) {\n\t\t\t\tmaskRulesPerCharacter[rule.symbol] = rule.regex;\n\t\t\t}\n\t\t\tlet valueIndex = 0;\n\t\t\tlet formattedValue = \"\";\n\t\t\tconst mask = this.oFormatOptions.mask;\n\t\t\tfor (let i = 0; i < mask.length; i++) {\n\t\t\t\t// Process character by character, comparing with the mask rules\n\t\t\t\t// If the character matches a mask rule, replace it with the character from the value and increment the value index;\n\t\t\t\t// Otherwise replace it with the character from the mask\n\t\t\t\tif (maskRulesPerCharacter[mask[i]]) {\n\t\t\t\t\tif (value[valueIndex] && value[valueIndex].match(new RegExp(maskRulesPerCharacter[mask[i]]))) {\n\t\t\t\t\t\tformattedValue += value[valueIndex++];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tformattedValue += this.oFormatOptions.placeholderSymbol;\n\t\t\t\t\t}\n\t\t\t\t} else if (mask[i] === \"^\") {\n\t\t\t\t\t// if the mask character is ^ then add the character after it to the formatted value and increment the value i++\n\t\t\t\t\tformattedValue += mask[i + 1];\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tformattedValue += mask[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tformatValue = formattedValue;\n\t\t}\n\t\treturn formatValue;\n\t}\n}\nexport default InputMaskType;\n"],"mappings":";;;;kZAgBMA,GAAaC,EADlBC,EAAe,8BAA6BD,EAAAE,EAAA,SAAAC,GAE5C,SAAAJ,EAAYK,GAA8E,OACzFD,EAAAE,KAAAC,KAAMF,IAAeE,IACtB,CAACC,EAAAR,EAAAI,GAAA,IAAAK,EAAAT,EAAAU,UAIDD,EAKAE,cAAA,SAAAA,EAAcC,GAEb,MAAMC,EAAcN,KAAKO,YAAYF,GACrC,GAAIC,EAAYE,SAASR,KAAKF,eAAeW,mBAAoB,CAChE,IAAIC,EAAOC,EAAQC,qBAAqB,eAAgBC,QAAQ,+BAChE,IAAKH,EAAM,CACVA,EAAO,EACR,CACA,MAAM,IAAII,EAAkBJ,EAC7B,CACAb,EAAAM,UAAMC,cAAaL,KAAAC,KAACK,EACrB,EACAH,EAMAa,WAAA,SAAAA,EAAWV,GAEV,IAAIW,EAAc,GAClB,IAAIC,EAAmB,EACvB,MAAMC,EAAOlB,KAAKF,gBAAgBoB,KAClC,GAAIA,EAAM,CACT,IAAK,IAAIC,EAAI,EAAGA,GAAKD,EAAKE,OAAQD,IAAK,CACtC,GAAInB,KAAKqB,qBAAqBrB,KAAKF,eAAewB,SAAUJ,EAAKC,IAAK,CACrE,MAAMG,EAAWtB,KAAKF,eAAewB,SAASC,KAAMC,GAASA,EAAKC,SAAWP,EAAKC,IAClF,GAAId,EAAMY,IAAqBK,GAAYjB,EAAMY,GAAkBS,MAAM,IAAIC,OAAOL,EAASM,QAAS,CACrGZ,GAAeX,EAAMY,IACtB,CACD,MAAO,GAAIC,EAAKC,KAAO,IAAK,CAE3BA,IACAF,GACD,KAAO,CACNA,GACD,CACD,CACD,CACA,OAAOD,CACR,EACAd,EAOAmB,qBAAA,SAAAA,EAAqBC,EAA2BO,GAC/C,IAAK,MAAML,KAAQF,EAAU,CAC5B,GAAIE,EAAKC,SAAWI,EAAe,CAClC,OAAO,IACR,CACD,CACA,OAAO,KACR,EACA3B,EAMAK,YAAA,SAAAA,EAAYF,GACX,IAAKA,EAAO,OAAOA,EAEnB,MAAMyB,EAAgD,CAAC,EACvD,IAAIvB,EAAc,GAElB,GAAIP,KAAKF,eAAewB,SAAU,CACjC,IAAK,MAAME,KAAQxB,KAAKF,eAAewB,SAAU,CAChDQ,EAAsBN,EAAKC,QAAUD,EAAKI,KAC3C,CACA,IAAIG,EAAa,EACjB,IAAIC,EAAiB,GACrB,MAAMd,EAAOlB,KAAKF,eAAeoB,KACjC,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAKE,OAAQD,IAAK,CAIrC,GAAIW,EAAsBZ,EAAKC,IAAK,CACnC,GAAId,EAAM0B,IAAe1B,EAAM0B,GAAYL,MAAM,IAAIC,OAAOG,EAAsBZ,EAAKC,MAAO,CAC7Fa,GAAkB3B,EAAM0B,IACzB,KAAO,CACNC,GAAkBhC,KAAKF,eAAeW,iBACvC,CACD,MAAO,GAAIS,EAAKC,KAAO,IAAK,CAE3Ba,GAAkBd,EAAKC,EAAI,GAC3BA,GACD,KAAO,CACNa,GAAkBd,EAAKC,EACxB,CACD,CACAZ,EAAcyB,CACf,CACA,OAAOzB,CACR,EAAC,OAAAd,CAAA,CA7G2C,CACjBwC,KAAerC,GAAA,OA8G5BH,CAAa","ignoreList":[]}