{"version":3,"names":["InputMaskType","_dec","defineUI5Class","_class","_ODataStringType","oFormatOptions","call","_inheritsLoose","_proto","prototype","validateValue","value","maskedValue","formatValue","includes","placeholderSymbol","text","Library","getResourceBundleFor","getText","ValidateException","parseValue","parsedValue","parsedValueIndex","mask","i","length","doesMakingRuleExists","maskRule","find","rule","symbol","match","RegExp","regex","maskCharacter","maskRulesPerCharacter","valueIndex","formattedValue","ODataStringType"],"sourceRoot":".","sources":["InputMask.ts"],"sourcesContent":["import { defineUI5Class } from \"sap/fe/base/ClassSupport\";\nimport Library from \"sap/ui/core/Lib\";\nimport ValidateException from \"sap/ui/model/ValidateException\";\nimport ODataStringType from \"sap/ui/model/odata/type/String\";\n\nexport type InputMaskRule = {\n\tsymbol: string;\n\tregex: string;\n};\nexport type InputMaskFormatOptions = {\n\tmask: string;\n\tplaceholderSymbol: string;\n\tmaskRule: InputMaskRule[];\n};\n\n@defineUI5Class(\"sap.fe.core.type.InputMask\")\nclass InputMaskType extends ODataStringType {\n\tconstructor(oFormatOptions: InputMaskFormatOptions & { parseKeepsEmptyString?: boolean }) {\n\t\tsuper(oFormatOptions);\n\t}\n\n\toFormatOptions!: InputMaskFormatOptions;\n\n\t/**\n\t * Validates the value against the mask. If the value is not provided for any of the mask characters, it throws an error.\n\t * @param value String value received from the parseValue method without the mask.\n\t */\n\n\tvalidateValue(value: string): void {\n\t\t// Reuse the formatValue to validate if the value does not match the mask and throw an error in that case\n\t\tconst maskedValue = this.formatValue(value);\n\t\tif (maskedValue.includes(this.oFormatOptions.placeholderSymbol)) {\n\t\t\tlet text = Library.getResourceBundleFor(\"sap.fe.core\")!.getText(\"T_MASKEDINPUT_INVALID_VALUE\");\n\t\t\tif (!text) {\n\t\t\t\ttext = \"\";\n\t\t\t}\n\t\t\tthrow new ValidateException(text);\n\t\t}\n\t\tsuper.validateValue(value);\n\t}\n\t/**\n\t * Parse the value by removing the mask characters.\n\t * @param value String value from the control with the mask\n\t * @returns String value without the mask\n\t */\n\n\tparseValue(value: string): string {\n\t\t// Remove the mask characters from the value\n\t\tlet parsedValue = \"\";\n\t\tlet parsedValueIndex = 0;\n\t\tconst mask = this.oFormatOptions?.mask;\n\t\tif (mask) {\n\t\t\tfor (let i = 0; i <= mask.length; i++) {\n\t\t\t\tif (this.doesMakingRuleExists(this.oFormatOptions.maskRule, mask[i])) {\n\t\t\t\t\tconst maskRule = this.oFormatOptions.maskRule.find((rule) => rule.symbol === mask[i]);\n\t\t\t\t\tif (value[parsedValueIndex] && maskRule && value[parsedValueIndex].match(new RegExp(maskRule.regex))) {\n\t\t\t\t\t\tparsedValue += value[parsedValueIndex++];\n\t\t\t\t\t}\n\t\t\t\t} else if (mask[i] === \"^\") {\n\t\t\t\t\t// check if the character is ^, then skip the next character in value and increment the loop i++ as we don't want to add the escaped character to the parsed value\n\t\t\t\t\ti++;\n\t\t\t\t\tparsedValueIndex++;\n\t\t\t\t} else {\n\t\t\t\t\tparsedValueIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn parsedValue;\n\t}\n\t/**\n\t * Checks if the mask rule exists for the given mask character.\n\t * @param maskRule Array of mask rules\n\t * @param maskCharacter Single mask character\n\t * @returns True or False based on the result\n\t */\n\n\tdoesMakingRuleExists(maskRule: InputMaskRule[], maskCharacter: string): boolean {\n\t\tfor (const rule of maskRule) {\n\t\t\tif (rule.symbol === maskCharacter) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t/**\n\t * Format the value by applying the mask.\n\t * @param value String value from the model without the mask\n\t * @returns String value with the mask\n\t */\n\n\tformatValue(value: string): string {\n\t\tif (!value) return value;\n\n\t\tconst maskRulesPerCharacter: Record<string, string> = {};\n\t\tlet formatValue = \"\";\n\t\t// Create a map of mask rules per character\n\t\tif (this.oFormatOptions.maskRule) {\n\t\t\tfor (const rule of this.oFormatOptions.maskRule) {\n\t\t\t\tmaskRulesPerCharacter[rule.symbol] = rule.regex;\n\t\t\t}\n\t\t\tlet valueIndex = 0;\n\t\t\tlet formattedValue = \"\";\n\t\t\tconst mask = this.oFormatOptions.mask;\n\t\t\tfor (let i = 0; i < mask.length; i++) {\n\t\t\t\t// Process character by character, comparing with the mask rules\n\t\t\t\t// If the character matches a mask rule, replace it with the character from the value and increment the value index;\n\t\t\t\t// Otherwise replace it with the character from the mask\n\t\t\t\tif (maskRulesPerCharacter[mask[i]]) {\n\t\t\t\t\tif (value[valueIndex] && value[valueIndex].match(new RegExp(maskRulesPerCharacter[mask[i]]))) {\n\t\t\t\t\t\tformattedValue += value[valueIndex++];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tformattedValue += this.oFormatOptions.placeholderSymbol;\n\t\t\t\t\t}\n\t\t\t\t} else if (mask[i] === \"^\") {\n\t\t\t\t\t// if the mask character is ^ then add the character after it to the formatted value and increment the value i++\n\t\t\t\t\tformattedValue += mask[i + 1];\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tformattedValue += mask[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tformatValue = formattedValue;\n\t\t}\n\t\treturn formatValue;\n\t}\n}\nexport default InputMaskType;\n"],"mappings":"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","ignoreList":[],"file":"InputMask-dbg.js"}