{"version":3,"file":"BuildingBlockTemplateProcessor.js","names":["LOGGER_SCOPE","XMLTEMPLATING_NS","DOMParserInstance","DOMParser","validateMacroMetadataContext","sName","mContexts","oContextSettings","sKey","oContext","oContextObject","getObject","required","Error","hasOwnProperty","$kind","undefined","expectedTypes","includes","getPath","$Type","expectedAnnotationTypes","validateMacroSignature","oMetadata","oNode","aMetadataContextKeys","metadataContexts","Object","keys","aProperties","properties","oAttributeNames","attributeNames","getAttributeNames","attributeName","forEach","oPropertySettings","hasAttribute","startsWith","Log","warning","_exports","SAP_UI_CORE_ELEMENT","SAP_UI_MODEL_CONTEXT","transformMetadata","buildingBlockMetadata","class","type","isPublic","aggregations","dependents","slot","customData","layoutData","propertyName","propertyType","_checkAbsoluteAndContextPaths","oSettings","sAttributeValue","sMetaPath","sContextPath","currentContextPath","endsWith","model","path","_createInitialMetadataContext","sAttributeName","returnContext","models","converterContext","getProperty","data","unstoreObjectValue","setProperty","bindingContexts","entitySet","_getMetadataContext","oVisitor","bDoNotResolve","isOpen","oMetadataContext","getAttribute","BindingInfo","parse","metaContextPath","context","getContext","getModel","isA","e","async","processProperties","definitionProperties","aDefinitionPropertiesKeys","propertyValues","sKeyValue","defaultValue","deepClone","error","visitAttribute","attributes","getNamedItem","value","Number","processContexts","contextPath","mMissingContext","oDefinitionContexts","aDefinitionContextsKeys","contextPathIndex","indexOf","contextPathDefinition","splice","propertyValue","length","name","addSingleContext","parseAggregation","oAggregation","definition","oOutObjects","children","firstElementChild","namespaceURI","oParent","parentNode","visitNode","childIdx","childDefinition","childKey","skipKey","multiple","uid","setAttribute","aggregationObject","key","position","placement","Placement","After","anchor","processAggregations","tagName","nodeName","processObject","element","myArray","myObject","childNodeNames","map","localName","childIsArray","Set","size","push","processChildren","oAggregations","oFirstElementChild","iChildIndex","Array","from","nextElementSibling","sChildName","sAggregationName","toUpperCase","defaultAggregation","aggregationDefinition","parsedAggregation","parsedAggregationKey","oNextChild","nextChild","hasVirtualNode","childWrapper","document","createElementNS","appendChild","removeAttribute","oNewChild","cloneNode","aggregationPropertyValues","myChild","processSlots","oMetadataAggregations","processCustomData","arguments","oAggregationElement","oElementChild","sSlotName","oTargetElement","querySelector","prepareAggregationElement","replaceWith","replace","processBuildingBlock","BuildingBlockClass","metadata","sFragmentName","fragment","namespace","publicNamespace","xmlTag","getSettings","JSONModel","initialKeys","oControlConfig","viewData","processedPropertyValues","propName","oData","originalDefinition","validate","oInstance","getProperties","sContextName","targetObject","isContext","attributeValue","storeObjectValue","newContext","createBindingContext","oAttributesModel","AttributeModel","oPreviousMacroInfo","coreRequire","TraceInfo","isTraceInfoActive","oTraceInfo","traceMacroCalls","macroInfo","oContextVisitor","with","oPromise","insertFragment","oldKeys","temporaryObjectStore","templateString","jsx","renderAsXML","getTemplate","isRuntime","storeKey","hasError","hasParseError","parsedTemplate","parseXMLString","iter","createNodeIterator","NodeFilter","SHOW_TEXT","textnode","nextNode","textContent","trim","processXmlInTrace","initialTemplate","oErrorText","createErrorXML","template","outerHTML","join","visitedNodes","internalNode","Promise","all","remove","resolve","oMacroElement","oRemainingSlots","querySelectorAll","oSlotElement","requireOnMacro","getAttributeNS","substring","setAttributeNS","classList","add","traceDetails","initialProperties","resolvedProperties","missingContexts","oError","stack","oTemplate","oCtx","mSetting","ex","registerBuildingBlock","XMLPreprocessor","plugIn","unregisterBuildingBlock","errorMessages","xmlFragment","additionalData","errorLabels","errorMessage","xml","escapeXMLAttributeValue","errorStack","stackFormatted","btoa","additionalText","jsonValue","JSON","stringify","replaceAll","propertyUID","processNextXmlInTrace","method","returnValue","xmlString","addDefaultNamespaces","xmlDocument","parseFromString","output","parentElement","renderInTraceMode","outStr","xmlResult","innerText","innerHTML","split","strings","i","_len","values","_key","isArray","flat","isFunctionArray","valuefn","isBindingToolkitExpression","compiledExpression","compileExpression","propertyUId","addConditionallyToXML","condition","partToAdd","addAttributeToXML","isUndefinedExpression"],"sources":["./BuildingBlockTemplateProcessor.ts"],"sourcesContent":["import Log from \"sap/base/Log\";\nimport deepClone from \"sap/base/util/deepClone\";\nimport uid from \"sap/base/util/uid\";\nimport type { BindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport { compileExpression, isBindingToolkitExpression, isUndefinedExpression } from \"sap/fe/base/BindingToolkit\";\nimport jsx from \"sap/fe/base/jsx-runtime/jsx\";\nimport type AppComponent from \"sap/fe/core/AppComponent\";\nimport type ResourceModel from \"sap/fe/core/ResourceModel\";\nimport AttributeModel from \"sap/fe/core/buildingBlocks/templating/AttributeModel\";\nimport type {\n\tBuildingBlockAggregationDefinition,\n\tBuildingBlockMetadata,\n\tBuildingBlockMetadataContextDefinition,\n\tBuildingBlockPropertyDefinition,\n\tObjectValue,\n\tObjectValue2\n} from \"sap/fe/core/buildingBlocks/templating/BuildingBlockSupport\";\nimport type BuildingBlockTemplatingBase from \"sap/fe/core/buildingBlocks/templating/BuildingBlockTemplatingBase\";\nimport type { Position } from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport { Placement } from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport type { DefinitionContext, DefinitionPage } from \"sap/fe/core/definition/FEDefinition\";\nimport { isContext, isFunctionArray } from \"sap/fe/core/helpers/TypeGuards\";\nimport BindingInfo from \"sap/ui/base/BindingInfo\";\nimport type Control from \"sap/ui/core/Control\";\nimport XMLPreprocessor from \"sap/ui/core/util/XMLPreprocessor\";\nimport type Context from \"sap/ui/model/Context\";\nimport type Model from \"sap/ui/model/Model\";\nimport JSONModel from \"sap/ui/model/json/JSONModel\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\nimport type { MacroInfo } from \"../TraceInfo\";\nimport TraceInfo from \"../TraceInfo\";\n\nconst LOGGER_SCOPE = \"sap.fe.core.buildingBlocks.templating.BuildingBlockTemplateProcessor\";\nconst XMLTEMPLATING_NS = \"http://schemas.sap.com/sapui5/extension/sap.ui.core.template/1\";\nconst DOMParserInstance = new DOMParser();\n\nexport type TransformedBuildingBlockMetadata = BuildingBlockMetadata & {\n\tmetadataContexts: Record<string, BuildingBlockMetadataContextDefinition>;\n};\n\n/**\n * Definition of a meta data context\n */\ntype MetaDataContext = {\n\tname?: string;\n\tmodel: string;\n\tpath: string;\n};\n\nexport type TemplateProcessorSettings = {\n\tcurrentContextPath: Context;\n\tisPublic: boolean;\n\tappComponent: AppComponent;\n\tisRuntimeInstantiation?: boolean;\n\tmodels: Record<string, Model> & {\n\t\tconverterContext: JSONModel;\n\t\tviewData: JSONModel;\n\t\tinternal: JSONModel;\n\t\tmetaModel: ODataMetaModel;\n\t\t\"sap.fe.i18n\"?: ResourceModel;\n\t};\n\tgetDefinitionContext(): DefinitionContext;\n\tgetDefinitionForPage(): DefinitionPage;\n\tbindingContexts: Record<string, Context>;\n\t_macroInfo?: MacroInfo;\n\t[k: string]: unknown;\n};\n\nexport type IVisitorCallback = {\n\tgetSettings(): TemplateProcessorSettings;\n\t/**\n\t * Visits the given node and either processes a template instruction, calls\n\t * a visitor, or simply calls both {@link\n\t * sap.ui.core.util.XMLPreprocessor.ICallback.visitAttributes visitAttributes}\n\t * and {@link sap.ui.core.util.XMLPreprocessor.ICallback.visitChildNodes\n\t * visitChildNodes}.\n\t * @param oNode\n\t *   The XML DOM node\n\t * @returns\n\t *   A thenable which resolves with <code>undefined</code> as soon as visiting\n\t *   is done, or is rejected with a corresponding error if visiting fails\n\t */\n\tvisitNode(oNode: Node): Promise<void>;\n\n\t/**\n\t * Inserts the fragment with the given name in place of the given element. Loads the\n\t * fragment, takes care of caching (for the current pre-processor run) and visits the\n\t * fragment's content once it has been imported into the element's owner document and\n\t * put into place. Loading of fragments is asynchronous if the template view is\n\t * asynchronous.\n\t * @param sFragment\n\t *   the fragment's resolved name\n\t * @param oElement\n\t *   the XML DOM element, e.g. <sap.ui.core:Fragment> or <core:ExtensionPoint>\n\t * @param oWith\n\t *   the parent's \"with\" control\n\t * @returns\n\t * A sync promise which resolves with <code>undefined</code> as soon as the fragment\n\t *   has been inserted, or is rejected with a corresponding error if loading or visiting\n\t *   fails.\n\t */\n\tinsertFragment(sFragment: string, oElement: Element, oWith?: Control): Promise<void>;\n\tvisitAttribute(oNode: Element, oAttribute: Attr): Promise<void>;\n\tvisitAttributes(oNode: Element): Promise<void>;\n\tgetViewInfo(): Promise<unknown>;\n\tvisitChildNodes(oNode: Node): Promise<void>;\n\t/**\n\t * Interprets the given XML DOM attribute value as a binding and returns the\n\t * resulting value.\n\t * @param sValue\n\t *   An XML DOM attribute value\n\t * @param [element]\n\t *   The XML DOM element the attribute value belongs to (needed only for\n\t *   warnings which are logged to the console)\n\t * @returns\n\t *   A thenable which resolves with the resulting value, or is rejected with a\n\t *   corresponding error (for example, an error thrown by a formatter) or\n\t *   <code>null</code> in case the binding is not ready (because it refers to a\n\t *   model which is not available) (since 1.57.0)\n\t */\n\tgetResult(sValue: string, element?: Element): Promise<Context> | null;\n\tgetContext(sPath?: string): Context | undefined;\n\t/**\n\t * Returns a callback interface instance for the given map of variables which\n\t * override currently known variables of the same name in <code>this</code>\n\t * parent interface or replace them altogether. Each variable name becomes a\n\t * named model with a corresponding object binding and can be used inside the\n\t * XML template in the usual way, that is, with a binding expression like\n\t * <code>\"{var>some/relative/path}\"</code> (see example).\n\t * @param [mVariables={}]\n\t *   Map from variable name (string) to value\n\t * @param [bReplace]\n\t *   Whether only the given variables are known in the new callback interface\n\t *   instance, no inherited ones\n\t * @returns\n\t *   A callback interface instance\n\t * @param mVariables\n\t * @param bReplace\n\t */\n\t\"with\"(mVariables?: Record<string, Context>, bReplace?: boolean): IVisitorCallback;\n};\n\nfunction validateMacroMetadataContext(\n\tsName: string,\n\tmContexts: Record<string, Context>,\n\toContextSettings: BuildingBlockMetadataContextDefinition,\n\tsKey: string\n): void {\n\tconst oContext = mContexts[sKey];\n\tconst oContextObject = oContext?.getObject() as {\n\t\t$Type?: string;\n\t\t$kind?: string;\n\t};\n\n\tif (oContextSettings.required === true && (!oContext || oContextObject === null)) {\n\t\tthrow new Error(`${sName}: Required metadataContext '${sKey}' is missing`);\n\t} else if (oContextObject) {\n\t\t// If context object has $kind property, $Type should not be checked\n\t\t// Therefore remove from context settings\n\t\tif (oContextObject.hasOwnProperty(\"$kind\") && oContextObject.$kind !== undefined && oContextSettings.expectedTypes !== undefined) {\n\t\t\t// Check if the $kind is part of the allowed ones\n\t\t\tif (!oContextSettings.expectedTypes.includes(oContextObject.$kind)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`${sName}: '${sKey}' must be '$kind' '${oContextSettings.expectedTypes}' but is '${\n\t\t\t\t\t\toContextObject.$kind\n\t\t\t\t\t}': ${oContext.getPath()}`\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (\n\t\t\toContextObject.hasOwnProperty(\"$Type\") &&\n\t\t\toContextObject.$Type !== undefined &&\n\t\t\toContextSettings.expectedAnnotationTypes\n\t\t) {\n\t\t\t// Check only $Type\n\t\t\tif (!oContextSettings.expectedAnnotationTypes.includes(oContextObject.$Type)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`${sName}: '${sKey}' must be '$Type' '${oContextSettings.expectedAnnotationTypes}' but is '${\n\t\t\t\t\t\toContextObject.$Type\n\t\t\t\t\t}': ${oContext.getPath()}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\nexport function validateMacroSignature(\n\tsName: string,\n\toMetadata: TransformedBuildingBlockMetadata,\n\tmContexts: Record<string, Context>,\n\toNode: Element\n): void {\n\tconst aMetadataContextKeys = (oMetadata.metadataContexts && Object.keys(oMetadata.metadataContexts)) || [],\n\t\taProperties = (oMetadata.properties && Object.keys(oMetadata.properties)) || [],\n\t\toAttributeNames: Record<string, boolean> = {};\n\n\t// collect all attributes to find unchecked properties\n\tconst attributeNames = oNode.getAttributeNames();\n\tfor (const attributeName of attributeNames) {\n\t\toAttributeNames[attributeName] = true;\n\t}\n\n\t//Check metadataContexts\n\taMetadataContextKeys.forEach(function (sKey) {\n\t\tconst oContextSettings = oMetadata.metadataContexts[sKey];\n\n\t\tvalidateMacroMetadataContext(sName, mContexts, oContextSettings, sKey);\n\t\tdelete oAttributeNames[sKey];\n\t});\n\t//Check properties\n\taProperties.forEach(function (sKey) {\n\t\tconst oPropertySettings = oMetadata.properties[sKey];\n\t\tif (!oNode.hasAttribute(sKey)) {\n\t\t\tif (oPropertySettings.required && !oPropertySettings.hasOwnProperty(\"defaultValue\")) {\n\t\t\t\tthrow new Error(`${sName}: ` + `Required property '${sKey}' is missing`);\n\t\t\t}\n\t\t} else {\n\t\t\tdelete oAttributeNames[sKey];\n\t\t}\n\t});\n\n\t// Unchecked properties\n\tObject.keys(oAttributeNames).forEach(function (sKey: string) {\n\t\t// no check for properties which contain a colon \":\" (different namespace), e.g. xmlns:trace, trace:macroID, unittest:id\n\t\tif (!sKey.includes(\":\") && !sKey.startsWith(\"xmlns\")) {\n\t\t\tLog.warning(`Unchecked parameter: ${sName}: ${sKey}`, undefined, LOGGER_SCOPE);\n\t\t}\n\t});\n}\n\nconst SAP_UI_CORE_ELEMENT = \"sap.ui.core.Element\";\n\nexport const SAP_UI_MODEL_CONTEXT = \"sap.ui.model.Context\";\n\n/**\n * Transforms the metadata of a building block by adding additional aggregations,\n * and splitting properties into actual properties and metadata contexts.\n * @param buildingBlockMetadata The metadata received from the input\n * @returns The transformed metadata\n */\nfunction transformMetadata(buildingBlockMetadata: BuildingBlockMetadata): TransformedBuildingBlockMetadata {\n\tconst properties: Record<string, BuildingBlockPropertyDefinition> = {\n\t\tclass: {\n\t\t\ttype: \"string\",\n\t\t\tisPublic: true\n\t\t}\n\t};\n\tconst aggregations: Record<string, BuildingBlockAggregationDefinition> = {\n\t\tdependents: {\n\t\t\ttype: SAP_UI_CORE_ELEMENT,\n\t\t\tslot: \"dependents\",\n\t\t\tisPublic: true\n\t\t},\n\t\tcustomData: {\n\t\t\ttype: SAP_UI_CORE_ELEMENT,\n\t\t\tslot: \"customData\",\n\t\t\tisPublic: true\n\t\t},\n\t\tlayoutData: {\n\t\t\ttype: SAP_UI_CORE_ELEMENT,\n\t\t\tslot: \"layoutData\",\n\t\t\tisPublic: true\n\t\t},\n\t\t...buildingBlockMetadata.aggregations\n\t};\n\tconst metadataContexts: Record<string, BuildingBlockMetadataContextDefinition> = {};\n\n\tfor (const propertyName of Object.keys(buildingBlockMetadata.properties)) {\n\t\tconst propertyType = buildingBlockMetadata.properties[propertyName].type;\n\n\t\tif (propertyType !== SAP_UI_MODEL_CONTEXT) {\n\t\t\tproperties[propertyName] = buildingBlockMetadata.properties[propertyName];\n\t\t}\n\n\t\tif ([SAP_UI_MODEL_CONTEXT, \"object\", \"array\"].includes(propertyType)) {\n\t\t\t// Explicitly defined contexts, objects, and arrays may come from the metadataContext\n\t\t\tmetadataContexts[propertyName] = buildingBlockMetadata.properties[propertyName] as BuildingBlockMetadataContextDefinition;\n\t\t}\n\t}\n\n\treturn {\n\t\t...buildingBlockMetadata,\n\t\tproperties,\n\t\tmetadataContexts,\n\t\taggregations\n\t};\n}\n\n/**\n * Checks the absolute or context paths and returns an appropriate MetaContext.\n * @param oSettings Additional settings\n * @param sAttributeValue The attribute value\n * @returns The meta data context object\n */\nfunction _checkAbsoluteAndContextPaths(oSettings: TemplateProcessorSettings, sAttributeValue: string): MetaDataContext {\n\tlet sMetaPath: string;\n\tif (sAttributeValue && sAttributeValue.startsWith(\"/\")) {\n\t\t// absolute path - we just use this one\n\t\tsMetaPath = sAttributeValue;\n\t} else {\n\t\tlet sContextPath = oSettings.currentContextPath.getPath();\n\t\tif (!sContextPath.endsWith(\"/\")) {\n\t\t\tsContextPath += \"/\";\n\t\t}\n\t\tsMetaPath = sContextPath + sAttributeValue;\n\t}\n\treturn {\n\t\tmodel: \"metaModel\",\n\t\tpath: sMetaPath\n\t};\n}\n\n/**\n * This method helps to create the metadata context in case it is not yet available in the store.\n * @param oSettings Additional settings\n * @param sAttributeName The attribute name\n * @param sAttributeValue The attribute value\n * @returns The meta data context object\n */\nfunction _createInitialMetadataContext(\n\toSettings: TemplateProcessorSettings,\n\tsAttributeName: string,\n\tsAttributeValue: string\n): MetaDataContext {\n\tlet returnContext: MetaDataContext;\n\tif (sAttributeValue.startsWith(\"/uid--\") && !oSettings.models.converterContext.getProperty(sAttributeValue)) {\n\t\tconst data = unstoreObjectValue(sAttributeValue);\n\t\toSettings.models.converterContext.setProperty(sAttributeValue, data);\n\t\treturnContext = {\n\t\t\tmodel: \"converterContext\",\n\t\t\tpath: sAttributeValue\n\t\t};\n\t} else if ((sAttributeName === \"metaPath\" && oSettings.currentContextPath) || sAttributeName === \"contextPath\") {\n\t\treturnContext = _checkAbsoluteAndContextPaths(oSettings, sAttributeValue);\n\t} else if (sAttributeValue && sAttributeValue.startsWith(\"/\")) {\n\t\t// absolute path - we just use this one\n\t\treturnContext = {\n\t\t\tmodel: \"metaModel\",\n\t\t\tpath: sAttributeValue\n\t\t};\n\t} else {\n\t\treturnContext = {\n\t\t\tmodel: \"metaModel\",\n\t\t\tpath: oSettings.bindingContexts.entitySet ? oSettings.bindingContexts.entitySet.getPath(sAttributeValue) : sAttributeValue\n\t\t};\n\t}\n\treturn returnContext;\n}\n\nfunction _getMetadataContext(\n\toSettings: TemplateProcessorSettings,\n\toNode: Element,\n\tsAttributeName: string,\n\toVisitor: IVisitorCallback,\n\tbDoNotResolve: boolean,\n\tisOpen: boolean\n): MetaDataContext | undefined {\n\tlet oMetadataContext: MetaDataContext | undefined;\n\tif (!bDoNotResolve && oNode.hasAttribute(sAttributeName)) {\n\t\tlet sAttributeValue = oNode.getAttribute(sAttributeName) as string;\n\t\toMetadataContext = BindingInfo.parse(sAttributeValue);\n\t\tif (oMetadataContext && sAttributeName === \"metaPath\" && oMetadataContext.model && oMetadataContext.path) {\n\t\t\t// if the metaPath is filled through a JSON model, we can't use this context as the metadataContext,\n\t\t\t// but instead we have to create a new one with the actual value\n\t\t\tconst metaContextPath = `${oMetadataContext.model}>${oMetadataContext.path}`;\n\t\t\tconst context = oVisitor.getContext(metaContextPath);\n\t\t\tif (context?.getModel()?.isA(\"sap.ui.model.json.JSONModel\")) {\n\t\t\t\tsAttributeValue = context.getObject();\n\t\t\t\toMetadataContext = undefined;\n\t\t\t}\n\t\t}\n\n\t\tif (!oMetadataContext) {\n\t\t\toMetadataContext = _createInitialMetadataContext(oSettings, sAttributeName, sAttributeValue);\n\t\t}\n\t} else if (oSettings.bindingContexts.hasOwnProperty(sAttributeName)) {\n\t\toMetadataContext = {\n\t\t\tmodel: sAttributeName,\n\t\t\tpath: \"\"\n\t\t};\n\t} else if (isOpen) {\n\t\ttry {\n\t\t\tif (oVisitor.getContext(`${sAttributeName}>`)) {\n\t\t\t\toMetadataContext = {\n\t\t\t\t\tmodel: sAttributeName,\n\t\t\t\t\tpath: \"\"\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\treturn oMetadataContext;\n}\n\n/**\n * Parse the incoming XML node and try to resolve the properties defined there.\n * @param oMetadata The metadata for the building block\n * @param oNode The XML node to parse\n * @param isPublic Whether the building block is used in a public context or not\n * @param oVisitor The visitor instance\n * @returns The processed properties\n */\nasync function processProperties(\n\toMetadata: TransformedBuildingBlockMetadata,\n\toNode: Element,\n\tisPublic: boolean,\n\toVisitor: IVisitorCallback\n): Promise<Record<string, ObjectValue>> {\n\tconst definitionProperties = oMetadata.properties;\n\n\t// Retrieve properties values\n\tconst aDefinitionPropertiesKeys = Object.keys(definitionProperties);\n\n\tconst propertyValues: Record<string, ObjectValue> = {};\n\tfor (const sKeyValue of aDefinitionPropertiesKeys) {\n\t\tif (definitionProperties[sKeyValue].type === \"object\") {\n\t\t\tpropertyValues[sKeyValue] =\n\t\t\t\tdefinitionProperties[sKeyValue].defaultValue && deepClone(definitionProperties[sKeyValue].defaultValue); // To avoid values being reused across macros\n\t\t} else {\n\t\t\tpropertyValues[sKeyValue] = definitionProperties[sKeyValue].defaultValue as string | boolean | number;\n\t\t}\n\n\t\tif (oNode.hasAttribute(sKeyValue) && isPublic && definitionProperties[sKeyValue].isPublic !== true) {\n\t\t\tLog.error(`Property ${sKeyValue} was ignored as it is not intended for public usage`);\n\t\t} else if (oNode.hasAttribute(sKeyValue)) {\n\t\t\tawait oVisitor.visitAttribute(oNode, oNode.attributes.getNamedItem(sKeyValue) as Attr);\n\t\t\tlet value: string | boolean | number | null | undefined = oNode.getAttribute(sKeyValue);\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\tif (typeof value === \"string\" && !value.startsWith(\"{\")) {\n\t\t\t\t\tswitch (definitionProperties[sKeyValue].type) {\n\t\t\t\t\t\tcase \"boolean\":\n\t\t\t\t\t\t\tvalue = value === \"true\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"number\":\n\t\t\t\t\t\t\tvalue = Number(value);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvalue = value === null ? undefined : value;\n\t\t\t\tpropertyValues[sKeyValue] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn propertyValues;\n}\n\n/**\n * Parse the incoming XML node and try to resolve the binding contexts defined inside.\n * @param oMetadata The metadata for the building block\n * @param oSettings The settings object\n * @param oNode The XML node to parse\n * @param isPublic Whether the building block is used in a public context or not\n * @param oVisitor The visitor instance\n * @param mContexts The contexts to be used\n * @param propertyValues The current property values\n * @returns The processed and missing contexts\n */\nfunction processContexts(\n\toMetadata: TransformedBuildingBlockMetadata,\n\toSettings: TemplateProcessorSettings,\n\toNode: Element,\n\tisPublic: boolean,\n\toVisitor: IVisitorCallback,\n\tmContexts: Record<string, Context>,\n\tpropertyValues: Record<string, ObjectValue>\n): Record<string, boolean> {\n\toSettings.currentContextPath = oSettings.bindingContexts.contextPath;\n\tconst mMissingContext: Record<string, boolean> = {};\n\tconst oDefinitionContexts = oMetadata.metadataContexts;\n\tconst aDefinitionContextsKeys = Object.keys(oDefinitionContexts);\n\t// Since the metaPath and other property can be relative to the contextPath we need to evaluate the current contextPath first\n\tconst contextPathIndex = aDefinitionContextsKeys.indexOf(\"contextPath\");\n\tif (contextPathIndex !== -1) {\n\t\t// If it is defined we extract it and reinsert it in the first position of the array\n\t\tconst contextPathDefinition = aDefinitionContextsKeys.splice(contextPathIndex, 1);\n\t\taDefinitionContextsKeys.splice(0, 0, contextPathDefinition[0]);\n\t}\n\tfor (const sAttributeName of aDefinitionContextsKeys) {\n\t\t// If the context was resolved as a property (binding / xml aggregation) then we don't need to resolve it here.\n\t\tconst propertyValue = propertyValues[sAttributeName];\n\t\tif (propertyValue !== undefined && typeof propertyValue === \"object\" && Object.keys(propertyValue as object).length > 0) {\n\t\t\tdelete oMetadata.metadataContexts[sAttributeName];\n\t\t\tcontinue;\n\t\t}\n\t\tconst bDoNotResolve = isPublic && oDefinitionContexts[sAttributeName].isPublic === false && oNode.hasAttribute(sAttributeName);\n\t\tconst oMetadataContext = _getMetadataContext(oSettings, oNode, sAttributeName, oVisitor, bDoNotResolve, oMetadata.isOpen ?? false);\n\t\tif (oMetadataContext) {\n\t\t\toMetadataContext.name = sAttributeName;\n\t\t\taddSingleContext(mContexts, oVisitor, oMetadataContext);\n\t\t\tif (\n\t\t\t\t(sAttributeName === \"entitySet\" || sAttributeName === \"contextPath\") &&\n\t\t\t\t!oSettings.bindingContexts.hasOwnProperty(sAttributeName)\n\t\t\t) {\n\t\t\t\toSettings.bindingContexts[sAttributeName] = mContexts[sAttributeName];\n\t\t\t}\n\t\t\tif (sAttributeName === \"contextPath\") {\n\t\t\t\toSettings.currentContextPath = mContexts[sAttributeName];\n\t\t\t}\n\t\t\tif (mContexts[sAttributeName] !== undefined) {\n\t\t\t\tpropertyValues[sAttributeName] = mContexts[sAttributeName];\n\t\t\t} else if (typeof propertyValues[sAttributeName] === \"string\") {\n\t\t\t\t// If the binding couldn't be resolved consider that there was no value here\n\t\t\t\tdelete oMetadata.metadataContexts[sAttributeName];\n\t\t\t}\n\t\t} else {\n\t\t\tmMissingContext[sAttributeName] = true;\n\t\t}\n\t}\n\treturn mMissingContext;\n}\n\nexport type BuildingBlockAggregation = {\n\tkey: string;\n\tposition: Position;\n\ttype: \"Slot\";\n};\nasync function parseAggregation(\n\toVisitor: IVisitorCallback,\n\toAggregation?: Element,\n\tdefinition?: BuildingBlockAggregationDefinition\n): Promise<Record<string, BuildingBlockAggregation>> {\n\tconst oOutObjects: Record<string, BuildingBlockAggregation> = {};\n\tif (oAggregation && oAggregation.children.length > 0) {\n\t\tconst firstElementChild = oAggregation.firstElementChild;\n\t\tif (firstElementChild?.namespaceURI === XMLTEMPLATING_NS) {\n\t\t\t// In case we encounter a templating tag, run the visitor on it and continue with the resulting child\n\t\t\tconst oParent = firstElementChild.parentNode;\n\t\t\tif (oParent) {\n\t\t\t\tawait oVisitor.visitNode(firstElementChild);\n\t\t\t}\n\t\t}\n\t\tconst children = oAggregation.children;\n\t\tfor (let childIdx = 0; childIdx < children.length; childIdx++) {\n\t\t\tconst childDefinition = children[childIdx];\n\t\t\tlet childKey =\n\t\t\t\tchildDefinition.getAttribute(\"key\") ||\n\t\t\t\tchildDefinition.getAttribute(\"id\") ||\n\t\t\t\t(definition?.skipKey && definition.multiple === false && uid());\n\t\t\tif (childKey) {\n\t\t\t\tchildKey = `InlineXML_${childKey}`;\n\t\t\t\tchildDefinition.setAttribute(\"key\", childKey);\n\t\t\t\tlet aggregationObject: BuildingBlockAggregation = {\n\t\t\t\t\tkey: childKey,\n\t\t\t\t\tposition: {\n\t\t\t\t\t\tplacement: (childDefinition.getAttribute(\"placement\") as Placement) || Placement.After,\n\t\t\t\t\t\tanchor: childDefinition.getAttribute(\"anchor\") || undefined\n\t\t\t\t\t},\n\t\t\t\t\ttype: \"Slot\"\n\t\t\t\t};\n\t\t\t\tif (definition?.processAggregations) {\n\t\t\t\t\taggregationObject = definition.processAggregations(childDefinition, aggregationObject);\n\t\t\t\t}\n\t\t\t\toOutObjects[aggregationObject.key] = aggregationObject;\n\t\t\t} else if (childDefinition.tagName !== \"slot\") {\n\t\t\t\tLog.error(`The aggregation ${childDefinition.nodeName} is missing a Key attribute. It is not displayed`);\n\t\t\t}\n\t\t}\n\t}\n\treturn oOutObjects;\n}\n\n/**\n * Processes the child nodes of the building block properties when the type is an object.\n * @param element The XML element to parse\n * @returns The processed object\n */\nfunction processObject(element: Element): object {\n\tconst children = element.children;\n\tconst myArray: Array<unknown> = [];\n\tconst myObject: Record<string, unknown> = {};\n\tfor (const attributeName of element.getAttributeNames()) {\n\t\tmyObject[attributeName] = element.getAttribute(attributeName);\n\t}\n\tif (children.length > 0) {\n\t\tconst childNodeNames = Object.keys(children).map((key) => children[key as unknown as number].localName);\n\t\tconst childIsArray = childNodeNames.length !== new Set(childNodeNames).size;\n\t\tfor (const childDefinition of children as unknown as Array<Element>) {\n\t\t\tif (childIsArray) {\n\t\t\t\tmyArray.push(processObject(childDefinition));\n\t\t\t} else {\n\t\t\t\tmyObject[childDefinition.localName] = processObject(childDefinition);\n\t\t\t}\n\t\t}\n\t\tif (childIsArray) {\n\t\t\treturn myArray;\n\t\t}\n\t}\n\treturn myObject;\n}\n\n/**\n * Processes the child nodes of the building block and parses them as either aggregations or object-/array-based values.\n * @param oNode The XML node for which to process the children\n * @param oVisitor The visitor instance\n * @param oMetadata The metadata for the building block\n * @param isPublic Whether the building block is used in a public context or not\n * @param propertyValues The values of already parsed property\n * @returns The processed children\n */\nasync function processChildren(\n\toNode: Element,\n\toVisitor: IVisitorCallback,\n\toMetadata: TransformedBuildingBlockMetadata,\n\tisPublic: boolean,\n\tpropertyValues: Record<string, ObjectValue>\n): Promise<Record<string, Element>> {\n\tconst oAggregations: Record<string, Element> = {};\n\tif (oNode.firstElementChild !== null) {\n\t\tlet oFirstElementChild: Element | null = oNode.firstElementChild as Element | null;\n\n\t\twhile (oFirstElementChild !== null) {\n\t\t\tif (oFirstElementChild.namespaceURI === XMLTEMPLATING_NS) {\n\t\t\t\t// In case we encounter a templating tag, run the visitor on it and continue with the resulting child\n\t\t\t\tconst oParent = oFirstElementChild.parentNode;\n\t\t\t\tif (oParent) {\n\t\t\t\t\tconst iChildIndex = Array.from(oParent.children).indexOf(oFirstElementChild);\n\t\t\t\t\tawait oVisitor.visitNode(oFirstElementChild);\n\t\t\t\t\toFirstElementChild = oParent.children[iChildIndex] ? oParent.children[iChildIndex] : null;\n\t\t\t\t} else {\n\t\t\t\t\t// Not sure how this could happen but I also don't want to create infinite loops\n\t\t\t\t\toFirstElementChild = oFirstElementChild.nextElementSibling;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst sChildName = oFirstElementChild.localName;\n\t\t\t\tlet sAggregationName = sChildName;\n\t\t\t\tif (sAggregationName[0].toUpperCase() === sAggregationName[0]) {\n\t\t\t\t\t// not a sub aggregation, go back to default Aggregation\n\t\t\t\t\tsAggregationName = oMetadata.defaultAggregation || \"\";\n\t\t\t\t}\n\t\t\t\tconst aggregationDefinition = oMetadata.aggregations[sAggregationName];\n\t\t\t\tif (aggregationDefinition !== undefined && !aggregationDefinition.slot) {\n\t\t\t\t\tconst parsedAggregation = await parseAggregation(oVisitor, oFirstElementChild, aggregationDefinition);\n\t\t\t\t\tpropertyValues[sAggregationName] = parsedAggregation;\n\t\t\t\t\tfor (const parsedAggregationKey in parsedAggregation) {\n\t\t\t\t\t\toMetadata.aggregations[parsedAggregationKey] = parsedAggregation[parsedAggregationKey];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toFirstElementChild = oFirstElementChild.nextElementSibling;\n\t\t\t}\n\t\t}\n\n\t\toFirstElementChild = oNode.firstElementChild;\n\t\twhile (oFirstElementChild !== null) {\n\t\t\tconst oNextChild: Element | null = oFirstElementChild.nextElementSibling;\n\t\t\tconst sChildName = oFirstElementChild.localName;\n\t\t\tlet sAggregationName = sChildName;\n\t\t\tif (sAggregationName[0].toUpperCase() === sAggregationName[0]) {\n\t\t\t\t// not a sub aggregation, go back to default Aggregation\n\t\t\t\tsAggregationName = oMetadata.defaultAggregation || \"\";\n\t\t\t}\n\t\t\tif (\n\t\t\t\tObject.keys(oMetadata.aggregations).includes(sAggregationName) &&\n\t\t\t\t(!isPublic || oMetadata.aggregations[sAggregationName].isPublic === true)\n\t\t\t) {\n\t\t\t\tconst aggregationDefinition = oMetadata.aggregations[sAggregationName];\n\t\t\t\tif (!aggregationDefinition.slot && oFirstElementChild !== null && oFirstElementChild.children.length > 0) {\n\t\t\t\t\tawait oVisitor.visitNode(oFirstElementChild);\n\t\t\t\t\tlet childDefinition = oFirstElementChild.firstElementChild;\n\t\t\t\t\twhile (childDefinition) {\n\t\t\t\t\t\tconst nextChild = childDefinition.nextElementSibling;\n\t\t\t\t\t\tif (!aggregationDefinition.hasVirtualNode) {\n\t\t\t\t\t\t\tconst childWrapper = document.createElementNS(oNode.namespaceURI, childDefinition.getAttribute(\"key\")!);\n\t\t\t\t\t\t\tchildWrapper.appendChild(childDefinition);\n\t\t\t\t\t\t\toAggregations[childDefinition.getAttribute(\"key\")!] = childWrapper;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toAggregations[childDefinition.getAttribute(\"key\")!] = childDefinition;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tchildDefinition.removeAttribute(\"key\");\n\t\t\t\t\t\tchildDefinition = nextChild;\n\t\t\t\t\t}\n\t\t\t\t} else if (aggregationDefinition.slot) {\n\t\t\t\t\tawait oVisitor.visitNode(oFirstElementChild);\n\t\t\t\t\tif (sAggregationName !== sChildName) {\n\t\t\t\t\t\tif (!oAggregations[sAggregationName]) {\n\t\t\t\t\t\t\tconst oNewChild = document.createElementNS(oNode.namespaceURI, sAggregationName);\n\t\t\t\t\t\t\toAggregations[sAggregationName] = oNewChild;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toAggregations[sAggregationName].appendChild(oFirstElementChild.cloneNode(true) as Element);\n\t\t\t\t\t} else {\n\t\t\t\t\t\toAggregations[sAggregationName] = oFirstElementChild.cloneNode(true) as Element;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (Object.keys(oMetadata.properties).includes(sAggregationName)) {\n\t\t\t\tawait oVisitor.visitNode(oFirstElementChild);\n\t\t\t\tif (oMetadata.properties[sAggregationName].type === \"object\") {\n\t\t\t\t\tconst aggregationPropertyValues = processObject(oFirstElementChild);\n\t\t\t\t\tpropertyValues[sAggregationName] = aggregationPropertyValues;\n\t\t\t\t} else if (oMetadata.properties[sAggregationName].type === \"array\") {\n\t\t\t\t\tif (oFirstElementChild !== null && oFirstElementChild.children.length > 0) {\n\t\t\t\t\t\tconst children = oFirstElementChild.children;\n\t\t\t\t\t\tconst oOutObjects: Record<string, ObjectValue2>[] = [];\n\t\t\t\t\t\tfor (let childIdx = 0; childIdx < children.length; childIdx++) {\n\t\t\t\t\t\t\tconst childDefinition = children[childIdx];\n\t\t\t\t\t\t\t// non keyed child, just add it to the aggregation\n\t\t\t\t\t\t\tconst myChild: Record<string, ObjectValue2> = {};\n\t\t\t\t\t\t\tconst attributeNames = childDefinition.getAttributeNames();\n\t\t\t\t\t\t\tfor (const attributeName of attributeNames) {\n\t\t\t\t\t\t\t\tmyChild[attributeName] = childDefinition.getAttribute(attributeName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toOutObjects.push(myChild);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpropertyValues[sAggregationName] = oOutObjects;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toFirstElementChild = oNextChild;\n\t\t}\n\t}\n\treturn oAggregations;\n}\n\nfunction processSlots(\n\toAggregations: Record<string, Element>,\n\toMetadataAggregations: Record<string, BuildingBlockAggregationDefinition>,\n\toNode: Element,\n\tprocessCustomData = false\n): void {\n\tif (Object.keys(oAggregations).length > 0) {\n\t\tObject.keys(oAggregations).forEach(function (sAggregationName: string) {\n\t\t\tconst oAggregationElement = oAggregations[sAggregationName];\n\t\t\tif (oNode !== null && oNode !== undefined && oAggregationElement) {\n\t\t\t\t// slots can have :: as keys which is not a valid aggregation name therefore replacing them\n\t\t\t\tconst oElementChild = oAggregationElement.firstElementChild;\n\t\t\t\tif (![\"dependents\", \"customData\", \"layoutData\"].includes(sAggregationName)) {\n\t\t\t\t\tconst sSlotName =\n\t\t\t\t\t\t(oMetadataAggregations[sAggregationName] !== undefined && oMetadataAggregations[sAggregationName].slot) ||\n\t\t\t\t\t\tsAggregationName;\n\t\t\t\t\tconst oTargetElement = oNode.querySelector(`slot[name='${sSlotName}']`);\n\t\t\t\t\tif (oTargetElement !== null) {\n\t\t\t\t\t\tconst oNewChild = prepareAggregationElement(oNode, sAggregationName, oElementChild);\n\t\t\t\t\t\toTargetElement.replaceWith(...(oNewChild.children as unknown as Node[])); // Somehow TS doesn't like this but the documentation says is should work\n\t\t\t\t\t}\n\t\t\t\t} else if (processCustomData && oElementChild !== null) {\n\t\t\t\t\tconst sSlotName =\n\t\t\t\t\t\t(oMetadataAggregations[sAggregationName] !== undefined && oMetadataAggregations[sAggregationName].slot) ||\n\t\t\t\t\t\tsAggregationName;\n\t\t\t\t\tconst oTargetElement = oNode.querySelector(`slot[name='${sSlotName}']`);\n\t\t\t\t\tconst oNewChild = prepareAggregationElement(oNode, sAggregationName, oElementChild);\n\t\t\t\t\tif (oTargetElement !== null) {\n\t\t\t\t\t\toTargetElement.replaceWith(...(oNewChild.children as unknown as Node[])); // Somehow TS doesn't like this but the documentation says is should work\n\t\t\t\t\t} else {\n\t\t\t\t\t\toNode.appendChild(oNewChild);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction prepareAggregationElement(oNode: Element, sAggregationName: string, oElementChild: Element | null): Element {\n\tconst oNewChild = document.createElementNS(oNode.namespaceURI, sAggregationName.replace(/:/gi, \"_\"));\n\twhile (oElementChild) {\n\t\tconst oNextChild = oElementChild.nextElementSibling;\n\t\toNewChild.appendChild(oElementChild);\n\t\toElementChild = oNextChild;\n\t}\n\treturn oNewChild;\n}\n\nasync function processBuildingBlock(\n\tBuildingBlockClass: typeof BuildingBlockTemplatingBase,\n\toNode: Element,\n\toVisitor: IVisitorCallback,\n\tisPublic = false\n): Promise<void> {\n\tconst oMetadata = transformMetadata(BuildingBlockClass.metadata);\n\n\tconst sFragmentName = oMetadata.fragment ?? `${oMetadata.namespace ?? oMetadata.publicNamespace}.${oMetadata.xmlTag ?? oMetadata.name}`;\n\n\tconst mContexts: Record<string, Context> = {};\n\tconst oSettings = oVisitor.getSettings();\n\n\t// Add an empty converter context if there is none in order to have a place to store object values\n\toSettings.models.converterContext ??= new JSONModel();\n\n\t//Inject storage for macros\n\tif (!oSettings[sFragmentName]) {\n\t\toSettings[sFragmentName] = {};\n\t}\n\n\t// First of all we need to visit the attributes to resolve the properties and the metadata contexts\n\tconst propertyValues = await processProperties(oMetadata, oNode, isPublic, oVisitor);\n\tconst initialKeys = Object.keys(propertyValues);\n\tconst mMissingContext = processContexts(oMetadata, oSettings, oNode, isPublic, oVisitor, mContexts, propertyValues);\n\n\ttry {\n\t\t// Aggregation and complex type support\n\t\tconst oAggregations = await processChildren(oNode, oVisitor, oMetadata, isPublic, propertyValues);\n\t\tlet oControlConfig = {};\n\n\t\tif (oSettings.models.viewData) {\n\t\t\t// Only used in the Field macro and even then maybe not really useful\n\t\t\toControlConfig = oSettings.models.viewData.getProperty(\"/controlConfiguration\");\n\t\t}\n\t\tlet processedPropertyValues = propertyValues;\n\n\t\tObject.keys(propertyValues).forEach((propName) => {\n\t\t\tlet oData = propertyValues[propName] as unknown as Context;\n\t\t\t//check for additional processing function to validate / overwrite parameters\n\t\t\tconst originalDefinition = BuildingBlockClass?.metadata?.properties[propName];\n\t\t\tif (originalDefinition?.validate) {\n\t\t\t\toData = originalDefinition.validate(oData) || oData;\n\t\t\t}\n\t\t\tif (oData?.isA?.(SAP_UI_MODEL_CONTEXT) && !oData.getModel().isA(\"sap.ui.model.odata.v4.ODataMetaModel\")) {\n\t\t\t\tpropertyValues[propName] = oData.getObject();\n\t\t\t}\n\t\t});\n\t\tpropertyValues.isPublic = isPublic;\n\n\t\tconst oInstance = new BuildingBlockClass({ ...propertyValues, ...oAggregations }, oControlConfig, oSettings);\n\t\tprocessedPropertyValues = oInstance.getProperties();\n\t\tObject.keys(oMetadata.metadataContexts).forEach(function (sContextName: string) {\n\t\t\tif (processedPropertyValues.hasOwnProperty(sContextName)) {\n\t\t\t\tconst targetObject = processedPropertyValues[sContextName];\n\t\t\t\tif (isContext(targetObject)) {\n\t\t\t\t\tmContexts[sContextName] = targetObject as Context;\n\t\t\t\t} else if (typeof targetObject === \"object\") {\n\t\t\t\t\tconst attributeValue = storeObjectValue(targetObject);\n\t\t\t\t\toSettings.models.converterContext.setProperty(attributeValue, targetObject);\n\t\t\t\t\tconst newContext = oSettings.models.converterContext.createBindingContext(attributeValue)!;\n\t\t\t\t\tunstoreObjectValue(attributeValue);\n\t\t\t\t\tmContexts[sContextName] = newContext;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst oAttributesModel: JSONModel = new AttributeModel(oNode, processedPropertyValues, BuildingBlockClass);\n\t\tmContexts[\"this\"] = oAttributesModel.createBindingContext(\"/\");\n\t\tlet oPreviousMacroInfo: MacroInfo | undefined;\n\t\t// core:require need to be defined on the node itself to be picked up due to the templating step\n\t\tconst coreRequire = oNode?.getAttribute(\"core:require\") || undefined;\n\n\t\t// Keep track\n\t\tif (TraceInfo.isTraceInfoActive()) {\n\t\t\tconst oTraceInfo = TraceInfo.traceMacroCalls(sFragmentName, oMetadata, mContexts, oNode, oVisitor);\n\t\t\tif (oTraceInfo?.macroInfo) {\n\t\t\t\toPreviousMacroInfo = oSettings[\"_macroInfo\"];\n\t\t\t\toSettings[\"_macroInfo\"] = oTraceInfo.macroInfo;\n\t\t\t}\n\t\t}\n\t\tvalidateMacroSignature(sFragmentName, oMetadata, mContexts, oNode);\n\n\t\tconst oContextVisitor = oVisitor.with(mContexts, oMetadata.isOpen !== undefined ? !oMetadata.isOpen : true);\n\t\tconst oParent = oNode.parentNode;\n\n\t\tlet iChildIndex: number;\n\t\tlet oPromise;\n\t\tif (oParent) {\n\t\t\tiChildIndex = Array.from(oParent.children).indexOf(oNode);\n\n\t\t\tif (oMetadata.fragment) {\n\t\t\t\toPromise = oContextVisitor.insertFragment(sFragmentName, oNode);\n\t\t\t} else {\n\t\t\t\tconst oldKeys = Object.keys(temporaryObjectStore);\n\t\t\t\tconst templateString = await jsx.renderAsXML(async () => oInstance.getTemplate!(oNode));\n\n\t\t\t\tif (BuildingBlockClass.isRuntime) {\n\t\t\t\t\t// For runtime building blocks, we need to attach all objects to the converterContext directly, as the actual rendering takes place at runtime\n\t\t\t\t\tfor (const storeKey in temporaryObjectStore) {\n\t\t\t\t\t\tif (!oldKeys.includes(storeKey)) {\n\t\t\t\t\t\t\tconst data = unstoreObjectValue(storeKey);\n\t\t\t\t\t\t\toSettings.models.converterContext.setProperty(storeKey, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet hasError = \"\";\n\t\t\t\tif (templateString) {\n\t\t\t\t\tlet hasParseError = false;\n\t\t\t\t\tlet parsedTemplate = parseXMLString(templateString, true);\n\t\t\t\t\t// For safety purpose we try to detect trailing text in between XML Tags\n\t\t\t\t\tfor (const element of parsedTemplate) {\n\t\t\t\t\t\tconst iter = document.createNodeIterator(element, NodeFilter.SHOW_TEXT);\n\t\t\t\t\t\tlet textnode = iter.nextNode();\n\t\t\t\t\t\tif (element.localName === \"parsererror\") {\n\t\t\t\t\t\t\thasParseError = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (textnode) {\n\t\t\t\t\t\t\tif (textnode.textContent && textnode.textContent.trim().length > 0) {\n\t\t\t\t\t\t\t\thasError = textnode.textContent;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextnode = iter.nextNode();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hasParseError) {\n\t\t\t\t\t\t// If there is a parseerror while processing the XML it means the XML itself is malformed, as such we rerun the template process\n\t\t\t\t\t\t// Setting isTraceMode true will make it so that each xml` expression is checked for validity from XML perspective\n\t\t\t\t\t\t// If an error is found it's returned instead of the normal fragment\n\t\t\t\t\t\tLog.error(`Error while processing building block ${oMetadata.xmlTag || oMetadata.name}`, hasError);\n\t\t\t\t\t\tparsedTemplate = (await processXmlInTrace(async () => {\n\t\t\t\t\t\t\tconst initialTemplate = await jsx.renderAsXML(async () => oInstance.getTemplate!(oNode));\n\n\t\t\t\t\t\t\treturn parseXMLString(initialTemplate ?? \"\", true);\n\t\t\t\t\t\t})) as Element[];\n\t\t\t\t\t} else if (hasError.length > 0) {\n\t\t\t\t\t\t// If there is trailing text we create a standard error and display it.\n\t\t\t\t\t\tLog.error(`Error while processing building block ${oMetadata.xmlTag || oMetadata.name}`);\n\t\t\t\t\t\tconst oErrorText = createErrorXML(\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t`Error while processing building block ${oMetadata.xmlTag || oMetadata.name}`,\n\t\t\t\t\t\t\t\t`Trailing text was found in the XML: ${hasError}`\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tparsedTemplate.map((template) => template.outerHTML).join(\"\\n\")\n\t\t\t\t\t\t);\n\t\t\t\t\t\tparsedTemplate = parseXMLString(oErrorText, true);\n\t\t\t\t\t}\n\t\t\t\t\toNode.replaceWith(...parsedTemplate);\n\n\t\t\t\t\tconst visitedNodes = parsedTemplate.map(async (internalNode) => {\n\t\t\t\t\t\tprocessSlots(oAggregations, oMetadata.aggregations, internalNode, false);\n\t\t\t\t\t\treturn oContextVisitor.visitNode(internalNode);\n\t\t\t\t\t});\n\t\t\t\t\toPromise = Promise.all(visitedNodes);\n\t\t\t\t} else {\n\t\t\t\t\toNode.remove();\n\t\t\t\t\toPromise = Promise.resolve();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait oPromise;\n\t\t\tconst oMacroElement = oParent.children[iChildIndex];\n\t\t\tprocessSlots(oAggregations, oMetadata.aggregations, oMacroElement, true);\n\t\t\tif (oMacroElement !== undefined) {\n\t\t\t\tconst oRemainingSlots = oMacroElement.querySelectorAll(\"slot\");\n\t\t\t\toRemainingSlots.forEach(function (oSlotElement) {\n\t\t\t\t\toSlotElement.remove();\n\t\t\t\t});\n\t\t\t\tif (coreRequire) {\n\t\t\t\t\tlet requireOnMacro = oMacroElement.getAttributeNS(\"sap.ui.core\", \"require\");\n\t\t\t\t\tif (requireOnMacro) {\n\t\t\t\t\t\trequireOnMacro = requireOnMacro.substring(0, requireOnMacro.length - 1) + \",\" + coreRequire.substring(1); // Remove last } and first {\n\t\t\t\t\t} else {\n\t\t\t\t\t\trequireOnMacro = coreRequire;\n\t\t\t\t\t}\n\t\t\t\t\toMacroElement.setAttributeNS(\"sap.ui.core\", \"core:require\", requireOnMacro);\n\t\t\t\t}\n\t\t\t\tif (propertyValues.class && !BuildingBlockClass.isRuntime) {\n\t\t\t\t\toMacroElement.classList.add(propertyValues.class as string);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (oPreviousMacroInfo) {\n\t\t\t//restore macro info if available\n\t\t\toSettings[\"_macroInfo\"] = oPreviousMacroInfo;\n\t\t} else {\n\t\t\tdelete oSettings[\"_macroInfo\"];\n\t\t}\n\t} catch (e: unknown) {\n\t\t// In case there is a generic error (usually code error), we retrieve the current context information and create a dedicated error message\n\n\t\tconst traceDetails = {\n\t\t\tinitialProperties: {} as Record<string, unknown>,\n\t\t\tresolvedProperties: {} as Record<string, unknown>,\n\t\t\tmissingContexts: mMissingContext\n\t\t};\n\t\tfor (const propertyName of initialKeys) {\n\t\t\tconst propertyValue = propertyValues[propertyName];\n\t\t\tif (isContext(propertyValue)) {\n\t\t\t\ttraceDetails.initialProperties[propertyName] = {\n\t\t\t\t\tpath: propertyValue.getPath(),\n\t\t\t\t\tvalue: propertyValue.getObject()\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\ttraceDetails.initialProperties[propertyName] = propertyValue;\n\t\t\t}\n\t\t}\n\t\tfor (const propertyName in propertyValues) {\n\t\t\tconst propertyValue = propertyValues[propertyName];\n\t\t\tif (!initialKeys.includes(propertyName)) {\n\t\t\t\tif (isContext(propertyValue)) {\n\t\t\t\t\ttraceDetails.resolvedProperties[propertyName] = {\n\t\t\t\t\t\tpath: propertyValue.getPath(),\n\t\t\t\t\t\tvalue: propertyValue.getObject()\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\ttraceDetails.resolvedProperties[propertyName] = propertyValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLog.error(e as string);\n\t\tconst oError = createErrorXML(\n\t\t\t[`Error while processing building block ${oMetadata.name}`],\n\t\t\toNode.outerHTML,\n\t\t\ttraceDetails,\n\t\t\t(e as Error).stack\n\t\t);\n\t\tconst oTemplate = parseXMLString(oError, true);\n\t\toNode.replaceWith(...oTemplate);\n\t}\n}\nfunction addSingleContext(\n\tmContexts: Record<string, Context | undefined>,\n\toVisitor: IVisitorCallback,\n\toCtx: {\n\t\tname?: string;\n\t\tpath: string;\n\t\tmodel?: string;\n\t}\n): void {\n\tconst sKey = (oCtx.name || oCtx.model || undefined) as string;\n\tif (mContexts[sKey]) {\n\t\treturn; // do not add twice\n\t}\n\ttry {\n\t\tlet sContextPath = oCtx.path;\n\t\tif (oCtx.model !== null) {\n\t\t\tsContextPath = `${oCtx.model}>${sContextPath}`;\n\t\t}\n\t\tconst mSetting = oVisitor.getSettings();\n\t\tif (oCtx.model === \"converterContext\" && oCtx.path.length > 0) {\n\t\t\tmContexts[sKey] = mSetting.models[oCtx.model].getContext(oCtx.path /*, mSetting.bindingContexts[oCtx.model]*/); // add the context to the visitor\n\t\t} else if (!mSetting.bindingContexts[oCtx.model!] && mSetting.models[oCtx.model!]) {\n\t\t\tmContexts[sKey] = mSetting.models[oCtx.model!].getContext(oCtx.path); // add the context to the visitor\n\t\t} else {\n\t\t\tmContexts[sKey] = oVisitor.getContext(sContextPath); // add the context to the visitor\n\t\t}\n\t} catch (ex) {\n\t\t// ignore the context as this can only be the case if the model is not ready,\n\t\t// i.e. not a preprocessing model but maybe a model for providing afterwards\n\t}\n}\n\n/**\n * Register a building block definition to be used inside the xml template processor.\n * @param BuildingBlockClass The building block definition\n */\nexport function registerBuildingBlock(BuildingBlockClass: typeof BuildingBlockTemplatingBase): void {\n\tif (BuildingBlockClass.metadata.namespace !== undefined) {\n\t\tXMLPreprocessor.plugIn(\n\t\t\tasync (oNode: Element, oVisitor: IVisitorCallback) => processBuildingBlock(BuildingBlockClass, oNode, oVisitor),\n\t\t\tBuildingBlockClass.metadata.namespace,\n\t\t\tBuildingBlockClass.metadata.xmlTag || BuildingBlockClass.metadata.name\n\t\t);\n\t}\n\tif (BuildingBlockClass.metadata.publicNamespace !== undefined) {\n\t\tXMLPreprocessor.plugIn(\n\t\t\tasync (oNode: Element, oVisitor: IVisitorCallback) => processBuildingBlock(BuildingBlockClass, oNode, oVisitor, true),\n\t\t\tBuildingBlockClass.metadata.publicNamespace,\n\t\t\tBuildingBlockClass.metadata.xmlTag || BuildingBlockClass.metadata.name\n\t\t);\n\t}\n}\n\n/**\n * UnRegister a building block definition so that it is no longer used inside the xml template processor.\n * @param BuildingBlockClass The building block definition\n */\nexport function unregisterBuildingBlock(BuildingBlockClass: typeof BuildingBlockTemplatingBase): void {\n\tif (BuildingBlockClass.metadata.namespace !== undefined) {\n\t\tXMLPreprocessor.plugIn(\n\t\t\tnull,\n\t\t\tBuildingBlockClass.metadata.namespace,\n\t\t\tBuildingBlockClass.metadata.xmlTag || BuildingBlockClass.metadata.name\n\t\t);\n\t}\n\tif (BuildingBlockClass.metadata.publicNamespace !== undefined) {\n\t\tXMLPreprocessor.plugIn(\n\t\t\tnull,\n\t\t\tBuildingBlockClass.metadata.publicNamespace,\n\t\t\tBuildingBlockClass.metadata.xmlTag || BuildingBlockClass.metadata.name\n\t\t);\n\t}\n}\n\nfunction createErrorXML(errorMessages: string[], xmlFragment: string, additionalData?: object, stack?: string): string {\n\tconst errorLabels = errorMessages.map((errorMessage) => xml`<m:Label text=\"${escapeXMLAttributeValue(errorMessage)}\"/>`);\n\tlet errorStack = \"\";\n\tif (stack) {\n\t\tconst stackFormatted = btoa(`<pre>${stack}</pre>`);\n\t\terrorStack = xml`<m:FormattedText htmlText=\"{= BBF.base64Decode('${stackFormatted}') }\" />`;\n\t}\n\tlet additionalText = \"\";\n\tif (additionalData) {\n\t\tlet jsonValue = \"\";\n\t\ttry {\n\t\t\tjsonValue = btoa(JSON.stringify(additionalData, null, 4));\n\t\t} catch (e) {\n\t\t\tjsonValue = btoa(JSON.stringify({ error: \"Could not stringify additionalData due to circular structure.\" }, null, 4));\n\t\t}\n\n\t\tadditionalText = xml`<m:VBox>\n\t\t\t<m:Label text=\"Trace Info\"/>\n\t\t\t<code:CodeEditor type=\"json\"  value=\"${`{= BBF.base64Decode('${jsonValue}') }`}\" height=\"300px\" />\n\t\t</m:VBox>`;\n\t}\n\treturn xml`<controls:FormElementWrapper xmlns:controls=\"sap.fe.core.controls\">\n\t\t\t\t\t<m:VBox xmlns:m=\"sap.m\" xmlns:code=\"sap.ui.codeeditor\" core:require=\"{BBF:'sap/fe/core/buildingBlocks/templating/BuildingBlockFormatter'}\">\n\t\t\t\t\t${errorLabels}\n\t\t\t\t\t${errorStack}\n\t\t\t\t\t\t<grid:CSSGrid gridTemplateRows=\"fr\" gridTemplateColumns=\"repeat(2,1fr)\" gridGap=\"1rem\" xmlns:grid=\"sap.ui.layout.cssgrid\" >\n\t\t\t\t\t\t\t<m:VBox>\n\t\t\t\t\t\t\t\t<m:Label text=\"How the building block was called\"/>\n\t\t\t\t\t\t\t\t<code:CodeEditor type=\"xml\" value=\"${`{= BBF.base64Decode('${btoa(xmlFragment.replaceAll(\"&gt;\", \">\"))}') }`}\" height=\"300px\" />\n\t\t\t\t\t\t\t</m:VBox>\n\t\t\t\t\t\t\t${additionalText}\n\t\t\t\t\t\t</grid:CSSGrid>\n\t\t\t\t\t</m:VBox>\n\t\t\t\t</controls:FormElementWrapper>`;\n}\n\nconst temporaryObjectStore: Record<string, unknown> = {};\n\n/**\n * Stores an object value in a temporary storage and returns an ID used to retrieve this value at a later point in time.\n *\n * Required as there is functionality like the xml` function, which might take objects as parameters but needs to return a serialized string.\n * @param value Value to store\n * @returns ID to retrieve this value\n */\nexport function storeObjectValue(value: unknown): string {\n\tconst propertyUID = `/uid--${uid()}`;\n\ttemporaryObjectStore[propertyUID] = value;\n\treturn propertyUID;\n}\n\n/**\n * Unstores an object from a temporary store by removing it and returning its object value.\n * @param propertyUID ID to retrieve this value\n * @returns Object value\n */\nfunction unstoreObjectValue(propertyUID: string): unknown {\n\tconst value = temporaryObjectStore[propertyUID];\n\tdelete temporaryObjectStore[propertyUID];\n\treturn value;\n}\n\nlet processNextXmlInTrace = false;\n/**\n * Makes sure that all xml` calls inside the given method are processed in trace mode.\n * @param method The method to execute\n * @returns The return value of the given method\n */\nconst processXmlInTrace = async function (method: (...args: unknown[]) => Promise<unknown>): Promise<unknown> {\n\tprocessNextXmlInTrace = true;\n\tlet returnValue;\n\ttry {\n\t\treturnValue = method();\n\t} finally {\n\t\tprocessNextXmlInTrace = false;\n\t}\n\treturn returnValue;\n};\n\n/**\n * Parse an XML string and return the associated document.\n * @param xmlString The xml string\n * @param [addDefaultNamespaces] Whether or not default namespaces should be added\n * @returns The XML document.\n */\nexport function parseXMLString(xmlString: string, addDefaultNamespaces = false): Element[] {\n\tif (addDefaultNamespaces) {\n\t\txmlString = `<template\n\t\t\t\t\t\txmlns:template=\"http://schemas.sap.com/sapui5/extension/sap.ui.core.template/1\"\n\t\t\t\t\t\txmlns:m=\"sap.m\"\n\t\t\t\t\t\txmlns:macros=\"sap.fe.macros\"\n\t\t\t\t\t\txmlns:core=\"sap.ui.core\"\n\t\t\t\t\t\txmlns:mdc=\"sap.ui.mdc\"\n\t\t\t\t\t\txmlns:customData=\"http://schemas.sap.com/sapui5/extension/sap.ui.core.CustomData/1\">${xmlString}</template>`;\n\t}\n\tconst xmlDocument = DOMParserInstance.parseFromString(xmlString, \"text/xml\");\n\tlet output = xmlDocument.firstElementChild;\n\twhile (output?.localName === \"template\") {\n\t\toutput = output.firstElementChild;\n\t}\n\tconst children = output?.parentElement ? output?.parentElement.children : [output as Element];\n\treturn Array.from(children);\n}\n\n/**\n * Escape an XML attribute value.\n * @param value The attribute value to escape.\n * @returns The escaped string.\n */\nexport function escapeXMLAttributeValue(value?: string): string | undefined {\n\treturn value?.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&apos;\");\n}\n\nfunction renderInTraceMode(outStr: string): string {\n\tconst xmlResult = parseXMLString(outStr, true);\n\tif (xmlResult?.length > 0 && xmlResult[0]?.localName === \"parsererror\") {\n\t\tconst errorMessage = (xmlResult[0] as HTMLElement).innerText || (xmlResult[0] as HTMLElement).innerHTML;\n\t\treturn createErrorXML([errorMessage.split(\"\\n\")[0]], outStr);\n\t} else {\n\t\treturn outStr;\n\t}\n}\n\nexport type XMLProcessorTypeValue =\n\t| string\n\t| boolean\n\t| number\n\t| undefined\n\t| null\n\t| object\n\t| Record<string, unknown>\n\t| BindingToolkitExpression<string | boolean | number>\n\t| Array<string>\n\t| Array<Function>\n\t| Function\n\t| Context;\n/**\n * Create a string representation of the template literal while handling special object case.\n * @param strings The string parts of the template literal\n * @param values The values part of the template literal\n * @returns The XML string document representing the string that was used.\n */\nexport const xml = (strings: TemplateStringsArray, ...values: XMLProcessorTypeValue[]): string => {\n\tlet outStr = \"\";\n\tlet i;\n\tfor (i = 0; i < values.length; i++) {\n\t\toutStr += strings[i];\n\n\t\t// Handle the different case of object, if it's an array we join them, if it's a binding expression then we compile it.\n\t\tconst value = values[i];\n\n\t\tif (Array.isArray(value) && value.length > 0 && typeof value[0] === \"string\") {\n\t\t\toutStr += value.flat(5).join(\"\\n\").trim();\n\t\t} else if (isFunctionArray(value)) {\n\t\t\toutStr += value.map((valuefn) => valuefn()).join(\"\\n\");\n\t\t} else if (isBindingToolkitExpression(value)) {\n\t\t\tconst compiledExpression = compileExpression(value);\n\t\t\toutStr += escapeXMLAttributeValue(compiledExpression);\n\t\t} else if (typeof value === \"undefined\") {\n\t\t\toutStr += \"{this>undefinedValue}\";\n\t\t} else if (typeof value === \"function\") {\n\t\t\toutStr += value();\n\t\t} else if (typeof value === \"object\" && value !== null) {\n\t\t\tif (isContext(value)) {\n\t\t\t\toutStr += value.getPath();\n\t\t\t} else {\n\t\t\t\tconst propertyUId = storeObjectValue(value);\n\t\t\t\toutStr += `${propertyUId}`;\n\t\t\t}\n\t\t} else if (value && typeof value === \"string\" && !value.startsWith(\"<\") && !value.startsWith(\"&lt;\")) {\n\t\t\toutStr += escapeXMLAttributeValue(value);\n\t\t} else {\n\t\t\toutStr += value;\n\t\t}\n\t}\n\toutStr += strings[i];\n\toutStr = outStr.trim();\n\tif (processNextXmlInTrace) {\n\t\treturn renderInTraceMode(outStr);\n\t}\n\treturn outStr;\n};\n\nexport const addConditionallyToXML = function (condition: boolean, partToAdd: string): string {\n\tif (condition) {\n\t\treturn partToAdd;\n\t} else {\n\t\treturn \"\";\n\t}\n};\n\n/**\n * Add an attribute depending on the current value of the property.\n * If it's undefined the attribute is not added.\n * @param attributeName\n * @param value\n * @returns The attribute to add if the value is not undefined, otherwise an empty string\n */\nexport const addAttributeToXML = function (attributeName: string, value?: XMLProcessorTypeValue): () => string {\n\tif (value !== undefined && !isUndefinedExpression(value)) {\n\t\treturn () => xml`${attributeName}=\"${value}\"`;\n\t} else {\n\t\treturn () => \"\";\n\t}\n};\n"],"mappings":"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","ignoreList":[]}