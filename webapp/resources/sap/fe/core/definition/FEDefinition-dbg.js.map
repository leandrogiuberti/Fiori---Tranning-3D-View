{"version":3,"sources":["webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/BaseDefinition.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/MetaPath.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/elements/FilterBar.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/floorplans/DefinitionPage.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/index.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/odata/DefinitionContext.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/odata/EntitySet.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/odata/QueryBuilder.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/odata/annotations/UI/_DataField.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/odata/annotations/UI/_HeaderInfo.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/odata/annotations/UI/_Identification.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/odata/annotations/UI/_LineItem.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/utils/Expression.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/utils/Formatters.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/utils/TypeGuards.ts","webpack://FEDefinition/webpack/bootstrap","webpack://FEDefinition/webpack/startup"],"names":["Placement","exports","BaseDefinition","constructor","metaPath","configuration","annotationPath","getPath","configurablePropertiesKey","__configurableProperties","configSettings","configurationValue","aliasFor","undefined","validator","defaultValue","targetObject","getTarget","annotationPropertiesKey","__annotationProperties","annotations","_annotations","term","valueOf","getConfiguration","outObj","noop","value","configurable","propertyConfiguration","target","propertyKey","propertyDescriptor","localPropertyConfiguration","name","initializer","targetPrototype","prototype","annotation","annotationConfiguration","localAnnotationConfiguration","_TypeGuards","require","enhancePath","sBasePath","sPathAddition","startsWith","endsWith","MetaPath","convertedMetadata","contextPath","navigationProperties","contextNavigationProperties","absolutePath","relativePath","replace","substring","resolvedMetaPath","resolvePath","resolvedContextPath","Error","rootEntitySet","currentEntitySet","currentEntityType","navigatedPaths","objectPath","forEach","objectPart","isServiceObject","_type","push","targetType","navigationPropertyBinding","hasOwnProperty","join","entityType","getResolvedContextPath","serviceObjectPath","length","map","nav","contextRootEntitySet","getContextPath","sPathPart","getRelativePath","getClosestEntitySet","closestEntitySet","navigationProperty","navigationPropertyBindingElement","getClosestEntityType","closestEntityType","getContextClosestEntitySet","nonNullEntitySet","getNavigationProperties","getMetaPathForClosestEntitySet","fullyQualifiedName","getMetaPathForPath","targetPath","_error","getMetaPathForObject","isAnnotationPath","isPathAnnotationExpression","path","metaPathApp","getConvertedMetadata","_BaseDefinition","_EntitySet2","_interopRequireDefault","_dec","_dec2","_dec3","_dec4","_dec5","_class","_descriptor","_descriptor2","_descriptor3","_descriptor4","e","__esModule","default","_initializerDefineProperty","i","r","l","Object","defineProperty","enumerable","writable","call","_defineProperty","t","_toPropertyKey","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","_applyDecoratedDescriptor","n","a","keys","slice","reverse","reduce","_initializerWarningHelper","FilterField","filterFieldProperty","isParameter","Common","ResultContext","label","Label","toString","filterFieldConfiguration","getOwnPropertyDescriptor","FilterBar","selectionFields","filterBarConfiguration","isParameterizedEntitySet","containsTarget","getFilterGroups","filterFacets","UI","FilterFacets","filterFieldsGroup","fieldGroups","filter","key","fieldGroup","Data","fieldGroupEntry","$Type","fieldGroupValue","Value","$target","group","groupLabel","qualifier","filterFacet","filterFacetTarget","Target","isAnnotationOfType","ID","getFilterFields","filterGroups","consideredProperties","parameterizedFields","parametrizedEntitySetMetaPath","entityProperties","property","metaPathForProperty","visible","required","field","requiredProperties","_EntitySet","getRequiredProperties","fromSelectionField","isValidPropertyPathExpression","includes","nonFilterableProperties","getNonFilterableProperties","Hidden","isSearchSupported","isSearchAllowed","_FilterBar","_HeaderInfo2","_Identification2","_LineItem2","DefinitionPage","getMetaPath","getIdentification","targetEntityType","idAnnotation","Identification","_Identification","getHeaderInfo","info","HeaderInfo","_HeaderInfo","getTableVisualization","_LineItem","fromSPV","_getTableVisualizationAnnotation","getFilterBarDefinition","selectionField","SelectionFields","assign","createDefaultTableVisualization","createDefault","spv","SelectionPresentationVariant","PresentationVariant","Visualizations","find","v","pv","LineItem","_DefinitionPage","_DataField","_DefinitionContext","_QueryBuilder","_Formatters","_exportNames","get","_MetaPath","DefinitionContext","addApplicationManifest","manifest","getEntitySets","entitySets","getEntitySet","entitySetName","by_name","getRootEntitySet","initialRoutePattern","initialRoute","routing","routes","pattern","targets","options","settings","entitySet","getPageFor","getVersion","match","version","major","parseInt","minor","entitySetConfiguration","Capabilities","FilterRestrictions","RequiredProperties","propertyPath","NonFilterableProperties","getAllowedFilterExpression","filterExpressionRestrictions","FilterExpressionRestrictions","propertyRestrictions","filterExpressionRestriction","Property","propertyRestriction","AllowedExpressions","SearchRestrictions","Searchable","_Expression","QueryBuilder","contextMetaPath","definitionContext","Set","addPathsFromExpression","expression","transformRecursively","pathExpression","addPath","paths","add","buildQuery","query","createQueryV4","createQueryV2","select","expand","parts","split","propertyMetaPath","isNavigationProperty","$format","$select","size","$expand","Array","from","node","Map","processPathRecursiveV4","values","serializeExpandV4Recursive","parentNode","set","navigationPropertyOffset","expandNode","serializeSelect","expandValue","separator","fields","dataField","scopedContextMetaPath","getValue","getExpressionFromAnnotation","unresolvableExpression","getFormattedValue","targetValue","navProp","ownPath","measure","getMeasure","concat","displayMode","getDisplayMode","text","Text","formatResult","formatters","formatWithBrackets","measures","Measures","Unit","ISOCurrency","textAnnotation","textArrangement","TextArrangement","getLabel","valueTarget","getProperty","getFullyQualifiedName","_DataField2","pageMetaPath","getTitle","Title","getDescription","Description","getTypeName","TypeName","id","getDataFields","item","restrictTypes","importance","Importance","lineItem","fakeLineItemAnnotation","prop","DataFieldDefault","type","getActions","getHeaderActions","action","Determining","hasUnresolvableExpression","expressions","expr","_checkExpressionsAreEqual","b","operand","operator","operands","every","some","otherExpression","condition","onTrue","onFalse","operand1","operand2","aExpressions","bExpressions","index","pathInModel","modelName","targetEntitySet","fn","parameters","bindingParameters","otherFunction","obj","ref","flattenSetExpression","result","candidatesForFlattening","candidate","hasOppositeExpressions","negatedExpressions","not","and","wrapPrimitive","isStaticFalse","nonTrivialExpression","isFalse","isConstant","constant","isValid","isTrue","or","isStaticTrue","isComparison","isTruthy","visitedNavigationPaths","pathVisitor","localPath","constantValue","isArray","isPrimitiveObject","entries","plainExpression","val","wrappedValue","resolveBindingString","pathInModelRegex","pathInModelRegexMatch","exec","isNaN","reference","something","isExpression","maybeConstant","isPathInModelExpression","maybeBinding","isComplexTypeExpression","isConcatExpression","isIfElseExpression","isUndefinedExpression","expressionAsExpression","objectType","isComplexAnnotationExpression","annotationValue","annotationIfExpression","$If","parseAnnotationCondition","$Not","equal","$Eq","notEqual","$Ne","greaterThan","$Gt","greaterOrEqual","$Ge","lessThan","$Lt","lessOrEqual","$Le","$Or","orCondition","$And","andCondition","annotationApplyExpression","$Path","Path","$Function","$Apply","$EnumMember","Bool","Int","Decimal","ifElse","convertSubApplyParameters","applyParam","applyParamConverted","applyExpression","parameter","template","templateParams","$Name","$LabeledElement","comparison","leftOperand","rightOperand","leftExpression","rightExpression","checkUndefined","left","right","reduced","conditionExpression","onTrueExpression","onFalseExpression","pathIdx","myIfElseExpression","allParts","constantPath","unshift","JSON","stringify","hasReferenceToDefaultContext","formatterFunction","contextEntityType","ignoreComplexType","parameterExpressions","functionName","__functionName","formatterClass","formatterName","myFormatExpression","getFiscalType","IsFiscalYear","IsFiscalPeriod","IsFiscalYearPeriod","IsFiscalQuarter","IsFiscalYearQuarter","IsFiscalWeek","IsFiscalYearWeek","IsDayOfFiscalYear","func","on","isFormattingFn","isEmpty","aBindings","inExpressions","concatenated","myConcatExpression","inExpression","expressionType","transformFunction","includeAllExpression","subExpression","bindingParameter","args","apply","FORMATTERS_PATH","firstPart","secondPart","_default","potentialAnnotationType","typeName","isAnnotationOfTerm","potentialAnnotation","termName","isAnnotationTerm","serviceObject","isComplexType","isTypeDefinition","isEntityContainer","isEntitySet","isSingleton","isEntityType","isProperty","isSingleNavigationProperty","isCollection","isMultipleNavigationProperty","isPropertyPathExpression"],"mappings":"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","file":"FEDefinition-dbg.js","sourceRoot":"","sourcesContent":["import type { ServiceObject } from \"@sap-ux/vocabularies-types\";\nimport type { AnnotationTerm } from \"@sap-ux/vocabularies-types/Edm\";\nimport type MetaPath from \"./MetaPath\";\nimport type { PrimitiveType } from \"./utils/Expression\";\n\nexport type BaseConfiguration = Record<string, PrimitiveType>;\ntype InPropertyConfiguration = {\n\taliasFor?: string;\n\tvalidator?: Function;\n};\ntype PropertyConfiguration = {\n\taliasFor: string;\n\tvalidator: Function;\n\tname: string;\n\tdefaultValue: unknown;\n};\ntype InAnnotationConfiguration = {\n\tterm: string;\n};\ntype AnnotationConfiguration = {\n\tname: string;\n\tdefaultValue: unknown;\n\tterm: string;\n};\n\nexport enum Placement {\n\tAfter = \"After\",\n\tBefore = \"Before\",\n\tEnd = \"End\"\n}\n\nexport class BaseDefinition<T extends BaseConfiguration> {\n\tpublic annotationPath?: string;\n\n\t__configurableProperties!: Record<string, PropertyConfiguration>;\n\n\t__annotationProperties!: Record<string, AnnotationConfiguration>;\n\n\tconstructor(metaPath: MetaPath<ServiceObject | AnnotationTerm<{ term: string }>> | null, configuration: T) {\n\t\tthis.annotationPath = metaPath?.getPath();\n\t\tfor (const configurablePropertiesKey in this.__configurableProperties) {\n\t\t\tconst configSettings = this.__configurableProperties[configurablePropertiesKey];\n\t\t\tif (configSettings) {\n\t\t\t\tconst configurationValue = configuration[configSettings.aliasFor];\n\t\t\t\tif (configurationValue !== undefined) {\n\t\t\t\t\tthis[configurablePropertiesKey as keyof this] = configSettings.validator(configurationValue) as never;\n\t\t\t\t} else if (configSettings.defaultValue !== undefined) {\n\t\t\t\t\tthis[configurablePropertiesKey as keyof this] = configSettings.defaultValue as never;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst targetObject = metaPath?.getTarget();\n\t\tif (targetObject) {\n\t\t\tfor (const annotationPropertiesKey in this.__annotationProperties) {\n\t\t\t\tconst configSettings = this.__annotationProperties[annotationPropertiesKey];\n\t\t\t\tif (configSettings) {\n\t\t\t\t\tconst configurationValue = (\n\t\t\t\t\t\ttargetObject.annotations as unknown as {\n\t\t\t\t\t\t\t_annotations?: Record<string, unknown>;\n\t\t\t\t\t\t}\n\t\t\t\t\t)._annotations?.[configSettings.term];\n\t\t\t\t\tif (configurationValue !== undefined && configurationValue !== null) {\n\t\t\t\t\t\tthis[annotationPropertiesKey as keyof this] = configurationValue.valueOf() as never;\n\t\t\t\t\t} else if (configSettings.defaultValue !== undefined) {\n\t\t\t\t\t\tthis[annotationPropertiesKey as keyof this] = configSettings.defaultValue as never;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgetConfiguration(): T {\n\t\tconst outObj: BaseConfiguration = {};\n\t\tfor (const configurablePropertiesKey in this.__configurableProperties) {\n\t\t\tconst configSettings = this.__configurableProperties[configurablePropertiesKey];\n\t\t\tif (configSettings) {\n\t\t\t\toutObj[configSettings.aliasFor] = this[configurablePropertiesKey as keyof this] as PrimitiveType;\n\t\t\t}\n\t\t}\n\t\treturn outObj as T;\n\t}\n}\n\nfunction noop(value: PrimitiveType): PrimitiveType {\n\treturn value;\n}\nexport function configurable(propertyConfiguration: InPropertyConfiguration = {}): PropertyDecorator {\n\treturn function (\n\t\ttarget: BaseDefinition<BaseConfiguration>,\n\t\tpropertyKey: string,\n\t\tpropertyDescriptor: TypedPropertyDescriptor<PrimitiveType>\n\t) {\n\t\tconst localPropertyConfiguration: PropertyConfiguration = {\n\t\t\tname: propertyKey,\n\t\t\tvalidator: propertyConfiguration.validator || noop,\n\t\t\taliasFor: propertyConfiguration.aliasFor || propertyKey,\n\t\t\tdefaultValue: (propertyDescriptor as { initializer?: Function }).initializer?.()\n\t\t};\n\t\tconst targetPrototype = target.constructor.prototype as BaseDefinition<BaseConfiguration>;\n\t\tif (!targetPrototype.__configurableProperties) {\n\t\t\ttargetPrototype.__configurableProperties = {};\n\t\t}\n\t\tdelete (propertyDescriptor as { initializer?: Function } | undefined)?.initializer;\n\n\t\ttargetPrototype.__configurableProperties[propertyKey] = localPropertyConfiguration;\n\t} as unknown as PropertyDecorator;\n}\n\nexport function annotation(annotationConfiguration: InAnnotationConfiguration): PropertyDecorator {\n\treturn function (target: BaseDefinition<BaseConfiguration>, propertyKey: string, propertyDescriptor: TypedPropertyDescriptor<unknown>) {\n\t\tconst localAnnotationConfiguration: AnnotationConfiguration = {\n\t\t\tname: propertyKey,\n\t\t\tterm: annotationConfiguration.term,\n\t\t\tdefaultValue: (propertyDescriptor as { initializer?: Function }).initializer?.()\n\t\t};\n\t\tconst targetPrototype = target.constructor.prototype as BaseDefinition<BaseConfiguration>;\n\t\tif (!targetPrototype.__annotationProperties) {\n\t\t\ttargetPrototype.__annotationProperties = {};\n\t\t}\n\t\ttargetPrototype.__annotationProperties[propertyKey] = localAnnotationConfiguration;\n\t\tdelete (propertyDescriptor as { initializer?: Function }).initializer;\n\t\treturn propertyDescriptor;\n\t} as unknown as PropertyDecorator; // This is technically an accessor decorator, but somehow the compiler doesn't like it if i declare it as such.;\n}\n","import type {\n\tConvertedMetadata,\n\tEntitySet,\n\tEntityType,\n\tNavigationProperty,\n\tPathAnnotationExpression,\n\tResolutionTarget,\n\tServiceObjectAndAnnotation,\n\tSingleton\n} from \"@sap-ux/vocabularies-types\";\nimport type { AnnotationPath, Property, PropertyAnnotationValue } from \"@sap-ux/vocabularies-types/Edm\";\nimport { isAnnotationPath, isPathAnnotationExpression, isServiceObject } from \"./utils/TypeGuards\";\n\nfunction enhancePath(sBasePath: string, sPathAddition?: string): string {\n\tif (sPathAddition) {\n\t\tif (sPathAddition.startsWith(\"/\")) {\n\t\t\treturn sPathAddition;\n\t\t} else if (sPathAddition.startsWith(\"@\")) {\n\t\t\treturn sBasePath + sPathAddition;\n\t\t} else if (!sBasePath.endsWith(\"/\")) {\n\t\t\treturn sBasePath + \"/\" + sPathAddition;\n\t\t} else {\n\t\t\treturn sBasePath + sPathAddition;\n\t\t}\n\t}\n\treturn sBasePath;\n}\n\ntype ResolvedTarget<T> =\n\tT extends AnnotationPath<infer K>\n\t\t? K\n\t\t: T extends PropertyAnnotationValue<infer V extends string>\n\t\t\t? V\n\t\t\t: T extends PathAnnotationExpression<unknown>\n\t\t\t\t? Property | undefined\n\t\t\t\t: T;\n\n/**\n *\n */\nexport default class MetaPath<T> {\n\tprivate rootEntitySet: EntitySet;\n\n\tprivate contextRootEntitySet: EntitySet | undefined;\n\n\tprivate absolutePath: string;\n\n\tprivate serviceObjectPath: string;\n\n\tprivate relativePath: string;\n\n\tprivate navigationProperties: NavigationProperty[];\n\n\tprivate contextNavigationProperties: NavigationProperty[];\n\n\tprivate currentEntitySet: EntitySet | Singleton | undefined;\n\n\tprivate currentEntityType?: EntityType;\n\n\tprivate targetObject: T;\n\n\t/**\n\t * Create the MetaPath object.\n\t * @param convertedMetadata The current model converter output\n\t * @param metaPath The current object metaPath\n\t * @param contextPath The current context\n\t */\n\tconstructor(\n\t\tprivate convertedMetadata: ConvertedMetadata,\n\t\tprivate metaPath: string,\n\t\tprivate contextPath: string\n\t) {\n\t\tthis.navigationProperties = [];\n\t\tthis.contextNavigationProperties = [];\n\t\tthis.absolutePath = enhancePath(contextPath, metaPath);\n\t\tthis.relativePath = this.absolutePath.replace(contextPath, \"\");\n\t\tif (this.relativePath.startsWith(\"/\")) {\n\t\t\tthis.relativePath = this.relativePath.substring(1);\n\t\t}\n\n\t\tconst resolvedMetaPath: ResolutionTarget<T> = this.convertedMetadata.resolvePath(this.absolutePath);\n\t\tconst resolvedContextPath: ResolutionTarget<T> = this.convertedMetadata.resolvePath(contextPath);\n\t\tif (resolvedMetaPath.target === undefined || resolvedMetaPath.target === null) {\n\t\t\tthrow new Error(`No annotation target found for ${metaPath}`);\n\t\t}\n\t\tthis.targetObject = resolvedMetaPath.target;\n\t\tlet rootEntitySet: EntitySet | undefined;\n\t\tlet currentEntitySet: EntitySet | Singleton | undefined;\n\t\tlet currentEntityType: EntityType | undefined;\n\t\tlet navigatedPaths: string[] = [];\n\t\tresolvedMetaPath.objectPath.forEach((objectPart: ServiceObjectAndAnnotation) => {\n\t\t\tif (isServiceObject(objectPart)) {\n\t\t\t\tswitch (objectPart._type) {\n\t\t\t\t\tcase \"NavigationProperty\":\n\t\t\t\t\t\tnavigatedPaths.push(objectPart.name);\n\t\t\t\t\t\tthis.navigationProperties.push(objectPart);\n\t\t\t\t\t\tcurrentEntityType = objectPart.targetType;\n\t\t\t\t\t\tif (currentEntitySet?.navigationPropertyBinding.hasOwnProperty(navigatedPaths.join(\"/\"))) {\n\t\t\t\t\t\t\tcurrentEntitySet = currentEntitySet.navigationPropertyBinding[navigatedPaths.join(\"/\")];\n\t\t\t\t\t\t\tnavigatedPaths = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"EntitySet\":\n\t\t\t\t\t\tif (rootEntitySet === undefined) {\n\t\t\t\t\t\t\trootEntitySet = objectPart;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrentEntitySet = objectPart;\n\t\t\t\t\t\tcurrentEntityType = currentEntitySet.entityType;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"EntityType\":\n\t\t\t\t\t\tif (currentEntityType === undefined) {\n\t\t\t\t\t\t\tcurrentEntityType = objectPart;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tresolvedContextPath.objectPath.forEach((objectPart: ServiceObjectAndAnnotation) => {\n\t\t\trootEntitySet = this.getResolvedContextPath(objectPart, currentEntityType, rootEntitySet);\n\t\t});\n\t\tif (rootEntitySet === undefined || currentEntityType === undefined) {\n\t\t\tthrow new Error(\"MetaPath doesn't contain an entitySet -> Should never happen\");\n\t\t}\n\t\tthis.serviceObjectPath = \"/\" + rootEntitySet.name;\n\t\tif (this.navigationProperties.length) {\n\t\t\tthis.serviceObjectPath += \"/\" + this.navigationProperties.map((nav) => nav.name).join(\"/\");\n\t\t}\n\t\tthis.rootEntitySet = rootEntitySet;\n\t\tthis.currentEntitySet = currentEntitySet;\n\t\tthis.currentEntityType = currentEntityType;\n\t}\n\n\tprivate getResolvedContextPath(\n\t\tobjectPart: ServiceObjectAndAnnotation,\n\t\tcurrentEntityType: EntityType | undefined,\n\t\trootEntitySet: EntitySet | undefined\n\t): EntitySet | undefined {\n\t\tif (isServiceObject(objectPart)) {\n\t\t\tswitch (objectPart._type) {\n\t\t\t\tcase \"NavigationProperty\":\n\t\t\t\t\tthis.contextNavigationProperties.push(objectPart);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"EntitySet\":\n\t\t\t\t\tif (this.contextRootEntitySet === undefined) {\n\t\t\t\t\t\tthis.contextRootEntitySet = objectPart;\n\t\t\t\t\t}\n\t\t\t\t\tif (rootEntitySet === undefined && objectPart.entityType === currentEntityType) {\n\t\t\t\t\t\trootEntitySet = objectPart;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn rootEntitySet;\n\t}\n\n\tpublic getContextPath(): string {\n\t\treturn this.contextPath;\n\t}\n\n\t/**\n\t * Retrieve the absolute path for this MetaPath.\n\t * @param sPathPart The path to evaluate\n\t * @returns The absolute path\n\t */\n\tpublic getPath(sPathPart?: string): string {\n\t\treturn enhancePath(this.absolutePath, sPathPart);\n\t}\n\n\t/**\n\t * Retrieve the path relative to the context for this MetaPath.\n\t * @param sPathPart The path to evaluate\n\t * @returns The relative path\n\t */\n\tpublic getRelativePath(sPathPart?: string): string {\n\t\treturn enhancePath(this.relativePath, sPathPart);\n\t}\n\n\t/**\n\t * Retrieve the typed target for this object call.\n\t * @returns The typed target object\n\t */\n\tpublic getTarget(): T {\n\t\treturn this.targetObject;\n\t}\n\n\t/**\n\t * Retrieve the closest entityset in the path.\n\t * @returns The closest entityset\n\t */\n\tpublic getClosestEntitySet(): EntitySet | Singleton {\n\t\tlet closestEntitySet: EntitySet | Singleton = this.rootEntitySet;\n\t\tfor (const navigationProperty of this.navigationProperties) {\n\t\t\tconst navigationPropertyBindingElement: EntitySet | Singleton | undefined =\n\t\t\t\tclosestEntitySet.navigationPropertyBinding[navigationProperty.name];\n\t\t\tif (navigationPropertyBindingElement) {\n\t\t\t\tclosestEntitySet = navigationPropertyBindingElement;\n\t\t\t}\n\t\t}\n\t\treturn closestEntitySet;\n\t}\n\n\tpublic getClosestEntityType(): EntityType {\n\t\tlet closestEntityType: EntityType = this.rootEntitySet.entityType;\n\t\tfor (const navigationProperty of this.navigationProperties) {\n\t\t\tclosestEntityType = navigationProperty.targetType;\n\t\t}\n\t\treturn closestEntityType;\n\t}\n\n\t/**\n\t * Retrieve the closest entityset in the path.\n\t * @returns The closest entityset\n\t */\n\tpublic getContextClosestEntitySet(): EntitySet | Singleton | undefined {\n\t\tlet closestEntitySet: EntitySet | Singleton | undefined = this.contextRootEntitySet;\n\t\tif (closestEntitySet === undefined) {\n\t\t\treturn closestEntitySet;\n\t\t}\n\t\tconst nonNullEntitySet: EntitySet | Singleton = closestEntitySet;\n\t\tfor (const navigationProperty of this.contextNavigationProperties) {\n\t\t\tif (nonNullEntitySet.navigationPropertyBinding[navigationProperty.name]) {\n\t\t\t\tclosestEntitySet = nonNullEntitySet.navigationPropertyBinding[navigationProperty.name];\n\t\t\t}\n\t\t}\n\t\treturn closestEntitySet;\n\t}\n\n\tpublic getNavigationProperties(): NavigationProperty[] {\n\t\treturn this.navigationProperties;\n\t}\n\n\tpublic getMetaPathForClosestEntitySet(): MetaPath<EntitySet | Singleton> {\n\t\treturn new MetaPath<EntitySet | Singleton>(this.convertedMetadata, \"\", this.getClosestEntitySet().fullyQualifiedName);\n\t}\n\n\tpublic getMetaPathForPath<SubType>(targetPath: string): MetaPath<SubType> | undefined {\n\t\ttry {\n\t\t\treturn new MetaPath<SubType>(this.convertedMetadata, enhancePath(this.serviceObjectPath, targetPath), this.contextPath);\n\t\t} catch (_error) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tpublic getMetaPathForObject<SubType extends { fullyQualifiedName: string }>(\n\t\ttargetObject: SubType\n\t): MetaPath<ResolvedTarget<SubType>> | undefined {\n\t\tif (isAnnotationPath(targetObject)) {\n\t\t\treturn this.getMetaPathForPath<ResolvedTarget<SubType>>(targetObject.value);\n\t\t} else if (isPathAnnotationExpression(targetObject)) {\n\t\t\treturn this.getMetaPathForPath<ResolvedTarget<SubType>>(targetObject.path);\n\t\t} else {\n\t\t\tconst metaPathApp = targetObject.fullyQualifiedName.replace(this.rootEntitySet.entityType.fullyQualifiedName, this.contextPath);\n\t\t\treturn new MetaPath<ResolvedTarget<SubType>>(this.convertedMetadata, metaPathApp, this.contextPath);\n\t\t}\n\t}\n\n\tpublic getConvertedMetadata(): ConvertedMetadata {\n\t\treturn this.convertedMetadata;\n\t}\n}\n","import type { EntitySet } from \"@sap-ux/vocabularies-types\";\nimport type { Property } from \"@sap-ux/vocabularies-types/Edm\";\nimport type { FieldGroup, SelectionFields } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type { EntityTypeAnnotations_UI } from \"@sap-ux/vocabularies-types/vocabularies/UI_Edm\";\nimport { BaseDefinition, configurable } from \"../BaseDefinition\";\nimport type { PageTargetEntity } from \"../floorplans/DefinitionPage\";\nimport type MetaPath from \"../MetaPath\";\nimport _EntitySet from \"../odata/EntitySet\";\nimport { isAnnotationOfType, isPathAnnotationExpression, isValidPropertyPathExpression } from \"../utils/TypeGuards\";\n\nexport type FilterFieldConfiguration = {\n\tgroup?: string;\n\tgroupLabel?: string;\n\tvisible?: boolean;\n\trequired?: boolean;\n\tisParameter?: boolean;\n};\n\nexport class FilterField extends BaseDefinition<FilterFieldConfiguration> {\n\t@configurable()\n\tgroup?: string;\n\n\t@configurable()\n\tgroupLabel?: string;\n\n\t@configurable()\n\tvisible?: boolean;\n\n\t@configurable()\n\trequired?: boolean;\n\n\t@configurable()\n\tget name(): string {\n\t\treturn this.filterFieldProperty.getTarget().name;\n\t}\n\n\tget isParameter(): boolean {\n\t\t// The property is a parameter if the closest entity type has a ResultContext annotation\n\t\t// This indicates that the entity type is a parametrized entity type with a result context\n\t\treturn !!this.filterFieldProperty.getClosestEntityType().annotations.Common?.ResultContext;\n\t}\n\n\tget label(): string {\n\t\treturn this.filterFieldProperty.getTarget().annotations.Common?.Label?.toString() ?? this.filterFieldProperty.getTarget().name;\n\t}\n\n\tconstructor(\n\t\tprivate readonly filterFieldProperty: MetaPath<Property>,\n\t\tfilterFieldConfiguration: FilterFieldConfiguration\n\t) {\n\t\tsuper(filterFieldProperty, filterFieldConfiguration);\n\t}\n\n\tgetTarget(): Property {\n\t\treturn this.filterFieldProperty.getTarget();\n\t}\n}\nexport type FilterBarConfiguration = {\n\tfilterFields?: Record<string, FilterFieldConfiguration[]>;\n};\nexport default class FilterBar {\n\tconstructor(\n\t\tprivate readonly selectionFields: SelectionFields,\n\t\tprivate readonly filterBarConfiguration: FilterBarConfiguration,\n\t\tprivate readonly metaPath: MetaPath<PageTargetEntity>\n\t) {}\n\n\tisParameterizedEntitySet(): boolean {\n\t\tconst target = this.metaPath.getTarget();\n\t\tif (target._type === \"NavigationProperty\" && target.containsTarget) {\n\t\t\treturn this.metaPath.getClosestEntitySet().entityType.annotations.Common?.ResultContext !== undefined;\n\t\t}\n\t\treturn false;\n\t}\n\n\tgetFilterGroups(): Record<string, { group?: string; groupLabel?: string }> {\n\t\tconst filterFacets = this.metaPath.getClosestEntityType().annotations.UI?.FilterFacets;\n\t\tconst filterFieldsGroup: Record<string, { group?: string; groupLabel?: string }> = {};\n\t\tif (!filterFacets) {\n\t\t\tconst fieldGroups = Object.keys(this.metaPath.getClosestEntityType().annotations.UI ?? {})\n\t\t\t\t.filter((key) => {\n\t\t\t\t\treturn key.startsWith(\"FieldGroup\");\n\t\t\t\t})\n\t\t\t\t.map((key) => {\n\t\t\t\t\treturn this.metaPath.getClosestEntityType().annotations.UI?.[key as keyof EntityTypeAnnotations_UI];\n\t\t\t\t}) as FieldGroup[];\n\t\t\tfor (const fieldGroup of fieldGroups) {\n\t\t\t\tfieldGroup.Data.forEach((fieldGroupEntry) => {\n\t\t\t\t\tswitch (fieldGroupEntry.$Type) {\n\t\t\t\t\t\tcase UIAnnotationTypes.DataField: {\n\t\t\t\t\t\t\tconst fieldGroupValue = fieldGroupEntry.Value as unknown;\n\t\t\t\t\t\t\tif (isPathAnnotationExpression(fieldGroupValue) && fieldGroupValue.$target) {\n\t\t\t\t\t\t\t\tfilterFieldsGroup[fieldGroupValue.$target.fullyQualifiedName] = {\n\t\t\t\t\t\t\t\t\tgroup: fieldGroup.fullyQualifiedName,\n\t\t\t\t\t\t\t\t\tgroupLabel:\n\t\t\t\t\t\t\t\t\t\tfieldGroup.Label?.toString() ??\n\t\t\t\t\t\t\t\t\t\tfieldGroup.annotations?.Common?.Label?.toString() ??\n\t\t\t\t\t\t\t\t\t\tfieldGroup.qualifier\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// Not supported\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tfilterFacets.forEach((filterFacet) => {\n\t\t\t\tconst filterFacetTarget = filterFacet.Target.$target;\n\t\t\t\tif (isAnnotationOfType<FieldGroup>(filterFacetTarget, UIAnnotationTypes.FieldGroupType)) {\n\t\t\t\t\tfilterFacetTarget.Data.forEach((fieldGroupEntry) => {\n\t\t\t\t\t\tswitch (fieldGroupEntry.$Type) {\n\t\t\t\t\t\t\tcase UIAnnotationTypes.DataField: {\n\t\t\t\t\t\t\t\tconst fieldGroupValue = fieldGroupEntry.Value as unknown;\n\t\t\t\t\t\t\t\tif (isPathAnnotationExpression(fieldGroupValue) && fieldGroupValue.$target) {\n\t\t\t\t\t\t\t\t\tfilterFieldsGroup[fieldGroupValue.$target.fullyQualifiedName] = {\n\t\t\t\t\t\t\t\t\t\tgroup: filterFacet.ID?.toString(),\n\t\t\t\t\t\t\t\t\t\tgroupLabel: filterFacet.Label?.toString()\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// Not supported\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn filterFieldsGroup;\n\t}\n\n\tgetFilterFields(): FilterField[] {\n\t\tconst filterGroups = this.getFilterGroups();\n\n\t\tconst consideredProperties: Record<string, boolean> = {};\n\t\tlet parameterizedFields: FilterField[] = [];\n\t\tif (this.isParameterizedEntitySet()) {\n\t\t\tconst parametrizedEntitySetMetaPath = this.metaPath.getMetaPathForClosestEntitySet();\n\t\t\tparameterizedFields = parametrizedEntitySetMetaPath\n\t\t\t\t.getClosestEntityType()\n\t\t\t\t.entityProperties.map((property) => {\n\t\t\t\t\tconst metaPathForProperty = parametrizedEntitySetMetaPath.getMetaPathForPath<Property>(property.name);\n\t\t\t\t\tif (metaPathForProperty) {\n\t\t\t\t\t\tconsideredProperties[metaPathForProperty.getTarget().fullyQualifiedName] = true;\n\t\t\t\t\t\treturn new FilterField(metaPathForProperty, {\n\t\t\t\t\t\t\tgroup: filterGroups[metaPathForProperty.getTarget().fullyQualifiedName]?.group,\n\t\t\t\t\t\t\tgroupLabel: filterGroups[metaPathForProperty.getTarget().fullyQualifiedName]?.groupLabel,\n\t\t\t\t\t\t\tvisible: true,\n\t\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\t\tisParameter: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.filter((field): field is FilterField => {\n\t\t\t\t\treturn !!field;\n\t\t\t\t});\n\t\t}\n\t\tconst requiredProperties = new _EntitySet(this.metaPath as MetaPath<EntitySet>).getRequiredProperties();\n\t\tconst fromSelectionField = this.selectionFields\n\t\t\t.filter(isValidPropertyPathExpression)\n\t\t\t.map((field) => {\n\t\t\t\tconst metaPathForProperty = this.metaPath.getMetaPathForPath<Property>(field.value);\n\t\t\t\tif (metaPathForProperty && !consideredProperties[metaPathForProperty.getTarget().fullyQualifiedName]) {\n\t\t\t\t\tconsideredProperties[metaPathForProperty.getTarget().fullyQualifiedName] = true;\n\t\t\t\t\treturn new FilterField(metaPathForProperty, {\n\t\t\t\t\t\tgroup: filterGroups[metaPathForProperty.getTarget().fullyQualifiedName]?.group,\n\t\t\t\t\t\tgroupLabel: filterGroups[metaPathForProperty.getTarget().fullyQualifiedName]?.groupLabel,\n\t\t\t\t\t\tvisible: true,\n\t\t\t\t\t\trequired: requiredProperties.includes(metaPathForProperty.getTarget())\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})\n\t\t\t.filter((field): field is FilterField => {\n\t\t\t\treturn !!field;\n\t\t\t});\n\t\tconst nonFilterableProperties = new _EntitySet(this.metaPath as MetaPath<EntitySet>).getNonFilterableProperties();\n\t\tthis.metaPath.getClosestEntityType().entityProperties.forEach((property) => {\n\t\t\tif (\n\t\t\t\t!consideredProperties[property.fullyQualifiedName] &&\n\t\t\t\t!nonFilterableProperties.includes(property) &&\n\t\t\t\tproperty.targetType === undefined &&\n\t\t\t\tproperty.annotations.UI?.Hidden?.valueOf() !== true\n\t\t\t) {\n\t\t\t\tconsideredProperties[property.fullyQualifiedName] = true;\n\t\t\t\tfromSelectionField.push(\n\t\t\t\t\tnew FilterField(this.metaPath.getMetaPathForPath<Property>(property.name)!, {\n\t\t\t\t\t\tgroup: filterGroups[property.fullyQualifiedName]?.group,\n\t\t\t\t\t\tgroupLabel: filterGroups[property.fullyQualifiedName]?.groupLabel,\n\t\t\t\t\t\tvisible: false\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\treturn [...parameterizedFields, ...fromSelectionField];\n\t}\n\n\tisSearchSupported(): boolean {\n\t\treturn new _EntitySet(this.metaPath as MetaPath<EntitySet>).isSearchAllowed();\n\t}\n}\n","import type { EntitySet, NavigationProperty, PropertyPath, Singleton } from \"@sap-ux/vocabularies-types\";\nimport type {\n\tLineItem,\n\tPresentationVariant,\n\tSelectionFields,\n\tSelectionPresentationVariant\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type { FilterBarConfiguration } from \"../elements/FilterBar\";\nimport FilterBar from \"../elements/FilterBar\";\nimport type MetaPath from \"../MetaPath\";\nimport { _HeaderInfo } from \"../odata/annotations/UI/_HeaderInfo\";\nimport { _Identification } from \"../odata/annotations/UI/_Identification\";\nimport { _LineItem } from \"../odata/annotations/UI/_LineItem\";\n\nexport type PageTargetEntity = EntitySet | Singleton | NavigationProperty;\nexport class DefinitionPage {\n\tconstructor(private metaPath: MetaPath<PageTargetEntity>) {}\n\n\tgetMetaPath(): MetaPath<PageTargetEntity> {\n\t\treturn this.metaPath;\n\t}\n\n\t/**\n\t * Gets the target entity set identification annotation if available.\n\t *\n\t * @returns Identification annotation wrapper\n\t */\n\tpublic getIdentification(): _Identification | undefined {\n\t\tconst targetEntityType = this.metaPath.getClosestEntityType();\n\t\tconst idAnnotation = targetEntityType.annotations.UI?.Identification;\n\t\tif (idAnnotation) {\n\t\t\treturn new _Identification(idAnnotation, this.metaPath);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tpublic getHeaderInfo(): _HeaderInfo | undefined {\n\t\tconst targetEntityType = this.metaPath.getClosestEntityType();\n\t\tconst info = targetEntityType.annotations.UI?.HeaderInfo;\n\t\tif (info) {\n\t\t\treturn new _HeaderInfo(info, this.metaPath);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Retrieves the LineItem annotation for the target entity set\n\t * @returns LineItem annotation\n\t */\n\tpublic getTableVisualization(): _LineItem | undefined {\n\t\treturn _LineItem.fromSPV(this._getTableVisualizationAnnotation(), this.metaPath);\n\t}\n\n\tpublic getFilterBarDefinition(filterBarConfiguration: FilterBarConfiguration): FilterBar {\n\t\tconst targetEntityType = this.metaPath.getClosestEntityType();\n\t\t//this.tracer.markRequest(\"Page.getFilterBarDefinition\", targetEntityType);\n\t\tlet selectionField = targetEntityType.annotations.UI?.SelectionFields;\n\t\tif (!selectionField) {\n\t\t\tselectionField = Object.assign([] as PropertyPath[], {\n\t\t\t\tterm: UIAnnotationTerms.SelectionFields\n\t\t\t}) as SelectionFields;\n\t\t}\n\t\t//this.tracer.endMarkRequest(\"Page.getFilterBarDefinition\");\n\t\treturn new FilterBar(selectionField, filterBarConfiguration, this.metaPath);\n\t}\n\n\t/**\n\t * Create a default LineItem annotation for the target entity type based on properties\n\t * @returns LineItem annotation\n\t */\n\tpublic createDefaultTableVisualization(): _LineItem {\n\t\treturn _LineItem.createDefault(this.metaPath);\n\t}\n\n\tprivate _getTableVisualizationAnnotation(): LineItem | SelectionPresentationVariant | PresentationVariant | undefined {\n\t\tconst targetEntityType = this.metaPath.getClosestEntityType();\n\t\tconst spv = targetEntityType.annotations.UI?.SelectionPresentationVariant;\n\t\tif (spv) {\n\t\t\tif (spv.PresentationVariant.Visualizations.find((v) => v.$target?.term === UIAnnotationTerms.LineItem)) {\n\t\t\t\treturn spv;\n\t\t\t}\n\t\t}\n\t\tconst pv = targetEntityType.annotations.UI?.PresentationVariant;\n\t\tif (pv?.Visualizations) {\n\t\t\tif (pv.Visualizations.find((v) => v.$target?.term === UIAnnotationTerms.LineItem)) {\n\t\t\t\treturn pv;\n\t\t\t}\n\t\t}\n\t\treturn targetEntityType.annotations.UI?.LineItem;\n\t}\n}\n","export { FilterField } from \"./elements/FilterBar\";\nexport { DefinitionPage } from \"./floorplans/DefinitionPage\";\nexport { _DataField } from \"./odata/annotations/UI/_DataField\";\nexport { _LineItem } from \"./odata/annotations/UI/_LineItem\";\nexport { DefinitionContext } from \"./odata/DefinitionContext\";\nexport { QueryBuilder } from \"./odata/QueryBuilder\";\nexport { FORMATTERS_PATH, formatters } from \"./utils/Formatters\";\nexport * from \"./utils/TypeGuards\";\n","import type { ConvertedMetadata, EntitySet, NavigationProperty, Singleton } from \"@sap-ux/vocabularies-types\";\nimport type { SAPJSONSchemaForWebApplicationManifestFile as ApplicationManifest, Route } from \"@ui5/manifest/types/manifest\";\nimport MetaPath from \"../MetaPath\";\nimport { DefinitionPage } from \"../floorplans/DefinitionPage\";\n\nexport class DefinitionContext {\n\tprivate manifest?: ApplicationManifest;\n\n\tconstructor(private readonly convertedMetadata: ConvertedMetadata) {}\n\n\taddApplicationManifest(manifest: ApplicationManifest): void {\n\t\tthis.manifest = manifest;\n\t}\n\n\tgetEntitySets(): EntitySet[] {\n\t\treturn this.convertedMetadata.entitySets;\n\t}\n\n\tgetEntitySet(entitySetName: string): EntitySet | undefined {\n\t\treturn this.convertedMetadata.entitySets.by_name(entitySetName);\n\t}\n\n\tgetRootEntitySet(): EntitySet | Singleton | undefined {\n\t\tif (this.manifest) {\n\t\t\t// Use the ui5 routing config to identify the root entityset\n\t\t\tconst initialRoutePattern = \":?query:\";\n\t\t\tconst initialRoute = (this.manifest[\"sap.ui5\"]?.routing?.routes as Route[]).find((r) => r.pattern === initialRoutePattern);\n\t\t\tif (initialRoute?.target && this.manifest[\"sap.ui5\"]?.routing?.targets) {\n\t\t\t\tconst target = this.manifest[\"sap.ui5\"].routing.targets[initialRoute.target as string];\n\t\t\t\tif (target?.name) {\n\t\t\t\t\tconst options = target.options as\n\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\tsettings?: {\n\t\t\t\t\t\t\t\t\tcontextPath?: string;\n\t\t\t\t\t\t\t\t\tentitySet: string;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t| undefined;\n\t\t\t\t\tconst settings = options?.settings;\n\t\t\t\t\tconst entitySet = this.convertedMetadata.resolvePath<EntitySet | Singleton>(\n\t\t\t\t\t\tsettings?.contextPath ?? `${settings?.entitySet}`\n\t\t\t\t\t);\n\t\t\t\t\treturn entitySet.target;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Try to determine the root entity set from the metadata\n\t}\n\n\tgetMetaPath<T>(metaPath: string, contextPath: string): MetaPath<T> {\n\t\treturn new MetaPath<T>(this.convertedMetadata, metaPath, contextPath);\n\t}\n\n\tgetPageFor(contextPath: string): DefinitionPage {\n\t\t// A page could point to\n\t\t// - An entitySet (/SalesOrder)\n\t\t// - A singleton (/Me)\n\t\t// - A navigation property (/SalesOrder/Set)\n\t\treturn new DefinitionPage(\n\t\t\tnew MetaPath<EntitySet | Singleton | NavigationProperty>(this.convertedMetadata, contextPath, contextPath)\n\t\t);\n\t}\n\n\tgetVersion(): { major: number; minor: number } {\n\t\tconst match = this.convertedMetadata.version.match(/^(\\d+)\\.(\\d+)$/);\n\t\tif (!match) {\n\t\t\tthrow new Error(\"Invalid version format\");\n\t\t}\n\t\treturn {\n\t\t\tmajor: parseInt(match[1]!, 10),\n\t\t\tminor: parseInt(match[2]!, 10)\n\t\t};\n\t}\n}\n","import type { EntitySet } from \"@sap-ux/vocabularies-types\";\nimport type { Property } from \"@sap-ux/vocabularies-types/Edm\";\nimport type { FilterExpressionType } from \"@sap-ux/vocabularies-types/vocabularies/Capabilities\";\nimport type { BaseConfiguration } from \"../BaseDefinition\";\nimport { BaseDefinition } from \"../BaseDefinition\";\nimport type MetaPath from \"../MetaPath\";\n\nexport default class _EntitySet extends BaseDefinition<BaseConfiguration> {\n\tconstructor(\n\t\tprivate readonly entitySet: MetaPath<EntitySet>,\n\t\tprivate readonly entitySetConfiguration: BaseConfiguration = {}\n\t) {\n\t\tsuper(entitySet, entitySetConfiguration);\n\t}\n\t//\n\t// @annotation({\n\t// \tterm: CapabilitiesAnnotationTerms.FilterRestrictions,\n\t// \tprocessor: (filterRestrictions?: FilterRestrictions): Property[] => {\n\t// \t\tconst requiredProperties =\n\t// \t\t\tfilterRestrictions?.RequiredProperties ?? [];\n\t// \t\treturn requiredProperties\n\t// \t\t\t.map((propertyPath) => {\n\t// \t\t\t\treturn propertyPath.$target;\n\t// \t\t\t})\n\t// \t\t\t.filter((property): property is Property => {\n\t// \t\t\t\treturn !!property;\n\t// \t\t\t});\n\t// \t}\n\t// })\n\t// requiredProperties: Property[];\n\n\t/**\n\t * Retrieves the required properties for the entity set.\n\t */\n\tgetRequiredProperties(): Property[] {\n\t\tconst requiredProperties = this.entitySet.getTarget().annotations.Capabilities?.FilterRestrictions?.RequiredProperties ?? [];\n\t\treturn requiredProperties\n\t\t\t.map((propertyPath) => {\n\t\t\t\treturn propertyPath.$target;\n\t\t\t})\n\t\t\t.filter((property): property is Property => {\n\t\t\t\treturn !!property;\n\t\t\t});\n\t}\n\n\t/**\n\t * Retrieves the required properties for the entity set.\n\t */\n\tgetNonFilterableProperties(): Property[] {\n\t\tconst nonFilterableProperties =\n\t\t\tthis.entitySet.getTarget().annotations.Capabilities?.FilterRestrictions?.NonFilterableProperties ?? [];\n\t\treturn nonFilterableProperties\n\t\t\t.map((propertyPath) => {\n\t\t\t\treturn propertyPath.$target;\n\t\t\t})\n\t\t\t.filter((property): property is Property => {\n\t\t\t\treturn !!property;\n\t\t\t});\n\t}\n\n\t/**\n\t * Retrieves the required properties for the entity set.\n\t * @param property\n\t */\n\tgetAllowedFilterExpression(property: Property): FilterExpressionType[] {\n\t\tconst filterExpressionRestrictions =\n\t\t\tthis.entitySet.getTarget().annotations.Capabilities?.FilterRestrictions?.FilterExpressionRestrictions ?? [];\n\t\tconst propertyRestrictions = filterExpressionRestrictions.filter(\n\t\t\t(filterExpressionRestriction) => filterExpressionRestriction.Property?.$target === property\n\t\t);\n\t\treturn propertyRestrictions\n\t\t\t.map((propertyRestriction) => {\n\t\t\t\treturn propertyRestriction.AllowedExpressions;\n\t\t\t})\n\t\t\t.filter((propertyRestriction): propertyRestriction is FilterExpressionType => {\n\t\t\t\treturn !!propertyRestriction;\n\t\t\t});\n\t}\n\n\tisSearchAllowed(): boolean {\n\t\treturn !!this.entitySet.getTarget().annotations.Capabilities?.SearchRestrictions?.Searchable;\n\t}\n}\n","import { type NavigationProperty } from \"@sap-ux/vocabularies-types\";\nimport type MetaPath from \"../MetaPath\";\nimport { type Expression, type PrimitiveType, transformRecursively } from \"../utils/Expression\";\nimport { type DefinitionContext } from \"./DefinitionContext\";\n\nexport class QueryBuilder {\n\tprivate readonly paths: Set<string> = new Set();\n\n\tconstructor(\n\t\tprivate readonly contextMetaPath: MetaPath<unknown>,\n\t\tprivate readonly definitionContext: DefinitionContext\n\t) {}\n\n\taddPathsFromExpression<T extends PrimitiveType>(expression: Expression<T>): void {\n\t\ttransformRecursively(\n\t\t\texpression,\n\t\t\t\"PathInModel\",\n\t\t\t(pathExpression) => {\n\t\t\t\tthis.addPath(pathExpression.path);\n\t\t\t\treturn pathExpression;\n\t\t\t},\n\t\t\ttrue /*includeAllExpressions*/\n\t\t);\n\t}\n\n\taddPath(path: string): void {\n\t\tthis.paths.add(path);\n\t}\n\n\tbuildQuery(): Query {\n\t\tlet query: Query;\n\t\tif (this.definitionContext.getVersion().major >= 4) {\n\t\t\tquery = this.createQueryV4(this.paths);\n\t\t} else {\n\t\t\tquery = this.createQueryV2(this.paths);\n\t\t}\n\t\treturn query;\n\t}\n\n\tprivate createQueryV2(paths: Set<string>): Query {\n\t\tconst select: string[] = [];\n\t\tconst expand: Set<string> = new Set<string>();\n\t\tpaths.forEach((property) => {\n\t\t\tconst parts = property.split(\"/\");\n\t\t\tconst propertyMetaPath = this.contextMetaPath.getMetaPathForPath(property);\n\t\t\tconst name = parts[0];\n\t\t\tif (name && this.isNavigationProperty(name, propertyMetaPath?.getNavigationProperties() ?? [])) {\n\t\t\t\texpand.add(name);\n\t\t\t} else {\n\t\t\t\tselect.push(property);\n\t\t\t}\n\t\t});\n\t\tconst query: Query = {\n\t\t\t$format: \"json\",\n\t\t\t$select: select.join(\",\")\n\t\t};\n\t\tif (expand.size > 0) {\n\t\t\tquery.$expand = Array.from(expand).join(\",\");\n\t\t}\n\t\treturn query;\n\t}\n\n\tprivate createQueryV4(paths: Set<string>): Query {\n\t\tconst node: QueryNode = {\n\t\t\tname: \"\",\n\t\t\t$select: new Set(),\n\t\t\t$expand: new Map()\n\t\t};\n\t\tpaths.forEach((property) => {\n\t\t\tconst parts: string[] = property.split(\"/\");\n\t\t\tconst propertyMetaPath = this.contextMetaPath.getMetaPathForPath(property);\n\t\t\tconst navigationProperties = propertyMetaPath?.getNavigationProperties() ?? [];\n\t\t\tthis.processPathRecursiveV4(parts, node, navigationProperties);\n\t\t});\n\t\tconst query: Query = {\n\t\t\t$format: \"json\",\n\t\t\t$select: Array.from(node.$select).join(\",\")\n\t\t};\n\t\tif (node.$expand.size > 0) {\n\t\t\tquery.$expand = Array.from(node.$expand.values()).map(serializeExpandV4Recursive).join(\",\");\n\t\t}\n\t\treturn query;\n\t}\n\n\tprivate processPathRecursiveV4(\n\t\tparts: Array<string>,\n\t\tparentNode: QueryNode,\n\t\tnavigationProperties: ReadonlyArray<NavigationProperty>\n\t): void {\n\t\tlet node: QueryNode | undefined;\n\t\tconst name = parts[0];\n\t\tif (name && this.isNavigationProperty(name, navigationProperties)) {\n\t\t\tnode = parentNode.$expand.get(name);\n\t\t\tif (!node) {\n\t\t\t\tnode = {\n\t\t\t\t\tname,\n\t\t\t\t\t$select: new Set(),\n\t\t\t\t\t$expand: new Map()\n\t\t\t\t};\n\t\t\t}\n\t\t\tparentNode.$expand.set(name, node);\n\t\t\tif (parts.length === 2) {\n\t\t\t\tnode.$select.add(parts[1] ?? \"\");\n\t\t\t} else {\n\t\t\t\tthis.processPathRecursiveV4(parts.slice(1), node, navigationProperties.slice(1));\n\t\t\t}\n\t\t} else {\n\t\t\tparentNode.$select.add(parts.join(\"/\"));\n\t\t}\n\t}\n\n\tprivate isNavigationProperty(property: string, navigationProperties: ReadonlyArray<NavigationProperty>): boolean {\n\t\tconst navigationPropertyOffset = this.contextMetaPath.getNavigationProperties().length;\n\t\treturn navigationProperties.length > navigationPropertyOffset && property === navigationProperties[navigationPropertyOffset]?.name;\n\t}\n}\n\nexport type Query = {\n\t$select: string;\n\t$expand?: string;\n\t$format: \"json\";\n};\n\ntype QueryNode = {\n\tname: string;\n\t$select: Set<string>;\n\t$expand: Map<string, QueryNode>;\n};\n\nfunction serializeExpandV4Recursive(expandNode: QueryNode): string {\n\tconst select = serializeSelect(expandNode.$select);\n\tconst expandValue = Array.from(expandNode.$expand.values()).map(serializeExpandV4Recursive).join(\",\");\n\tconst expand = expandValue.length > 0 ? `$expand=${expandValue}` : \"\";\n\tconst separator = select.length > 0 && expand.length > 0 ? \";\" : \"\";\n\treturn `${expandNode.name}(${select}${separator}${expand})`;\n}\n\nfunction serializeSelect(fields: Set<string>): string {\n\treturn fields.size > 0 ? `$select=${Array.from(fields).join(\",\")}` : \"\";\n}\n","import type { DynamicAnnotationExpression, Property } from \"@sap-ux/vocabularies-types\";\nimport type { DataFieldForAnnotationTypes, DataFieldTypes, FieldGroup } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { TextArrangementType, UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type MetaPath from \"../../../MetaPath\";\nimport type { Expression, PathInModelExpression, PrimitiveType } from \"../../../utils/Expression\";\nimport { concat, formatResult, getExpressionFromAnnotation, transformRecursively, unresolvableExpression } from \"../../../utils/Expression\";\nimport formatters from \"../../../utils/Formatters\";\nimport { isAnnotationOfType, isPathAnnotationExpression } from \"../../../utils/TypeGuards\";\n\nexport class _DataField {\n\tconstructor(\n\t\tprivate readonly dataField: DataFieldTypes | DataFieldForAnnotationTypes,\n\t\tprivate readonly scopedContextMetaPath: MetaPath<unknown>\n\t) {}\n\n\tgetValue(): Expression<PrimitiveType> {\n\t\tif (!isAnnotationOfType<DataFieldForAnnotationTypes>(this.dataField, UIAnnotationTypes.DataFieldForAnnotation)) {\n\t\t\treturn getExpressionFromAnnotation<PrimitiveType>(this.dataField.Value as DynamicAnnotationExpression<PrimitiveType>);\n\t\t}\n\t\treturn unresolvableExpression;\n\t}\n\n\tgetFormattedValue(): Expression<PrimitiveType> {\n\t\tif (!isAnnotationOfType<DataFieldForAnnotationTypes>(this.dataField, UIAnnotationTypes.DataFieldForAnnotation)) {\n\t\t\t// Compute display mode and then return the formatted value\n\t\t\t// Also consider units and currency\n\t\t\tconst targetValue = getExpressionFromAnnotation(\n\t\t\t\tthis.dataField.Value as DynamicAnnotationExpression<PrimitiveType>,\n\t\t\t\tthis.scopedContextMetaPath.getNavigationProperties().map((navProp) => navProp.name)\n\t\t\t);\n\t\t\treturn transformRecursively(targetValue, \"PathInModel\", (value: PathInModelExpression<unknown>): Expression<PrimitiveType> => {\n\t\t\t\tconst propertyMetaPath = this.scopedContextMetaPath.getMetaPathForPath<Property>(value.ownPath);\n\t\t\t\tif (!propertyMetaPath) {\n\t\t\t\t\treturn unresolvableExpression;\n\t\t\t\t}\n\n\t\t\t\tconst measure = this.getMeasure(propertyMetaPath);\n\t\t\t\tif (measure) {\n\t\t\t\t\treturn concat(value, \" \", measure);\n\t\t\t\t}\n\n\t\t\t\tconst displayMode = this.getDisplayMode(propertyMetaPath);\n\t\t\t\tif (displayMode !== \"Value\") {\n\t\t\t\t\tconst text = getExpressionFromAnnotation(\n\t\t\t\t\t\tpropertyMetaPath.getTarget().annotations.Common?.Text,\n\t\t\t\t\t\tpropertyMetaPath.getNavigationProperties().map((navProp) => navProp.name)\n\t\t\t\t\t);\n\t\t\t\t\tif (displayMode === \"Description\") {\n\t\t\t\t\t\treturn text;\n\t\t\t\t\t} else if (displayMode === \"DescriptionValue\") {\n\t\t\t\t\t\treturn formatResult([text, value], formatters.formatWithBrackets);\n\t\t\t\t\t} else if (displayMode === \"ValueDescription\") {\n\t\t\t\t\t\treturn formatResult([value, text], formatters.formatWithBrackets);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}) as Expression<PrimitiveType>;\n\t\t}\n\t\treturn unresolvableExpression;\n\t}\n\n\t/**\n\t * Checks if the given property has a Unit or ISOCurrency annotation and returns it.\n\t *\n\t * @param property property to get the measure for\n\t * @returns the measure annotation or undefined\n\t */\n\tgetMeasure(property: MetaPath<Property>): Expression<string> | undefined {\n\t\tconst measures = property.getTarget().annotations.Measures;\n\t\tif (measures) {\n\t\t\tconst measure = measures.Unit ?? measures.ISOCurrency;\n\t\t\tif (measure) {\n\t\t\t\treturn getExpressionFromAnnotation(measure);\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tgetDisplayMode(property: MetaPath<Property>): \"Description\" | \"Value\" | \"DescriptionValue\" | \"ValueDescription\" {\n\t\tconst currentEntityType = property.getClosestEntityType();\n\t\tconst textAnnotation = property.getTarget().annotations.Common?.Text;\n\t\tconst textArrangement = textAnnotation?.annotations?.UI?.TextArrangement ?? currentEntityType.annotations.UI?.TextArrangement;\n\n\t\tlet displayMode: \"Description\" | \"Value\" | \"DescriptionValue\" | \"ValueDescription\" = textAnnotation ? \"DescriptionValue\" : \"Value\";\n\t\tif (textAnnotation && textArrangement != null) {\n\t\t\tif (textArrangement === TextArrangementType.TextOnly) {\n\t\t\t\tdisplayMode = \"Description\";\n\t\t\t} else if (textArrangement === TextArrangementType.TextLast) {\n\t\t\t\tdisplayMode = \"ValueDescription\";\n\t\t\t} else if (textArrangement === TextArrangementType.TextSeparate) {\n\t\t\t\tdisplayMode = \"Value\";\n\t\t\t} else {\n\t\t\t\t//Default should be TextFirst if there is a Text annotation and neither TextOnly nor TextLast are set\n\t\t\t\tdisplayMode = \"DescriptionValue\";\n\t\t\t}\n\t\t}\n\t\treturn displayMode;\n\t}\n\n\tgetLabel(): string {\n\t\tlet label = this.dataField.Label?.toString() ?? this.dataField.annotations?.Common?.Label?.toString();\n\t\tif (!label) {\n\t\t\tlabel = this.dataField.fullyQualifiedName; // Fallback to the fully qualified name\n\t\t\tif (isAnnotationOfType<DataFieldForAnnotationTypes>(this.dataField, UIAnnotationTypes.DataFieldForAnnotation)) {\n\t\t\t\tconst target = this.dataField.Target.$target;\n\t\t\t\tif (isAnnotationOfType<FieldGroup>(target, UIAnnotationTypes.FieldGroupType) && target.Label) {\n\t\t\t\t\tlabel = target.Label.toString();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst valueTarget = this.dataField.Value as DynamicAnnotationExpression<unknown>;\n\t\t\t\tif (isPathAnnotationExpression(valueTarget)) {\n\t\t\t\t\tlabel = valueTarget.$target?.annotations.Common?.Label?.toString() ?? valueTarget.$target?.name ?? valueTarget.path;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn label;\n\t}\n\n\t/**\n\t * Retrieve a property from the data field IF it can be easily determined (no complex exression)\n\t */\n\tgetProperty(): Property | undefined {\n\t\tif (!isAnnotationOfType<DataFieldForAnnotationTypes>(this.dataField, UIAnnotationTypes.DataFieldForAnnotation)) {\n\t\t\tconst valueTarget = this.dataField.Value as DynamicAnnotationExpression<unknown> | undefined;\n\t\t\tif (valueTarget && isPathAnnotationExpression(valueTarget)) {\n\t\t\t\treturn valueTarget.$target;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tgetFullyQualifiedName(): string {\n\t\treturn this.dataField.fullyQualifiedName;\n\t}\n}\n","import type { HeaderInfo } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { type DataFieldTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type MetaPath from \"../../../MetaPath\";\nimport type { PageTargetEntity } from \"../../../floorplans/DefinitionPage\";\nimport { _DataField } from \"./_DataField\";\n\nexport class _HeaderInfo {\n\tconstructor(\n\t\tprotected readonly info: HeaderInfo,\n\t\tprotected readonly pageMetaPath: MetaPath<PageTargetEntity>\n\t) {}\n\n\tgetFullyQualifiedName(): string {\n\t\treturn this.info.fullyQualifiedName;\n\t}\n\n\tgetTitle(): _DataField | undefined {\n\t\treturn this.info.Title ? new _DataField(this.info.Title as DataFieldTypes, this.pageMetaPath) : undefined;\n\t}\n\n\tgetDescription(): _DataField | undefined {\n\t\treturn this.info.Description ? new _DataField(this.info.Description as DataFieldTypes, this.pageMetaPath) : undefined;\n\t}\n\n\tgetTypeName(): string {\n\t\t// eslint-disable-next-line @typescript-eslint/no-base-to-string\n\t\treturn this.info.TypeName.toString();\n\t}\n}\n","import {\n\tUIAnnotationTypes,\n\ttype DataFieldTypes,\n\ttype Identification,\n\ttype ImportanceType\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type MetaPath from \"../../../MetaPath\";\nimport type { PageTargetEntity } from \"../../../floorplans/DefinitionPage\";\nimport { _DataField } from \"./_DataField\";\n\nexport class _Identification {\n\tconstructor(\n\t\tprotected readonly id: Identification,\n\t\tprotected readonly pageMetaPath: MetaPath<PageTargetEntity>\n\t) {}\n\n\tgetDataFields(options?: { importance?: ImportanceType[]; restrictTypes?: string[] }): _DataField[] {\n\t\treturn this.id\n\t\t\t.filter((item): item is DataFieldTypes => {\n\t\t\t\tif (options?.restrictTypes && !options.restrictTypes.includes(item.$Type)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tswitch (item.$Type) {\n\t\t\t\t\tcase UIAnnotationTypes.DataField:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithAction:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithActionGroup:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithIntentBasedNavigation:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForAction:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForIntentBasedNavigation:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForActionGroup:\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\toptions?.importance === undefined ||\n\t\t\t\t\t\t\toptions.importance.includes(item.annotations?.UI?.Importance?.toString() as ImportanceType)\n\t\t\t\t\t\t);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.map((item) => {\n\t\t\t\treturn new _DataField(item, this.pageMetaPath);\n\t\t\t});\n\t}\n}\n","import type {\n\tDataFieldForAction,\n\tDataFieldTypes,\n\tImportanceType,\n\tLineItem,\n\tPresentationVariant,\n\tSelectionPresentationVariant\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTerms, UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type MetaPath from \"../../../MetaPath\";\nimport type { PageTargetEntity } from \"../../../floorplans/DefinitionPage\";\nimport { _DataField } from \"./_DataField\";\n\nexport class _LineItem {\n\tconstructor(\n\t\tprivate readonly lineItem: LineItem,\n\t\tprivate readonly pageMetaPath: MetaPath<PageTargetEntity>\n\t) {}\n\n\tstatic createDefault(pageMetaPath: MetaPath<PageTargetEntity>): _LineItem {\n\t\tconst fakeLineItemAnnotation: LineItem = pageMetaPath.getClosestEntityType().entityProperties.map((prop) => {\n\t\t\tif (prop.annotations.UI?.DataFieldDefault) {\n\t\t\t\treturn prop.annotations.UI.DataFieldDefault;\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\t$Type: UIAnnotationTypes.DataField,\n\t\t\t\t\tValue: {\n\t\t\t\t\t\ttype: \"Path\",\n\t\t\t\t\t\tpath: prop.name,\n\t\t\t\t\t\t$target: prop\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}) as LineItem;\n\t\tfakeLineItemAnnotation.term = UIAnnotationTerms.LineItem;\n\t\treturn new _LineItem(fakeLineItemAnnotation, pageMetaPath);\n\t}\n\n\tstatic fromSPV(\n\t\tspv: LineItem | PresentationVariant | SelectionPresentationVariant | undefined,\n\t\tpageMetaPath: MetaPath<PageTargetEntity>\n\t): _LineItem | undefined {\n\t\tswitch (spv?.term) {\n\t\t\tcase UIAnnotationTerms.LineItem:\n\t\t\t\treturn new _LineItem(spv, pageMetaPath);\n\t\t\tcase UIAnnotationTerms.PresentationVariant:\n\t\t\t\treturn new _LineItem(spv.Visualizations[0]!.$target as LineItem, pageMetaPath);\n\t\t\tcase UIAnnotationTerms.SelectionPresentationVariant:\n\t\t\t\treturn new _LineItem(spv.PresentationVariant.Visualizations[0]!.$target as LineItem, pageMetaPath);\n\t\t\tcase undefined:\n\t\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tgetActions(): DataFieldForAction[] {\n\t\treturn this.lineItem.filter((item): item is DataFieldForAction => item.$Type === UIAnnotationTypes.DataFieldForAction);\n\t}\n\n\tgetHeaderActions(): DataFieldForAction[] {\n\t\treturn this.getActions().filter((action) => action.Determining === true);\n\t}\n\n\tgetDataFields(options?: { importance?: ImportanceType[]; restrictTypes?: string[] }): _DataField[] {\n\t\treturn this.lineItem\n\t\t\t.filter((item): item is DataFieldTypes => {\n\t\t\t\tif (options?.restrictTypes && !options.restrictTypes.includes(item.$Type)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tswitch (item.$Type) {\n\t\t\t\t\tcase UIAnnotationTypes.DataField:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithAction:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithActionGroup:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithIntentBasedNavigation:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForAction:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForIntentBasedNavigation:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForActionGroup:\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\toptions?.importance === undefined ||\n\t\t\t\t\t\t\toptions.importance.includes(item.annotations?.UI?.Importance?.toString() as ImportanceType)\n\t\t\t\t\t\t);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.map((item) => {\n\t\t\t\treturn new _DataField(item, this.pageMetaPath);\n\t\t\t});\n\t}\n}\n","import type {\n\tAndAnnotationExpression,\n\tAndConditionalExpression,\n\tApplyAnnotationExpression,\n\tBoolean,\n\tConditionalCheckOrValue,\n\tEntitySet,\n\tEntityType,\n\tEqAnnotationExpression,\n\tEqConditionalExpression,\n\tGeAnnotationExpression,\n\tGeConditionalExpression,\n\tGtAnnotationExpression,\n\tGtConditionalExpression,\n\tIfAnnotationExpression,\n\tIfAnnotationExpressionValue,\n\tLeAnnotationExpression,\n\tLeConditionalExpression,\n\tLtAnnotationExpression,\n\tLtConditionalExpression,\n\tNeAnnotationExpression,\n\tNeConditionalExpression,\n\tNotAnnotationExpression,\n\tNotConditionalExpression,\n\tOrAnnotationExpression,\n\tOrConditionalExpression,\n\tPathAnnotationExpression,\n\tPathConditionExpression,\n\tProperty,\n\tPropertyAnnotationValue,\n\tConstantExpression as VocabularyConstantExpression\n} from \"@sap-ux/vocabularies-types\";\nimport { CommonAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\n\nexport type PrimitiveType = string | number | bigint | boolean | object | null | undefined;\ntype DefinedPrimitiveType = string | number | bigint | boolean | object;\n// eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\ntype PrimitiveTypeCast<P> = P extends String ? string : P extends Boolean ? boolean : P extends Number ? number : P;\ntype BaseExpression<_T> = {\n\t_type: string;\n};\n\nexport type FormatOptions = Partial<{\n\tcustomUnits: Record<string, object>;\n\tcustomCurrencies: Record<string, object>;\n\tdecimals: number;\n\temptyString: null | number | string;\n\tfiscalType: string;\n\tgroupingEnabled: boolean;\n\tmaxFractionDigits: number;\n\tmaxIntegerDigits: number;\n\tminFractionDigits: number;\n\tminIntegerDigits: number;\n\tparseAsString: boolean;\n\tparseKeepsEmptyString: boolean;\n\tpattern: string;\n\tprecision: number;\n\tpreserveDecimals: boolean;\n\tshortDecimals: number;\n\tshortRefNumber: number;\n\tshowMeasure: boolean;\n\tshowNumber: boolean;\n\tshowScale: boolean;\n\tstyle: string;\n}>;\n\nexport type ConstantExpression<T> = BaseExpression<T> & {\n\t_type: \"Constant\";\n\tvalue: T;\n};\n\ntype SetOperator = \"&&\" | \"||\";\nexport type SetExpression = BaseExpression<boolean> & {\n\t_type: \"Set\";\n\toperator: SetOperator;\n\toperands: Expression<boolean>[];\n};\n\nexport type NotExpression = BaseExpression<boolean> & {\n\t_type: \"Not\";\n\toperand: Expression<boolean>;\n};\n\nexport type TruthyExpression = BaseExpression<boolean> & {\n\t_type: \"Truthy\";\n\toperand: Expression<string>;\n};\n\nexport type ReferenceExpression = BaseExpression<object> & {\n\t_type: \"Ref\";\n\tref: string | null;\n};\n\nexport type FormatterExpression<T> = BaseExpression<T> & {\n\t_type: \"Formatter\";\n\tfn: string;\n\tparameters: Expression<unknown>[];\n};\n\ntype ComplexTypeExpression<T> = BaseExpression<T> & {\n\t_type: \"ComplexType\";\n\ttype: string;\n\tformatOptions: FormatOptions;\n\tparameters: object;\n\tbindingParameters: Expression<unknown>[];\n};\n\nexport type FunctionExpression<T> = BaseExpression<T> & {\n\t_type: \"Function\";\n\tobj?: Expression<object>;\n\tfn: string;\n\tisFormattingFn: boolean;\n\tparameters: Expression<unknown>[];\n};\n\nexport type ConcatExpression = BaseExpression<string> & {\n\t_type: \"Concat\";\n\texpressions: Expression<string>[];\n};\n\nexport type LengthExpression = BaseExpression<string> & {\n\t_type: \"Length\";\n\tpathInModel: PathInModelExpression<unknown>;\n};\n\ntype UnresolvablePathExpression = BaseExpression<string> & {\n\t_type: \"Unresolvable\";\n};\n\n/**\n */\nexport type PathInModelExpression<T> = BaseExpression<T> & {\n\t_type: \"PathInModel\";\n\townPath: string;\n\tmodelName?: string;\n\tpath: string;\n\ttargetEntitySet?: EntitySet;\n\ttype?: string;\n\tparameters?: object;\n\ttargetType?: string;\n\tmode?: string;\n\tformatOptions?: FormatOptions;\n};\n\nexport type EmbeddedUI5BindingExpression<T> = BaseExpression<T> & {\n\t_type: \"EmbeddedBinding\";\n\tvalue: string;\n};\n\nexport type EmbeddedUI5ExpressionBindingExpression<T> = BaseExpression<T> & {\n\t_type: \"EmbeddedExpressionBinding\";\n\tvalue: string;\n};\n\nexport type ComparisonOperator = \"===\" | \"!==\" | \">=\" | \">\" | \"<=\" | \"<\";\nexport type ComparisonExpression = BaseExpression<boolean> & {\n\t_type: \"Comparison\";\n\toperator: ComparisonOperator;\n\toperand1: Expression<unknown>;\n\toperand2: Expression<unknown>;\n};\n\nexport type IfElseExpression<T> = BaseExpression<T> & {\n\t_type: \"IfElse\";\n\tcondition: Expression<boolean>;\n\tonTrue: Expression<T>;\n\tonFalse: Expression<T>;\n};\n\n/**\n * An expression that evaluates to type T.\n *\n */\nexport type Expression<T> =\n\t| UnresolvablePathExpression\n\t| ConstantExpression<T>\n\t| SetExpression\n\t| NotExpression\n\t| TruthyExpression\n\t| ConcatExpression\n\t| LengthExpression\n\t| PathInModelExpression<T>\n\t| EmbeddedUI5BindingExpression<T>\n\t| EmbeddedUI5ExpressionBindingExpression<T>\n\t| ComparisonExpression\n\t| IfElseExpression<T>\n\t| FormatterExpression<T>\n\t| ComplexTypeExpression<T>\n\t| ReferenceExpression\n\t| FunctionExpression<T>;\n\n/**\n * An expression that evaluates to type T, or a constant value of type T\n */\nexport type ExpressionOrPrimitive<T extends PrimitiveType> = Expression<T> | T;\n\nexport const unresolvableExpression: UnresolvablePathExpression = {\n\t_type: \"Unresolvable\"\n};\n\nexport function hasUnresolvableExpression(...expressions: Expression<unknown>[]): boolean {\n\treturn expressions.find((expr) => expr._type === \"Unresolvable\") !== undefined;\n}\n/**\n * Check two expressions for (deep) equality.\n *\n * @param a\n * @param b\n * @returns `true` if the two expressions are equal\n */\nexport function _checkExpressionsAreEqual<T>(a?: Expression<T>, b?: Expression<T>): boolean {\n\tif (!a || !b) {\n\t\treturn false;\n\t}\n\tif (a._type !== b._type) {\n\t\treturn false;\n\t}\n\n\tswitch (a._type) {\n\t\tcase \"Unresolvable\":\n\t\t\treturn false; // Unresolvable is never equal to anything even itself\n\t\tcase \"Constant\":\n\t\tcase \"EmbeddedBinding\":\n\t\tcase \"EmbeddedExpressionBinding\":\n\t\t\treturn a.value === (b as ConstantExpression<T>).value;\n\n\t\tcase \"Not\":\n\t\t\treturn _checkExpressionsAreEqual(a.operand, (b as NotExpression).operand);\n\t\tcase \"Truthy\":\n\t\t\treturn _checkExpressionsAreEqual(a.operand, (b as TruthyExpression).operand);\n\t\tcase \"Set\":\n\t\t\treturn (\n\t\t\t\ta.operator === (b as SetExpression).operator &&\n\t\t\t\ta.operands.length === (b as SetExpression).operands.length &&\n\t\t\t\ta.operands.every((expression) =>\n\t\t\t\t\t(b as SetExpression).operands.some((otherExpression) => _checkExpressionsAreEqual(expression, otherExpression))\n\t\t\t\t)\n\t\t\t);\n\n\t\tcase \"IfElse\":\n\t\t\treturn (\n\t\t\t\t_checkExpressionsAreEqual(a.condition, (b as IfElseExpression<T>).condition) &&\n\t\t\t\t_checkExpressionsAreEqual(a.onTrue, (b as IfElseExpression<T>).onTrue) &&\n\t\t\t\t_checkExpressionsAreEqual(a.onFalse, (b as IfElseExpression<T>).onFalse)\n\t\t\t);\n\n\t\tcase \"Comparison\":\n\t\t\treturn (\n\t\t\t\ta.operator === (b as ComparisonExpression).operator &&\n\t\t\t\t_checkExpressionsAreEqual(a.operand1, (b as ComparisonExpression).operand1) &&\n\t\t\t\t_checkExpressionsAreEqual(a.operand2, (b as ComparisonExpression).operand2)\n\t\t\t);\n\n\t\tcase \"Concat\": {\n\t\t\tconst aExpressions = a.expressions;\n\t\t\tconst bExpressions = (b as ConcatExpression).expressions;\n\t\t\tif (aExpressions.length !== bExpressions.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn aExpressions.every((expression, index) => {\n\t\t\t\treturn _checkExpressionsAreEqual(expression, bExpressions[index]);\n\t\t\t});\n\t\t}\n\n\t\tcase \"Length\":\n\t\t\treturn _checkExpressionsAreEqual(a.pathInModel, (b as LengthExpression).pathInModel);\n\n\t\tcase \"PathInModel\":\n\t\t\treturn (\n\t\t\t\ta.modelName === (b as PathInModelExpression<T>).modelName &&\n\t\t\t\ta.path === (b as PathInModelExpression<T>).path &&\n\t\t\t\ta.targetEntitySet === (b as PathInModelExpression<T>).targetEntitySet\n\t\t\t);\n\n\t\tcase \"Formatter\":\n\t\t\treturn (\n\t\t\t\ta.fn === (b as FormatterExpression<T>).fn &&\n\t\t\t\ta.parameters.length === (b as FormatterExpression<T>).parameters.length &&\n\t\t\t\ta.parameters.every((value, index) => _checkExpressionsAreEqual((b as FormatterExpression<T>).parameters[index], value))\n\t\t\t);\n\t\tcase \"ComplexType\":\n\t\t\treturn (\n\t\t\t\ta.type === (b as ComplexTypeExpression<T>).type &&\n\t\t\t\ta.bindingParameters.length === (b as ComplexTypeExpression<T>).bindingParameters.length &&\n\t\t\t\ta.bindingParameters.every((value, index) =>\n\t\t\t\t\t_checkExpressionsAreEqual((b as ComplexTypeExpression<T>).bindingParameters[index], value)\n\t\t\t\t)\n\t\t\t);\n\t\tcase \"Function\":\n\t\t\tconst otherFunction = b as FunctionExpression<T>;\n\t\t\tif (a.obj === undefined || otherFunction.obj === undefined) {\n\t\t\t\treturn a.obj === otherFunction;\n\t\t\t}\n\n\t\t\treturn (\n\t\t\t\ta.fn === otherFunction.fn &&\n\t\t\t\t_checkExpressionsAreEqual(a.obj, otherFunction.obj) &&\n\t\t\t\ta.parameters.length === otherFunction.parameters.length &&\n\t\t\t\ta.parameters.every((value, index) => _checkExpressionsAreEqual(otherFunction.parameters[index], value))\n\t\t\t);\n\n\t\tcase \"Ref\":\n\t\t\treturn a.ref === (b as ReferenceExpression).ref;\n\t}\n\treturn false;\n}\n\n/**\n * Converts a nested SetExpression by inlining operands of type SetExpression with the same operator.\n *\n * @param expression The expression to flatten\n * @returns A new SetExpression with the same operator\n */\nfunction flattenSetExpression(expression: SetExpression): SetExpression {\n\treturn expression.operands.reduce<SetExpression>(\n\t\t(result: SetExpression, operand) => {\n\t\t\tconst candidatesForFlattening =\n\t\t\t\toperand._type === \"Set\" && operand.operator === expression.operator ? operand.operands : [operand];\n\t\t\tcandidatesForFlattening.forEach((candidate) => {\n\t\t\t\tif (result.operands.every((e) => !_checkExpressionsAreEqual(e, candidate))) {\n\t\t\t\t\tresult.operands.push(candidate);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn result;\n\t\t},\n\t\t{ _type: \"Set\", operator: expression.operator, operands: [] }\n\t);\n}\n\n/**\n * Detects whether an array of boolean expressions contains an expression and its negation.\n *\n * @param expressions Array of expressions\n * @returns `true` if the set of expressions contains an expression and its negation\n */\nfunction hasOppositeExpressions(expressions: Expression<boolean>[]): boolean {\n\tconst negatedExpressions = expressions.map(not);\n\treturn expressions.some((expression, index) => {\n\t\tfor (let i = index + 1; i < negatedExpressions.length; i++) {\n\t\t\tif (_checkExpressionsAreEqual(expression, negatedExpressions[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t});\n}\n\n/**\n * Logical `and` expression.\n *\n * The expression is simplified to false if this can be decided statically (that is, if one operand is a constant\n * false or if the expression contains an operand and its negation).\n *\n * @param operands Expressions to connect by `and`\n * @returns Expression evaluating to boolean\n */\nexport function and(...operands: ExpressionOrPrimitive<boolean>[]): Expression<boolean> {\n\tconst expressions = flattenSetExpression({\n\t\t_type: \"Set\",\n\t\toperator: \"&&\",\n\t\toperands: operands.map(wrapPrimitive)\n\t}).operands;\n\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet isStaticFalse = false;\n\tconst nonTrivialExpression = expressions.filter((expression) => {\n\t\tif (isFalse(expression)) {\n\t\t\tisStaticFalse = true;\n\t\t}\n\t\treturn !isConstant(expression);\n\t});\n\tif (isStaticFalse) {\n\t\treturn constant(false);\n\t} else if (nonTrivialExpression.length === 0) {\n\t\t// Resolve the constant then\n\t\tconst isValid = expressions.reduce((result, expression) => result && isTrue(expression), true);\n\t\treturn constant(isValid);\n\t} else if (nonTrivialExpression.length === 1) {\n\t\treturn nonTrivialExpression[0]!;\n\t} else if (hasOppositeExpressions(nonTrivialExpression)) {\n\t\treturn constant(false);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Set\",\n\t\t\toperator: \"&&\",\n\t\t\toperands: nonTrivialExpression\n\t\t};\n\t}\n}\n\n// let tracer: any;\n// export function traceExpression(inTracer: never): void {\n// \ttracer = inTracer;\n// }\n//\n// export function pickFirstNonNull(\n// \t...operands: ExpressionOrPrimitive<PrimitiveType>[]\n// ): ExpressionOrPrimitive<PrimitiveType> {\n// \tconst result = operands.find((operand) => operand !== undefined);\n// \tif (tracer) {\n// \t\ttracer.logConditional(\"pickFirstNonNull\", operands, result);\n// \t}\n// \treturn result;\n// }\n/**\n * Logical `or` expression.\n *\n * The expression is simplified to true if this can be decided statically (that is, if one operand is a constant\n * true or if the expression contains an operand and its negation).\n *\n * @param operands Expressions to connect by `or`\n * @returns Expression evaluating to boolean\n */\nexport function or(...operands: ExpressionOrPrimitive<boolean>[]): Expression<boolean> {\n\tconst expressions = flattenSetExpression({\n\t\t_type: \"Set\",\n\t\toperator: \"||\",\n\t\toperands: operands.map(wrapPrimitive)\n\t}).operands;\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet isStaticTrue = false;\n\tconst nonTrivialExpression = expressions.filter((expression) => {\n\t\tif (isTrue(expression)) {\n\t\t\tisStaticTrue = true;\n\t\t}\n\t\treturn !isConstant(expression) || expression.value;\n\t});\n\tif (isStaticTrue) {\n\t\treturn constant(true);\n\t} else if (nonTrivialExpression.length === 0) {\n\t\t// Resolve the constant then\n\t\tconst isValid = expressions.reduce((result, expression) => result && isTrue(expression), true);\n\t\treturn constant(isValid);\n\t} else if (nonTrivialExpression.length === 1) {\n\t\treturn nonTrivialExpression[0]!;\n\t} else if (hasOppositeExpressions(nonTrivialExpression)) {\n\t\treturn constant(true);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Set\",\n\t\t\toperator: \"||\",\n\t\t\toperands: nonTrivialExpression\n\t\t};\n\t}\n}\n\n/**\n * Logical `not` operator.\n *\n * @param operand The expression to reverse\n * @returns The resulting expression that evaluates to boolean\n */\nexport function not(operand: ExpressionOrPrimitive<boolean>): Expression<boolean> {\n\toperand = wrapPrimitive(operand);\n\tif (hasUnresolvableExpression(operand)) {\n\t\treturn unresolvableExpression;\n\t} else if (isConstant(operand)) {\n\t\treturn constant(!operand.value);\n\t} else if (\n\t\ttypeof operand === \"object\" &&\n\t\toperand._type === \"Set\" &&\n\t\toperand.operator === \"||\" &&\n\t\toperand.operands.every((expression) => isConstant(expression) || isComparison(expression))\n\t) {\n\t\treturn and(...operand.operands.map((expression) => not(expression)));\n\t} else if (\n\t\ttypeof operand === \"object\" &&\n\t\toperand._type === \"Set\" &&\n\t\toperand.operator === \"&&\" &&\n\t\toperand.operands.every((expression) => isConstant(expression) || isComparison(expression))\n\t) {\n\t\treturn or(...operand.operands.map((expression) => not(expression)));\n\t} else if (isComparison(operand)) {\n\t\t// Create the reverse comparison\n\t\tswitch (operand.operator) {\n\t\t\tcase \"!==\":\n\t\t\t\treturn { ...operand, operator: \"===\" };\n\t\t\tcase \"<\":\n\t\t\t\treturn { ...operand, operator: \">=\" };\n\t\t\tcase \"<=\":\n\t\t\t\treturn { ...operand, operator: \">\" };\n\t\t\tcase \"===\":\n\t\t\t\treturn { ...operand, operator: \"!==\" };\n\t\t\tcase \">\":\n\t\t\t\treturn { ...operand, operator: \"<=\" };\n\t\t\tcase \">=\":\n\t\t\t\treturn { ...operand, operator: \"<\" };\n\t\t}\n\t} else if (operand._type === \"Not\") {\n\t\treturn operand.operand;\n\t}\n\n\treturn {\n\t\t_type: \"Not\",\n\t\toperand: operand\n\t};\n}\n\n/**\n * Evaluates whether a binding expression is equal to true with a loose equality.\n *\n * @param operand The expression to check\n * @returns The resulting expression that evaluates to boolean\n */\nexport function isTruthy(operand: Expression<string>): Expression<boolean> {\n\tif (isConstant(operand)) {\n\t\treturn constant(!!operand.value);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Truthy\",\n\t\t\toperand: operand\n\t\t};\n\t}\n}\n\n/**\n * Creates a binding expression that will be evaluated by the corresponding model.\n *\n * @param path\n * @param modelName\n * @param visitedNavigationPaths\n * @param pathVisitor\n * @returns An expression representating that path in the model\n */\nexport function objectPath<TargetType extends PrimitiveType>(\n\tpath: string,\n\tmodelName?: string,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): PathInModelExpression<TargetType> | UnresolvablePathExpression {\n\treturn pathInModel(path, modelName, visitedNavigationPaths, pathVisitor);\n}\n\n/**\n * Creates a binding expression that will be evaluated by the corresponding model.\n *\n * @template TargetType\n * @param path The path on the model\n * @param [modelName] The name of the model\n * @param [visitedNavigationPaths] The paths from the root entitySet\n * @param [pathVisitor] A function to modify the resulting path\n * @returns An expression representating that path in the model\n */\nexport function pathInModel(\n\tpath: undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: Function\n): UnresolvablePathExpression;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: undefined\n): PathInModelExpression<TargetType>;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string | undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: Function\n): UnresolvablePathExpression | PathInModelExpression<TargetType>;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string | undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): UnresolvablePathExpression | PathInModelExpression<TargetType> {\n\tif (path === undefined) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet targetPath: string;\n\tif (pathVisitor) {\n\t\ttargetPath = pathVisitor(path) as string;\n\t\tif (targetPath === undefined) {\n\t\t\treturn unresolvableExpression;\n\t\t}\n\t} else {\n\t\tconst localPath = visitedNavigationPaths.concat();\n\t\tlocalPath.push(path);\n\t\ttargetPath = localPath.join(\"/\");\n\t}\n\treturn {\n\t\t_type: \"PathInModel\",\n\t\tmodelName: modelName,\n\t\tpath: targetPath,\n\t\townPath: path\n\t};\n}\n\ntype PlainExpressionObject = { [index: string]: Expression<unknown> };\n\n/**\n * Creates a constant expression based on a primitive value.\n *\n * @template T\n * @param value The constant to wrap in an expression\n * @returns The constant expression\n */\nexport function constant<T extends PrimitiveType>(value: T): ConstantExpression<T> {\n\tlet constantValue: T;\n\n\tif (typeof value === \"object\" && value !== null && value !== undefined) {\n\t\tif (Array.isArray(value)) {\n\t\t\tconstantValue = value.map(wrapPrimitive) as T;\n\t\t} else if (isPrimitiveObject(value)) {\n\t\t\tconstantValue = value.valueOf() as T;\n\t\t} else {\n\t\t\tconstantValue = Object.entries(value).reduce((plainExpression, [key, val]) => {\n\t\t\t\tconst wrappedValue = wrapPrimitive(val);\n\t\t\t\tif (wrappedValue._type !== \"Constant\" || wrappedValue.value !== undefined) {\n\t\t\t\t\tplainExpression[key as keyof typeof plainExpression] = wrappedValue as never;\n\t\t\t\t}\n\t\t\t\treturn plainExpression;\n\t\t\t}, {} satisfies PlainExpressionObject) as T;\n\t\t}\n\t} else {\n\t\tconstantValue = value;\n\t}\n\n\treturn { _type: \"Constant\", value: constantValue };\n}\n\nexport function resolveBindingString<T extends PrimitiveType>(\n\tvalue: string | boolean | number,\n\ttargetType?: string\n): ConstantExpression<T> | PathInModelExpression<T> | EmbeddedUI5BindingExpression<T> | EmbeddedUI5ExpressionBindingExpression<T> {\n\tif (value !== undefined && typeof value === \"string\" && value.startsWith(\"{\")) {\n\t\tconst pathInModelRegex = /^{(.*)>(.+)}$/; // Matches model paths like \"model>path\" or \">path\" (default model)\n\t\tconst pathInModelRegexMatch = pathInModelRegex.exec(value);\n\n\t\tif (value.startsWith(\"{=\")) {\n\t\t\t// Expression binding, we can just remove the outer binding things\n\t\t\treturn {\n\t\t\t\t_type: \"EmbeddedExpressionBinding\",\n\t\t\t\tvalue: value\n\t\t\t};\n\t\t} else if (pathInModelRegexMatch) {\n\t\t\treturn pathInModel(pathInModelRegexMatch[2] || \"\", pathInModelRegexMatch[1] || undefined);\n\t\t} else {\n\t\t\treturn {\n\t\t\t\t_type: \"EmbeddedBinding\",\n\t\t\t\tvalue: value\n\t\t\t};\n\t\t}\n\t} else if (targetType === \"boolean\" && typeof value === \"string\" && (value === \"true\" || value === \"false\")) {\n\t\treturn constant(value === \"true\") as ConstantExpression<T>;\n\t} else if (targetType === \"number\" && typeof value === \"string\" && (!isNaN(Number(value)) || value === \"NaN\")) {\n\t\treturn constant(Number(value)) as ConstantExpression<T>;\n\t} else {\n\t\treturn constant(value) as ConstantExpression<T>;\n\t}\n}\n\n/**\n * A named reference.\n *\n * @see fn\n * @param reference Reference\n * @returns The object reference binding part\n */\nexport function ref(reference: string | null): ReferenceExpression {\n\treturn { _type: \"Ref\", ref: reference };\n}\n\n/**\n * Wrap a primitive into a constant expression if it is not already an expression.\n *\n * @template T\n * @param something The object to wrap in a Constant expression\n * @returns Either the original object or the wrapped one depending on the case\n */\nexport function wrapPrimitive<T extends PrimitiveType>(something: ExpressionOrPrimitive<T>): Expression<T> {\n\tif (isExpression(something as Expression<T>)) {\n\t\treturn something as Expression<T>;\n\t}\n\n\treturn constant(something as T);\n}\n\n/**\n * Checks if the expression or value provided is a binding tooling expression or not.\n *\n * Every object having a property named `_type` of some value is considered an expression, even if there is actually\n * no such expression type supported.\n *\n * @param expression\n * @returns `true` if the expression is a binding toolkit expression\n */\nexport function isExpression<T = unknown>(expression: unknown): expression is Expression<T> {\n\treturn (expression as Expression<T> | undefined)?._type !== undefined;\n}\n\n/**\n * Checks if the expression or value provided is constant or not.\n *\n * @template T The target type\n * @param  maybeConstant The expression or primitive value that is to be checked\n * @returns `true` if it is constant\n */\nexport function isConstant<T extends PrimitiveType>(maybeConstant: ExpressionOrPrimitive<T>): maybeConstant is ConstantExpression<T> {\n\treturn typeof maybeConstant !== \"object\" || (maybeConstant as BaseExpression<T>)._type === \"Constant\";\n}\n\nfunction isTrue(expression: Expression<PrimitiveType>): boolean {\n\treturn isConstant(expression) && expression.value === true;\n}\n\nfunction isFalse(expression: Expression<PrimitiveType>): boolean {\n\treturn isConstant(expression) && expression.value === false;\n}\n\n/**\n * Checks if the expression or value provided is a path in model expression or not.\n *\n * @template T The target type\n * @param  maybeBinding The expression or primitive value that is to be checked\n * @returns `true` if it is a path in model expression\n */\nexport function isPathInModelExpression<T extends PrimitiveType>(\n\tmaybeBinding: ExpressionOrPrimitive<T>\n): maybeBinding is PathInModelExpression<T> {\n\treturn (maybeBinding as BaseExpression<T>)._type === \"PathInModel\";\n}\n\n/**\n * Checks if the expression or value provided is a complex type expression.\n *\n * @template T The target type\n * @param  maybeBinding The expression or primitive value that is to be checked\n * @returns `true` if it is a path in model expression\n */\nexport function isComplexTypeExpression<T extends PrimitiveType>(\n\tmaybeBinding: ExpressionOrPrimitive<T>\n): maybeBinding is ComplexTypeExpression<T> {\n\treturn (maybeBinding as BaseExpression<T>)._type === \"ComplexType\";\n}\n\n/**\n * Checks if the expression or value provided is a concat expression or not.\n *\n * @param expression\n * @returns `true` if the expression is a ConcatExpression\n */\nfunction isConcatExpression(expression: Expression<PrimitiveType>): expression is ConcatExpression {\n\treturn (expression as BaseExpression<PrimitiveType>)._type === \"Concat\";\n}\n\n/**\n * Checks if the expression or value provided is a IfElse expression or not.\n *\n * @param expression\n * @returns `true` if the expression is a IfElseExpression\n */\nfunction isIfElseExpression(expression: Expression<PrimitiveType>): expression is ConcatExpression {\n\treturn (expression as BaseExpression<PrimitiveType>)._type === \"IfElse\";\n}\n\n/**\n * Checks if the expression provided is a comparison or not.\n *\n * @template T The target type\n * @param expression The expression\n * @returns `true` if the expression is a ComparisonExpression\n */\nfunction isComparison<T extends PrimitiveType>(expression: Expression<T>): expression is ComparisonExpression {\n\treturn expression._type === \"Comparison\";\n}\n\n/**\n * Checks whether the input parameter is a constant expression of type undefined.\n *\n * @param expression The input expression or object in general\n * @returns `true` if the input is constant which has undefined for value\n */\nexport function isUndefinedExpression(expression: unknown): expression is ConstantExpression<undefined> {\n\tconst expressionAsExpression = expression as Expression<unknown>;\n\treturn expressionAsExpression._type === \"Constant\" && expressionAsExpression.value === undefined;\n}\n\ntype ComplexAnnotationExpression<P> =\n\t| PathAnnotationExpression<P>\n\t| ApplyAnnotationExpression<P>\n\t| IfAnnotationExpression<P>\n\t| OrAnnotationExpression<P>\n\t| AndAnnotationExpression<P>\n\t| NeAnnotationExpression<P>\n\t| EqAnnotationExpression<P>\n\t| NotAnnotationExpression<P>\n\t| GtAnnotationExpression<P>\n\t| GeAnnotationExpression<P>\n\t| LeAnnotationExpression<P>\n\t| LtAnnotationExpression<P>\n\t| VocabularyConstantExpression<P>;\n\nfunction isPrimitiveObject(objectType: object): boolean {\n\tswitch (objectType.constructor.name) {\n\t\tcase \"String\":\n\t\tcase \"Number\":\n\t\tcase \"Boolean\":\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n/**\n * Check if the passed annotation annotationValue is a ComplexAnnotationExpression.\n *\n * @template T The target type\n * @param  annotationValue The annotation annotationValue to evaluate\n * @returns `true` if the object is a {ComplexAnnotationExpression}\n */\nfunction isComplexAnnotationExpression<T>(annotationValue: PropertyAnnotationValue<T>): annotationValue is ComplexAnnotationExpression<T> {\n\treturn typeof annotationValue === \"object\" && !isPrimitiveObject(annotationValue as object);\n}\n\n/**\n * Generate the corresponding annotationValue for a given annotation annotationValue.\n *\n * @template T The target type\n * @param annotationValue The source annotation annotationValue\n * @param visitedNavigationPaths The path from the root entity set\n * @param defaultValue Default value if the annotationValue is undefined\n * @param pathVisitor A function to modify the resulting path\n * @returns The annotationValue equivalent to that annotation annotationValue\n */\nexport function getExpressionFromAnnotation<T extends PrimitiveType>(\n\tannotationValue: PropertyAnnotationValue<T> | undefined,\n\tvisitedNavigationPaths: string[] = [],\n\tdefaultValue?: ExpressionOrPrimitive<T>,\n\tpathVisitor?: Function\n): Expression<PrimitiveTypeCast<T>> {\n\tif (annotationValue === undefined) {\n\t\treturn wrapPrimitive(defaultValue as PrimitiveTypeCast<T>);\n\t}\n\tannotationValue = annotationValue.valueOf() as PropertyAnnotationValue<T>;\n\tif (!isComplexAnnotationExpression(annotationValue)) {\n\t\treturn constant(annotationValue);\n\t}\n\n\tswitch (annotationValue.type) {\n\t\tcase \"Path\":\n\t\t\treturn pathInModel(annotationValue.path, undefined, visitedNavigationPaths, pathVisitor);\n\t\tcase \"If\":\n\t\t\treturn annotationIfExpression(annotationValue.$If, visitedNavigationPaths, pathVisitor) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Not\":\n\t\t\treturn not(parseAnnotationCondition(annotationValue.$Not, visitedNavigationPaths, pathVisitor)) as Expression<\n\t\t\t\tPrimitiveTypeCast<T>\n\t\t\t>;\n\t\tcase \"Eq\":\n\t\t\treturn equal(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Eq[0]!, visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Eq[1]!, visitedNavigationPaths, pathVisitor)\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Ne\":\n\t\t\treturn notEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ne[0]!, visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ne[1]!, visitedNavigationPaths, pathVisitor)\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Gt\":\n\t\t\treturn greaterThan(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Gt[0]!, visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Gt[1]!, visitedNavigationPaths, pathVisitor)\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Ge\":\n\t\t\treturn greaterOrEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ge[0]!, visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ge[1]!, visitedNavigationPaths, pathVisitor)\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Lt\":\n\t\t\treturn lessThan(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Lt[0]!, visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Lt[1]!, visitedNavigationPaths, pathVisitor)\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Le\":\n\t\t\treturn lessOrEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Le[0]!, visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Le[1]!, visitedNavigationPaths, pathVisitor)\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Or\":\n\t\t\treturn or(\n\t\t\t\t...annotationValue.$Or.map(function (orCondition) {\n\t\t\t\t\treturn parseAnnotationCondition<boolean>(orCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t\t})\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"And\":\n\t\t\treturn and(\n\t\t\t\t...annotationValue.$And.map(function (andCondition) {\n\t\t\t\t\treturn parseAnnotationCondition<boolean>(andCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t\t})\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Apply\":\n\t\t\treturn annotationApplyExpression(\n\t\t\t\tannotationValue as ApplyAnnotationExpression<string>,\n\t\t\t\tvisitedNavigationPaths,\n\t\t\t\tpathVisitor\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Constant\":\n\t\t\treturn constant(annotationValue.value as PrimitiveTypeCast<T>);\n\t}\n\treturn unresolvableExpression;\n}\n\n/**\n * Parse the annotation condition into an expression.\n *\n * @template T The target type\n * @param annotationValue The condition or value from the annotation\n * @param visitedNavigationPaths The path from the root entity set\n * @param pathVisitor A function to modify the resulting path\n * @returns An equivalent expression\n */\nfunction parseAnnotationCondition<T extends PrimitiveType>(\n\tannotationValue: ConditionalCheckOrValue,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): Expression<T> {\n\tif (annotationValue === null || typeof annotationValue !== \"object\") {\n\t\treturn constant(annotationValue as T);\n\t} else if (annotationValue.hasOwnProperty(\"$Or\")) {\n\t\treturn or(\n\t\t\t...((annotationValue as OrConditionalExpression).$Or.map(function (orCondition) {\n\t\t\t\treturn parseAnnotationCondition(orCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t}) as unknown as Expression<boolean>[])\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$And\")) {\n\t\treturn and(\n\t\t\t...((annotationValue as AndConditionalExpression).$And.map(function (andCondition) {\n\t\t\t\treturn parseAnnotationCondition(andCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t}) as unknown as Expression<boolean>[])\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Not\")) {\n\t\treturn not(\n\t\t\tparseAnnotationCondition((annotationValue as NotConditionalExpression).$Not, visitedNavigationPaths, pathVisitor)\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Eq\")) {\n\t\treturn equal(\n\t\t\tparseAnnotationCondition((annotationValue as EqConditionalExpression).$Eq[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as EqConditionalExpression).$Eq[1], visitedNavigationPaths, pathVisitor)\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Ne\")) {\n\t\treturn notEqual(\n\t\t\tparseAnnotationCondition((annotationValue as NeConditionalExpression).$Ne[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as NeConditionalExpression).$Ne[1], visitedNavigationPaths, pathVisitor)\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Gt\")) {\n\t\treturn greaterThan(\n\t\t\tparseAnnotationCondition((annotationValue as GtConditionalExpression).$Gt[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as GtConditionalExpression).$Gt[1], visitedNavigationPaths, pathVisitor)\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Ge\")) {\n\t\treturn greaterOrEqual(\n\t\t\tparseAnnotationCondition((annotationValue as GeConditionalExpression).$Ge[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as GeConditionalExpression).$Ge[1], visitedNavigationPaths, pathVisitor)\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Lt\")) {\n\t\treturn lessThan(\n\t\t\tparseAnnotationCondition((annotationValue as LtConditionalExpression).$Lt[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as LtConditionalExpression).$Lt[1], visitedNavigationPaths, pathVisitor)\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Le\")) {\n\t\treturn lessOrEqual(\n\t\t\tparseAnnotationCondition((annotationValue as LeConditionalExpression).$Le[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as LeConditionalExpression).$Le[1], visitedNavigationPaths, pathVisitor)\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Path\")) {\n\t\treturn pathInModel((annotationValue as PathConditionExpression<T>).$Path, undefined, visitedNavigationPaths, pathVisitor);\n\t} else if (annotationValue.hasOwnProperty(\"Path\")) {\n\t\treturn pathInModel((annotationValue as unknown as { Path: string }).Path, undefined, visitedNavigationPaths, pathVisitor);\n\t} else if (annotationValue.hasOwnProperty(\"$Apply\")) {\n\t\treturn getExpressionFromAnnotation(\n\t\t\t{\n\t\t\t\ttype: \"Apply\",\n\t\t\t\t$Function: (annotationValue as { $Function?: string }).$Function as \"odata.concat\",\n\t\t\t\t$Apply: (annotationValue as { $Apply?: PropertyAnnotationValue<T>[] }).$Apply!\n\t\t\t} satisfies ApplyAnnotationExpression<T>,\n\t\t\tvisitedNavigationPaths,\n\t\t\tundefined,\n\t\t\tpathVisitor\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$If\")) {\n\t\treturn getExpressionFromAnnotation(\n\t\t\t{\n\t\t\t\ttype: \"If\",\n\t\t\t\t$If: (annotationValue as { $If?: IfAnnotationExpressionValue<T> }).$If!\n\t\t\t} satisfies IfAnnotationExpression<T>,\n\t\t\tvisitedNavigationPaths,\n\t\t\tundefined,\n\t\t\tpathVisitor\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$EnumMember\")) {\n\t\treturn constant((annotationValue as { $EnumMember?: string }).$EnumMember as T);\n\t} else if (annotationValue.hasOwnProperty(\"String\")) {\n\t\treturn constant((annotationValue as unknown as { String: string }).String) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"Bool\")) {\n\t\treturn constant((annotationValue as unknown as { Bool: boolean }).Bool) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"Int\")) {\n\t\treturn constant((annotationValue as unknown as { Int: number }).Int) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"Decimal\")) {\n\t\treturn constant((annotationValue as unknown as { Decimal: number }).Decimal) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"type\") && (annotationValue as unknown as { type: string }).type === \"Null\") {\n\t\treturn constant(null) as Expression<T>;\n\t}\n\treturn constant(false as T);\n}\n\n/**\n * Process the {IfAnnotationExpressionValue} into an expression.\n *\n * @template T The target type\n * @param annotationValue An If expression returning the type T\n * @param visitedNavigationPaths The path from the root entity set\n * @param pathVisitor A function to modify the resulting path\n * @returns The equivalent ifElse expression\n */\nexport function annotationIfExpression<T extends PrimitiveType>(\n\tannotationValue: IfAnnotationExpressionValue<T>,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): Expression<T> {\n\treturn ifElse(\n\t\tparseAnnotationCondition(annotationValue[0], visitedNavigationPaths, pathVisitor),\n\t\tparseAnnotationCondition(annotationValue[1] as ConditionalCheckOrValue, visitedNavigationPaths, pathVisitor),\n\t\tparseAnnotationCondition(annotationValue[2] as ConditionalCheckOrValue, visitedNavigationPaths, pathVisitor)\n\t);\n}\n// This type is not recursively transformed from the metamodel content, as such we have some ugly things there\ntype SubApplyExpressionFromMetamodel = Record<string, unknown>;\nfunction convertSubApplyParameters(applyParam: SubApplyExpressionFromMetamodel): SubApplyExpressionFromMetamodel {\n\tlet applyParamConverted = applyParam;\n\tif (applyParam.hasOwnProperty(\"$Path\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"Path\",\n\t\t\tpath: applyParam.$Path as string\n\t\t} satisfies Partial<PathAnnotationExpression<string>>;\n\t} else if (applyParam.hasOwnProperty(\"$If\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"If\",\n\t\t\t$If: applyParam.$If as IfAnnotationExpressionValue<string>\n\t\t} satisfies IfAnnotationExpression<string>;\n\t} else if (applyParam.hasOwnProperty(\"$Apply\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"Apply\",\n\t\t\t$Function: applyParam.$Function as \"odata.concat\",\n\t\t\t$Apply: applyParam.$Apply as PropertyAnnotationValue<string>[]\n\t\t} satisfies ApplyAnnotationExpression<string>;\n\t}\n\treturn applyParamConverted;\n}\n\ntype ODataFunction = \"odata.concat\" | \"odata.fillUriTemplate\" | \"odata.uriEncode\";\nexport function annotationApplyExpression(\n\tapplyExpression: ApplyAnnotationExpression<string>,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): Expression<string> {\n\tswitch (applyExpression.$Function as ODataFunction) {\n\t\tcase \"odata.concat\":\n\t\t\treturn concat(\n\t\t\t\t...applyExpression.$Apply.map((applyParam) => {\n\t\t\t\t\treturn getExpressionFromAnnotation(\n\t\t\t\t\t\tconvertSubApplyParameters(applyParam) as PropertyAnnotationValue<string>,\n\t\t\t\t\t\tvisitedNavigationPaths,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tpathVisitor\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\tcase \"odata.uriEncode\":\n\t\t\tconst parameter = getExpressionFromAnnotation(\n\t\t\t\tconvertSubApplyParameters(\n\t\t\t\t\tapplyExpression.$Apply[0] as unknown as SubApplyExpressionFromMetamodel\n\t\t\t\t) as PropertyAnnotationValue<string>,\n\t\t\t\tvisitedNavigationPaths,\n\t\t\t\tundefined,\n\t\t\t\tpathVisitor\n\t\t\t);\n\t\t\t// The second parameter for uriEncode is always a string since the target evaluation is against a formatValue call in ODataUtils which expect the target type as second parameter\n\t\t\treturn fn(\"odata.uriEncode\", [parameter, \"Edm.String\"], undefined, true);\n\t\tcase \"odata.fillUriTemplate\":\n\t\t\tconst template = applyExpression.$Apply[0];\n\t\t\tconst templateParams = applyExpression.$Apply.slice(1) as unknown as SubApplyExpressionFromMetamodel[];\n\t\t\tconst targetObject: Record<string, Expression<unknown>> = {};\n\t\t\ttemplateParams.forEach((applyParam) => {\n\t\t\t\ttargetObject[applyParam.$Name as string] = getExpressionFromAnnotation(\n\t\t\t\t\tconvertSubApplyParameters(\n\t\t\t\t\t\tapplyParam.$LabeledElement as SubApplyExpressionFromMetamodel\n\t\t\t\t\t) as PropertyAnnotationValue<string>,\n\t\t\t\t\tvisitedNavigationPaths,\n\t\t\t\t\tundefined,\n\t\t\t\t\tpathVisitor\n\t\t\t\t);\n\t\t\t});\n\t\t\treturn fn(\"odata.fillUriTemplate\", [template, targetObject], undefined, true);\n\t}\n\treturn unresolvableExpression;\n}\n\n/**\n * Generic helper for the comparison operations (equal, notEqual, ...).\n *\n * @template T The target type\n * @param operator The operator to apply\n * @param leftOperand The operand on the left side of the operator\n * @param rightOperand The operand on the right side of the operator\n * @returns An expression representing the comparison\n */\nfunction comparison<T extends PrimitiveType>(\n\toperator: ComparisonOperator,\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): Expression<boolean> {\n\tconst leftExpression = wrapPrimitive(leftOperand);\n\tconst rightExpression = wrapPrimitive(rightOperand);\n\tif (hasUnresolvableExpression(leftExpression, rightExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (isConstant(leftExpression) && isConstant(rightExpression)) {\n\t\tswitch (operator) {\n\t\t\tcase \"!==\":\n\t\t\t\treturn constant(leftExpression.value !== rightExpression.value);\n\t\t\tcase \"===\":\n\t\t\t\treturn constant(leftExpression.value === rightExpression.value);\n\t\t\tcase \"<\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value < rightExpression.value);\n\t\t\tcase \"<=\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value <= rightExpression.value);\n\t\t\tcase \">\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value > rightExpression.value);\n\t\t\tcase \">=\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value >= rightExpression.value);\n\t\t}\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Comparison\",\n\t\t\toperator: operator,\n\t\t\toperand1: leftExpression,\n\t\t\toperand2: rightExpression\n\t\t};\n\t}\n}\n\n/**\n * Generic helper for the length of an expression.\n *\n * @param expression The input expression pointing to an array\n * @param checkUndefined Is the array potentially undefined\n * @returns An expression representing the length\n */\nexport function length(\n\texpression: PathInModelExpression<unknown> | UnresolvablePathExpression,\n\tcheckUndefined = false\n): Expression<number> {\n\tif (expression._type === \"Unresolvable\") {\n\t\treturn expression;\n\t}\n\tif (!checkUndefined) {\n\t\treturn {\n\t\t\t_type: \"Length\",\n\t\t\tpathInModel: expression\n\t\t};\n\t}\n\treturn ifElse(equal(expression, undefined), -1, length(expression));\n}\n\n/**\n * Comparison: \"equal\" (===).\n *\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function equal<T extends PrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): Expression<boolean> {\n\tconst leftExpression = wrapPrimitive(leftOperand);\n\tconst rightExpression = wrapPrimitive(rightOperand);\n\tif (hasUnresolvableExpression(leftExpression, rightExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (_checkExpressionsAreEqual(leftExpression, rightExpression)) {\n\t\treturn constant(true);\n\t}\n\n\tfunction reduce(left: Expression<T>, right: Expression<T>): Expression<boolean> | undefined {\n\t\tif (left._type === \"Comparison\" && isTrue(right)) {\n\t\t\t// compare(a, b) === true ~~> compare(a, b)\n\t\t\treturn left;\n\t\t} else if (left._type === \"Comparison\" && isFalse(right)) {\n\t\t\t// compare(a, b) === false ~~> !compare(a, b)\n\t\t\treturn not(left);\n\t\t} else if (left._type === \"IfElse\" && _checkExpressionsAreEqual(left.onTrue, right)) {\n\t\t\t// (if (x) { a } else { b }) === a ~~> x || (b === a)\n\t\t\treturn or(left.condition, equal(left.onFalse, right));\n\t\t} else if (left._type === \"IfElse\" && _checkExpressionsAreEqual(left.onFalse, right)) {\n\t\t\t// (if (x) { a } else { b }) === b ~~> !x || (a === b)\n\t\t\treturn or(not(left.condition), equal(left.onTrue, right));\n\t\t} else if (\n\t\t\tleft._type === \"IfElse\" &&\n\t\t\tisConstant(left.onTrue) &&\n\t\t\tisConstant(left.onFalse) &&\n\t\t\tisConstant(right) &&\n\t\t\t!_checkExpressionsAreEqual(left.onTrue, right) &&\n\t\t\t!_checkExpressionsAreEqual(left.onFalse, right)\n\t\t) {\n\t\t\treturn constant(false);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t// exploit symmetry: a === b <~> b === a\n\tconst reduced = reduce(leftExpression, rightExpression) ?? reduce(rightExpression, leftExpression);\n\treturn reduced ?? comparison(\"===\", leftExpression, rightExpression);\n}\n\n/**\n * Comparison: \"not equal\" (!==).\n *\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function notEqual<T extends PrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): Expression<boolean> {\n\treturn not(equal(leftOperand, rightOperand));\n}\n\n/**\n * Comparison: \"greater or equal\" (>=).\n *\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function greaterOrEqual<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): Expression<boolean> {\n\treturn comparison(\">=\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"greater than\" (>).\n *\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function greaterThan<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): Expression<boolean> {\n\treturn comparison(\">\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"less or equal\" (<=).\n *\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function lessOrEqual<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): Expression<boolean> {\n\treturn comparison(\"<=\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"less than\" (<).\n *\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function lessThan<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): Expression<boolean> {\n\treturn comparison(\"<\", leftOperand, rightOperand);\n}\n\n/**\n * If-then-else expression.\n *\n * Evaluates to onTrue if the condition evaluates to true, else evaluates to onFalse.\n *\n * @template T The target type\n * @param condition The condition to evaluate\n * @param onTrue Expression result if the condition evaluates to true\n * @param onFalse Expression result if the condition evaluates to false\n * @returns The expression that represents this conditional check\n */\nexport function ifElse<T extends PrimitiveType>(\n\tcondition: ExpressionOrPrimitive<boolean>,\n\tonTrue: ExpressionOrPrimitive<T>,\n\tonFalse: ExpressionOrPrimitive<T>\n): Expression<T> {\n\tlet conditionExpression = wrapPrimitive(condition);\n\tlet onTrueExpression = wrapPrimitive(onTrue);\n\tlet onFalseExpression = wrapPrimitive(onFalse);\n\n\t// swap branches if the condition is a negation\n\tif (conditionExpression._type === \"Not\") {\n\t\t// ifElse(not(X), a, b) --> ifElse(X, b, a)\n\t\t[onTrueExpression, onFalseExpression] = [onFalseExpression, onTrueExpression];\n\t\tconditionExpression = not(conditionExpression);\n\t}\n\n\t// inline nested if-else expressions: onTrue branch\n\t// ifElse(X, ifElse(X, a, b), c) ==> ifElse(X, a, c)\n\tif (onTrueExpression._type === \"IfElse\" && _checkExpressionsAreEqual(conditionExpression, onTrueExpression.condition)) {\n\t\tonTrueExpression = onTrueExpression.onTrue;\n\t}\n\n\t// inline nested if-else expressions: onFalse branch\n\t// ifElse(X, a, ifElse(X, b, c)) ==> ifElse(X, a, c)\n\tif (onFalseExpression._type === \"IfElse\" && _checkExpressionsAreEqual(conditionExpression, onFalseExpression.condition)) {\n\t\tonFalseExpression = onFalseExpression.onFalse;\n\t}\n\n\t// (if true then a else b)  ~~> a\n\t// (if false then a else b) ~~> b\n\tif (isConstant(conditionExpression)) {\n\t\treturn conditionExpression.value ? onTrueExpression : onFalseExpression;\n\t}\n\n\t// if (isConstantBoolean(onTrueExpression) || isConstantBoolean(onFalseExpression)) {\n\t// \treturn or(and(condition, onTrueExpression as Expression<boolean>), and(not(condition), onFalseExpression as Expression<boolean>)) as Expression<T>\n\t// }\n\n\t// (if X then a else a) ~~> a\n\tif (_checkExpressionsAreEqual(onTrueExpression, onFalseExpression)) {\n\t\treturn onTrueExpression;\n\t}\n\n\t// if X then a else false ~~> X && a\n\tif (isFalse(onFalseExpression)) {\n\t\treturn and(conditionExpression, onTrueExpression as Expression<boolean>) as Expression<T>;\n\t}\n\n\t// if X then a else true ~~> !X || a\n\tif (isTrue(onFalseExpression)) {\n\t\treturn or(not(conditionExpression), onTrueExpression as Expression<boolean>) as Expression<T>;\n\t}\n\n\t// if X then false else a ~~> !X && a\n\tif (isFalse(onTrueExpression)) {\n\t\treturn and(not(conditionExpression), onFalseExpression as Expression<boolean>) as Expression<T>;\n\t}\n\n\t// if X then true else a ~~> X || a\n\tif (isTrue(onTrueExpression)) {\n\t\treturn or(conditionExpression, onFalseExpression as Expression<boolean>) as Expression<T>;\n\t}\n\tif (hasUnresolvableExpression(conditionExpression, onTrueExpression, onFalseExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (isComplexTypeExpression(condition) || isComplexTypeExpression(onTrue) || isComplexTypeExpression(onFalse)) {\n\t\tlet pathIdx = 0;\n\t\tconst myIfElseExpression = formatResult([condition, onTrue, onFalse], \"sap.fe.core.formatters.StandardFormatter#ifElse\");\n\t\tconst allParts = [];\n\t\ttransformRecursively(\n\t\t\tmyIfElseExpression as Expression<PrimitiveType>,\n\t\t\t\"PathInModel\",\n\t\t\t(constantPath: PathInModelExpression<unknown>) => {\n\t\t\t\tallParts.push(constantPath);\n\t\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t\t},\n\t\t\ttrue\n\t\t);\n\t\tallParts.unshift(constant(JSON.stringify(myIfElseExpression)));\n\t\treturn formatResult(allParts, \"sap.fe.core.formatters.StandardFormatter#evaluateComplexExpression\", undefined, true);\n\t}\n\treturn {\n\t\t_type: \"IfElse\",\n\t\tcondition: conditionExpression,\n\t\tonTrue: onTrueExpression,\n\t\tonFalse: onFalseExpression\n\t};\n}\n\n/**\n * Checks whether the current expression has a reference to the default model (undefined).\n *\n * @param expression The expression to evaluate\n * @returns `true` if there is a reference to the default context\n */\nfunction hasReferenceToDefaultContext(expression: Expression<unknown>): boolean {\n\tswitch (expression._type) {\n\t\tcase \"Constant\":\n\t\tcase \"Formatter\":\n\t\tcase \"ComplexType\":\n\t\t\treturn false;\n\t\tcase \"Set\":\n\t\t\treturn expression.operands.some(hasReferenceToDefaultContext);\n\t\tcase \"PathInModel\":\n\t\t\treturn expression.modelName === undefined;\n\t\tcase \"Comparison\":\n\t\t\treturn hasReferenceToDefaultContext(expression.operand1) || hasReferenceToDefaultContext(expression.operand2);\n\t\tcase \"IfElse\":\n\t\t\treturn (\n\t\t\t\thasReferenceToDefaultContext(expression.condition) ||\n\t\t\t\thasReferenceToDefaultContext(expression.onTrue) ||\n\t\t\t\thasReferenceToDefaultContext(expression.onFalse)\n\t\t\t);\n\t\tcase \"Not\":\n\t\tcase \"Truthy\":\n\t\t\treturn hasReferenceToDefaultContext(expression.operand);\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n// This is one case where any does make sense...\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Fn<T> = ((...params: any) => T | Promise<T>) & {\n\t__functionName: string;\n};\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\ntype WrappedTuple<T> = {\n\t[K in keyof T]:\n\t\t| WrappedTuple<T[K]>\n\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t// @ts-ignore\n\t\t| ExpressionOrPrimitive<T[K]>\n\t\t| undefined;\n};\n\n// So, this works but I cannot get it to compile :D, but it still does what is expected...\n\n/**\n * A function reference or a function name.\n */\ntype FunctionOrName<T> = Fn<T> | string;\n\n/**\n * Function parameters, either derived from the function or an untyped array.\n */\ntype FunctionParameters<T, F extends FunctionOrName<T>> = F extends Fn<T> ? Parameters<F> : unknown[];\n\n/**\n * Calls a formatter function to process the parameters.\n * If requireContext is set to true and no context is passed a default context will be added automatically.\n *\n * @template T\n * @template U\n * @param parameters The list of parameter that should match the type and number of the formatter function\n * @param formatterFunction The function to call\n * @param [contextEntityType] If no parameter refers to the context then we use this information to add a reference to the keys from the entity type.\n * @param [ignoreComplexType] Whether to ignore the transgformation to the StandardFormatter or not\n * @returns The corresponding expression\n */\nexport function formatResult<T, U extends Fn<T>>(\n\tparameters: WrappedTuple<Parameters<U>>,\n\tformatterFunction: U | string,\n\tcontextEntityType?: EntityType,\n\tignoreComplexType = false\n): Expression<T> {\n\tconst parameterExpressions = (parameters as ExpressionOrPrimitive<PrimitiveType>[]).map(wrapPrimitive);\n\n\tif (hasUnresolvableExpression(...parameterExpressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (contextEntityType) {\n\t\t// Otherwise, if the context is required and no context is provided make sure to add the default binding\n\t\tif (!parameterExpressions.some(hasReferenceToDefaultContext)) {\n\t\t\tcontextEntityType.keys.forEach((key) => parameterExpressions.push(pathInModel(key.name, \"\")));\n\t\t}\n\t}\n\tlet functionName = \"\";\n\tif (typeof formatterFunction === \"string\") {\n\t\tfunctionName = formatterFunction;\n\t} else {\n\t\tfunctionName = formatterFunction.__functionName;\n\t}\n\t// FormatterName can be of format sap.fe.core.xxx#methodName to have multiple formatter in one class\n\tconst [formatterClass, formatterName] = functionName.split(\"#\");\n\n\t// In some case we also cannot call directly a function because of too complex input, in that case we need to convert to a simpler function call\n\tif (\n\t\t!ignoreComplexType &&\n\t\t(parameterExpressions.some(isComplexTypeExpression) ||\n\t\t\tparameterExpressions.some(isConcatExpression) ||\n\t\t\tparameterExpressions.some(isIfElseExpression))\n\t) {\n\t\tlet pathIdx = 0;\n\t\tconst myFormatExpression = formatResult(parameterExpressions, functionName, undefined, true);\n\t\tconst allParts = [];\n\t\ttransformRecursively(\n\t\t\tmyFormatExpression as Expression<PrimitiveType>,\n\t\t\t\"PathInModel\",\n\t\t\t(constantPath: PathInModelExpression<unknown>) => {\n\t\t\t\tallParts.push(constantPath);\n\t\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t\t},\n\t\t\ttrue\n\t\t);\n\t\tallParts.unshift(constant(JSON.stringify(myFormatExpression)));\n\t\treturn formatResult(allParts, \"sap.fe.core.formatters.StandardFormatter#evaluateComplexExpression\", undefined, true);\n\t} else if (!!formatterName && formatterName.length > 0) {\n\t\tparameterExpressions.unshift(constant(formatterName));\n\t}\n\n\treturn {\n\t\t_type: \"Formatter\",\n\t\tfn: formatterClass!,\n\t\tparameters: parameterExpressions\n\t};\n}\n\nexport const getFiscalType = function (property: Property): string | undefined {\n\tif (property.annotations.Common?.IsFiscalYear) {\n\t\treturn CommonAnnotationTerms.IsFiscalYear;\n\t}\n\tif (property.annotations.Common?.IsFiscalPeriod) {\n\t\treturn CommonAnnotationTerms.IsFiscalPeriod;\n\t}\n\tif (property.annotations.Common?.IsFiscalYearPeriod) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearPeriod;\n\t}\n\tif (property.annotations.Common?.IsFiscalQuarter) {\n\t\treturn CommonAnnotationTerms.IsFiscalQuarter;\n\t}\n\tif (property.annotations.Common?.IsFiscalYearQuarter) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearQuarter;\n\t}\n\tif (property.annotations.Common?.IsFiscalWeek) {\n\t\treturn CommonAnnotationTerms.IsFiscalWeek;\n\t}\n\tif (property.annotations.Common?.IsFiscalYearWeek) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearWeek;\n\t}\n\tif (property.annotations.Common?.IsDayOfFiscalYear) {\n\t\treturn CommonAnnotationTerms.IsDayOfFiscalYear;\n\t}\n};\n\n/**\n * Function call, optionally with arguments.\n *\n * @param func Function name or reference to function\n * @param parameters Arguments\n * @param on Object to call the function on\n * @param isFormattingFn\n * @returns Expression representing the function call (not the result of the function call!)\n */\nexport function fn<T, U extends FunctionOrName<T>>(\n\tfunc: U,\n\tparameters: WrappedTuple<FunctionParameters<T, U>>,\n\ton?: ExpressionOrPrimitive<object>,\n\tisFormattingFn = false\n): FunctionExpression<T> {\n\tconst functionName = typeof func === \"string\" ? func : func.__functionName;\n\treturn {\n\t\t_type: \"Function\",\n\t\tobj: on !== undefined ? wrapPrimitive(on) : undefined,\n\t\tfn: functionName,\n\t\tisFormattingFn: isFormattingFn,\n\t\tparameters: (parameters as ExpressionOrPrimitive<PrimitiveType>[]).map(wrapPrimitive)\n\t};\n}\n\n/**\n * Shortcut function to determine if a binding value is null, undefined or empty.\n *\n * @param expression\n * @returns A Boolean expression evaluating the fact that the current element is empty\n */\nexport function isEmpty(expression: Expression<string>): Expression<boolean> {\n\tconst aBindings: ExpressionOrPrimitive<boolean>[] = [];\n\ttransformRecursively(expression, \"PathInModel\", (expr) => {\n\t\taBindings.push(or(equal(expr, \"\"), equal(expr, undefined), equal(expr, null)));\n\t\treturn expr;\n\t});\n\treturn and(...aBindings);\n}\n\nexport function concat(\n\t//eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\n\t...inExpressions: ExpressionOrPrimitive<string | String>[]\n): Expression<string> {\n\tconst expressions = inExpressions.map(wrapPrimitive);\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (expressions.every(isConstant)) {\n\t\treturn constant(\n\t\t\texpressions.reduce((concatenated: string, value) => {\n\t\t\t\tif (value.value !== undefined && value.value !== null) {\n\t\t\t\t\treturn concatenated + value.value.toString();\n\t\t\t\t}\n\t\t\t\treturn concatenated;\n\t\t\t}, \"\")\n\t\t);\n\t} else if (expressions.some(isComplexTypeExpression)) {\n\t\tlet pathIdx = 0;\n\t\tconst myConcatExpression = formatResult(expressions, \"sap.fe.core.formatters.StandardFormatter#concat\", undefined, true);\n\t\tconst allParts = [];\n\t\ttransformRecursively(\n\t\t\tmyConcatExpression as Expression<PrimitiveType>,\n\t\t\t\"PathInModel\",\n\t\t\t(constantPath: PathInModelExpression<unknown>) => {\n\t\t\t\tallParts.push(constantPath);\n\t\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t\t}\n\t\t);\n\t\tallParts.unshift(constant(JSON.stringify(myConcatExpression)));\n\t\treturn formatResult(allParts, \"sap.fe.core.formatters.StandardFormatter#evaluateComplexExpression\", undefined, true);\n\t}\n\treturn {\n\t\t_type: \"Concat\",\n\t\texpressions: expressions as Expression<string>[]\n\t};\n}\n\ntype ExpressionTypeToExpression<T extends ExpressionType, V> = T extends \"Constant\"\n\t? ConstantExpression<V>\n\t: T extends \"PathInModel\"\n\t\t? PathInModelExpression<V>\n\t\t: T extends \"Function\"\n\t\t\t? FunctionExpression<V>\n\t\t\t: T extends \"Unresolvable\"\n\t\t\t\t? UnresolvablePathExpression\n\t\t\t\t: Expression<V>;\n\nexport type TransformFunction<T, V> = (expressionPart: T) => Expression<V>;\nexport type ExpressionType = Pick<Expression<unknown>, \"_type\">[\"_type\"];\nexport function transformRecursively<T extends PrimitiveType, ET extends ExpressionType>(\n\tinExpression: Expression<T>,\n\texpressionType: ET,\n\ttransformFunction: TransformFunction<ExpressionTypeToExpression<ET, T>, T>,\n\tincludeAllExpression = false\n): Expression<T> {\n\tlet expression: Expression<T> = inExpression;\n\tswitch (expression._type) {\n\t\tcase \"Function\":\n\t\tcase \"Formatter\":\n\t\t\texpression.parameters = expression.parameters.map((parameter) =>\n\t\t\t\ttransformRecursively(parameter as Expression<T>, expressionType, transformFunction, includeAllExpression)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase \"Concat\":\n\t\t\texpression.expressions = expression.expressions.map((subExpression) =>\n\t\t\t\ttransformRecursively(\n\t\t\t\t\tsubExpression,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, string>, string>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t)\n\t\t\t);\n\t\t\texpression = concat(...expression.expressions) as Expression<T>;\n\t\t\tbreak;\n\t\tcase \"ComplexType\":\n\t\t\texpression.bindingParameters = expression.bindingParameters.map((bindingParameter) =>\n\t\t\t\ttransformRecursively(bindingParameter as Expression<T>, expressionType, transformFunction, includeAllExpression)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase \"IfElse\": {\n\t\t\tconst onTrue = transformRecursively(expression.onTrue, expressionType, transformFunction, includeAllExpression);\n\t\t\tconst onFalse = transformRecursively(expression.onFalse, expressionType, transformFunction, includeAllExpression);\n\t\t\tlet condition = expression.condition;\n\t\t\tif (includeAllExpression) {\n\t\t\t\tcondition = transformRecursively(\n\t\t\t\t\texpression.condition,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t}\n\t\t\texpression = ifElse(condition, onTrue, onFalse);\n\t\t\tbreak;\n\t\t}\n\t\tcase \"Not\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operand = transformRecursively(\n\t\t\t\t\texpression.operand,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\texpression = not(operand) as Expression<T>;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Truthy\":\n\t\t\tbreak;\n\t\tcase \"Set\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operands = expression.operands.map((operand) =>\n\t\t\t\t\ttransformRecursively(\n\t\t\t\t\t\toperand,\n\t\t\t\t\t\texpressionType,\n\t\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\t\tincludeAllExpression\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\texpression = expression.operator === \"||\" ? (or(...operands) as Expression<T>) : (and(...operands) as Expression<T>);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Comparison\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operand1 = transformRecursively(\n\t\t\t\t\texpression.operand1 as Expression<T>,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\tconst operand2 = transformRecursively(\n\t\t\t\t\texpression.operand2 as Expression<T>,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\texpression = comparison(expression.operator, operand1, operand2) as Expression<T>;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Constant\": {\n\t\t\tconst constantValue: Record<string, Expression<unknown>> = expression.value as Record<string, Expression<unknown>>;\n\t\t\tif (typeof constantValue === \"object\" && constantValue) {\n\t\t\t\tObject.keys(constantValue).forEach((key) => {\n\t\t\t\t\tconstantValue[key] = transformRecursively(\n\t\t\t\t\t\tconstantValue[key] as ConstantExpression<T>,\n\t\t\t\t\t\texpressionType,\n\t\t\t\t\t\ttransformFunction,\n\t\t\t\t\t\tincludeAllExpression\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"Ref\":\n\t\tcase \"Length\":\n\t\tcase \"PathInModel\":\n\t\tcase \"EmbeddedBinding\":\n\t\tcase \"EmbeddedExpressionBinding\":\n\t\tcase \"Unresolvable\":\n\t\t\t// Do nothing\n\t\t\tbreak;\n\t}\n\tif (expressionType === expression._type) {\n\t\texpression = transformFunction(inExpression as ExpressionTypeToExpression<ET, T>);\n\t}\n\treturn expression;\n}\n","/**\n * Collection of table formatters.\n * @param this The context\n * @param name The inner function name\n * @param args The inner function parameters\n * @returns The value from the inner function\n */\nexport const formatters = function (this: object, name: string, ...args: unknown[]): unknown {\n\tif (formatters.hasOwnProperty(name)) {\n\t\treturn (formatters as unknown as Record<string, Function>)[name]!.apply(this, args);\n\t} else {\n\t\treturn \"\";\n\t}\n};\n\nexport const FORMATTERS_PATH = \"sap.fe.definition.formatters\";\n\nexport function formatWithBrackets(firstPart?: string, secondPart?: string): string {\n\tif (firstPart && secondPart) {\n\t\treturn `${firstPart} (${secondPart})`;\n\t} else {\n\t\treturn firstPart || secondPart || \"\";\n\t}\n}\nformatWithBrackets.__functionName = `${FORMATTERS_PATH}#formatWithBrackets`;\n\nformatters.formatWithBrackets = formatWithBrackets;\n\nexport default formatters;\n","import type {\n\tAnnotationTerm,\n\tComplexType,\n\tEntityContainer,\n\tEntitySet,\n\tEntityType,\n\tMultipleNavigationProperty,\n\tNavigationProperty,\n\tPathAnnotationExpression,\n\tProperty,\n\tPropertyPath,\n\tServiceObject,\n\tSingleNavigationProperty,\n\tSingleton,\n\tTypeDefinition\n} from \"@sap-ux/vocabularies-types\";\nimport type { AnnotationPath } from \"@sap-ux/vocabularies-types/Edm\";\n\nexport type AnnotationType = {\n\t$Type?: string;\n\tfullyQualifiedName?: string;\n};\nexport type _AnnotationTerm = {\n\tterm: string;\n\tqualifier?: string;\n};\n\n/**\n * Checks whether the argument is an annotation of the given type.\n * @param potentialAnnotationType The annotation to check\n * @param typeName The type to check for\n * @returns Whether the argument is an annotation of the given type\n */\nexport function isAnnotationOfType<T extends object & AnnotationType>(\n\tpotentialAnnotationType: AnnotationType | undefined,\n\ttypeName: T[\"$Type\"] | T[\"$Type\"][]\n): potentialAnnotationType is T {\n\tif (Array.isArray(typeName)) {\n\t\treturn typeName.includes(potentialAnnotationType?.$Type);\n\t}\n\treturn potentialAnnotationType?.$Type === typeName;\n}\n\n/**\n * Checks whether the argument is an annotation of the given term.\n * @param potentialAnnotation The annotation to check\n * @param termName The term to check for\n * @returns Whether the argument is an annotation of the given term\n */\nexport function isAnnotationOfTerm<T extends object & _AnnotationTerm>(\n\tpotentialAnnotation: unknown,\n\ttermName: T[\"term\"]\n): potentialAnnotation is AnnotationTerm<T> {\n\treturn (potentialAnnotation as _AnnotationTerm).term === termName;\n}\n\nexport function isAnnotationTerm(potentialAnnotation: unknown): potentialAnnotation is _AnnotationTerm {\n\treturn (potentialAnnotation as _AnnotationTerm).hasOwnProperty(\"term\");\n}\n\n/**\n * Checks whether the argument is a {@link ServiceObject}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link ServiceObject}.\n */\nexport function isServiceObject(serviceObject: unknown): serviceObject is ServiceObject {\n\treturn serviceObject?.hasOwnProperty(\"_type\") ?? false;\n}\n\n/**\n * Checks whether the argument is a {@link ComplexType}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link ComplexType}.\n */\nexport function isComplexType(serviceObject: unknown): serviceObject is ComplexType {\n\treturn (serviceObject as { _type: string })._type === \"ComplexType\";\n}\n\n/**\n * Checks whether the argument is a {@link TypeDefinition}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link TypeDefinition}.\n */\nexport function isTypeDefinition(serviceObject: unknown): serviceObject is TypeDefinition {\n\treturn (serviceObject as { _type: string })._type === \"TypeDefinition\";\n}\n\n/**\n * Checks whether the argument is an {@link EntityContainer}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is an {@link EntityContainer}.\n */\nexport function isEntityContainer(serviceObject: unknown): serviceObject is EntityContainer {\n\treturn (serviceObject as { _type: string })._type === \"EntityContainer\";\n}\n\n/**\n * Checks whether the argument is an {@link EntitySet}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is an {@link EntitySet}.\n */\nexport function isEntitySet(serviceObject: unknown): serviceObject is EntitySet {\n\treturn (serviceObject as { _type: string })._type === \"EntitySet\";\n}\n\n/**\n * Checks whether the argument is a {@link Singleton}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link Singleton}\n */\nexport function isSingleton(serviceObject: unknown): serviceObject is Singleton {\n\treturn (serviceObject as { _type: string })._type === \"Singleton\";\n}\n\n/**\n * Checks whether the argument is an {@link EntityType}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is an {@link EntityType}\n */\nexport function isEntityType(serviceObject: unknown): serviceObject is EntityType {\n\treturn (serviceObject as { _type: string })._type === \"EntityType\";\n}\n\n/**\n * Checks whether the argument is a {@link Property}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link Property}.\n */\nexport function isProperty(serviceObject: unknown): serviceObject is Property {\n\treturn (serviceObject as { _type: string })._type === \"Property\";\n}\n\n/**\n * Checks whether the argument is a {@link NavigationProperty}.\n *\n * Hint: There are also the more specific functions {@link isSingleNavigationProperty} and {@link isMultipleNavigationProperty}. These can be\n * used to check for to-one and to-many navigation properties, respectively.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link NavigationProperty}.\n */\nexport function isNavigationProperty(serviceObject: unknown): serviceObject is NavigationProperty {\n\treturn (serviceObject as { _type: string })._type === \"NavigationProperty\";\n}\n\n/**\n * Checks whether the argument is a {@link SingleNavigationProperty}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link SingleNavigationProperty}.\n */\nexport function isSingleNavigationProperty(serviceObject: unknown): serviceObject is SingleNavigationProperty {\n\treturn isNavigationProperty(serviceObject) && !serviceObject.isCollection;\n}\n\n/**\n * Checks whether the argument is a {@link MultipleNavigationProperty}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link MultipleNavigationProperty}.\n */\nexport function isMultipleNavigationProperty(serviceObject: unknown): serviceObject is MultipleNavigationProperty {\n\treturn isNavigationProperty(serviceObject) && serviceObject.isCollection;\n}\n\n/**\n * Checks whether the argument is a {@link PathAnnotationExpression}.\n *\n * @param expression The object to be checked.\n * @returns Whether the argument is a {@link PathAnnotationExpression}.\n */\nexport function isPathAnnotationExpression<T>(expression: unknown): expression is PathAnnotationExpression<T> {\n\treturn (expression as { type: string }).type === \"Path\";\n}\n\n/**\n * Checks whether the argument is a {@link AnnotationPathExpression}.\n *\n * @param expression The object to be checked.\n * @returns Whether the argument is a {@link AnnotationPathExpression}.\n */\nexport function isAnnotationPath<T>(expression: unknown): expression is AnnotationPath<T> {\n\treturn (expression as { type: string }).type == \"AnnotationPath\";\n}\n\n/**\n * Checks whether the argument is a {@link PropertyPath}.\n *\n * @param expression The object to be checked.\n * @returns Whether the argument is a {@link PropertyPath}.\n */\nexport function isPropertyPathExpression(expression: unknown): expression is PropertyPath {\n\treturn (expression as { type: string } | undefined)?.type === \"PropertyPath\";\n}\nexport type ValidPropertyPath = PropertyPath & { $target: Property };\n\n/**\n * Checks whether the argument is a {@link PropertyPath}.\n *\n * @param expression The object to be checked.\n * @returns Whether the argument is a {@link PropertyPath}.\n */\nexport function isValidPropertyPathExpression(expression: unknown): expression is ValidPropertyPath {\n\treturn (expression as { type: string }).type === \"PropertyPath\" && !!(expression as { $target: Property }).$target;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(16);\n",""]}