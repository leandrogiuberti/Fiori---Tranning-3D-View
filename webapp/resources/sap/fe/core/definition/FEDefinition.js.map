{"version":3,"file":"FEDefinition.js","names":["Placement","exports","BaseDefinition","constructor","metaPath","configuration","this","annotationPath","getPath","configurablePropertiesKey","__configurableProperties","configSettings","configurationValue","aliasFor","undefined","validator","defaultValue","targetObject","getTarget","annotationPropertiesKey","__annotationProperties","annotations","_annotations","term","valueOf","getConfiguration","outObj","noop","value","configurable","propertyConfiguration","target","propertyKey","propertyDescriptor","localPropertyConfiguration","name","initializer","targetPrototype","prototype","annotation","annotationConfiguration","localAnnotationConfiguration","_TypeGuards","require","enhancePath","sBasePath","sPathAddition","startsWith","endsWith","MetaPath","convertedMetadata","contextPath","navigationProperties","contextNavigationProperties","absolutePath","relativePath","replace","substring","resolvedMetaPath","resolvePath","resolvedContextPath","Error","rootEntitySet","currentEntitySet","currentEntityType","navigatedPaths","objectPath","forEach","objectPart","isServiceObject","_type","push","targetType","navigationPropertyBinding","hasOwnProperty","join","entityType","getResolvedContextPath","serviceObjectPath","length","map","nav","contextRootEntitySet","getContextPath","sPathPart","getRelativePath","getClosestEntitySet","closestEntitySet","navigationProperty","navigationPropertyBindingElement","getClosestEntityType","closestEntityType","getContextClosestEntitySet","nonNullEntitySet","getNavigationProperties","getMetaPathForClosestEntitySet","fullyQualifiedName","getMetaPathForPath","targetPath","_error","getMetaPathForObject","isAnnotationPath","isPathAnnotationExpression","path","metaPathApp","getConvertedMetadata","_BaseDefinition","_EntitySet2","_interopRequireDefault","_dec","_dec2","_dec3","_dec4","_dec5","_class","_descriptor","_descriptor2","_descriptor3","_descriptor4","e","__esModule","default","_initializerDefineProperty","i","r","l","Object","defineProperty","enumerable","writable","call","_defineProperty","t","_toPropertyKey","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","_applyDecoratedDescriptor","n","a","keys","slice","reverse","reduce","_initializerWarningHelper","FilterField","filterFieldProperty","isParameter","Common","ResultContext","label","Label","toString","filterFieldConfiguration","super","getOwnPropertyDescriptor","FilterBar","selectionFields","filterBarConfiguration","isParameterizedEntitySet","containsTarget","getFilterGroups","filterFacets","UI","FilterFacets","filterFieldsGroup","fieldGroups","filter","key","fieldGroup","Data","fieldGroupEntry","$Type","fieldGroupValue","Value","$target","group","groupLabel","qualifier","filterFacet","filterFacetTarget","Target","isAnnotationOfType","ID","getFilterFields","filterGroups","consideredProperties","parameterizedFields","parametrizedEntitySetMetaPath","entityProperties","property","metaPathForProperty","visible","required","field","requiredProperties","_EntitySet","getRequiredProperties","fromSelectionField","isValidPropertyPathExpression","includes","nonFilterableProperties","getNonFilterableProperties","Hidden","isSearchSupported","isSearchAllowed","_FilterBar","_HeaderInfo2","_Identification2","_LineItem2","DefinitionPage","getMetaPath","getIdentification","targetEntityType","idAnnotation","Identification","_Identification","getHeaderInfo","info","HeaderInfo","_HeaderInfo","getTableVisualization","_LineItem","fromSPV","_getTableVisualizationAnnotation","getFilterBarDefinition","selectionField","SelectionFields","assign","createDefaultTableVisualization","createDefault","spv","SelectionPresentationVariant","PresentationVariant","Visualizations","find","v","pv","LineItem","_DefinitionPage","_DataField","_DefinitionContext","_QueryBuilder","_Formatters","_exportNames","get","_MetaPath","DefinitionContext","addApplicationManifest","manifest","getEntitySets","entitySets","getEntitySet","entitySetName","by_name","getRootEntitySet","initialRoutePattern","initialRoute","routing","routes","pattern","targets","options","settings","entitySet","getPageFor","getVersion","match","version","major","parseInt","minor","entitySetConfiguration","Capabilities","FilterRestrictions","RequiredProperties","propertyPath","NonFilterableProperties","getAllowedFilterExpression","filterExpressionRestrictions","FilterExpressionRestrictions","propertyRestrictions","filterExpressionRestriction","Property","propertyRestriction","AllowedExpressions","SearchRestrictions","Searchable","_Expression","QueryBuilder","contextMetaPath","definitionContext","Set","addPathsFromExpression","expression","transformRecursively","pathExpression","addPath","paths","add","buildQuery","query","createQueryV4","createQueryV2","select","expand","parts","split","propertyMetaPath","isNavigationProperty","$format","$select","size","$expand","Array","from","node","Map","processPathRecursiveV4","values","serializeExpandV4Recursive","parentNode","set","navigationPropertyOffset","expandNode","serializeSelect","expandValue","separator","fields","dataField","scopedContextMetaPath","getValue","getExpressionFromAnnotation","unresolvableExpression","getFormattedValue","targetValue","navProp","ownPath","measure","getMeasure","concat","displayMode","getDisplayMode","text","Text","formatResult","formatters","formatWithBrackets","measures","Measures","Unit","ISOCurrency","textAnnotation","textArrangement","TextArrangement","getLabel","valueTarget","getProperty","getFullyQualifiedName","_DataField2","pageMetaPath","getTitle","Title","getDescription","Description","getTypeName","TypeName","id","getDataFields","item","restrictTypes","importance","Importance","lineItem","fakeLineItemAnnotation","prop","DataFieldDefault","type","getActions","getHeaderActions","action","Determining","hasUnresolvableExpression","expressions","expr","_checkExpressionsAreEqual","b","operand","operator","operands","every","some","otherExpression","condition","onTrue","onFalse","operand1","operand2","aExpressions","bExpressions","index","pathInModel","modelName","targetEntitySet","fn","parameters","bindingParameters","otherFunction","obj","ref","flattenSetExpression","result","candidatesForFlattening","candidate","hasOppositeExpressions","negatedExpressions","not","and","wrapPrimitive","isStaticFalse","nonTrivialExpression","isFalse","isConstant","constant","isValid","isTrue","or","isStaticTrue","isComparison","isTruthy","visitedNavigationPaths","pathVisitor","localPath","constantValue","isArray","isPrimitiveObject","entries","plainExpression","val","wrappedValue","resolveBindingString","pathInModelRegex","pathInModelRegexMatch","exec","isNaN","reference","something","isExpression","maybeConstant","isPathInModelExpression","maybeBinding","isComplexTypeExpression","isConcatExpression","isIfElseExpression","isUndefinedExpression","expressionAsExpression","objectType","isComplexAnnotationExpression","annotationValue","annotationIfExpression","$If","parseAnnotationCondition","$Not","equal","$Eq","notEqual","$Ne","greaterThan","$Gt","greaterOrEqual","$Ge","lessThan","$Lt","lessOrEqual","$Le","$Or","orCondition","$And","andCondition","annotationApplyExpression","$Path","Path","$Function","$Apply","$EnumMember","Bool","Int","Decimal","ifElse","convertSubApplyParameters","applyParam","applyParamConverted","applyExpression","parameter","template","templateParams","$Name","$LabeledElement","comparison","leftOperand","rightOperand","leftExpression","rightExpression","checkUndefined","left","right","reduced","conditionExpression","onTrueExpression","onFalseExpression","pathIdx","myIfElseExpression","allParts","constantPath","unshift","JSON","stringify","hasReferenceToDefaultContext","formatterFunction","contextEntityType","ignoreComplexType","parameterExpressions","functionName","__functionName","formatterClass","formatterName","myFormatExpression","getFiscalType","IsFiscalYear","IsFiscalPeriod","IsFiscalYearPeriod","IsFiscalQuarter","IsFiscalYearQuarter","IsFiscalWeek","IsFiscalYearWeek","IsDayOfFiscalYear","func","on","isFormattingFn","isEmpty","aBindings","inExpressions","concatenated","myConcatExpression","inExpression","expressionType","transformFunction","includeAllExpression","subExpression","bindingParameter","args","apply","FORMATTERS_PATH","firstPart","secondPart","_default","potentialAnnotationType","typeName","isAnnotationOfTerm","potentialAnnotation","termName","isAnnotationTerm","serviceObject","isComplexType","isTypeDefinition","isEntityContainer","isEntitySet","isSingleton","isEntityType","isProperty","isSingleNavigationProperty","isCollection","isMultipleNavigationProperty","isPropertyPathExpression","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","__webpack_exports__"],"sources":["webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/BaseDefinition.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/MetaPath.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/elements/FilterBar.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/floorplans/DefinitionPage.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/index.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/odata/DefinitionContext.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/odata/EntitySet.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/odata/QueryBuilder.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/odata/annotations/UI/_DataField.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/odata/annotations/UI/_HeaderInfo.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/odata/annotations/UI/_Identification.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/odata/annotations/UI/_LineItem.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/utils/Expression.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/utils/Formatters.ts","webpack://FEDefinition/node_modules/.pnpm/@sap-ux+sap.fe.definition@0.0.20/node_modules/@sap-ux/sap.fe.definition/src/utils/TypeGuards.ts","webpack://FEDefinition/webpack/bootstrap","webpack://FEDefinition/webpack/startup"],"sourcesContent":["import type { ServiceObject } from \"@sap-ux/vocabularies-types\";\nimport type { AnnotationTerm } from \"@sap-ux/vocabularies-types/Edm\";\nimport type MetaPath from \"./MetaPath\";\nimport type { PrimitiveType } from \"./utils/Expression\";\n\nexport type BaseConfiguration = Record<string, PrimitiveType>;\ntype InPropertyConfiguration = {\n\taliasFor?: string;\n\tvalidator?: Function;\n};\ntype PropertyConfiguration = {\n\taliasFor: string;\n\tvalidator: Function;\n\tname: string;\n\tdefaultValue: unknown;\n};\ntype InAnnotationConfiguration = {\n\tterm: string;\n};\ntype AnnotationConfiguration = {\n\tname: string;\n\tdefaultValue: unknown;\n\tterm: string;\n};\n\nexport enum Placement {\n\tAfter = \"After\",\n\tBefore = \"Before\",\n\tEnd = \"End\"\n}\n\nexport class BaseDefinition<T extends BaseConfiguration> {\n\tpublic annotationPath?: string;\n\n\t__configurableProperties!: Record<string, PropertyConfiguration>;\n\n\t__annotationProperties!: Record<string, AnnotationConfiguration>;\n\n\tconstructor(metaPath: MetaPath<ServiceObject | AnnotationTerm<{ term: string }>> | null, configuration: T) {\n\t\tthis.annotationPath = metaPath?.getPath();\n\t\tfor (const configurablePropertiesKey in this.__configurableProperties) {\n\t\t\tconst configSettings = this.__configurableProperties[configurablePropertiesKey];\n\t\t\tif (configSettings) {\n\t\t\t\tconst configurationValue = configuration[configSettings.aliasFor];\n\t\t\t\tif (configurationValue !== undefined) {\n\t\t\t\t\tthis[configurablePropertiesKey as keyof this] = configSettings.validator(configurationValue) as never;\n\t\t\t\t} else if (configSettings.defaultValue !== undefined) {\n\t\t\t\t\tthis[configurablePropertiesKey as keyof this] = configSettings.defaultValue as never;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst targetObject = metaPath?.getTarget();\n\t\tif (targetObject) {\n\t\t\tfor (const annotationPropertiesKey in this.__annotationProperties) {\n\t\t\t\tconst configSettings = this.__annotationProperties[annotationPropertiesKey];\n\t\t\t\tif (configSettings) {\n\t\t\t\t\tconst configurationValue = (\n\t\t\t\t\t\ttargetObject.annotations as unknown as {\n\t\t\t\t\t\t\t_annotations?: Record<string, unknown>;\n\t\t\t\t\t\t}\n\t\t\t\t\t)._annotations?.[configSettings.term];\n\t\t\t\t\tif (configurationValue !== undefined && configurationValue !== null) {\n\t\t\t\t\t\tthis[annotationPropertiesKey as keyof this] = configurationValue.valueOf() as never;\n\t\t\t\t\t} else if (configSettings.defaultValue !== undefined) {\n\t\t\t\t\t\tthis[annotationPropertiesKey as keyof this] = configSettings.defaultValue as never;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgetConfiguration(): T {\n\t\tconst outObj: BaseConfiguration = {};\n\t\tfor (const configurablePropertiesKey in this.__configurableProperties) {\n\t\t\tconst configSettings = this.__configurableProperties[configurablePropertiesKey];\n\t\t\tif (configSettings) {\n\t\t\t\toutObj[configSettings.aliasFor] = this[configurablePropertiesKey as keyof this] as PrimitiveType;\n\t\t\t}\n\t\t}\n\t\treturn outObj as T;\n\t}\n}\n\nfunction noop(value: PrimitiveType): PrimitiveType {\n\treturn value;\n}\nexport function configurable(propertyConfiguration: InPropertyConfiguration = {}): PropertyDecorator {\n\treturn function (\n\t\ttarget: BaseDefinition<BaseConfiguration>,\n\t\tpropertyKey: string,\n\t\tpropertyDescriptor: TypedPropertyDescriptor<PrimitiveType>\n\t) {\n\t\tconst localPropertyConfiguration: PropertyConfiguration = {\n\t\t\tname: propertyKey,\n\t\t\tvalidator: propertyConfiguration.validator || noop,\n\t\t\taliasFor: propertyConfiguration.aliasFor || propertyKey,\n\t\t\tdefaultValue: (propertyDescriptor as { initializer?: Function }).initializer?.()\n\t\t};\n\t\tconst targetPrototype = target.constructor.prototype as BaseDefinition<BaseConfiguration>;\n\t\tif (!targetPrototype.__configurableProperties) {\n\t\t\ttargetPrototype.__configurableProperties = {};\n\t\t}\n\t\tdelete (propertyDescriptor as { initializer?: Function } | undefined)?.initializer;\n\n\t\ttargetPrototype.__configurableProperties[propertyKey] = localPropertyConfiguration;\n\t} as unknown as PropertyDecorator;\n}\n\nexport function annotation(annotationConfiguration: InAnnotationConfiguration): PropertyDecorator {\n\treturn function (target: BaseDefinition<BaseConfiguration>, propertyKey: string, propertyDescriptor: TypedPropertyDescriptor<unknown>) {\n\t\tconst localAnnotationConfiguration: AnnotationConfiguration = {\n\t\t\tname: propertyKey,\n\t\t\tterm: annotationConfiguration.term,\n\t\t\tdefaultValue: (propertyDescriptor as { initializer?: Function }).initializer?.()\n\t\t};\n\t\tconst targetPrototype = target.constructor.prototype as BaseDefinition<BaseConfiguration>;\n\t\tif (!targetPrototype.__annotationProperties) {\n\t\t\ttargetPrototype.__annotationProperties = {};\n\t\t}\n\t\ttargetPrototype.__annotationProperties[propertyKey] = localAnnotationConfiguration;\n\t\tdelete (propertyDescriptor as { initializer?: Function }).initializer;\n\t\treturn propertyDescriptor;\n\t} as unknown as PropertyDecorator; // This is technically an accessor decorator, but somehow the compiler doesn't like it if i declare it as such.;\n}\n","import type {\n\tConvertedMetadata,\n\tEntitySet,\n\tEntityType,\n\tNavigationProperty,\n\tPathAnnotationExpression,\n\tResolutionTarget,\n\tServiceObjectAndAnnotation,\n\tSingleton\n} from \"@sap-ux/vocabularies-types\";\nimport type { AnnotationPath, Property, PropertyAnnotationValue } from \"@sap-ux/vocabularies-types/Edm\";\nimport { isAnnotationPath, isPathAnnotationExpression, isServiceObject } from \"./utils/TypeGuards\";\n\nfunction enhancePath(sBasePath: string, sPathAddition?: string): string {\n\tif (sPathAddition) {\n\t\tif (sPathAddition.startsWith(\"/\")) {\n\t\t\treturn sPathAddition;\n\t\t} else if (sPathAddition.startsWith(\"@\")) {\n\t\t\treturn sBasePath + sPathAddition;\n\t\t} else if (!sBasePath.endsWith(\"/\")) {\n\t\t\treturn sBasePath + \"/\" + sPathAddition;\n\t\t} else {\n\t\t\treturn sBasePath + sPathAddition;\n\t\t}\n\t}\n\treturn sBasePath;\n}\n\ntype ResolvedTarget<T> =\n\tT extends AnnotationPath<infer K>\n\t\t? K\n\t\t: T extends PropertyAnnotationValue<infer V extends string>\n\t\t\t? V\n\t\t\t: T extends PathAnnotationExpression<unknown>\n\t\t\t\t? Property | undefined\n\t\t\t\t: T;\n\n/**\n *\n */\nexport default class MetaPath<T> {\n\tprivate rootEntitySet: EntitySet;\n\n\tprivate contextRootEntitySet: EntitySet | undefined;\n\n\tprivate absolutePath: string;\n\n\tprivate serviceObjectPath: string;\n\n\tprivate relativePath: string;\n\n\tprivate navigationProperties: NavigationProperty[];\n\n\tprivate contextNavigationProperties: NavigationProperty[];\n\n\tprivate currentEntitySet: EntitySet | Singleton | undefined;\n\n\tprivate currentEntityType?: EntityType;\n\n\tprivate targetObject: T;\n\n\t/**\n\t * Create the MetaPath object.\n\t * @param convertedMetadata The current model converter output\n\t * @param metaPath The current object metaPath\n\t * @param contextPath The current context\n\t */\n\tconstructor(\n\t\tprivate convertedMetadata: ConvertedMetadata,\n\t\tprivate metaPath: string,\n\t\tprivate contextPath: string\n\t) {\n\t\tthis.navigationProperties = [];\n\t\tthis.contextNavigationProperties = [];\n\t\tthis.absolutePath = enhancePath(contextPath, metaPath);\n\t\tthis.relativePath = this.absolutePath.replace(contextPath, \"\");\n\t\tif (this.relativePath.startsWith(\"/\")) {\n\t\t\tthis.relativePath = this.relativePath.substring(1);\n\t\t}\n\n\t\tconst resolvedMetaPath: ResolutionTarget<T> = this.convertedMetadata.resolvePath(this.absolutePath);\n\t\tconst resolvedContextPath: ResolutionTarget<T> = this.convertedMetadata.resolvePath(contextPath);\n\t\tif (resolvedMetaPath.target === undefined || resolvedMetaPath.target === null) {\n\t\t\tthrow new Error(`No annotation target found for ${metaPath}`);\n\t\t}\n\t\tthis.targetObject = resolvedMetaPath.target;\n\t\tlet rootEntitySet: EntitySet | undefined;\n\t\tlet currentEntitySet: EntitySet | Singleton | undefined;\n\t\tlet currentEntityType: EntityType | undefined;\n\t\tlet navigatedPaths: string[] = [];\n\t\tresolvedMetaPath.objectPath.forEach((objectPart: ServiceObjectAndAnnotation) => {\n\t\t\tif (isServiceObject(objectPart)) {\n\t\t\t\tswitch (objectPart._type) {\n\t\t\t\t\tcase \"NavigationProperty\":\n\t\t\t\t\t\tnavigatedPaths.push(objectPart.name);\n\t\t\t\t\t\tthis.navigationProperties.push(objectPart);\n\t\t\t\t\t\tcurrentEntityType = objectPart.targetType;\n\t\t\t\t\t\tif (currentEntitySet?.navigationPropertyBinding.hasOwnProperty(navigatedPaths.join(\"/\"))) {\n\t\t\t\t\t\t\tcurrentEntitySet = currentEntitySet.navigationPropertyBinding[navigatedPaths.join(\"/\")];\n\t\t\t\t\t\t\tnavigatedPaths = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"EntitySet\":\n\t\t\t\t\t\tif (rootEntitySet === undefined) {\n\t\t\t\t\t\t\trootEntitySet = objectPart;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrentEntitySet = objectPart;\n\t\t\t\t\t\tcurrentEntityType = currentEntitySet.entityType;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"EntityType\":\n\t\t\t\t\t\tif (currentEntityType === undefined) {\n\t\t\t\t\t\t\tcurrentEntityType = objectPart;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tresolvedContextPath.objectPath.forEach((objectPart: ServiceObjectAndAnnotation) => {\n\t\t\trootEntitySet = this.getResolvedContextPath(objectPart, currentEntityType, rootEntitySet);\n\t\t});\n\t\tif (rootEntitySet === undefined || currentEntityType === undefined) {\n\t\t\tthrow new Error(\"MetaPath doesn't contain an entitySet -> Should never happen\");\n\t\t}\n\t\tthis.serviceObjectPath = \"/\" + rootEntitySet.name;\n\t\tif (this.navigationProperties.length) {\n\t\t\tthis.serviceObjectPath += \"/\" + this.navigationProperties.map((nav) => nav.name).join(\"/\");\n\t\t}\n\t\tthis.rootEntitySet = rootEntitySet;\n\t\tthis.currentEntitySet = currentEntitySet;\n\t\tthis.currentEntityType = currentEntityType;\n\t}\n\n\tprivate getResolvedContextPath(\n\t\tobjectPart: ServiceObjectAndAnnotation,\n\t\tcurrentEntityType: EntityType | undefined,\n\t\trootEntitySet: EntitySet | undefined\n\t): EntitySet | undefined {\n\t\tif (isServiceObject(objectPart)) {\n\t\t\tswitch (objectPart._type) {\n\t\t\t\tcase \"NavigationProperty\":\n\t\t\t\t\tthis.contextNavigationProperties.push(objectPart);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"EntitySet\":\n\t\t\t\t\tif (this.contextRootEntitySet === undefined) {\n\t\t\t\t\t\tthis.contextRootEntitySet = objectPart;\n\t\t\t\t\t}\n\t\t\t\t\tif (rootEntitySet === undefined && objectPart.entityType === currentEntityType) {\n\t\t\t\t\t\trootEntitySet = objectPart;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn rootEntitySet;\n\t}\n\n\tpublic getContextPath(): string {\n\t\treturn this.contextPath;\n\t}\n\n\t/**\n\t * Retrieve the absolute path for this MetaPath.\n\t * @param sPathPart The path to evaluate\n\t * @returns The absolute path\n\t */\n\tpublic getPath(sPathPart?: string): string {\n\t\treturn enhancePath(this.absolutePath, sPathPart);\n\t}\n\n\t/**\n\t * Retrieve the path relative to the context for this MetaPath.\n\t * @param sPathPart The path to evaluate\n\t * @returns The relative path\n\t */\n\tpublic getRelativePath(sPathPart?: string): string {\n\t\treturn enhancePath(this.relativePath, sPathPart);\n\t}\n\n\t/**\n\t * Retrieve the typed target for this object call.\n\t * @returns The typed target object\n\t */\n\tpublic getTarget(): T {\n\t\treturn this.targetObject;\n\t}\n\n\t/**\n\t * Retrieve the closest entityset in the path.\n\t * @returns The closest entityset\n\t */\n\tpublic getClosestEntitySet(): EntitySet | Singleton {\n\t\tlet closestEntitySet: EntitySet | Singleton = this.rootEntitySet;\n\t\tfor (const navigationProperty of this.navigationProperties) {\n\t\t\tconst navigationPropertyBindingElement: EntitySet | Singleton | undefined =\n\t\t\t\tclosestEntitySet.navigationPropertyBinding[navigationProperty.name];\n\t\t\tif (navigationPropertyBindingElement) {\n\t\t\t\tclosestEntitySet = navigationPropertyBindingElement;\n\t\t\t}\n\t\t}\n\t\treturn closestEntitySet;\n\t}\n\n\tpublic getClosestEntityType(): EntityType {\n\t\tlet closestEntityType: EntityType = this.rootEntitySet.entityType;\n\t\tfor (const navigationProperty of this.navigationProperties) {\n\t\t\tclosestEntityType = navigationProperty.targetType;\n\t\t}\n\t\treturn closestEntityType;\n\t}\n\n\t/**\n\t * Retrieve the closest entityset in the path.\n\t * @returns The closest entityset\n\t */\n\tpublic getContextClosestEntitySet(): EntitySet | Singleton | undefined {\n\t\tlet closestEntitySet: EntitySet | Singleton | undefined = this.contextRootEntitySet;\n\t\tif (closestEntitySet === undefined) {\n\t\t\treturn closestEntitySet;\n\t\t}\n\t\tconst nonNullEntitySet: EntitySet | Singleton = closestEntitySet;\n\t\tfor (const navigationProperty of this.contextNavigationProperties) {\n\t\t\tif (nonNullEntitySet.navigationPropertyBinding[navigationProperty.name]) {\n\t\t\t\tclosestEntitySet = nonNullEntitySet.navigationPropertyBinding[navigationProperty.name];\n\t\t\t}\n\t\t}\n\t\treturn closestEntitySet;\n\t}\n\n\tpublic getNavigationProperties(): NavigationProperty[] {\n\t\treturn this.navigationProperties;\n\t}\n\n\tpublic getMetaPathForClosestEntitySet(): MetaPath<EntitySet | Singleton> {\n\t\treturn new MetaPath<EntitySet | Singleton>(this.convertedMetadata, \"\", this.getClosestEntitySet().fullyQualifiedName);\n\t}\n\n\tpublic getMetaPathForPath<SubType>(targetPath: string): MetaPath<SubType> | undefined {\n\t\ttry {\n\t\t\treturn new MetaPath<SubType>(this.convertedMetadata, enhancePath(this.serviceObjectPath, targetPath), this.contextPath);\n\t\t} catch (_error) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tpublic getMetaPathForObject<SubType extends { fullyQualifiedName: string }>(\n\t\ttargetObject: SubType\n\t): MetaPath<ResolvedTarget<SubType>> | undefined {\n\t\tif (isAnnotationPath(targetObject)) {\n\t\t\treturn this.getMetaPathForPath<ResolvedTarget<SubType>>(targetObject.value);\n\t\t} else if (isPathAnnotationExpression(targetObject)) {\n\t\t\treturn this.getMetaPathForPath<ResolvedTarget<SubType>>(targetObject.path);\n\t\t} else {\n\t\t\tconst metaPathApp = targetObject.fullyQualifiedName.replace(this.rootEntitySet.entityType.fullyQualifiedName, this.contextPath);\n\t\t\treturn new MetaPath<ResolvedTarget<SubType>>(this.convertedMetadata, metaPathApp, this.contextPath);\n\t\t}\n\t}\n\n\tpublic getConvertedMetadata(): ConvertedMetadata {\n\t\treturn this.convertedMetadata;\n\t}\n}\n","import type { EntitySet } from \"@sap-ux/vocabularies-types\";\nimport type { Property } from \"@sap-ux/vocabularies-types/Edm\";\nimport type { FieldGroup, SelectionFields } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type { EntityTypeAnnotations_UI } from \"@sap-ux/vocabularies-types/vocabularies/UI_Edm\";\nimport { BaseDefinition, configurable } from \"../BaseDefinition\";\nimport type { PageTargetEntity } from \"../floorplans/DefinitionPage\";\nimport type MetaPath from \"../MetaPath\";\nimport _EntitySet from \"../odata/EntitySet\";\nimport { isAnnotationOfType, isPathAnnotationExpression, isValidPropertyPathExpression } from \"../utils/TypeGuards\";\n\nexport type FilterFieldConfiguration = {\n\tgroup?: string;\n\tgroupLabel?: string;\n\tvisible?: boolean;\n\trequired?: boolean;\n\tisParameter?: boolean;\n};\n\nexport class FilterField extends BaseDefinition<FilterFieldConfiguration> {\n\t@configurable()\n\tgroup?: string;\n\n\t@configurable()\n\tgroupLabel?: string;\n\n\t@configurable()\n\tvisible?: boolean;\n\n\t@configurable()\n\trequired?: boolean;\n\n\t@configurable()\n\tget name(): string {\n\t\treturn this.filterFieldProperty.getTarget().name;\n\t}\n\n\tget isParameter(): boolean {\n\t\t// The property is a parameter if the closest entity type has a ResultContext annotation\n\t\t// This indicates that the entity type is a parametrized entity type with a result context\n\t\treturn !!this.filterFieldProperty.getClosestEntityType().annotations.Common?.ResultContext;\n\t}\n\n\tget label(): string {\n\t\treturn this.filterFieldProperty.getTarget().annotations.Common?.Label?.toString() ?? this.filterFieldProperty.getTarget().name;\n\t}\n\n\tconstructor(\n\t\tprivate readonly filterFieldProperty: MetaPath<Property>,\n\t\tfilterFieldConfiguration: FilterFieldConfiguration\n\t) {\n\t\tsuper(filterFieldProperty, filterFieldConfiguration);\n\t}\n\n\tgetTarget(): Property {\n\t\treturn this.filterFieldProperty.getTarget();\n\t}\n}\nexport type FilterBarConfiguration = {\n\tfilterFields?: Record<string, FilterFieldConfiguration[]>;\n};\nexport default class FilterBar {\n\tconstructor(\n\t\tprivate readonly selectionFields: SelectionFields,\n\t\tprivate readonly filterBarConfiguration: FilterBarConfiguration,\n\t\tprivate readonly metaPath: MetaPath<PageTargetEntity>\n\t) {}\n\n\tisParameterizedEntitySet(): boolean {\n\t\tconst target = this.metaPath.getTarget();\n\t\tif (target._type === \"NavigationProperty\" && target.containsTarget) {\n\t\t\treturn this.metaPath.getClosestEntitySet().entityType.annotations.Common?.ResultContext !== undefined;\n\t\t}\n\t\treturn false;\n\t}\n\n\tgetFilterGroups(): Record<string, { group?: string; groupLabel?: string }> {\n\t\tconst filterFacets = this.metaPath.getClosestEntityType().annotations.UI?.FilterFacets;\n\t\tconst filterFieldsGroup: Record<string, { group?: string; groupLabel?: string }> = {};\n\t\tif (!filterFacets) {\n\t\t\tconst fieldGroups = Object.keys(this.metaPath.getClosestEntityType().annotations.UI ?? {})\n\t\t\t\t.filter((key) => {\n\t\t\t\t\treturn key.startsWith(\"FieldGroup\");\n\t\t\t\t})\n\t\t\t\t.map((key) => {\n\t\t\t\t\treturn this.metaPath.getClosestEntityType().annotations.UI?.[key as keyof EntityTypeAnnotations_UI];\n\t\t\t\t}) as FieldGroup[];\n\t\t\tfor (const fieldGroup of fieldGroups) {\n\t\t\t\tfieldGroup.Data.forEach((fieldGroupEntry) => {\n\t\t\t\t\tswitch (fieldGroupEntry.$Type) {\n\t\t\t\t\t\tcase UIAnnotationTypes.DataField: {\n\t\t\t\t\t\t\tconst fieldGroupValue = fieldGroupEntry.Value as unknown;\n\t\t\t\t\t\t\tif (isPathAnnotationExpression(fieldGroupValue) && fieldGroupValue.$target) {\n\t\t\t\t\t\t\t\tfilterFieldsGroup[fieldGroupValue.$target.fullyQualifiedName] = {\n\t\t\t\t\t\t\t\t\tgroup: fieldGroup.fullyQualifiedName,\n\t\t\t\t\t\t\t\t\tgroupLabel:\n\t\t\t\t\t\t\t\t\t\tfieldGroup.Label?.toString() ??\n\t\t\t\t\t\t\t\t\t\tfieldGroup.annotations?.Common?.Label?.toString() ??\n\t\t\t\t\t\t\t\t\t\tfieldGroup.qualifier\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// Not supported\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tfilterFacets.forEach((filterFacet) => {\n\t\t\t\tconst filterFacetTarget = filterFacet.Target.$target;\n\t\t\t\tif (isAnnotationOfType<FieldGroup>(filterFacetTarget, UIAnnotationTypes.FieldGroupType)) {\n\t\t\t\t\tfilterFacetTarget.Data.forEach((fieldGroupEntry) => {\n\t\t\t\t\t\tswitch (fieldGroupEntry.$Type) {\n\t\t\t\t\t\t\tcase UIAnnotationTypes.DataField: {\n\t\t\t\t\t\t\t\tconst fieldGroupValue = fieldGroupEntry.Value as unknown;\n\t\t\t\t\t\t\t\tif (isPathAnnotationExpression(fieldGroupValue) && fieldGroupValue.$target) {\n\t\t\t\t\t\t\t\t\tfilterFieldsGroup[fieldGroupValue.$target.fullyQualifiedName] = {\n\t\t\t\t\t\t\t\t\t\tgroup: filterFacet.ID?.toString(),\n\t\t\t\t\t\t\t\t\t\tgroupLabel: filterFacet.Label?.toString()\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// Not supported\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn filterFieldsGroup;\n\t}\n\n\tgetFilterFields(): FilterField[] {\n\t\tconst filterGroups = this.getFilterGroups();\n\n\t\tconst consideredProperties: Record<string, boolean> = {};\n\t\tlet parameterizedFields: FilterField[] = [];\n\t\tif (this.isParameterizedEntitySet()) {\n\t\t\tconst parametrizedEntitySetMetaPath = this.metaPath.getMetaPathForClosestEntitySet();\n\t\t\tparameterizedFields = parametrizedEntitySetMetaPath\n\t\t\t\t.getClosestEntityType()\n\t\t\t\t.entityProperties.map((property) => {\n\t\t\t\t\tconst metaPathForProperty = parametrizedEntitySetMetaPath.getMetaPathForPath<Property>(property.name);\n\t\t\t\t\tif (metaPathForProperty) {\n\t\t\t\t\t\tconsideredProperties[metaPathForProperty.getTarget().fullyQualifiedName] = true;\n\t\t\t\t\t\treturn new FilterField(metaPathForProperty, {\n\t\t\t\t\t\t\tgroup: filterGroups[metaPathForProperty.getTarget().fullyQualifiedName]?.group,\n\t\t\t\t\t\t\tgroupLabel: filterGroups[metaPathForProperty.getTarget().fullyQualifiedName]?.groupLabel,\n\t\t\t\t\t\t\tvisible: true,\n\t\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\t\tisParameter: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.filter((field): field is FilterField => {\n\t\t\t\t\treturn !!field;\n\t\t\t\t});\n\t\t}\n\t\tconst requiredProperties = new _EntitySet(this.metaPath as MetaPath<EntitySet>).getRequiredProperties();\n\t\tconst fromSelectionField = this.selectionFields\n\t\t\t.filter(isValidPropertyPathExpression)\n\t\t\t.map((field) => {\n\t\t\t\tconst metaPathForProperty = this.metaPath.getMetaPathForPath<Property>(field.value);\n\t\t\t\tif (metaPathForProperty && !consideredProperties[metaPathForProperty.getTarget().fullyQualifiedName]) {\n\t\t\t\t\tconsideredProperties[metaPathForProperty.getTarget().fullyQualifiedName] = true;\n\t\t\t\t\treturn new FilterField(metaPathForProperty, {\n\t\t\t\t\t\tgroup: filterGroups[metaPathForProperty.getTarget().fullyQualifiedName]?.group,\n\t\t\t\t\t\tgroupLabel: filterGroups[metaPathForProperty.getTarget().fullyQualifiedName]?.groupLabel,\n\t\t\t\t\t\tvisible: true,\n\t\t\t\t\t\trequired: requiredProperties.includes(metaPathForProperty.getTarget())\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})\n\t\t\t.filter((field): field is FilterField => {\n\t\t\t\treturn !!field;\n\t\t\t});\n\t\tconst nonFilterableProperties = new _EntitySet(this.metaPath as MetaPath<EntitySet>).getNonFilterableProperties();\n\t\tthis.metaPath.getClosestEntityType().entityProperties.forEach((property) => {\n\t\t\tif (\n\t\t\t\t!consideredProperties[property.fullyQualifiedName] &&\n\t\t\t\t!nonFilterableProperties.includes(property) &&\n\t\t\t\tproperty.targetType === undefined &&\n\t\t\t\tproperty.annotations.UI?.Hidden?.valueOf() !== true\n\t\t\t) {\n\t\t\t\tconsideredProperties[property.fullyQualifiedName] = true;\n\t\t\t\tfromSelectionField.push(\n\t\t\t\t\tnew FilterField(this.metaPath.getMetaPathForPath<Property>(property.name)!, {\n\t\t\t\t\t\tgroup: filterGroups[property.fullyQualifiedName]?.group,\n\t\t\t\t\t\tgroupLabel: filterGroups[property.fullyQualifiedName]?.groupLabel,\n\t\t\t\t\t\tvisible: false\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\treturn [...parameterizedFields, ...fromSelectionField];\n\t}\n\n\tisSearchSupported(): boolean {\n\t\treturn new _EntitySet(this.metaPath as MetaPath<EntitySet>).isSearchAllowed();\n\t}\n}\n","import type { EntitySet, NavigationProperty, PropertyPath, Singleton } from \"@sap-ux/vocabularies-types\";\nimport type {\n\tLineItem,\n\tPresentationVariant,\n\tSelectionFields,\n\tSelectionPresentationVariant\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type { FilterBarConfiguration } from \"../elements/FilterBar\";\nimport FilterBar from \"../elements/FilterBar\";\nimport type MetaPath from \"../MetaPath\";\nimport { _HeaderInfo } from \"../odata/annotations/UI/_HeaderInfo\";\nimport { _Identification } from \"../odata/annotations/UI/_Identification\";\nimport { _LineItem } from \"../odata/annotations/UI/_LineItem\";\n\nexport type PageTargetEntity = EntitySet | Singleton | NavigationProperty;\nexport class DefinitionPage {\n\tconstructor(private metaPath: MetaPath<PageTargetEntity>) {}\n\n\tgetMetaPath(): MetaPath<PageTargetEntity> {\n\t\treturn this.metaPath;\n\t}\n\n\t/**\n\t * Gets the target entity set identification annotation if available.\n\t *\n\t * @returns Identification annotation wrapper\n\t */\n\tpublic getIdentification(): _Identification | undefined {\n\t\tconst targetEntityType = this.metaPath.getClosestEntityType();\n\t\tconst idAnnotation = targetEntityType.annotations.UI?.Identification;\n\t\tif (idAnnotation) {\n\t\t\treturn new _Identification(idAnnotation, this.metaPath);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tpublic getHeaderInfo(): _HeaderInfo | undefined {\n\t\tconst targetEntityType = this.metaPath.getClosestEntityType();\n\t\tconst info = targetEntityType.annotations.UI?.HeaderInfo;\n\t\tif (info) {\n\t\t\treturn new _HeaderInfo(info, this.metaPath);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Retrieves the LineItem annotation for the target entity set\n\t * @returns LineItem annotation\n\t */\n\tpublic getTableVisualization(): _LineItem | undefined {\n\t\treturn _LineItem.fromSPV(this._getTableVisualizationAnnotation(), this.metaPath);\n\t}\n\n\tpublic getFilterBarDefinition(filterBarConfiguration: FilterBarConfiguration): FilterBar {\n\t\tconst targetEntityType = this.metaPath.getClosestEntityType();\n\t\t//this.tracer.markRequest(\"Page.getFilterBarDefinition\", targetEntityType);\n\t\tlet selectionField = targetEntityType.annotations.UI?.SelectionFields;\n\t\tif (!selectionField) {\n\t\t\tselectionField = Object.assign([] as PropertyPath[], {\n\t\t\t\tterm: UIAnnotationTerms.SelectionFields\n\t\t\t}) as SelectionFields;\n\t\t}\n\t\t//this.tracer.endMarkRequest(\"Page.getFilterBarDefinition\");\n\t\treturn new FilterBar(selectionField, filterBarConfiguration, this.metaPath);\n\t}\n\n\t/**\n\t * Create a default LineItem annotation for the target entity type based on properties\n\t * @returns LineItem annotation\n\t */\n\tpublic createDefaultTableVisualization(): _LineItem {\n\t\treturn _LineItem.createDefault(this.metaPath);\n\t}\n\n\tprivate _getTableVisualizationAnnotation(): LineItem | SelectionPresentationVariant | PresentationVariant | undefined {\n\t\tconst targetEntityType = this.metaPath.getClosestEntityType();\n\t\tconst spv = targetEntityType.annotations.UI?.SelectionPresentationVariant;\n\t\tif (spv) {\n\t\t\tif (spv.PresentationVariant.Visualizations.find((v) => v.$target?.term === UIAnnotationTerms.LineItem)) {\n\t\t\t\treturn spv;\n\t\t\t}\n\t\t}\n\t\tconst pv = targetEntityType.annotations.UI?.PresentationVariant;\n\t\tif (pv?.Visualizations) {\n\t\t\tif (pv.Visualizations.find((v) => v.$target?.term === UIAnnotationTerms.LineItem)) {\n\t\t\t\treturn pv;\n\t\t\t}\n\t\t}\n\t\treturn targetEntityType.annotations.UI?.LineItem;\n\t}\n}\n","export { FilterField } from \"./elements/FilterBar\";\nexport { DefinitionPage } from \"./floorplans/DefinitionPage\";\nexport { _DataField } from \"./odata/annotations/UI/_DataField\";\nexport { _LineItem } from \"./odata/annotations/UI/_LineItem\";\nexport { DefinitionContext } from \"./odata/DefinitionContext\";\nexport { QueryBuilder } from \"./odata/QueryBuilder\";\nexport { FORMATTERS_PATH, formatters } from \"./utils/Formatters\";\nexport * from \"./utils/TypeGuards\";\n","import type { ConvertedMetadata, EntitySet, NavigationProperty, Singleton } from \"@sap-ux/vocabularies-types\";\nimport type { SAPJSONSchemaForWebApplicationManifestFile as ApplicationManifest, Route } from \"@ui5/manifest/types/manifest\";\nimport MetaPath from \"../MetaPath\";\nimport { DefinitionPage } from \"../floorplans/DefinitionPage\";\n\nexport class DefinitionContext {\n\tprivate manifest?: ApplicationManifest;\n\n\tconstructor(private readonly convertedMetadata: ConvertedMetadata) {}\n\n\taddApplicationManifest(manifest: ApplicationManifest): void {\n\t\tthis.manifest = manifest;\n\t}\n\n\tgetEntitySets(): EntitySet[] {\n\t\treturn this.convertedMetadata.entitySets;\n\t}\n\n\tgetEntitySet(entitySetName: string): EntitySet | undefined {\n\t\treturn this.convertedMetadata.entitySets.by_name(entitySetName);\n\t}\n\n\tgetRootEntitySet(): EntitySet | Singleton | undefined {\n\t\tif (this.manifest) {\n\t\t\t// Use the ui5 routing config to identify the root entityset\n\t\t\tconst initialRoutePattern = \":?query:\";\n\t\t\tconst initialRoute = (this.manifest[\"sap.ui5\"]?.routing?.routes as Route[]).find((r) => r.pattern === initialRoutePattern);\n\t\t\tif (initialRoute?.target && this.manifest[\"sap.ui5\"]?.routing?.targets) {\n\t\t\t\tconst target = this.manifest[\"sap.ui5\"].routing.targets[initialRoute.target as string];\n\t\t\t\tif (target?.name) {\n\t\t\t\t\tconst options = target.options as\n\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\tsettings?: {\n\t\t\t\t\t\t\t\t\tcontextPath?: string;\n\t\t\t\t\t\t\t\t\tentitySet: string;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t| undefined;\n\t\t\t\t\tconst settings = options?.settings;\n\t\t\t\t\tconst entitySet = this.convertedMetadata.resolvePath<EntitySet | Singleton>(\n\t\t\t\t\t\tsettings?.contextPath ?? `${settings?.entitySet}`\n\t\t\t\t\t);\n\t\t\t\t\treturn entitySet.target;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Try to determine the root entity set from the metadata\n\t}\n\n\tgetMetaPath<T>(metaPath: string, contextPath: string): MetaPath<T> {\n\t\treturn new MetaPath<T>(this.convertedMetadata, metaPath, contextPath);\n\t}\n\n\tgetPageFor(contextPath: string): DefinitionPage {\n\t\t// A page could point to\n\t\t// - An entitySet (/SalesOrder)\n\t\t// - A singleton (/Me)\n\t\t// - A navigation property (/SalesOrder/Set)\n\t\treturn new DefinitionPage(\n\t\t\tnew MetaPath<EntitySet | Singleton | NavigationProperty>(this.convertedMetadata, contextPath, contextPath)\n\t\t);\n\t}\n\n\tgetVersion(): { major: number; minor: number } {\n\t\tconst match = this.convertedMetadata.version.match(/^(\\d+)\\.(\\d+)$/);\n\t\tif (!match) {\n\t\t\tthrow new Error(\"Invalid version format\");\n\t\t}\n\t\treturn {\n\t\t\tmajor: parseInt(match[1]!, 10),\n\t\t\tminor: parseInt(match[2]!, 10)\n\t\t};\n\t}\n}\n","import type { EntitySet } from \"@sap-ux/vocabularies-types\";\nimport type { Property } from \"@sap-ux/vocabularies-types/Edm\";\nimport type { FilterExpressionType } from \"@sap-ux/vocabularies-types/vocabularies/Capabilities\";\nimport type { BaseConfiguration } from \"../BaseDefinition\";\nimport { BaseDefinition } from \"../BaseDefinition\";\nimport type MetaPath from \"../MetaPath\";\n\nexport default class _EntitySet extends BaseDefinition<BaseConfiguration> {\n\tconstructor(\n\t\tprivate readonly entitySet: MetaPath<EntitySet>,\n\t\tprivate readonly entitySetConfiguration: BaseConfiguration = {}\n\t) {\n\t\tsuper(entitySet, entitySetConfiguration);\n\t}\n\t//\n\t// @annotation({\n\t// \tterm: CapabilitiesAnnotationTerms.FilterRestrictions,\n\t// \tprocessor: (filterRestrictions?: FilterRestrictions): Property[] => {\n\t// \t\tconst requiredProperties =\n\t// \t\t\tfilterRestrictions?.RequiredProperties ?? [];\n\t// \t\treturn requiredProperties\n\t// \t\t\t.map((propertyPath) => {\n\t// \t\t\t\treturn propertyPath.$target;\n\t// \t\t\t})\n\t// \t\t\t.filter((property): property is Property => {\n\t// \t\t\t\treturn !!property;\n\t// \t\t\t});\n\t// \t}\n\t// })\n\t// requiredProperties: Property[];\n\n\t/**\n\t * Retrieves the required properties for the entity set.\n\t */\n\tgetRequiredProperties(): Property[] {\n\t\tconst requiredProperties = this.entitySet.getTarget().annotations.Capabilities?.FilterRestrictions?.RequiredProperties ?? [];\n\t\treturn requiredProperties\n\t\t\t.map((propertyPath) => {\n\t\t\t\treturn propertyPath.$target;\n\t\t\t})\n\t\t\t.filter((property): property is Property => {\n\t\t\t\treturn !!property;\n\t\t\t});\n\t}\n\n\t/**\n\t * Retrieves the required properties for the entity set.\n\t */\n\tgetNonFilterableProperties(): Property[] {\n\t\tconst nonFilterableProperties =\n\t\t\tthis.entitySet.getTarget().annotations.Capabilities?.FilterRestrictions?.NonFilterableProperties ?? [];\n\t\treturn nonFilterableProperties\n\t\t\t.map((propertyPath) => {\n\t\t\t\treturn propertyPath.$target;\n\t\t\t})\n\t\t\t.filter((property): property is Property => {\n\t\t\t\treturn !!property;\n\t\t\t});\n\t}\n\n\t/**\n\t * Retrieves the required properties for the entity set.\n\t * @param property\n\t */\n\tgetAllowedFilterExpression(property: Property): FilterExpressionType[] {\n\t\tconst filterExpressionRestrictions =\n\t\t\tthis.entitySet.getTarget().annotations.Capabilities?.FilterRestrictions?.FilterExpressionRestrictions ?? [];\n\t\tconst propertyRestrictions = filterExpressionRestrictions.filter(\n\t\t\t(filterExpressionRestriction) => filterExpressionRestriction.Property?.$target === property\n\t\t);\n\t\treturn propertyRestrictions\n\t\t\t.map((propertyRestriction) => {\n\t\t\t\treturn propertyRestriction.AllowedExpressions;\n\t\t\t})\n\t\t\t.filter((propertyRestriction): propertyRestriction is FilterExpressionType => {\n\t\t\t\treturn !!propertyRestriction;\n\t\t\t});\n\t}\n\n\tisSearchAllowed(): boolean {\n\t\treturn !!this.entitySet.getTarget().annotations.Capabilities?.SearchRestrictions?.Searchable;\n\t}\n}\n","import { type NavigationProperty } from \"@sap-ux/vocabularies-types\";\nimport type MetaPath from \"../MetaPath\";\nimport { type Expression, type PrimitiveType, transformRecursively } from \"../utils/Expression\";\nimport { type DefinitionContext } from \"./DefinitionContext\";\n\nexport class QueryBuilder {\n\tprivate readonly paths: Set<string> = new Set();\n\n\tconstructor(\n\t\tprivate readonly contextMetaPath: MetaPath<unknown>,\n\t\tprivate readonly definitionContext: DefinitionContext\n\t) {}\n\n\taddPathsFromExpression<T extends PrimitiveType>(expression: Expression<T>): void {\n\t\ttransformRecursively(\n\t\t\texpression,\n\t\t\t\"PathInModel\",\n\t\t\t(pathExpression) => {\n\t\t\t\tthis.addPath(pathExpression.path);\n\t\t\t\treturn pathExpression;\n\t\t\t},\n\t\t\ttrue /*includeAllExpressions*/\n\t\t);\n\t}\n\n\taddPath(path: string): void {\n\t\tthis.paths.add(path);\n\t}\n\n\tbuildQuery(): Query {\n\t\tlet query: Query;\n\t\tif (this.definitionContext.getVersion().major >= 4) {\n\t\t\tquery = this.createQueryV4(this.paths);\n\t\t} else {\n\t\t\tquery = this.createQueryV2(this.paths);\n\t\t}\n\t\treturn query;\n\t}\n\n\tprivate createQueryV2(paths: Set<string>): Query {\n\t\tconst select: string[] = [];\n\t\tconst expand: Set<string> = new Set<string>();\n\t\tpaths.forEach((property) => {\n\t\t\tconst parts = property.split(\"/\");\n\t\t\tconst propertyMetaPath = this.contextMetaPath.getMetaPathForPath(property);\n\t\t\tconst name = parts[0];\n\t\t\tif (name && this.isNavigationProperty(name, propertyMetaPath?.getNavigationProperties() ?? [])) {\n\t\t\t\texpand.add(name);\n\t\t\t} else {\n\t\t\t\tselect.push(property);\n\t\t\t}\n\t\t});\n\t\tconst query: Query = {\n\t\t\t$format: \"json\",\n\t\t\t$select: select.join(\",\")\n\t\t};\n\t\tif (expand.size > 0) {\n\t\t\tquery.$expand = Array.from(expand).join(\",\");\n\t\t}\n\t\treturn query;\n\t}\n\n\tprivate createQueryV4(paths: Set<string>): Query {\n\t\tconst node: QueryNode = {\n\t\t\tname: \"\",\n\t\t\t$select: new Set(),\n\t\t\t$expand: new Map()\n\t\t};\n\t\tpaths.forEach((property) => {\n\t\t\tconst parts: string[] = property.split(\"/\");\n\t\t\tconst propertyMetaPath = this.contextMetaPath.getMetaPathForPath(property);\n\t\t\tconst navigationProperties = propertyMetaPath?.getNavigationProperties() ?? [];\n\t\t\tthis.processPathRecursiveV4(parts, node, navigationProperties);\n\t\t});\n\t\tconst query: Query = {\n\t\t\t$format: \"json\",\n\t\t\t$select: Array.from(node.$select).join(\",\")\n\t\t};\n\t\tif (node.$expand.size > 0) {\n\t\t\tquery.$expand = Array.from(node.$expand.values()).map(serializeExpandV4Recursive).join(\",\");\n\t\t}\n\t\treturn query;\n\t}\n\n\tprivate processPathRecursiveV4(\n\t\tparts: Array<string>,\n\t\tparentNode: QueryNode,\n\t\tnavigationProperties: ReadonlyArray<NavigationProperty>\n\t): void {\n\t\tlet node: QueryNode | undefined;\n\t\tconst name = parts[0];\n\t\tif (name && this.isNavigationProperty(name, navigationProperties)) {\n\t\t\tnode = parentNode.$expand.get(name);\n\t\t\tif (!node) {\n\t\t\t\tnode = {\n\t\t\t\t\tname,\n\t\t\t\t\t$select: new Set(),\n\t\t\t\t\t$expand: new Map()\n\t\t\t\t};\n\t\t\t}\n\t\t\tparentNode.$expand.set(name, node);\n\t\t\tif (parts.length === 2) {\n\t\t\t\tnode.$select.add(parts[1] ?? \"\");\n\t\t\t} else {\n\t\t\t\tthis.processPathRecursiveV4(parts.slice(1), node, navigationProperties.slice(1));\n\t\t\t}\n\t\t} else {\n\t\t\tparentNode.$select.add(parts.join(\"/\"));\n\t\t}\n\t}\n\n\tprivate isNavigationProperty(property: string, navigationProperties: ReadonlyArray<NavigationProperty>): boolean {\n\t\tconst navigationPropertyOffset = this.contextMetaPath.getNavigationProperties().length;\n\t\treturn navigationProperties.length > navigationPropertyOffset && property === navigationProperties[navigationPropertyOffset]?.name;\n\t}\n}\n\nexport type Query = {\n\t$select: string;\n\t$expand?: string;\n\t$format: \"json\";\n};\n\ntype QueryNode = {\n\tname: string;\n\t$select: Set<string>;\n\t$expand: Map<string, QueryNode>;\n};\n\nfunction serializeExpandV4Recursive(expandNode: QueryNode): string {\n\tconst select = serializeSelect(expandNode.$select);\n\tconst expandValue = Array.from(expandNode.$expand.values()).map(serializeExpandV4Recursive).join(\",\");\n\tconst expand = expandValue.length > 0 ? `$expand=${expandValue}` : \"\";\n\tconst separator = select.length > 0 && expand.length > 0 ? \";\" : \"\";\n\treturn `${expandNode.name}(${select}${separator}${expand})`;\n}\n\nfunction serializeSelect(fields: Set<string>): string {\n\treturn fields.size > 0 ? `$select=${Array.from(fields).join(\",\")}` : \"\";\n}\n","import type { DynamicAnnotationExpression, Property } from \"@sap-ux/vocabularies-types\";\nimport type { DataFieldForAnnotationTypes, DataFieldTypes, FieldGroup } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { TextArrangementType, UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type MetaPath from \"../../../MetaPath\";\nimport type { Expression, PathInModelExpression, PrimitiveType } from \"../../../utils/Expression\";\nimport { concat, formatResult, getExpressionFromAnnotation, transformRecursively, unresolvableExpression } from \"../../../utils/Expression\";\nimport formatters from \"../../../utils/Formatters\";\nimport { isAnnotationOfType, isPathAnnotationExpression } from \"../../../utils/TypeGuards\";\n\nexport class _DataField {\n\tconstructor(\n\t\tprivate readonly dataField: DataFieldTypes | DataFieldForAnnotationTypes,\n\t\tprivate readonly scopedContextMetaPath: MetaPath<unknown>\n\t) {}\n\n\tgetValue(): Expression<PrimitiveType> {\n\t\tif (!isAnnotationOfType<DataFieldForAnnotationTypes>(this.dataField, UIAnnotationTypes.DataFieldForAnnotation)) {\n\t\t\treturn getExpressionFromAnnotation<PrimitiveType>(this.dataField.Value as DynamicAnnotationExpression<PrimitiveType>);\n\t\t}\n\t\treturn unresolvableExpression;\n\t}\n\n\tgetFormattedValue(): Expression<PrimitiveType> {\n\t\tif (!isAnnotationOfType<DataFieldForAnnotationTypes>(this.dataField, UIAnnotationTypes.DataFieldForAnnotation)) {\n\t\t\t// Compute display mode and then return the formatted value\n\t\t\t// Also consider units and currency\n\t\t\tconst targetValue = getExpressionFromAnnotation(\n\t\t\t\tthis.dataField.Value as DynamicAnnotationExpression<PrimitiveType>,\n\t\t\t\tthis.scopedContextMetaPath.getNavigationProperties().map((navProp) => navProp.name)\n\t\t\t);\n\t\t\treturn transformRecursively(targetValue, \"PathInModel\", (value: PathInModelExpression<unknown>): Expression<PrimitiveType> => {\n\t\t\t\tconst propertyMetaPath = this.scopedContextMetaPath.getMetaPathForPath<Property>(value.ownPath);\n\t\t\t\tif (!propertyMetaPath) {\n\t\t\t\t\treturn unresolvableExpression;\n\t\t\t\t}\n\n\t\t\t\tconst measure = this.getMeasure(propertyMetaPath);\n\t\t\t\tif (measure) {\n\t\t\t\t\treturn concat(value, \" \", measure);\n\t\t\t\t}\n\n\t\t\t\tconst displayMode = this.getDisplayMode(propertyMetaPath);\n\t\t\t\tif (displayMode !== \"Value\") {\n\t\t\t\t\tconst text = getExpressionFromAnnotation(\n\t\t\t\t\t\tpropertyMetaPath.getTarget().annotations.Common?.Text,\n\t\t\t\t\t\tpropertyMetaPath.getNavigationProperties().map((navProp) => navProp.name)\n\t\t\t\t\t);\n\t\t\t\t\tif (displayMode === \"Description\") {\n\t\t\t\t\t\treturn text;\n\t\t\t\t\t} else if (displayMode === \"DescriptionValue\") {\n\t\t\t\t\t\treturn formatResult([text, value], formatters.formatWithBrackets);\n\t\t\t\t\t} else if (displayMode === \"ValueDescription\") {\n\t\t\t\t\t\treturn formatResult([value, text], formatters.formatWithBrackets);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}) as Expression<PrimitiveType>;\n\t\t}\n\t\treturn unresolvableExpression;\n\t}\n\n\t/**\n\t * Checks if the given property has a Unit or ISOCurrency annotation and returns it.\n\t *\n\t * @param property property to get the measure for\n\t * @returns the measure annotation or undefined\n\t */\n\tgetMeasure(property: MetaPath<Property>): Expression<string> | undefined {\n\t\tconst measures = property.getTarget().annotations.Measures;\n\t\tif (measures) {\n\t\t\tconst measure = measures.Unit ?? measures.ISOCurrency;\n\t\t\tif (measure) {\n\t\t\t\treturn getExpressionFromAnnotation(measure);\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tgetDisplayMode(property: MetaPath<Property>): \"Description\" | \"Value\" | \"DescriptionValue\" | \"ValueDescription\" {\n\t\tconst currentEntityType = property.getClosestEntityType();\n\t\tconst textAnnotation = property.getTarget().annotations.Common?.Text;\n\t\tconst textArrangement = textAnnotation?.annotations?.UI?.TextArrangement ?? currentEntityType.annotations.UI?.TextArrangement;\n\n\t\tlet displayMode: \"Description\" | \"Value\" | \"DescriptionValue\" | \"ValueDescription\" = textAnnotation ? \"DescriptionValue\" : \"Value\";\n\t\tif (textAnnotation && textArrangement != null) {\n\t\t\tif (textArrangement === TextArrangementType.TextOnly) {\n\t\t\t\tdisplayMode = \"Description\";\n\t\t\t} else if (textArrangement === TextArrangementType.TextLast) {\n\t\t\t\tdisplayMode = \"ValueDescription\";\n\t\t\t} else if (textArrangement === TextArrangementType.TextSeparate) {\n\t\t\t\tdisplayMode = \"Value\";\n\t\t\t} else {\n\t\t\t\t//Default should be TextFirst if there is a Text annotation and neither TextOnly nor TextLast are set\n\t\t\t\tdisplayMode = \"DescriptionValue\";\n\t\t\t}\n\t\t}\n\t\treturn displayMode;\n\t}\n\n\tgetLabel(): string {\n\t\tlet label = this.dataField.Label?.toString() ?? this.dataField.annotations?.Common?.Label?.toString();\n\t\tif (!label) {\n\t\t\tlabel = this.dataField.fullyQualifiedName; // Fallback to the fully qualified name\n\t\t\tif (isAnnotationOfType<DataFieldForAnnotationTypes>(this.dataField, UIAnnotationTypes.DataFieldForAnnotation)) {\n\t\t\t\tconst target = this.dataField.Target.$target;\n\t\t\t\tif (isAnnotationOfType<FieldGroup>(target, UIAnnotationTypes.FieldGroupType) && target.Label) {\n\t\t\t\t\tlabel = target.Label.toString();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst valueTarget = this.dataField.Value as DynamicAnnotationExpression<unknown>;\n\t\t\t\tif (isPathAnnotationExpression(valueTarget)) {\n\t\t\t\t\tlabel = valueTarget.$target?.annotations.Common?.Label?.toString() ?? valueTarget.$target?.name ?? valueTarget.path;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn label;\n\t}\n\n\t/**\n\t * Retrieve a property from the data field IF it can be easily determined (no complex exression)\n\t */\n\tgetProperty(): Property | undefined {\n\t\tif (!isAnnotationOfType<DataFieldForAnnotationTypes>(this.dataField, UIAnnotationTypes.DataFieldForAnnotation)) {\n\t\t\tconst valueTarget = this.dataField.Value as DynamicAnnotationExpression<unknown> | undefined;\n\t\t\tif (valueTarget && isPathAnnotationExpression(valueTarget)) {\n\t\t\t\treturn valueTarget.$target;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tgetFullyQualifiedName(): string {\n\t\treturn this.dataField.fullyQualifiedName;\n\t}\n}\n","import type { HeaderInfo } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { type DataFieldTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type MetaPath from \"../../../MetaPath\";\nimport type { PageTargetEntity } from \"../../../floorplans/DefinitionPage\";\nimport { _DataField } from \"./_DataField\";\n\nexport class _HeaderInfo {\n\tconstructor(\n\t\tprotected readonly info: HeaderInfo,\n\t\tprotected readonly pageMetaPath: MetaPath<PageTargetEntity>\n\t) {}\n\n\tgetFullyQualifiedName(): string {\n\t\treturn this.info.fullyQualifiedName;\n\t}\n\n\tgetTitle(): _DataField | undefined {\n\t\treturn this.info.Title ? new _DataField(this.info.Title as DataFieldTypes, this.pageMetaPath) : undefined;\n\t}\n\n\tgetDescription(): _DataField | undefined {\n\t\treturn this.info.Description ? new _DataField(this.info.Description as DataFieldTypes, this.pageMetaPath) : undefined;\n\t}\n\n\tgetTypeName(): string {\n\t\t// eslint-disable-next-line @typescript-eslint/no-base-to-string\n\t\treturn this.info.TypeName.toString();\n\t}\n}\n","import {\n\tUIAnnotationTypes,\n\ttype DataFieldTypes,\n\ttype Identification,\n\ttype ImportanceType\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type MetaPath from \"../../../MetaPath\";\nimport type { PageTargetEntity } from \"../../../floorplans/DefinitionPage\";\nimport { _DataField } from \"./_DataField\";\n\nexport class _Identification {\n\tconstructor(\n\t\tprotected readonly id: Identification,\n\t\tprotected readonly pageMetaPath: MetaPath<PageTargetEntity>\n\t) {}\n\n\tgetDataFields(options?: { importance?: ImportanceType[]; restrictTypes?: string[] }): _DataField[] {\n\t\treturn this.id\n\t\t\t.filter((item): item is DataFieldTypes => {\n\t\t\t\tif (options?.restrictTypes && !options.restrictTypes.includes(item.$Type)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tswitch (item.$Type) {\n\t\t\t\t\tcase UIAnnotationTypes.DataField:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithAction:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithActionGroup:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithIntentBasedNavigation:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForAction:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForIntentBasedNavigation:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForActionGroup:\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\toptions?.importance === undefined ||\n\t\t\t\t\t\t\toptions.importance.includes(item.annotations?.UI?.Importance?.toString() as ImportanceType)\n\t\t\t\t\t\t);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.map((item) => {\n\t\t\t\treturn new _DataField(item, this.pageMetaPath);\n\t\t\t});\n\t}\n}\n","import type {\n\tDataFieldForAction,\n\tDataFieldTypes,\n\tImportanceType,\n\tLineItem,\n\tPresentationVariant,\n\tSelectionPresentationVariant\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTerms, UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type MetaPath from \"../../../MetaPath\";\nimport type { PageTargetEntity } from \"../../../floorplans/DefinitionPage\";\nimport { _DataField } from \"./_DataField\";\n\nexport class _LineItem {\n\tconstructor(\n\t\tprivate readonly lineItem: LineItem,\n\t\tprivate readonly pageMetaPath: MetaPath<PageTargetEntity>\n\t) {}\n\n\tstatic createDefault(pageMetaPath: MetaPath<PageTargetEntity>): _LineItem {\n\t\tconst fakeLineItemAnnotation: LineItem = pageMetaPath.getClosestEntityType().entityProperties.map((prop) => {\n\t\t\tif (prop.annotations.UI?.DataFieldDefault) {\n\t\t\t\treturn prop.annotations.UI.DataFieldDefault;\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\t$Type: UIAnnotationTypes.DataField,\n\t\t\t\t\tValue: {\n\t\t\t\t\t\ttype: \"Path\",\n\t\t\t\t\t\tpath: prop.name,\n\t\t\t\t\t\t$target: prop\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}) as LineItem;\n\t\tfakeLineItemAnnotation.term = UIAnnotationTerms.LineItem;\n\t\treturn new _LineItem(fakeLineItemAnnotation, pageMetaPath);\n\t}\n\n\tstatic fromSPV(\n\t\tspv: LineItem | PresentationVariant | SelectionPresentationVariant | undefined,\n\t\tpageMetaPath: MetaPath<PageTargetEntity>\n\t): _LineItem | undefined {\n\t\tswitch (spv?.term) {\n\t\t\tcase UIAnnotationTerms.LineItem:\n\t\t\t\treturn new _LineItem(spv, pageMetaPath);\n\t\t\tcase UIAnnotationTerms.PresentationVariant:\n\t\t\t\treturn new _LineItem(spv.Visualizations[0]!.$target as LineItem, pageMetaPath);\n\t\t\tcase UIAnnotationTerms.SelectionPresentationVariant:\n\t\t\t\treturn new _LineItem(spv.PresentationVariant.Visualizations[0]!.$target as LineItem, pageMetaPath);\n\t\t\tcase undefined:\n\t\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tgetActions(): DataFieldForAction[] {\n\t\treturn this.lineItem.filter((item): item is DataFieldForAction => item.$Type === UIAnnotationTypes.DataFieldForAction);\n\t}\n\n\tgetHeaderActions(): DataFieldForAction[] {\n\t\treturn this.getActions().filter((action) => action.Determining === true);\n\t}\n\n\tgetDataFields(options?: { importance?: ImportanceType[]; restrictTypes?: string[] }): _DataField[] {\n\t\treturn this.lineItem\n\t\t\t.filter((item): item is DataFieldTypes => {\n\t\t\t\tif (options?.restrictTypes && !options.restrictTypes.includes(item.$Type)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tswitch (item.$Type) {\n\t\t\t\t\tcase UIAnnotationTypes.DataField:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithAction:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithActionGroup:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithIntentBasedNavigation:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForAction:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForIntentBasedNavigation:\n\t\t\t\t\tcase UIAnnotationTypes.DataFieldForActionGroup:\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\toptions?.importance === undefined ||\n\t\t\t\t\t\t\toptions.importance.includes(item.annotations?.UI?.Importance?.toString() as ImportanceType)\n\t\t\t\t\t\t);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.map((item) => {\n\t\t\t\treturn new _DataField(item, this.pageMetaPath);\n\t\t\t});\n\t}\n}\n","import type {\n\tAndAnnotationExpression,\n\tAndConditionalExpression,\n\tApplyAnnotationExpression,\n\tBoolean,\n\tConditionalCheckOrValue,\n\tEntitySet,\n\tEntityType,\n\tEqAnnotationExpression,\n\tEqConditionalExpression,\n\tGeAnnotationExpression,\n\tGeConditionalExpression,\n\tGtAnnotationExpression,\n\tGtConditionalExpression,\n\tIfAnnotationExpression,\n\tIfAnnotationExpressionValue,\n\tLeAnnotationExpression,\n\tLeConditionalExpression,\n\tLtAnnotationExpression,\n\tLtConditionalExpression,\n\tNeAnnotationExpression,\n\tNeConditionalExpression,\n\tNotAnnotationExpression,\n\tNotConditionalExpression,\n\tOrAnnotationExpression,\n\tOrConditionalExpression,\n\tPathAnnotationExpression,\n\tPathConditionExpression,\n\tProperty,\n\tPropertyAnnotationValue,\n\tConstantExpression as VocabularyConstantExpression\n} from \"@sap-ux/vocabularies-types\";\nimport { CommonAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\n\nexport type PrimitiveType = string | number | bigint | boolean | object | null | undefined;\ntype DefinedPrimitiveType = string | number | bigint | boolean | object;\n// eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\ntype PrimitiveTypeCast<P> = P extends String ? string : P extends Boolean ? boolean : P extends Number ? number : P;\ntype BaseExpression<_T> = {\n\t_type: string;\n};\n\nexport type FormatOptions = Partial<{\n\tcustomUnits: Record<string, object>;\n\tcustomCurrencies: Record<string, object>;\n\tdecimals: number;\n\temptyString: null | number | string;\n\tfiscalType: string;\n\tgroupingEnabled: boolean;\n\tmaxFractionDigits: number;\n\tmaxIntegerDigits: number;\n\tminFractionDigits: number;\n\tminIntegerDigits: number;\n\tparseAsString: boolean;\n\tparseKeepsEmptyString: boolean;\n\tpattern: string;\n\tprecision: number;\n\tpreserveDecimals: boolean;\n\tshortDecimals: number;\n\tshortRefNumber: number;\n\tshowMeasure: boolean;\n\tshowNumber: boolean;\n\tshowScale: boolean;\n\tstyle: string;\n}>;\n\nexport type ConstantExpression<T> = BaseExpression<T> & {\n\t_type: \"Constant\";\n\tvalue: T;\n};\n\ntype SetOperator = \"&&\" | \"||\";\nexport type SetExpression = BaseExpression<boolean> & {\n\t_type: \"Set\";\n\toperator: SetOperator;\n\toperands: Expression<boolean>[];\n};\n\nexport type NotExpression = BaseExpression<boolean> & {\n\t_type: \"Not\";\n\toperand: Expression<boolean>;\n};\n\nexport type TruthyExpression = BaseExpression<boolean> & {\n\t_type: \"Truthy\";\n\toperand: Expression<string>;\n};\n\nexport type ReferenceExpression = BaseExpression<object> & {\n\t_type: \"Ref\";\n\tref: string | null;\n};\n\nexport type FormatterExpression<T> = BaseExpression<T> & {\n\t_type: \"Formatter\";\n\tfn: string;\n\tparameters: Expression<unknown>[];\n};\n\ntype ComplexTypeExpression<T> = BaseExpression<T> & {\n\t_type: \"ComplexType\";\n\ttype: string;\n\tformatOptions: FormatOptions;\n\tparameters: object;\n\tbindingParameters: Expression<unknown>[];\n};\n\nexport type FunctionExpression<T> = BaseExpression<T> & {\n\t_type: \"Function\";\n\tobj?: Expression<object>;\n\tfn: string;\n\tisFormattingFn: boolean;\n\tparameters: Expression<unknown>[];\n};\n\nexport type ConcatExpression = BaseExpression<string> & {\n\t_type: \"Concat\";\n\texpressions: Expression<string>[];\n};\n\nexport type LengthExpression = BaseExpression<string> & {\n\t_type: \"Length\";\n\tpathInModel: PathInModelExpression<unknown>;\n};\n\ntype UnresolvablePathExpression = BaseExpression<string> & {\n\t_type: \"Unresolvable\";\n};\n\n/**\n */\nexport type PathInModelExpression<T> = BaseExpression<T> & {\n\t_type: \"PathInModel\";\n\townPath: string;\n\tmodelName?: string;\n\tpath: string;\n\ttargetEntitySet?: EntitySet;\n\ttype?: string;\n\tparameters?: object;\n\ttargetType?: string;\n\tmode?: string;\n\tformatOptions?: FormatOptions;\n};\n\nexport type EmbeddedUI5BindingExpression<T> = BaseExpression<T> & {\n\t_type: \"EmbeddedBinding\";\n\tvalue: string;\n};\n\nexport type EmbeddedUI5ExpressionBindingExpression<T> = BaseExpression<T> & {\n\t_type: \"EmbeddedExpressionBinding\";\n\tvalue: string;\n};\n\nexport type ComparisonOperator = \"===\" | \"!==\" | \">=\" | \">\" | \"<=\" | \"<\";\nexport type ComparisonExpression = BaseExpression<boolean> & {\n\t_type: \"Comparison\";\n\toperator: ComparisonOperator;\n\toperand1: Expression<unknown>;\n\toperand2: Expression<unknown>;\n};\n\nexport type IfElseExpression<T> = BaseExpression<T> & {\n\t_type: \"IfElse\";\n\tcondition: Expression<boolean>;\n\tonTrue: Expression<T>;\n\tonFalse: Expression<T>;\n};\n\n/**\n * An expression that evaluates to type T.\n *\n */\nexport type Expression<T> =\n\t| UnresolvablePathExpression\n\t| ConstantExpression<T>\n\t| SetExpression\n\t| NotExpression\n\t| TruthyExpression\n\t| ConcatExpression\n\t| LengthExpression\n\t| PathInModelExpression<T>\n\t| EmbeddedUI5BindingExpression<T>\n\t| EmbeddedUI5ExpressionBindingExpression<T>\n\t| ComparisonExpression\n\t| IfElseExpression<T>\n\t| FormatterExpression<T>\n\t| ComplexTypeExpression<T>\n\t| ReferenceExpression\n\t| FunctionExpression<T>;\n\n/**\n * An expression that evaluates to type T, or a constant value of type T\n */\nexport type ExpressionOrPrimitive<T extends PrimitiveType> = Expression<T> | T;\n\nexport const unresolvableExpression: UnresolvablePathExpression = {\n\t_type: \"Unresolvable\"\n};\n\nexport function hasUnresolvableExpression(...expressions: Expression<unknown>[]): boolean {\n\treturn expressions.find((expr) => expr._type === \"Unresolvable\") !== undefined;\n}\n/**\n * Check two expressions for (deep) equality.\n *\n * @param a\n * @param b\n * @returns `true` if the two expressions are equal\n */\nexport function _checkExpressionsAreEqual<T>(a?: Expression<T>, b?: Expression<T>): boolean {\n\tif (!a || !b) {\n\t\treturn false;\n\t}\n\tif (a._type !== b._type) {\n\t\treturn false;\n\t}\n\n\tswitch (a._type) {\n\t\tcase \"Unresolvable\":\n\t\t\treturn false; // Unresolvable is never equal to anything even itself\n\t\tcase \"Constant\":\n\t\tcase \"EmbeddedBinding\":\n\t\tcase \"EmbeddedExpressionBinding\":\n\t\t\treturn a.value === (b as ConstantExpression<T>).value;\n\n\t\tcase \"Not\":\n\t\t\treturn _checkExpressionsAreEqual(a.operand, (b as NotExpression).operand);\n\t\tcase \"Truthy\":\n\t\t\treturn _checkExpressionsAreEqual(a.operand, (b as TruthyExpression).operand);\n\t\tcase \"Set\":\n\t\t\treturn (\n\t\t\t\ta.operator === (b as SetExpression).operator &&\n\t\t\t\ta.operands.length === (b as SetExpression).operands.length &&\n\t\t\t\ta.operands.every((expression) =>\n\t\t\t\t\t(b as SetExpression).operands.some((otherExpression) => _checkExpressionsAreEqual(expression, otherExpression))\n\t\t\t\t)\n\t\t\t);\n\n\t\tcase \"IfElse\":\n\t\t\treturn (\n\t\t\t\t_checkExpressionsAreEqual(a.condition, (b as IfElseExpression<T>).condition) &&\n\t\t\t\t_checkExpressionsAreEqual(a.onTrue, (b as IfElseExpression<T>).onTrue) &&\n\t\t\t\t_checkExpressionsAreEqual(a.onFalse, (b as IfElseExpression<T>).onFalse)\n\t\t\t);\n\n\t\tcase \"Comparison\":\n\t\t\treturn (\n\t\t\t\ta.operator === (b as ComparisonExpression).operator &&\n\t\t\t\t_checkExpressionsAreEqual(a.operand1, (b as ComparisonExpression).operand1) &&\n\t\t\t\t_checkExpressionsAreEqual(a.operand2, (b as ComparisonExpression).operand2)\n\t\t\t);\n\n\t\tcase \"Concat\": {\n\t\t\tconst aExpressions = a.expressions;\n\t\t\tconst bExpressions = (b as ConcatExpression).expressions;\n\t\t\tif (aExpressions.length !== bExpressions.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn aExpressions.every((expression, index) => {\n\t\t\t\treturn _checkExpressionsAreEqual(expression, bExpressions[index]);\n\t\t\t});\n\t\t}\n\n\t\tcase \"Length\":\n\t\t\treturn _checkExpressionsAreEqual(a.pathInModel, (b as LengthExpression).pathInModel);\n\n\t\tcase \"PathInModel\":\n\t\t\treturn (\n\t\t\t\ta.modelName === (b as PathInModelExpression<T>).modelName &&\n\t\t\t\ta.path === (b as PathInModelExpression<T>).path &&\n\t\t\t\ta.targetEntitySet === (b as PathInModelExpression<T>).targetEntitySet\n\t\t\t);\n\n\t\tcase \"Formatter\":\n\t\t\treturn (\n\t\t\t\ta.fn === (b as FormatterExpression<T>).fn &&\n\t\t\t\ta.parameters.length === (b as FormatterExpression<T>).parameters.length &&\n\t\t\t\ta.parameters.every((value, index) => _checkExpressionsAreEqual((b as FormatterExpression<T>).parameters[index], value))\n\t\t\t);\n\t\tcase \"ComplexType\":\n\t\t\treturn (\n\t\t\t\ta.type === (b as ComplexTypeExpression<T>).type &&\n\t\t\t\ta.bindingParameters.length === (b as ComplexTypeExpression<T>).bindingParameters.length &&\n\t\t\t\ta.bindingParameters.every((value, index) =>\n\t\t\t\t\t_checkExpressionsAreEqual((b as ComplexTypeExpression<T>).bindingParameters[index], value)\n\t\t\t\t)\n\t\t\t);\n\t\tcase \"Function\":\n\t\t\tconst otherFunction = b as FunctionExpression<T>;\n\t\t\tif (a.obj === undefined || otherFunction.obj === undefined) {\n\t\t\t\treturn a.obj === otherFunction;\n\t\t\t}\n\n\t\t\treturn (\n\t\t\t\ta.fn === otherFunction.fn &&\n\t\t\t\t_checkExpressionsAreEqual(a.obj, otherFunction.obj) &&\n\t\t\t\ta.parameters.length === otherFunction.parameters.length &&\n\t\t\t\ta.parameters.every((value, index) => _checkExpressionsAreEqual(otherFunction.parameters[index], value))\n\t\t\t);\n\n\t\tcase \"Ref\":\n\t\t\treturn a.ref === (b as ReferenceExpression).ref;\n\t}\n\treturn false;\n}\n\n/**\n * Converts a nested SetExpression by inlining operands of type SetExpression with the same operator.\n *\n * @param expression The expression to flatten\n * @returns A new SetExpression with the same operator\n */\nfunction flattenSetExpression(expression: SetExpression): SetExpression {\n\treturn expression.operands.reduce<SetExpression>(\n\t\t(result: SetExpression, operand) => {\n\t\t\tconst candidatesForFlattening =\n\t\t\t\toperand._type === \"Set\" && operand.operator === expression.operator ? operand.operands : [operand];\n\t\t\tcandidatesForFlattening.forEach((candidate) => {\n\t\t\t\tif (result.operands.every((e) => !_checkExpressionsAreEqual(e, candidate))) {\n\t\t\t\t\tresult.operands.push(candidate);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn result;\n\t\t},\n\t\t{ _type: \"Set\", operator: expression.operator, operands: [] }\n\t);\n}\n\n/**\n * Detects whether an array of boolean expressions contains an expression and its negation.\n *\n * @param expressions Array of expressions\n * @returns `true` if the set of expressions contains an expression and its negation\n */\nfunction hasOppositeExpressions(expressions: Expression<boolean>[]): boolean {\n\tconst negatedExpressions = expressions.map(not);\n\treturn expressions.some((expression, index) => {\n\t\tfor (let i = index + 1; i < negatedExpressions.length; i++) {\n\t\t\tif (_checkExpressionsAreEqual(expression, negatedExpressions[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t});\n}\n\n/**\n * Logical `and` expression.\n *\n * The expression is simplified to false if this can be decided statically (that is, if one operand is a constant\n * false or if the expression contains an operand and its negation).\n *\n * @param operands Expressions to connect by `and`\n * @returns Expression evaluating to boolean\n */\nexport function and(...operands: ExpressionOrPrimitive<boolean>[]): Expression<boolean> {\n\tconst expressions = flattenSetExpression({\n\t\t_type: \"Set\",\n\t\toperator: \"&&\",\n\t\toperands: operands.map(wrapPrimitive)\n\t}).operands;\n\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet isStaticFalse = false;\n\tconst nonTrivialExpression = expressions.filter((expression) => {\n\t\tif (isFalse(expression)) {\n\t\t\tisStaticFalse = true;\n\t\t}\n\t\treturn !isConstant(expression);\n\t});\n\tif (isStaticFalse) {\n\t\treturn constant(false);\n\t} else if (nonTrivialExpression.length === 0) {\n\t\t// Resolve the constant then\n\t\tconst isValid = expressions.reduce((result, expression) => result && isTrue(expression), true);\n\t\treturn constant(isValid);\n\t} else if (nonTrivialExpression.length === 1) {\n\t\treturn nonTrivialExpression[0]!;\n\t} else if (hasOppositeExpressions(nonTrivialExpression)) {\n\t\treturn constant(false);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Set\",\n\t\t\toperator: \"&&\",\n\t\t\toperands: nonTrivialExpression\n\t\t};\n\t}\n}\n\n// let tracer: any;\n// export function traceExpression(inTracer: never): void {\n// \ttracer = inTracer;\n// }\n//\n// export function pickFirstNonNull(\n// \t...operands: ExpressionOrPrimitive<PrimitiveType>[]\n// ): ExpressionOrPrimitive<PrimitiveType> {\n// \tconst result = operands.find((operand) => operand !== undefined);\n// \tif (tracer) {\n// \t\ttracer.logConditional(\"pickFirstNonNull\", operands, result);\n// \t}\n// \treturn result;\n// }\n/**\n * Logical `or` expression.\n *\n * The expression is simplified to true if this can be decided statically (that is, if one operand is a constant\n * true or if the expression contains an operand and its negation).\n *\n * @param operands Expressions to connect by `or`\n * @returns Expression evaluating to boolean\n */\nexport function or(...operands: ExpressionOrPrimitive<boolean>[]): Expression<boolean> {\n\tconst expressions = flattenSetExpression({\n\t\t_type: \"Set\",\n\t\toperator: \"||\",\n\t\toperands: operands.map(wrapPrimitive)\n\t}).operands;\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet isStaticTrue = false;\n\tconst nonTrivialExpression = expressions.filter((expression) => {\n\t\tif (isTrue(expression)) {\n\t\t\tisStaticTrue = true;\n\t\t}\n\t\treturn !isConstant(expression) || expression.value;\n\t});\n\tif (isStaticTrue) {\n\t\treturn constant(true);\n\t} else if (nonTrivialExpression.length === 0) {\n\t\t// Resolve the constant then\n\t\tconst isValid = expressions.reduce((result, expression) => result && isTrue(expression), true);\n\t\treturn constant(isValid);\n\t} else if (nonTrivialExpression.length === 1) {\n\t\treturn nonTrivialExpression[0]!;\n\t} else if (hasOppositeExpressions(nonTrivialExpression)) {\n\t\treturn constant(true);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Set\",\n\t\t\toperator: \"||\",\n\t\t\toperands: nonTrivialExpression\n\t\t};\n\t}\n}\n\n/**\n * Logical `not` operator.\n *\n * @param operand The expression to reverse\n * @returns The resulting expression that evaluates to boolean\n */\nexport function not(operand: ExpressionOrPrimitive<boolean>): Expression<boolean> {\n\toperand = wrapPrimitive(operand);\n\tif (hasUnresolvableExpression(operand)) {\n\t\treturn unresolvableExpression;\n\t} else if (isConstant(operand)) {\n\t\treturn constant(!operand.value);\n\t} else if (\n\t\ttypeof operand === \"object\" &&\n\t\toperand._type === \"Set\" &&\n\t\toperand.operator === \"||\" &&\n\t\toperand.operands.every((expression) => isConstant(expression) || isComparison(expression))\n\t) {\n\t\treturn and(...operand.operands.map((expression) => not(expression)));\n\t} else if (\n\t\ttypeof operand === \"object\" &&\n\t\toperand._type === \"Set\" &&\n\t\toperand.operator === \"&&\" &&\n\t\toperand.operands.every((expression) => isConstant(expression) || isComparison(expression))\n\t) {\n\t\treturn or(...operand.operands.map((expression) => not(expression)));\n\t} else if (isComparison(operand)) {\n\t\t// Create the reverse comparison\n\t\tswitch (operand.operator) {\n\t\t\tcase \"!==\":\n\t\t\t\treturn { ...operand, operator: \"===\" };\n\t\t\tcase \"<\":\n\t\t\t\treturn { ...operand, operator: \">=\" };\n\t\t\tcase \"<=\":\n\t\t\t\treturn { ...operand, operator: \">\" };\n\t\t\tcase \"===\":\n\t\t\t\treturn { ...operand, operator: \"!==\" };\n\t\t\tcase \">\":\n\t\t\t\treturn { ...operand, operator: \"<=\" };\n\t\t\tcase \">=\":\n\t\t\t\treturn { ...operand, operator: \"<\" };\n\t\t}\n\t} else if (operand._type === \"Not\") {\n\t\treturn operand.operand;\n\t}\n\n\treturn {\n\t\t_type: \"Not\",\n\t\toperand: operand\n\t};\n}\n\n/**\n * Evaluates whether a binding expression is equal to true with a loose equality.\n *\n * @param operand The expression to check\n * @returns The resulting expression that evaluates to boolean\n */\nexport function isTruthy(operand: Expression<string>): Expression<boolean> {\n\tif (isConstant(operand)) {\n\t\treturn constant(!!operand.value);\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Truthy\",\n\t\t\toperand: operand\n\t\t};\n\t}\n}\n\n/**\n * Creates a binding expression that will be evaluated by the corresponding model.\n *\n * @param path\n * @param modelName\n * @param visitedNavigationPaths\n * @param pathVisitor\n * @returns An expression representating that path in the model\n */\nexport function objectPath<TargetType extends PrimitiveType>(\n\tpath: string,\n\tmodelName?: string,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): PathInModelExpression<TargetType> | UnresolvablePathExpression {\n\treturn pathInModel(path, modelName, visitedNavigationPaths, pathVisitor);\n}\n\n/**\n * Creates a binding expression that will be evaluated by the corresponding model.\n *\n * @template TargetType\n * @param path The path on the model\n * @param [modelName] The name of the model\n * @param [visitedNavigationPaths] The paths from the root entitySet\n * @param [pathVisitor] A function to modify the resulting path\n * @returns An expression representating that path in the model\n */\nexport function pathInModel(\n\tpath: undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: Function\n): UnresolvablePathExpression;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: undefined\n): PathInModelExpression<TargetType>;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string | undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths?: string[],\n\tpathVisitor?: Function\n): UnresolvablePathExpression | PathInModelExpression<TargetType>;\nexport function pathInModel<TargetType extends PrimitiveType>(\n\tpath: string | undefined,\n\tmodelName?: string,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): UnresolvablePathExpression | PathInModelExpression<TargetType> {\n\tif (path === undefined) {\n\t\treturn unresolvableExpression;\n\t}\n\tlet targetPath: string;\n\tif (pathVisitor) {\n\t\ttargetPath = pathVisitor(path) as string;\n\t\tif (targetPath === undefined) {\n\t\t\treturn unresolvableExpression;\n\t\t}\n\t} else {\n\t\tconst localPath = visitedNavigationPaths.concat();\n\t\tlocalPath.push(path);\n\t\ttargetPath = localPath.join(\"/\");\n\t}\n\treturn {\n\t\t_type: \"PathInModel\",\n\t\tmodelName: modelName,\n\t\tpath: targetPath,\n\t\townPath: path\n\t};\n}\n\ntype PlainExpressionObject = { [index: string]: Expression<unknown> };\n\n/**\n * Creates a constant expression based on a primitive value.\n *\n * @template T\n * @param value The constant to wrap in an expression\n * @returns The constant expression\n */\nexport function constant<T extends PrimitiveType>(value: T): ConstantExpression<T> {\n\tlet constantValue: T;\n\n\tif (typeof value === \"object\" && value !== null && value !== undefined) {\n\t\tif (Array.isArray(value)) {\n\t\t\tconstantValue = value.map(wrapPrimitive) as T;\n\t\t} else if (isPrimitiveObject(value)) {\n\t\t\tconstantValue = value.valueOf() as T;\n\t\t} else {\n\t\t\tconstantValue = Object.entries(value).reduce((plainExpression, [key, val]) => {\n\t\t\t\tconst wrappedValue = wrapPrimitive(val);\n\t\t\t\tif (wrappedValue._type !== \"Constant\" || wrappedValue.value !== undefined) {\n\t\t\t\t\tplainExpression[key as keyof typeof plainExpression] = wrappedValue as never;\n\t\t\t\t}\n\t\t\t\treturn plainExpression;\n\t\t\t}, {} satisfies PlainExpressionObject) as T;\n\t\t}\n\t} else {\n\t\tconstantValue = value;\n\t}\n\n\treturn { _type: \"Constant\", value: constantValue };\n}\n\nexport function resolveBindingString<T extends PrimitiveType>(\n\tvalue: string | boolean | number,\n\ttargetType?: string\n): ConstantExpression<T> | PathInModelExpression<T> | EmbeddedUI5BindingExpression<T> | EmbeddedUI5ExpressionBindingExpression<T> {\n\tif (value !== undefined && typeof value === \"string\" && value.startsWith(\"{\")) {\n\t\tconst pathInModelRegex = /^{(.*)>(.+)}$/; // Matches model paths like \"model>path\" or \">path\" (default model)\n\t\tconst pathInModelRegexMatch = pathInModelRegex.exec(value);\n\n\t\tif (value.startsWith(\"{=\")) {\n\t\t\t// Expression binding, we can just remove the outer binding things\n\t\t\treturn {\n\t\t\t\t_type: \"EmbeddedExpressionBinding\",\n\t\t\t\tvalue: value\n\t\t\t};\n\t\t} else if (pathInModelRegexMatch) {\n\t\t\treturn pathInModel(pathInModelRegexMatch[2] || \"\", pathInModelRegexMatch[1] || undefined);\n\t\t} else {\n\t\t\treturn {\n\t\t\t\t_type: \"EmbeddedBinding\",\n\t\t\t\tvalue: value\n\t\t\t};\n\t\t}\n\t} else if (targetType === \"boolean\" && typeof value === \"string\" && (value === \"true\" || value === \"false\")) {\n\t\treturn constant(value === \"true\") as ConstantExpression<T>;\n\t} else if (targetType === \"number\" && typeof value === \"string\" && (!isNaN(Number(value)) || value === \"NaN\")) {\n\t\treturn constant(Number(value)) as ConstantExpression<T>;\n\t} else {\n\t\treturn constant(value) as ConstantExpression<T>;\n\t}\n}\n\n/**\n * A named reference.\n *\n * @see fn\n * @param reference Reference\n * @returns The object reference binding part\n */\nexport function ref(reference: string | null): ReferenceExpression {\n\treturn { _type: \"Ref\", ref: reference };\n}\n\n/**\n * Wrap a primitive into a constant expression if it is not already an expression.\n *\n * @template T\n * @param something The object to wrap in a Constant expression\n * @returns Either the original object or the wrapped one depending on the case\n */\nexport function wrapPrimitive<T extends PrimitiveType>(something: ExpressionOrPrimitive<T>): Expression<T> {\n\tif (isExpression(something as Expression<T>)) {\n\t\treturn something as Expression<T>;\n\t}\n\n\treturn constant(something as T);\n}\n\n/**\n * Checks if the expression or value provided is a binding tooling expression or not.\n *\n * Every object having a property named `_type` of some value is considered an expression, even if there is actually\n * no such expression type supported.\n *\n * @param expression\n * @returns `true` if the expression is a binding toolkit expression\n */\nexport function isExpression<T = unknown>(expression: unknown): expression is Expression<T> {\n\treturn (expression as Expression<T> | undefined)?._type !== undefined;\n}\n\n/**\n * Checks if the expression or value provided is constant or not.\n *\n * @template T The target type\n * @param  maybeConstant The expression or primitive value that is to be checked\n * @returns `true` if it is constant\n */\nexport function isConstant<T extends PrimitiveType>(maybeConstant: ExpressionOrPrimitive<T>): maybeConstant is ConstantExpression<T> {\n\treturn typeof maybeConstant !== \"object\" || (maybeConstant as BaseExpression<T>)._type === \"Constant\";\n}\n\nfunction isTrue(expression: Expression<PrimitiveType>): boolean {\n\treturn isConstant(expression) && expression.value === true;\n}\n\nfunction isFalse(expression: Expression<PrimitiveType>): boolean {\n\treturn isConstant(expression) && expression.value === false;\n}\n\n/**\n * Checks if the expression or value provided is a path in model expression or not.\n *\n * @template T The target type\n * @param  maybeBinding The expression or primitive value that is to be checked\n * @returns `true` if it is a path in model expression\n */\nexport function isPathInModelExpression<T extends PrimitiveType>(\n\tmaybeBinding: ExpressionOrPrimitive<T>\n): maybeBinding is PathInModelExpression<T> {\n\treturn (maybeBinding as BaseExpression<T>)._type === \"PathInModel\";\n}\n\n/**\n * Checks if the expression or value provided is a complex type expression.\n *\n * @template T The target type\n * @param  maybeBinding The expression or primitive value that is to be checked\n * @returns `true` if it is a path in model expression\n */\nexport function isComplexTypeExpression<T extends PrimitiveType>(\n\tmaybeBinding: ExpressionOrPrimitive<T>\n): maybeBinding is ComplexTypeExpression<T> {\n\treturn (maybeBinding as BaseExpression<T>)._type === \"ComplexType\";\n}\n\n/**\n * Checks if the expression or value provided is a concat expression or not.\n *\n * @param expression\n * @returns `true` if the expression is a ConcatExpression\n */\nfunction isConcatExpression(expression: Expression<PrimitiveType>): expression is ConcatExpression {\n\treturn (expression as BaseExpression<PrimitiveType>)._type === \"Concat\";\n}\n\n/**\n * Checks if the expression or value provided is a IfElse expression or not.\n *\n * @param expression\n * @returns `true` if the expression is a IfElseExpression\n */\nfunction isIfElseExpression(expression: Expression<PrimitiveType>): expression is ConcatExpression {\n\treturn (expression as BaseExpression<PrimitiveType>)._type === \"IfElse\";\n}\n\n/**\n * Checks if the expression provided is a comparison or not.\n *\n * @template T The target type\n * @param expression The expression\n * @returns `true` if the expression is a ComparisonExpression\n */\nfunction isComparison<T extends PrimitiveType>(expression: Expression<T>): expression is ComparisonExpression {\n\treturn expression._type === \"Comparison\";\n}\n\n/**\n * Checks whether the input parameter is a constant expression of type undefined.\n *\n * @param expression The input expression or object in general\n * @returns `true` if the input is constant which has undefined for value\n */\nexport function isUndefinedExpression(expression: unknown): expression is ConstantExpression<undefined> {\n\tconst expressionAsExpression = expression as Expression<unknown>;\n\treturn expressionAsExpression._type === \"Constant\" && expressionAsExpression.value === undefined;\n}\n\ntype ComplexAnnotationExpression<P> =\n\t| PathAnnotationExpression<P>\n\t| ApplyAnnotationExpression<P>\n\t| IfAnnotationExpression<P>\n\t| OrAnnotationExpression<P>\n\t| AndAnnotationExpression<P>\n\t| NeAnnotationExpression<P>\n\t| EqAnnotationExpression<P>\n\t| NotAnnotationExpression<P>\n\t| GtAnnotationExpression<P>\n\t| GeAnnotationExpression<P>\n\t| LeAnnotationExpression<P>\n\t| LtAnnotationExpression<P>\n\t| VocabularyConstantExpression<P>;\n\nfunction isPrimitiveObject(objectType: object): boolean {\n\tswitch (objectType.constructor.name) {\n\t\tcase \"String\":\n\t\tcase \"Number\":\n\t\tcase \"Boolean\":\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n/**\n * Check if the passed annotation annotationValue is a ComplexAnnotationExpression.\n *\n * @template T The target type\n * @param  annotationValue The annotation annotationValue to evaluate\n * @returns `true` if the object is a {ComplexAnnotationExpression}\n */\nfunction isComplexAnnotationExpression<T>(annotationValue: PropertyAnnotationValue<T>): annotationValue is ComplexAnnotationExpression<T> {\n\treturn typeof annotationValue === \"object\" && !isPrimitiveObject(annotationValue as object);\n}\n\n/**\n * Generate the corresponding annotationValue for a given annotation annotationValue.\n *\n * @template T The target type\n * @param annotationValue The source annotation annotationValue\n * @param visitedNavigationPaths The path from the root entity set\n * @param defaultValue Default value if the annotationValue is undefined\n * @param pathVisitor A function to modify the resulting path\n * @returns The annotationValue equivalent to that annotation annotationValue\n */\nexport function getExpressionFromAnnotation<T extends PrimitiveType>(\n\tannotationValue: PropertyAnnotationValue<T> | undefined,\n\tvisitedNavigationPaths: string[] = [],\n\tdefaultValue?: ExpressionOrPrimitive<T>,\n\tpathVisitor?: Function\n): Expression<PrimitiveTypeCast<T>> {\n\tif (annotationValue === undefined) {\n\t\treturn wrapPrimitive(defaultValue as PrimitiveTypeCast<T>);\n\t}\n\tannotationValue = annotationValue.valueOf() as PropertyAnnotationValue<T>;\n\tif (!isComplexAnnotationExpression(annotationValue)) {\n\t\treturn constant(annotationValue);\n\t}\n\n\tswitch (annotationValue.type) {\n\t\tcase \"Path\":\n\t\t\treturn pathInModel(annotationValue.path, undefined, visitedNavigationPaths, pathVisitor);\n\t\tcase \"If\":\n\t\t\treturn annotationIfExpression(annotationValue.$If, visitedNavigationPaths, pathVisitor) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Not\":\n\t\t\treturn not(parseAnnotationCondition(annotationValue.$Not, visitedNavigationPaths, pathVisitor)) as Expression<\n\t\t\t\tPrimitiveTypeCast<T>\n\t\t\t>;\n\t\tcase \"Eq\":\n\t\t\treturn equal(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Eq[0]!, visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Eq[1]!, visitedNavigationPaths, pathVisitor)\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Ne\":\n\t\t\treturn notEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ne[0]!, visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ne[1]!, visitedNavigationPaths, pathVisitor)\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Gt\":\n\t\t\treturn greaterThan(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Gt[0]!, visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Gt[1]!, visitedNavigationPaths, pathVisitor)\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Ge\":\n\t\t\treturn greaterOrEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ge[0]!, visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Ge[1]!, visitedNavigationPaths, pathVisitor)\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Lt\":\n\t\t\treturn lessThan(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Lt[0]!, visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Lt[1]!, visitedNavigationPaths, pathVisitor)\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Le\":\n\t\t\treturn lessOrEqual(\n\t\t\t\tparseAnnotationCondition(annotationValue.$Le[0]!, visitedNavigationPaths, pathVisitor),\n\t\t\t\tparseAnnotationCondition(annotationValue.$Le[1]!, visitedNavigationPaths, pathVisitor)\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Or\":\n\t\t\treturn or(\n\t\t\t\t...annotationValue.$Or.map(function (orCondition) {\n\t\t\t\t\treturn parseAnnotationCondition<boolean>(orCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t\t})\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"And\":\n\t\t\treturn and(\n\t\t\t\t...annotationValue.$And.map(function (andCondition) {\n\t\t\t\t\treturn parseAnnotationCondition<boolean>(andCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t\t})\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Apply\":\n\t\t\treturn annotationApplyExpression(\n\t\t\t\tannotationValue as ApplyAnnotationExpression<string>,\n\t\t\t\tvisitedNavigationPaths,\n\t\t\t\tpathVisitor\n\t\t\t) as Expression<PrimitiveTypeCast<T>>;\n\t\tcase \"Constant\":\n\t\t\treturn constant(annotationValue.value as PrimitiveTypeCast<T>);\n\t}\n\treturn unresolvableExpression;\n}\n\n/**\n * Parse the annotation condition into an expression.\n *\n * @template T The target type\n * @param annotationValue The condition or value from the annotation\n * @param visitedNavigationPaths The path from the root entity set\n * @param pathVisitor A function to modify the resulting path\n * @returns An equivalent expression\n */\nfunction parseAnnotationCondition<T extends PrimitiveType>(\n\tannotationValue: ConditionalCheckOrValue,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): Expression<T> {\n\tif (annotationValue === null || typeof annotationValue !== \"object\") {\n\t\treturn constant(annotationValue as T);\n\t} else if (annotationValue.hasOwnProperty(\"$Or\")) {\n\t\treturn or(\n\t\t\t...((annotationValue as OrConditionalExpression).$Or.map(function (orCondition) {\n\t\t\t\treturn parseAnnotationCondition(orCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t}) as unknown as Expression<boolean>[])\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$And\")) {\n\t\treturn and(\n\t\t\t...((annotationValue as AndConditionalExpression).$And.map(function (andCondition) {\n\t\t\t\treturn parseAnnotationCondition(andCondition, visitedNavigationPaths, pathVisitor);\n\t\t\t}) as unknown as Expression<boolean>[])\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Not\")) {\n\t\treturn not(\n\t\t\tparseAnnotationCondition((annotationValue as NotConditionalExpression).$Not, visitedNavigationPaths, pathVisitor)\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Eq\")) {\n\t\treturn equal(\n\t\t\tparseAnnotationCondition((annotationValue as EqConditionalExpression).$Eq[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as EqConditionalExpression).$Eq[1], visitedNavigationPaths, pathVisitor)\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Ne\")) {\n\t\treturn notEqual(\n\t\t\tparseAnnotationCondition((annotationValue as NeConditionalExpression).$Ne[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as NeConditionalExpression).$Ne[1], visitedNavigationPaths, pathVisitor)\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Gt\")) {\n\t\treturn greaterThan(\n\t\t\tparseAnnotationCondition((annotationValue as GtConditionalExpression).$Gt[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as GtConditionalExpression).$Gt[1], visitedNavigationPaths, pathVisitor)\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Ge\")) {\n\t\treturn greaterOrEqual(\n\t\t\tparseAnnotationCondition((annotationValue as GeConditionalExpression).$Ge[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as GeConditionalExpression).$Ge[1], visitedNavigationPaths, pathVisitor)\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Lt\")) {\n\t\treturn lessThan(\n\t\t\tparseAnnotationCondition((annotationValue as LtConditionalExpression).$Lt[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as LtConditionalExpression).$Lt[1], visitedNavigationPaths, pathVisitor)\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Le\")) {\n\t\treturn lessOrEqual(\n\t\t\tparseAnnotationCondition((annotationValue as LeConditionalExpression).$Le[0], visitedNavigationPaths, pathVisitor),\n\t\t\tparseAnnotationCondition((annotationValue as LeConditionalExpression).$Le[1], visitedNavigationPaths, pathVisitor)\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$Path\")) {\n\t\treturn pathInModel((annotationValue as PathConditionExpression<T>).$Path, undefined, visitedNavigationPaths, pathVisitor);\n\t} else if (annotationValue.hasOwnProperty(\"Path\")) {\n\t\treturn pathInModel((annotationValue as unknown as { Path: string }).Path, undefined, visitedNavigationPaths, pathVisitor);\n\t} else if (annotationValue.hasOwnProperty(\"$Apply\")) {\n\t\treturn getExpressionFromAnnotation(\n\t\t\t{\n\t\t\t\ttype: \"Apply\",\n\t\t\t\t$Function: (annotationValue as { $Function?: string }).$Function as \"odata.concat\",\n\t\t\t\t$Apply: (annotationValue as { $Apply?: PropertyAnnotationValue<T>[] }).$Apply!\n\t\t\t} satisfies ApplyAnnotationExpression<T>,\n\t\t\tvisitedNavigationPaths,\n\t\t\tundefined,\n\t\t\tpathVisitor\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$If\")) {\n\t\treturn getExpressionFromAnnotation(\n\t\t\t{\n\t\t\t\ttype: \"If\",\n\t\t\t\t$If: (annotationValue as { $If?: IfAnnotationExpressionValue<T> }).$If!\n\t\t\t} satisfies IfAnnotationExpression<T>,\n\t\t\tvisitedNavigationPaths,\n\t\t\tundefined,\n\t\t\tpathVisitor\n\t\t) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"$EnumMember\")) {\n\t\treturn constant((annotationValue as { $EnumMember?: string }).$EnumMember as T);\n\t} else if (annotationValue.hasOwnProperty(\"String\")) {\n\t\treturn constant((annotationValue as unknown as { String: string }).String) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"Bool\")) {\n\t\treturn constant((annotationValue as unknown as { Bool: boolean }).Bool) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"Int\")) {\n\t\treturn constant((annotationValue as unknown as { Int: number }).Int) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"Decimal\")) {\n\t\treturn constant((annotationValue as unknown as { Decimal: number }).Decimal) as Expression<T>;\n\t} else if (annotationValue.hasOwnProperty(\"type\") && (annotationValue as unknown as { type: string }).type === \"Null\") {\n\t\treturn constant(null) as Expression<T>;\n\t}\n\treturn constant(false as T);\n}\n\n/**\n * Process the {IfAnnotationExpressionValue} into an expression.\n *\n * @template T The target type\n * @param annotationValue An If expression returning the type T\n * @param visitedNavigationPaths The path from the root entity set\n * @param pathVisitor A function to modify the resulting path\n * @returns The equivalent ifElse expression\n */\nexport function annotationIfExpression<T extends PrimitiveType>(\n\tannotationValue: IfAnnotationExpressionValue<T>,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): Expression<T> {\n\treturn ifElse(\n\t\tparseAnnotationCondition(annotationValue[0], visitedNavigationPaths, pathVisitor),\n\t\tparseAnnotationCondition(annotationValue[1] as ConditionalCheckOrValue, visitedNavigationPaths, pathVisitor),\n\t\tparseAnnotationCondition(annotationValue[2] as ConditionalCheckOrValue, visitedNavigationPaths, pathVisitor)\n\t);\n}\n// This type is not recursively transformed from the metamodel content, as such we have some ugly things there\ntype SubApplyExpressionFromMetamodel = Record<string, unknown>;\nfunction convertSubApplyParameters(applyParam: SubApplyExpressionFromMetamodel): SubApplyExpressionFromMetamodel {\n\tlet applyParamConverted = applyParam;\n\tif (applyParam.hasOwnProperty(\"$Path\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"Path\",\n\t\t\tpath: applyParam.$Path as string\n\t\t} satisfies Partial<PathAnnotationExpression<string>>;\n\t} else if (applyParam.hasOwnProperty(\"$If\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"If\",\n\t\t\t$If: applyParam.$If as IfAnnotationExpressionValue<string>\n\t\t} satisfies IfAnnotationExpression<string>;\n\t} else if (applyParam.hasOwnProperty(\"$Apply\")) {\n\t\tapplyParamConverted = {\n\t\t\ttype: \"Apply\",\n\t\t\t$Function: applyParam.$Function as \"odata.concat\",\n\t\t\t$Apply: applyParam.$Apply as PropertyAnnotationValue<string>[]\n\t\t} satisfies ApplyAnnotationExpression<string>;\n\t}\n\treturn applyParamConverted;\n}\n\ntype ODataFunction = \"odata.concat\" | \"odata.fillUriTemplate\" | \"odata.uriEncode\";\nexport function annotationApplyExpression(\n\tapplyExpression: ApplyAnnotationExpression<string>,\n\tvisitedNavigationPaths: string[] = [],\n\tpathVisitor?: Function\n): Expression<string> {\n\tswitch (applyExpression.$Function as ODataFunction) {\n\t\tcase \"odata.concat\":\n\t\t\treturn concat(\n\t\t\t\t...applyExpression.$Apply.map((applyParam) => {\n\t\t\t\t\treturn getExpressionFromAnnotation(\n\t\t\t\t\t\tconvertSubApplyParameters(applyParam) as PropertyAnnotationValue<string>,\n\t\t\t\t\t\tvisitedNavigationPaths,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tpathVisitor\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\tcase \"odata.uriEncode\":\n\t\t\tconst parameter = getExpressionFromAnnotation(\n\t\t\t\tconvertSubApplyParameters(\n\t\t\t\t\tapplyExpression.$Apply[0] as unknown as SubApplyExpressionFromMetamodel\n\t\t\t\t) as PropertyAnnotationValue<string>,\n\t\t\t\tvisitedNavigationPaths,\n\t\t\t\tundefined,\n\t\t\t\tpathVisitor\n\t\t\t);\n\t\t\t// The second parameter for uriEncode is always a string since the target evaluation is against a formatValue call in ODataUtils which expect the target type as second parameter\n\t\t\treturn fn(\"odata.uriEncode\", [parameter, \"Edm.String\"], undefined, true);\n\t\tcase \"odata.fillUriTemplate\":\n\t\t\tconst template = applyExpression.$Apply[0];\n\t\t\tconst templateParams = applyExpression.$Apply.slice(1) as unknown as SubApplyExpressionFromMetamodel[];\n\t\t\tconst targetObject: Record<string, Expression<unknown>> = {};\n\t\t\ttemplateParams.forEach((applyParam) => {\n\t\t\t\ttargetObject[applyParam.$Name as string] = getExpressionFromAnnotation(\n\t\t\t\t\tconvertSubApplyParameters(\n\t\t\t\t\t\tapplyParam.$LabeledElement as SubApplyExpressionFromMetamodel\n\t\t\t\t\t) as PropertyAnnotationValue<string>,\n\t\t\t\t\tvisitedNavigationPaths,\n\t\t\t\t\tundefined,\n\t\t\t\t\tpathVisitor\n\t\t\t\t);\n\t\t\t});\n\t\t\treturn fn(\"odata.fillUriTemplate\", [template, targetObject], undefined, true);\n\t}\n\treturn unresolvableExpression;\n}\n\n/**\n * Generic helper for the comparison operations (equal, notEqual, ...).\n *\n * @template T The target type\n * @param operator The operator to apply\n * @param leftOperand The operand on the left side of the operator\n * @param rightOperand The operand on the right side of the operator\n * @returns An expression representing the comparison\n */\nfunction comparison<T extends PrimitiveType>(\n\toperator: ComparisonOperator,\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): Expression<boolean> {\n\tconst leftExpression = wrapPrimitive(leftOperand);\n\tconst rightExpression = wrapPrimitive(rightOperand);\n\tif (hasUnresolvableExpression(leftExpression, rightExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (isConstant(leftExpression) && isConstant(rightExpression)) {\n\t\tswitch (operator) {\n\t\t\tcase \"!==\":\n\t\t\t\treturn constant(leftExpression.value !== rightExpression.value);\n\t\t\tcase \"===\":\n\t\t\t\treturn constant(leftExpression.value === rightExpression.value);\n\t\t\tcase \"<\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value < rightExpression.value);\n\t\t\tcase \"<=\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value <= rightExpression.value);\n\t\t\tcase \">\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value > rightExpression.value);\n\t\t\tcase \">=\":\n\t\t\t\tif (\n\t\t\t\t\tleftExpression.value === null ||\n\t\t\t\t\tleftExpression.value === undefined ||\n\t\t\t\t\trightExpression.value === null ||\n\t\t\t\t\trightExpression.value === undefined\n\t\t\t\t) {\n\t\t\t\t\treturn constant(false);\n\t\t\t\t}\n\t\t\t\treturn constant(leftExpression.value >= rightExpression.value);\n\t\t}\n\t} else {\n\t\treturn {\n\t\t\t_type: \"Comparison\",\n\t\t\toperator: operator,\n\t\t\toperand1: leftExpression,\n\t\t\toperand2: rightExpression\n\t\t};\n\t}\n}\n\n/**\n * Generic helper for the length of an expression.\n *\n * @param expression The input expression pointing to an array\n * @param checkUndefined Is the array potentially undefined\n * @returns An expression representing the length\n */\nexport function length(\n\texpression: PathInModelExpression<unknown> | UnresolvablePathExpression,\n\tcheckUndefined = false\n): Expression<number> {\n\tif (expression._type === \"Unresolvable\") {\n\t\treturn expression;\n\t}\n\tif (!checkUndefined) {\n\t\treturn {\n\t\t\t_type: \"Length\",\n\t\t\tpathInModel: expression\n\t\t};\n\t}\n\treturn ifElse(equal(expression, undefined), -1, length(expression));\n}\n\n/**\n * Comparison: \"equal\" (===).\n *\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function equal<T extends PrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): Expression<boolean> {\n\tconst leftExpression = wrapPrimitive(leftOperand);\n\tconst rightExpression = wrapPrimitive(rightOperand);\n\tif (hasUnresolvableExpression(leftExpression, rightExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (_checkExpressionsAreEqual(leftExpression, rightExpression)) {\n\t\treturn constant(true);\n\t}\n\n\tfunction reduce(left: Expression<T>, right: Expression<T>): Expression<boolean> | undefined {\n\t\tif (left._type === \"Comparison\" && isTrue(right)) {\n\t\t\t// compare(a, b) === true ~~> compare(a, b)\n\t\t\treturn left;\n\t\t} else if (left._type === \"Comparison\" && isFalse(right)) {\n\t\t\t// compare(a, b) === false ~~> !compare(a, b)\n\t\t\treturn not(left);\n\t\t} else if (left._type === \"IfElse\" && _checkExpressionsAreEqual(left.onTrue, right)) {\n\t\t\t// (if (x) { a } else { b }) === a ~~> x || (b === a)\n\t\t\treturn or(left.condition, equal(left.onFalse, right));\n\t\t} else if (left._type === \"IfElse\" && _checkExpressionsAreEqual(left.onFalse, right)) {\n\t\t\t// (if (x) { a } else { b }) === b ~~> !x || (a === b)\n\t\t\treturn or(not(left.condition), equal(left.onTrue, right));\n\t\t} else if (\n\t\t\tleft._type === \"IfElse\" &&\n\t\t\tisConstant(left.onTrue) &&\n\t\t\tisConstant(left.onFalse) &&\n\t\t\tisConstant(right) &&\n\t\t\t!_checkExpressionsAreEqual(left.onTrue, right) &&\n\t\t\t!_checkExpressionsAreEqual(left.onFalse, right)\n\t\t) {\n\t\t\treturn constant(false);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t// exploit symmetry: a === b <~> b === a\n\tconst reduced = reduce(leftExpression, rightExpression) ?? reduce(rightExpression, leftExpression);\n\treturn reduced ?? comparison(\"===\", leftExpression, rightExpression);\n}\n\n/**\n * Comparison: \"not equal\" (!==).\n *\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function notEqual<T extends PrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): Expression<boolean> {\n\treturn not(equal(leftOperand, rightOperand));\n}\n\n/**\n * Comparison: \"greater or equal\" (>=).\n *\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function greaterOrEqual<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): Expression<boolean> {\n\treturn comparison(\">=\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"greater than\" (>).\n *\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function greaterThan<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): Expression<boolean> {\n\treturn comparison(\">\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"less or equal\" (<=).\n *\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function lessOrEqual<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): Expression<boolean> {\n\treturn comparison(\"<=\", leftOperand, rightOperand);\n}\n\n/**\n * Comparison: \"less than\" (<).\n *\n * @template T The target type\n * @param leftOperand The operand on the left side\n * @param rightOperand The operand on the right side of the comparison\n * @returns An expression representing the comparison\n */\nexport function lessThan<T extends DefinedPrimitiveType>(\n\tleftOperand: ExpressionOrPrimitive<T>,\n\trightOperand: ExpressionOrPrimitive<T>\n): Expression<boolean> {\n\treturn comparison(\"<\", leftOperand, rightOperand);\n}\n\n/**\n * If-then-else expression.\n *\n * Evaluates to onTrue if the condition evaluates to true, else evaluates to onFalse.\n *\n * @template T The target type\n * @param condition The condition to evaluate\n * @param onTrue Expression result if the condition evaluates to true\n * @param onFalse Expression result if the condition evaluates to false\n * @returns The expression that represents this conditional check\n */\nexport function ifElse<T extends PrimitiveType>(\n\tcondition: ExpressionOrPrimitive<boolean>,\n\tonTrue: ExpressionOrPrimitive<T>,\n\tonFalse: ExpressionOrPrimitive<T>\n): Expression<T> {\n\tlet conditionExpression = wrapPrimitive(condition);\n\tlet onTrueExpression = wrapPrimitive(onTrue);\n\tlet onFalseExpression = wrapPrimitive(onFalse);\n\n\t// swap branches if the condition is a negation\n\tif (conditionExpression._type === \"Not\") {\n\t\t// ifElse(not(X), a, b) --> ifElse(X, b, a)\n\t\t[onTrueExpression, onFalseExpression] = [onFalseExpression, onTrueExpression];\n\t\tconditionExpression = not(conditionExpression);\n\t}\n\n\t// inline nested if-else expressions: onTrue branch\n\t// ifElse(X, ifElse(X, a, b), c) ==> ifElse(X, a, c)\n\tif (onTrueExpression._type === \"IfElse\" && _checkExpressionsAreEqual(conditionExpression, onTrueExpression.condition)) {\n\t\tonTrueExpression = onTrueExpression.onTrue;\n\t}\n\n\t// inline nested if-else expressions: onFalse branch\n\t// ifElse(X, a, ifElse(X, b, c)) ==> ifElse(X, a, c)\n\tif (onFalseExpression._type === \"IfElse\" && _checkExpressionsAreEqual(conditionExpression, onFalseExpression.condition)) {\n\t\tonFalseExpression = onFalseExpression.onFalse;\n\t}\n\n\t// (if true then a else b)  ~~> a\n\t// (if false then a else b) ~~> b\n\tif (isConstant(conditionExpression)) {\n\t\treturn conditionExpression.value ? onTrueExpression : onFalseExpression;\n\t}\n\n\t// if (isConstantBoolean(onTrueExpression) || isConstantBoolean(onFalseExpression)) {\n\t// \treturn or(and(condition, onTrueExpression as Expression<boolean>), and(not(condition), onFalseExpression as Expression<boolean>)) as Expression<T>\n\t// }\n\n\t// (if X then a else a) ~~> a\n\tif (_checkExpressionsAreEqual(onTrueExpression, onFalseExpression)) {\n\t\treturn onTrueExpression;\n\t}\n\n\t// if X then a else false ~~> X && a\n\tif (isFalse(onFalseExpression)) {\n\t\treturn and(conditionExpression, onTrueExpression as Expression<boolean>) as Expression<T>;\n\t}\n\n\t// if X then a else true ~~> !X || a\n\tif (isTrue(onFalseExpression)) {\n\t\treturn or(not(conditionExpression), onTrueExpression as Expression<boolean>) as Expression<T>;\n\t}\n\n\t// if X then false else a ~~> !X && a\n\tif (isFalse(onTrueExpression)) {\n\t\treturn and(not(conditionExpression), onFalseExpression as Expression<boolean>) as Expression<T>;\n\t}\n\n\t// if X then true else a ~~> X || a\n\tif (isTrue(onTrueExpression)) {\n\t\treturn or(conditionExpression, onFalseExpression as Expression<boolean>) as Expression<T>;\n\t}\n\tif (hasUnresolvableExpression(conditionExpression, onTrueExpression, onFalseExpression)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (isComplexTypeExpression(condition) || isComplexTypeExpression(onTrue) || isComplexTypeExpression(onFalse)) {\n\t\tlet pathIdx = 0;\n\t\tconst myIfElseExpression = formatResult([condition, onTrue, onFalse], \"sap.fe.core.formatters.StandardFormatter#ifElse\");\n\t\tconst allParts = [];\n\t\ttransformRecursively(\n\t\t\tmyIfElseExpression as Expression<PrimitiveType>,\n\t\t\t\"PathInModel\",\n\t\t\t(constantPath: PathInModelExpression<unknown>) => {\n\t\t\t\tallParts.push(constantPath);\n\t\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t\t},\n\t\t\ttrue\n\t\t);\n\t\tallParts.unshift(constant(JSON.stringify(myIfElseExpression)));\n\t\treturn formatResult(allParts, \"sap.fe.core.formatters.StandardFormatter#evaluateComplexExpression\", undefined, true);\n\t}\n\treturn {\n\t\t_type: \"IfElse\",\n\t\tcondition: conditionExpression,\n\t\tonTrue: onTrueExpression,\n\t\tonFalse: onFalseExpression\n\t};\n}\n\n/**\n * Checks whether the current expression has a reference to the default model (undefined).\n *\n * @param expression The expression to evaluate\n * @returns `true` if there is a reference to the default context\n */\nfunction hasReferenceToDefaultContext(expression: Expression<unknown>): boolean {\n\tswitch (expression._type) {\n\t\tcase \"Constant\":\n\t\tcase \"Formatter\":\n\t\tcase \"ComplexType\":\n\t\t\treturn false;\n\t\tcase \"Set\":\n\t\t\treturn expression.operands.some(hasReferenceToDefaultContext);\n\t\tcase \"PathInModel\":\n\t\t\treturn expression.modelName === undefined;\n\t\tcase \"Comparison\":\n\t\t\treturn hasReferenceToDefaultContext(expression.operand1) || hasReferenceToDefaultContext(expression.operand2);\n\t\tcase \"IfElse\":\n\t\t\treturn (\n\t\t\t\thasReferenceToDefaultContext(expression.condition) ||\n\t\t\t\thasReferenceToDefaultContext(expression.onTrue) ||\n\t\t\t\thasReferenceToDefaultContext(expression.onFalse)\n\t\t\t);\n\t\tcase \"Not\":\n\t\tcase \"Truthy\":\n\t\t\treturn hasReferenceToDefaultContext(expression.operand);\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n// This is one case where any does make sense...\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Fn<T> = ((...params: any) => T | Promise<T>) & {\n\t__functionName: string;\n};\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\ntype WrappedTuple<T> = {\n\t[K in keyof T]:\n\t\t| WrappedTuple<T[K]>\n\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t// @ts-ignore\n\t\t| ExpressionOrPrimitive<T[K]>\n\t\t| undefined;\n};\n\n// So, this works but I cannot get it to compile :D, but it still does what is expected...\n\n/**\n * A function reference or a function name.\n */\ntype FunctionOrName<T> = Fn<T> | string;\n\n/**\n * Function parameters, either derived from the function or an untyped array.\n */\ntype FunctionParameters<T, F extends FunctionOrName<T>> = F extends Fn<T> ? Parameters<F> : unknown[];\n\n/**\n * Calls a formatter function to process the parameters.\n * If requireContext is set to true and no context is passed a default context will be added automatically.\n *\n * @template T\n * @template U\n * @param parameters The list of parameter that should match the type and number of the formatter function\n * @param formatterFunction The function to call\n * @param [contextEntityType] If no parameter refers to the context then we use this information to add a reference to the keys from the entity type.\n * @param [ignoreComplexType] Whether to ignore the transgformation to the StandardFormatter or not\n * @returns The corresponding expression\n */\nexport function formatResult<T, U extends Fn<T>>(\n\tparameters: WrappedTuple<Parameters<U>>,\n\tformatterFunction: U | string,\n\tcontextEntityType?: EntityType,\n\tignoreComplexType = false\n): Expression<T> {\n\tconst parameterExpressions = (parameters as ExpressionOrPrimitive<PrimitiveType>[]).map(wrapPrimitive);\n\n\tif (hasUnresolvableExpression(...parameterExpressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (contextEntityType) {\n\t\t// Otherwise, if the context is required and no context is provided make sure to add the default binding\n\t\tif (!parameterExpressions.some(hasReferenceToDefaultContext)) {\n\t\t\tcontextEntityType.keys.forEach((key) => parameterExpressions.push(pathInModel(key.name, \"\")));\n\t\t}\n\t}\n\tlet functionName = \"\";\n\tif (typeof formatterFunction === \"string\") {\n\t\tfunctionName = formatterFunction;\n\t} else {\n\t\tfunctionName = formatterFunction.__functionName;\n\t}\n\t// FormatterName can be of format sap.fe.core.xxx#methodName to have multiple formatter in one class\n\tconst [formatterClass, formatterName] = functionName.split(\"#\");\n\n\t// In some case we also cannot call directly a function because of too complex input, in that case we need to convert to a simpler function call\n\tif (\n\t\t!ignoreComplexType &&\n\t\t(parameterExpressions.some(isComplexTypeExpression) ||\n\t\t\tparameterExpressions.some(isConcatExpression) ||\n\t\t\tparameterExpressions.some(isIfElseExpression))\n\t) {\n\t\tlet pathIdx = 0;\n\t\tconst myFormatExpression = formatResult(parameterExpressions, functionName, undefined, true);\n\t\tconst allParts = [];\n\t\ttransformRecursively(\n\t\t\tmyFormatExpression as Expression<PrimitiveType>,\n\t\t\t\"PathInModel\",\n\t\t\t(constantPath: PathInModelExpression<unknown>) => {\n\t\t\t\tallParts.push(constantPath);\n\t\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t\t},\n\t\t\ttrue\n\t\t);\n\t\tallParts.unshift(constant(JSON.stringify(myFormatExpression)));\n\t\treturn formatResult(allParts, \"sap.fe.core.formatters.StandardFormatter#evaluateComplexExpression\", undefined, true);\n\t} else if (!!formatterName && formatterName.length > 0) {\n\t\tparameterExpressions.unshift(constant(formatterName));\n\t}\n\n\treturn {\n\t\t_type: \"Formatter\",\n\t\tfn: formatterClass!,\n\t\tparameters: parameterExpressions\n\t};\n}\n\nexport const getFiscalType = function (property: Property): string | undefined {\n\tif (property.annotations.Common?.IsFiscalYear) {\n\t\treturn CommonAnnotationTerms.IsFiscalYear;\n\t}\n\tif (property.annotations.Common?.IsFiscalPeriod) {\n\t\treturn CommonAnnotationTerms.IsFiscalPeriod;\n\t}\n\tif (property.annotations.Common?.IsFiscalYearPeriod) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearPeriod;\n\t}\n\tif (property.annotations.Common?.IsFiscalQuarter) {\n\t\treturn CommonAnnotationTerms.IsFiscalQuarter;\n\t}\n\tif (property.annotations.Common?.IsFiscalYearQuarter) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearQuarter;\n\t}\n\tif (property.annotations.Common?.IsFiscalWeek) {\n\t\treturn CommonAnnotationTerms.IsFiscalWeek;\n\t}\n\tif (property.annotations.Common?.IsFiscalYearWeek) {\n\t\treturn CommonAnnotationTerms.IsFiscalYearWeek;\n\t}\n\tif (property.annotations.Common?.IsDayOfFiscalYear) {\n\t\treturn CommonAnnotationTerms.IsDayOfFiscalYear;\n\t}\n};\n\n/**\n * Function call, optionally with arguments.\n *\n * @param func Function name or reference to function\n * @param parameters Arguments\n * @param on Object to call the function on\n * @param isFormattingFn\n * @returns Expression representing the function call (not the result of the function call!)\n */\nexport function fn<T, U extends FunctionOrName<T>>(\n\tfunc: U,\n\tparameters: WrappedTuple<FunctionParameters<T, U>>,\n\ton?: ExpressionOrPrimitive<object>,\n\tisFormattingFn = false\n): FunctionExpression<T> {\n\tconst functionName = typeof func === \"string\" ? func : func.__functionName;\n\treturn {\n\t\t_type: \"Function\",\n\t\tobj: on !== undefined ? wrapPrimitive(on) : undefined,\n\t\tfn: functionName,\n\t\tisFormattingFn: isFormattingFn,\n\t\tparameters: (parameters as ExpressionOrPrimitive<PrimitiveType>[]).map(wrapPrimitive)\n\t};\n}\n\n/**\n * Shortcut function to determine if a binding value is null, undefined or empty.\n *\n * @param expression\n * @returns A Boolean expression evaluating the fact that the current element is empty\n */\nexport function isEmpty(expression: Expression<string>): Expression<boolean> {\n\tconst aBindings: ExpressionOrPrimitive<boolean>[] = [];\n\ttransformRecursively(expression, \"PathInModel\", (expr) => {\n\t\taBindings.push(or(equal(expr, \"\"), equal(expr, undefined), equal(expr, null)));\n\t\treturn expr;\n\t});\n\treturn and(...aBindings);\n}\n\nexport function concat(\n\t//eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\n\t...inExpressions: ExpressionOrPrimitive<string | String>[]\n): Expression<string> {\n\tconst expressions = inExpressions.map(wrapPrimitive);\n\tif (hasUnresolvableExpression(...expressions)) {\n\t\treturn unresolvableExpression;\n\t}\n\tif (expressions.every(isConstant)) {\n\t\treturn constant(\n\t\t\texpressions.reduce((concatenated: string, value) => {\n\t\t\t\tif (value.value !== undefined && value.value !== null) {\n\t\t\t\t\treturn concatenated + value.value.toString();\n\t\t\t\t}\n\t\t\t\treturn concatenated;\n\t\t\t}, \"\")\n\t\t);\n\t} else if (expressions.some(isComplexTypeExpression)) {\n\t\tlet pathIdx = 0;\n\t\tconst myConcatExpression = formatResult(expressions, \"sap.fe.core.formatters.StandardFormatter#concat\", undefined, true);\n\t\tconst allParts = [];\n\t\ttransformRecursively(\n\t\t\tmyConcatExpression as Expression<PrimitiveType>,\n\t\t\t\"PathInModel\",\n\t\t\t(constantPath: PathInModelExpression<unknown>) => {\n\t\t\t\tallParts.push(constantPath);\n\t\t\t\treturn pathInModel(`$${pathIdx++}`, \"$\");\n\t\t\t}\n\t\t);\n\t\tallParts.unshift(constant(JSON.stringify(myConcatExpression)));\n\t\treturn formatResult(allParts, \"sap.fe.core.formatters.StandardFormatter#evaluateComplexExpression\", undefined, true);\n\t}\n\treturn {\n\t\t_type: \"Concat\",\n\t\texpressions: expressions as Expression<string>[]\n\t};\n}\n\ntype ExpressionTypeToExpression<T extends ExpressionType, V> = T extends \"Constant\"\n\t? ConstantExpression<V>\n\t: T extends \"PathInModel\"\n\t\t? PathInModelExpression<V>\n\t\t: T extends \"Function\"\n\t\t\t? FunctionExpression<V>\n\t\t\t: T extends \"Unresolvable\"\n\t\t\t\t? UnresolvablePathExpression\n\t\t\t\t: Expression<V>;\n\nexport type TransformFunction<T, V> = (expressionPart: T) => Expression<V>;\nexport type ExpressionType = Pick<Expression<unknown>, \"_type\">[\"_type\"];\nexport function transformRecursively<T extends PrimitiveType, ET extends ExpressionType>(\n\tinExpression: Expression<T>,\n\texpressionType: ET,\n\ttransformFunction: TransformFunction<ExpressionTypeToExpression<ET, T>, T>,\n\tincludeAllExpression = false\n): Expression<T> {\n\tlet expression: Expression<T> = inExpression;\n\tswitch (expression._type) {\n\t\tcase \"Function\":\n\t\tcase \"Formatter\":\n\t\t\texpression.parameters = expression.parameters.map((parameter) =>\n\t\t\t\ttransformRecursively(parameter as Expression<T>, expressionType, transformFunction, includeAllExpression)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase \"Concat\":\n\t\t\texpression.expressions = expression.expressions.map((subExpression) =>\n\t\t\t\ttransformRecursively(\n\t\t\t\t\tsubExpression,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, string>, string>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t)\n\t\t\t);\n\t\t\texpression = concat(...expression.expressions) as Expression<T>;\n\t\t\tbreak;\n\t\tcase \"ComplexType\":\n\t\t\texpression.bindingParameters = expression.bindingParameters.map((bindingParameter) =>\n\t\t\t\ttransformRecursively(bindingParameter as Expression<T>, expressionType, transformFunction, includeAllExpression)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase \"IfElse\": {\n\t\t\tconst onTrue = transformRecursively(expression.onTrue, expressionType, transformFunction, includeAllExpression);\n\t\t\tconst onFalse = transformRecursively(expression.onFalse, expressionType, transformFunction, includeAllExpression);\n\t\t\tlet condition = expression.condition;\n\t\t\tif (includeAllExpression) {\n\t\t\t\tcondition = transformRecursively(\n\t\t\t\t\texpression.condition,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t}\n\t\t\texpression = ifElse(condition, onTrue, onFalse);\n\t\t\tbreak;\n\t\t}\n\t\tcase \"Not\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operand = transformRecursively(\n\t\t\t\t\texpression.operand,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\texpression = not(operand) as Expression<T>;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Truthy\":\n\t\t\tbreak;\n\t\tcase \"Set\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operands = expression.operands.map((operand) =>\n\t\t\t\t\ttransformRecursively(\n\t\t\t\t\t\toperand,\n\t\t\t\t\t\texpressionType,\n\t\t\t\t\t\ttransformFunction as unknown as TransformFunction<ExpressionTypeToExpression<ET, boolean>, boolean>,\n\t\t\t\t\t\tincludeAllExpression\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\texpression = expression.operator === \"||\" ? (or(...operands) as Expression<T>) : (and(...operands) as Expression<T>);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Comparison\":\n\t\t\tif (includeAllExpression) {\n\t\t\t\tconst operand1 = transformRecursively(\n\t\t\t\t\texpression.operand1 as Expression<T>,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\tconst operand2 = transformRecursively(\n\t\t\t\t\texpression.operand2 as Expression<T>,\n\t\t\t\t\texpressionType,\n\t\t\t\t\ttransformFunction,\n\t\t\t\t\tincludeAllExpression\n\t\t\t\t);\n\t\t\t\texpression = comparison(expression.operator, operand1, operand2) as Expression<T>;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"Constant\": {\n\t\t\tconst constantValue: Record<string, Expression<unknown>> = expression.value as Record<string, Expression<unknown>>;\n\t\t\tif (typeof constantValue === \"object\" && constantValue) {\n\t\t\t\tObject.keys(constantValue).forEach((key) => {\n\t\t\t\t\tconstantValue[key] = transformRecursively(\n\t\t\t\t\t\tconstantValue[key] as ConstantExpression<T>,\n\t\t\t\t\t\texpressionType,\n\t\t\t\t\t\ttransformFunction,\n\t\t\t\t\t\tincludeAllExpression\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"Ref\":\n\t\tcase \"Length\":\n\t\tcase \"PathInModel\":\n\t\tcase \"EmbeddedBinding\":\n\t\tcase \"EmbeddedExpressionBinding\":\n\t\tcase \"Unresolvable\":\n\t\t\t// Do nothing\n\t\t\tbreak;\n\t}\n\tif (expressionType === expression._type) {\n\t\texpression = transformFunction(inExpression as ExpressionTypeToExpression<ET, T>);\n\t}\n\treturn expression;\n}\n","/**\n * Collection of table formatters.\n * @param this The context\n * @param name The inner function name\n * @param args The inner function parameters\n * @returns The value from the inner function\n */\nexport const formatters = function (this: object, name: string, ...args: unknown[]): unknown {\n\tif (formatters.hasOwnProperty(name)) {\n\t\treturn (formatters as unknown as Record<string, Function>)[name]!.apply(this, args);\n\t} else {\n\t\treturn \"\";\n\t}\n};\n\nexport const FORMATTERS_PATH = \"sap.fe.definition.formatters\";\n\nexport function formatWithBrackets(firstPart?: string, secondPart?: string): string {\n\tif (firstPart && secondPart) {\n\t\treturn `${firstPart} (${secondPart})`;\n\t} else {\n\t\treturn firstPart || secondPart || \"\";\n\t}\n}\nformatWithBrackets.__functionName = `${FORMATTERS_PATH}#formatWithBrackets`;\n\nformatters.formatWithBrackets = formatWithBrackets;\n\nexport default formatters;\n","import type {\n\tAnnotationTerm,\n\tComplexType,\n\tEntityContainer,\n\tEntitySet,\n\tEntityType,\n\tMultipleNavigationProperty,\n\tNavigationProperty,\n\tPathAnnotationExpression,\n\tProperty,\n\tPropertyPath,\n\tServiceObject,\n\tSingleNavigationProperty,\n\tSingleton,\n\tTypeDefinition\n} from \"@sap-ux/vocabularies-types\";\nimport type { AnnotationPath } from \"@sap-ux/vocabularies-types/Edm\";\n\nexport type AnnotationType = {\n\t$Type?: string;\n\tfullyQualifiedName?: string;\n};\nexport type _AnnotationTerm = {\n\tterm: string;\n\tqualifier?: string;\n};\n\n/**\n * Checks whether the argument is an annotation of the given type.\n * @param potentialAnnotationType The annotation to check\n * @param typeName The type to check for\n * @returns Whether the argument is an annotation of the given type\n */\nexport function isAnnotationOfType<T extends object & AnnotationType>(\n\tpotentialAnnotationType: AnnotationType | undefined,\n\ttypeName: T[\"$Type\"] | T[\"$Type\"][]\n): potentialAnnotationType is T {\n\tif (Array.isArray(typeName)) {\n\t\treturn typeName.includes(potentialAnnotationType?.$Type);\n\t}\n\treturn potentialAnnotationType?.$Type === typeName;\n}\n\n/**\n * Checks whether the argument is an annotation of the given term.\n * @param potentialAnnotation The annotation to check\n * @param termName The term to check for\n * @returns Whether the argument is an annotation of the given term\n */\nexport function isAnnotationOfTerm<T extends object & _AnnotationTerm>(\n\tpotentialAnnotation: unknown,\n\ttermName: T[\"term\"]\n): potentialAnnotation is AnnotationTerm<T> {\n\treturn (potentialAnnotation as _AnnotationTerm).term === termName;\n}\n\nexport function isAnnotationTerm(potentialAnnotation: unknown): potentialAnnotation is _AnnotationTerm {\n\treturn (potentialAnnotation as _AnnotationTerm).hasOwnProperty(\"term\");\n}\n\n/**\n * Checks whether the argument is a {@link ServiceObject}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link ServiceObject}.\n */\nexport function isServiceObject(serviceObject: unknown): serviceObject is ServiceObject {\n\treturn serviceObject?.hasOwnProperty(\"_type\") ?? false;\n}\n\n/**\n * Checks whether the argument is a {@link ComplexType}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link ComplexType}.\n */\nexport function isComplexType(serviceObject: unknown): serviceObject is ComplexType {\n\treturn (serviceObject as { _type: string })._type === \"ComplexType\";\n}\n\n/**\n * Checks whether the argument is a {@link TypeDefinition}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link TypeDefinition}.\n */\nexport function isTypeDefinition(serviceObject: unknown): serviceObject is TypeDefinition {\n\treturn (serviceObject as { _type: string })._type === \"TypeDefinition\";\n}\n\n/**\n * Checks whether the argument is an {@link EntityContainer}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is an {@link EntityContainer}.\n */\nexport function isEntityContainer(serviceObject: unknown): serviceObject is EntityContainer {\n\treturn (serviceObject as { _type: string })._type === \"EntityContainer\";\n}\n\n/**\n * Checks whether the argument is an {@link EntitySet}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is an {@link EntitySet}.\n */\nexport function isEntitySet(serviceObject: unknown): serviceObject is EntitySet {\n\treturn (serviceObject as { _type: string })._type === \"EntitySet\";\n}\n\n/**\n * Checks whether the argument is a {@link Singleton}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link Singleton}\n */\nexport function isSingleton(serviceObject: unknown): serviceObject is Singleton {\n\treturn (serviceObject as { _type: string })._type === \"Singleton\";\n}\n\n/**\n * Checks whether the argument is an {@link EntityType}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is an {@link EntityType}\n */\nexport function isEntityType(serviceObject: unknown): serviceObject is EntityType {\n\treturn (serviceObject as { _type: string })._type === \"EntityType\";\n}\n\n/**\n * Checks whether the argument is a {@link Property}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link Property}.\n */\nexport function isProperty(serviceObject: unknown): serviceObject is Property {\n\treturn (serviceObject as { _type: string })._type === \"Property\";\n}\n\n/**\n * Checks whether the argument is a {@link NavigationProperty}.\n *\n * Hint: There are also the more specific functions {@link isSingleNavigationProperty} and {@link isMultipleNavigationProperty}. These can be\n * used to check for to-one and to-many navigation properties, respectively.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link NavigationProperty}.\n */\nexport function isNavigationProperty(serviceObject: unknown): serviceObject is NavigationProperty {\n\treturn (serviceObject as { _type: string })._type === \"NavigationProperty\";\n}\n\n/**\n * Checks whether the argument is a {@link SingleNavigationProperty}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link SingleNavigationProperty}.\n */\nexport function isSingleNavigationProperty(serviceObject: unknown): serviceObject is SingleNavigationProperty {\n\treturn isNavigationProperty(serviceObject) && !serviceObject.isCollection;\n}\n\n/**\n * Checks whether the argument is a {@link MultipleNavigationProperty}.\n *\n * @param serviceObject The object to be checked.\n * @returns Whether the argument is a {@link MultipleNavigationProperty}.\n */\nexport function isMultipleNavigationProperty(serviceObject: unknown): serviceObject is MultipleNavigationProperty {\n\treturn isNavigationProperty(serviceObject) && serviceObject.isCollection;\n}\n\n/**\n * Checks whether the argument is a {@link PathAnnotationExpression}.\n *\n * @param expression The object to be checked.\n * @returns Whether the argument is a {@link PathAnnotationExpression}.\n */\nexport function isPathAnnotationExpression<T>(expression: unknown): expression is PathAnnotationExpression<T> {\n\treturn (expression as { type: string }).type === \"Path\";\n}\n\n/**\n * Checks whether the argument is a {@link AnnotationPathExpression}.\n *\n * @param expression The object to be checked.\n * @returns Whether the argument is a {@link AnnotationPathExpression}.\n */\nexport function isAnnotationPath<T>(expression: unknown): expression is AnnotationPath<T> {\n\treturn (expression as { type: string }).type == \"AnnotationPath\";\n}\n\n/**\n * Checks whether the argument is a {@link PropertyPath}.\n *\n * @param expression The object to be checked.\n * @returns Whether the argument is a {@link PropertyPath}.\n */\nexport function isPropertyPathExpression(expression: unknown): expression is PropertyPath {\n\treturn (expression as { type: string } | undefined)?.type === \"PropertyPath\";\n}\nexport type ValidPropertyPath = PropertyPath & { $target: Property };\n\n/**\n * Checks whether the argument is a {@link PropertyPath}.\n *\n * @param expression The object to be checked.\n * @returns Whether the argument is a {@link PropertyPath}.\n */\nexport function isValidPropertyPathExpression(expression: unknown): expression is ValidPropertyPath {\n\treturn (expression as { type: string }).type === \"PropertyPath\" && !!(expression as { $target: Property }).$target;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n",null],"mappings":"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","ignoreList":[]}