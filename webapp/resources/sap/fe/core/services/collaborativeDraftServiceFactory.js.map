{"version":3,"file":"collaborativeDraftServiceFactory.js","names":["MYACTIVITIES","ACTIVEUSERS","ACTIVITIES","ASYNCMESSAGESQUEUE","RETAINEDASYNCMESSAGES","ASYNCMESSAGESTIMERID","SYNCGROUPID","DELAYONFOCUS","CollaborativeDraftService","_Service","apply","this","arguments","_exports","_inheritsLoose","_proto","prototype","checkPathForLock","activityModel","activityPath","myActivities","getProperty","includes","setLock","push","setProperty","removeLock","activityPaths","undefined","pathsToRemove","Array","isArray","myNewActivities","filter","activity","length","getLockedProperties","join","updateLocksForContextPath","element","oldContextPath","newContextPath","isConnected","internalModel","getModel","currentQueue","forEach","queueItem","path","startsWith","replace","changedActivities","unchangedActivities","lockedPath","newlockedPath","send","action","Activity","Lock","content","resetAsyncMessagesTimer","timerId","clearTimeout","setTimeout","queue","newQueue","pathsToRetain","item","doSend","retainAsyncMessages","additionalPathsToRetain","retainedPaths","releaseAsyncMessages","pathsToRelease","retainedPath","isCollaborationConnected","message","Unlock","doSendAsync","triggeredActionName","refreshListBinding","actionRequestedProperties","clientContent","requestedProperties","pathForLock","removed","broadcastCollaborationMessage","pathsToAdd","isCollaborationEnabled","view","bindingContext","getBindingContext","ModelHelper","isCollaborationDraftSupported","getMetaModel","connect","async","draftRootContext","me","CollaborationUtils","getMe","CommonUtils","getAppComponent","sDraftUUID","requestProperty","initialized","initializeCollaboration","messageReceive","disconnect","endCollaboration","userJoinDraft","activeUsers","sender","findIndex","user","id","unshift","userAction","Join","JoinEcho","LockEcho","userLeaveDraft","allActivities","removeUserActivities","bag","p","activities","activityKey","metaPath","calculateMetaPath","clientAction","userID","name","userDescription","initials","formatInitials","color","getUserColor","mactivity","Leave","Change","updateOnChange","Create","updateOnCreate","Delete","updateOnDelete","Activate","draftClosedByOtherUser","getText","Discard","Action","updateOnAction","key","getActivityKeyFromPath","initJSONModel","parts","split","i","slice","a","messageText","MessageBox","information","onClose","getBinding","resetChanges","InstanceManager","hasOpenDialog","closeAllDialogs","navigate","error","Log","updatedObjectsPaths","currentPage","getCurrentPage","currentContext","requestPromises","map","applyUpdatesForChange","getController","editFlow","updateDocument","Promise","all","propertyPathForUpdate","metaModel","metaContext","getMetaContext","dataModelObject","MetaModelConverter","getInvolvedDataModelObjects","targetContextPath","substring","lastIndexOf","targetContext","findContextForUpdate","parentCollectionPath","parentContextPath","parentContext","sideEffectsPromises","sideEffectsService","getSideEffectsService","targetMetaPath","getMetaPath","getPath","relativeMetaPathForUpdate","requestSideEffects","fieldGroupIds","computeFieldGroupIds","targetEntityType","fullyQualifiedName","targetObject","pageController","sideEffectsMapForFieldGroup","_sideEffects","getSideEffectsMapForFieldGroups","Object","keys","sideEffectName","sideEffect","sideEffects","context","err","currentPath","deletedObjectPaths","deletedPathInUse","find","deletedPath","getKeepAliveContext","setKeepAlive","requestPromise","applyUpdatesForCollection","_routing","navigateBackFromContext","createdObjectPaths","pathInCollection","appComponent","parentPath","metaPathForUpdate","parentMetaPath","relativePath","requestSideEffectsForNavigationProperty","pathsForAction","actionName","clientTriggeredActionName","clientRequestedProperties","clientRefreshListBinding","requestUpdateForAction","pathForAction","sideEffectService","sideEffectsFromAction","getODataActionSideEffects","sideEffectPromises","pathExpressions","metaPathForAction","dataModelPath","getContext","propertiesToRequest","entityProperties","property","prop","targetPaths","endsWith","model","parentListBinding","getAllBindings","binding","bindingPath","isRelative","getResolvedPath","isA","getAllCurrentContexts","bindContext","getBoundContext","getCreationMode","navigateToContext","recreateContext","getCurrentPageView","dataPath","init","initPromise","resolve","Service","CollaborativeDraftServiceFactory","_ServiceFactory","_proto2","createInstance","oServiceContext","collaborativeDraftService","ServiceFactory"],"sources":["./collaborativeDraftServiceFactory.ts"],"sourcesContent":["import type { Property } from \"@sap-ux/vocabularies-types\";\nimport Log from \"sap/base/Log\";\nimport type { FEView } from \"sap/fe/core/BaseController\";\nimport CommonUtils from \"sap/fe/core/CommonUtils\";\nimport type { FieldSideEffectDictionary } from \"sap/fe/core/controllerextensions/SideEffects\";\nimport {\n\tbroadcastCollaborationMessage,\n\tendCollaboration,\n\tinitializeCollaboration,\n\tisCollaborationConnected\n} from \"sap/fe/core/controllerextensions/collaboration/ActivityBase\";\nimport type { Message, User, UserActivity } from \"sap/fe/core/controllerextensions/collaboration/CollaborationCommon\";\nimport { Activity, CollaborationUtils, getActivityKeyFromPath } from \"sap/fe/core/controllerextensions/collaboration/CollaborationCommon\";\nimport * as MetaModelConverter from \"sap/fe/core/converters/MetaModelConverter\";\nimport ModelHelper from \"sap/fe/core/helpers/ModelHelper\";\nimport InstanceManager from \"sap/m/InstanceManager\";\nimport MessageBox from \"sap/m/MessageBox\";\nimport type UI5Element from \"sap/ui/core/Element\";\nimport type View from \"sap/ui/core/mvc/View\";\nimport Service from \"sap/ui/core/service/Service\";\nimport ServiceFactory from \"sap/ui/core/service/ServiceFactory\";\nimport type JSONModel from \"sap/ui/model/json/JSONModel\";\nimport type Context from \"sap/ui/model/odata/v4/Context\";\nimport type ODataListBinding from \"sap/ui/model/odata/v4/ODataListBinding\";\nimport type { ServiceContext } from \"types/metamodel_types\";\n\nconst MYACTIVITIES = \"/collaboration/myActivities\";\nconst ACTIVEUSERS = \"/collaboration/activeUsers\";\nconst ACTIVITIES = \"/collaboration/activities\";\nconst ASYNCMESSAGESQUEUE = \"/collaboration/asyncMsgQueue\";\nconst RETAINEDASYNCMESSAGES = \"/collaboration/retainedMessages\";\nconst ASYNCMESSAGESTIMERID = \"/collaboration/asyncMsgTimerId\";\nconst SYNCGROUPID = \"$auto.sync\";\n\nconst DELAYONFOCUS = 500; // 500ms delay for async LOCK/UNLOCK messages\n\ntype AsyncMessage = {\n\tpath: string;\n\taction: Activity.Unlock | Activity.Lock;\n};\n\nexport class CollaborativeDraftService extends Service<CollaborativeDraftServiceFactory> {\n\tinitPromise!: Promise<CollaborativeDraftService>;\n\n\t/**\n\t * Checks if a given path is locked by the current user.\n\t * @param activityModel\n\t * @param activityPath\n\t * @returns True if the path is locked\n\t */\n\tcheckPathForLock(activityModel: JSONModel, activityPath: string): boolean {\n\t\tconst myActivities: string[] | undefined | null = activityModel.getProperty(MYACTIVITIES);\n\t\tif (!myActivities) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn myActivities.includes(activityPath);\n\t\t}\n\t}\n\n\t/**\n\t * Sets a path as locked for the current user.\n\t * @param activityModel\n\t * @param activityPath\n\t */\n\tsetLock(activityModel: JSONModel, activityPath: string): void {\n\t\tconst myActivities: string[] = activityModel.getProperty(MYACTIVITIES) ?? [];\n\t\tif (!myActivities.includes(activityPath)) {\n\t\t\tmyActivities.push(activityPath);\n\t\t}\n\n\t\tactivityModel.setProperty(MYACTIVITIES, myActivities);\n\t}\n\n\t/**\n\t * Removes the lock for a given path.\n\t * @param activityModel\n\t * @param activityPaths\n\t * @returns True if the path was previously locked\n\t */\n\tremoveLock(activityModel: JSONModel, activityPaths: string | string[] | undefined): boolean {\n\t\tconst myActivities: string[] | undefined | null = activityModel.getProperty(MYACTIVITIES);\n\t\tif (!myActivities || activityPaths === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst pathsToRemove = Array.isArray(activityPaths) ? activityPaths : [activityPaths];\n\t\tconst myNewActivities = myActivities.filter((activity) => {\n\t\t\treturn !pathsToRemove.includes(activity);\n\t\t});\n\t\tactivityModel.setProperty(MYACTIVITIES, myNewActivities);\n\n\t\treturn myNewActivities.length !== myActivities.length;\n\t}\n\n\t/**\n\t * Returns all locked paths for the current user.\n\t * @param activityModel\n\t * @returns Concatenated paths for all locked properties\n\t */\n\tgetLockedProperties(activityModel: JSONModel): string | undefined {\n\t\tconst myActivities: string[] | undefined | null = activityModel.getProperty(MYACTIVITIES);\n\t\tif (!myActivities) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\treturn myActivities.join(\"|\");\n\t\t}\n\t}\n\n\t/**\n\t * Updates all current locks by changing a context path.\n\t * This is called when activating a context, where the initial locks were using the transient path\n\t * and need to be updated with the actual path.\n\t * @param element\n\t * @param oldContextPath\n\t * @param newContextPath\n\t */\n\tupdateLocksForContextPath(element: UI5Element, oldContextPath: string, newContextPath: string): void {\n\t\tif (!this.isConnected(element)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst internalModel = element.getModel(\"internal\") as JSONModel;\n\n\t\t// Replace paths in pending async messages\n\t\tconst currentQueue: AsyncMessage[] = internalModel.getProperty(ASYNCMESSAGESQUEUE);\n\t\tcurrentQueue.forEach((queueItem) => {\n\t\t\tif (queueItem.path.startsWith(oldContextPath)) {\n\t\t\t\tqueueItem.path = queueItem.path.replace(oldContextPath, newContextPath);\n\t\t\t}\n\t\t});\n\n\t\t// Replace paths in existing locks (and broadcast the corresponding message if necessary)\n\t\tconst myActivities: string[] | undefined | null = internalModel.getProperty(MYACTIVITIES);\n\t\tif (myActivities) {\n\t\t\tconst changedActivities: string[] = [];\n\t\t\tconst unchangedActivities: string[] = [];\n\t\t\tmyActivities.forEach((lockedPath) => {\n\t\t\t\tif (lockedPath.startsWith(oldContextPath)) {\n\t\t\t\t\t// Replace the path in the list of locks, and store this path for sending a new LOCK message\n\t\t\t\t\tconst newlockedPath = lockedPath.replace(oldContextPath, newContextPath);\n\t\t\t\t\tchangedActivities.push(newlockedPath);\n\t\t\t\t} else {\n\t\t\t\t\tunchangedActivities.push(lockedPath);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tinternalModel.setProperty(MYACTIVITIES, unchangedActivities);\n\t\t\tif (changedActivities.length !== 0) {\n\t\t\t\tthis.send(element, { action: Activity.Lock, content: changedActivities });\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Resets the timer for sending asynchronous collaboration messages.\n\t * @param internalModel\n\t */\n\tresetAsyncMessagesTimer(internalModel: JSONModel): void {\n\t\tlet timerId = internalModel.getProperty(ASYNCMESSAGESTIMERID);\n\t\tif (timerId !== undefined) {\n\t\t\tclearTimeout(timerId);\n\t\t}\n\n\t\ttimerId = setTimeout(() => {\n\t\t\tconst queue: AsyncMessage[] | undefined = internalModel.getProperty(ASYNCMESSAGESQUEUE);\n\t\t\tconst newQueue: AsyncMessage[] = [];\n\t\t\tconst pathsToRetain: string[] = internalModel.getProperty(RETAINEDASYNCMESSAGES) ?? [];\n\n\t\t\tif (!queue) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tqueue.forEach((item) => {\n\t\t\t\tif (pathsToRetain.includes(item.path)) {\n\t\t\t\t\tnewQueue.push(item);\n\t\t\t\t} else {\n\t\t\t\t\tthis.doSend(internalModel, item.action, item.path);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tinternalModel.setProperty(ASYNCMESSAGESQUEUE, newQueue);\n\t\t\tinternalModel.setProperty(ASYNCMESSAGESTIMERID, undefined);\n\n\t\t\tif (newQueue.length) {\n\t\t\t\t// If some messages are still pending, reschedule a new timer\n\t\t\t\tthis.resetAsyncMessagesTimer(internalModel);\n\t\t\t}\n\t\t}, DELAYONFOCUS);\n\n\t\tinternalModel.setProperty(ASYNCMESSAGESTIMERID, timerId);\n\t}\n\n\t/**\n\t * Mark some paths as being retained, i.e. async messages for these paths won't be sent but kept until they're released.\n\t * This applies to existing async messages in the queue, but also to future messages.\n\t * @param element\n\t * @param activityPaths The paths to be retained\n\t */\n\tretainAsyncMessages(element: UI5Element, activityPaths: string | string[]): void {\n\t\tconst internalModel = element.getModel(\"internal\") as JSONModel;\n\t\tconst additionalPathsToRetain = Array.isArray(activityPaths) ? activityPaths : [activityPaths];\n\n\t\tconst retainedPaths: string[] = internalModel.getProperty(RETAINEDASYNCMESSAGES);\n\t\tadditionalPathsToRetain.forEach((path) => {\n\t\t\tif (!retainedPaths.includes(path)) {\n\t\t\t\tretainedPaths.push(path);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Release async messages for some paths that were previously retained.\n\t * The corresponding messages are not sent immediately, but the next time the async timer wakes up.\n\t * @param element\n\t * @param activityPaths The paths to be released\n\t */\n\treleaseAsyncMessages(element: UI5Element, activityPaths: string | string[]): void {\n\t\tconst internalModel = element.getModel(\"internal\") as JSONModel;\n\t\tconst pathsToRetain: string[] = internalModel.getProperty(RETAINEDASYNCMESSAGES);\n\t\tconst pathsToRelease = Array.isArray(activityPaths) ? activityPaths : [activityPaths];\n\n\t\tinternalModel.setProperty(\n\t\t\tRETAINEDASYNCMESSAGES,\n\t\t\tpathsToRetain.filter((retainedPath) => {\n\t\t\t\treturn !pathsToRelease.includes(retainedPath);\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * Checks if a collaboration session is currently open.\n\t * @param element\n\t * @returns True if a collaboration session is currently open.\n\t */\n\tisConnected(element: UI5Element): boolean {\n\t\tconst internalModel = element.getModel(\"internal\") as JSONModel;\n\t\treturn isCollaborationConnected(internalModel);\n\t}\n\n\t/**\n\t * Sends a collaboration message to other connected users.\n\t * @param element\n\t * @param message\n\t * @param message.action\n\t * @param message.content\n\t * @param message.triggeredActionName\n\t * @param message.refreshListBinding\n\t * @param message.actionRequestedProperties\n\t */\n\tpublic send(\n\t\telement: UI5Element,\n\t\tmessage: {\n\t\t\taction: Activity;\n\t\t\tcontent: string | string[] | undefined;\n\t\t\ttriggeredActionName?: string;\n\t\t\trefreshListBinding?: boolean;\n\t\t\tactionRequestedProperties?: string[];\n\t\t}\n\t): void {\n\t\tif (this.isConnected(element)) {\n\t\t\tconst internalModel = element.getModel(\"internal\") as JSONModel;\n\t\t\tif (message.action === Activity.Lock || message.action === Activity.Unlock) {\n\t\t\t\t// Lock-related events are always sent with some delay\n\t\t\t\tthis.doSendAsync(internalModel, message.action, message.content);\n\t\t\t} else {\n\t\t\t\tthis.doSend(\n\t\t\t\t\tinternalModel,\n\t\t\t\t\tmessage.action,\n\t\t\t\t\tmessage.content,\n\t\t\t\t\tmessage.triggeredActionName,\n\t\t\t\t\tmessage.refreshListBinding,\n\t\t\t\t\tmessage.actionRequestedProperties\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal function to send a collaboration message immediately.\n\t * @param internalModel\n\t * @param action\n\t * @param content\n\t * @param triggeredActionName\n\t * @param refreshListBinding\n\t * @param actionRequestedProperties\n\t */\n\tdoSend(\n\t\tinternalModel: JSONModel,\n\t\taction: Activity,\n\t\tcontent: string | string[] | undefined,\n\t\ttriggeredActionName?: string,\n\t\trefreshListBinding?: boolean,\n\t\tactionRequestedProperties?: string[]\n\t): void {\n\t\tconst clientContent = (Array.isArray(content) ? content.join(\"|\") : content) ?? \"\";\n\t\tconst requestedProperties = actionRequestedProperties?.join(\"|\");\n\t\tif (action === Activity.Lock) {\n\t\t\tconst pathForLock = (Array.isArray(content) ? content[0] : content) ?? \"\";\n\t\t\t// To avoid unnecessary traffic we keep track of lock changes and send it only once\n\t\t\tif (this.checkPathForLock(internalModel, pathForLock)) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tthis.setLock(internalModel, pathForLock);\n\t\t\t}\n\t\t} else if (action === Activity.Unlock) {\n\t\t\tconst removed = this.removeLock(internalModel, content);\n\t\t\t// No need to send an Unlock message if it was not already locked\n\t\t\tif (!removed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tbroadcastCollaborationMessage(action, clientContent, internalModel, triggeredActionName, refreshListBinding, requestedProperties);\n\t}\n\n\t/**\n\t * Internal function to send a collaboration message asynchronously.\n\t * @param internalModel\n\t * @param action\n\t * @param content\n\t */\n\tdoSendAsync(internalModel: JSONModel, action: Activity.Lock | Activity.Unlock, content: string | string[] | undefined): void {\n\t\tif (content === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tconst currentQueue: AsyncMessage[] = internalModel.getProperty(ASYNCMESSAGESQUEUE);\n\t\tconst pathsToAdd = Array.isArray(content) ? content : [content];\n\t\t// Remove existing items in the queue for the paths that will be added\n\t\tconst newQueue = currentQueue.filter((item) => {\n\t\t\treturn !pathsToAdd.includes(item.path);\n\t\t});\n\t\tpathsToAdd.forEach((path) => {\n\t\t\tnewQueue.push({ path, action });\n\t\t});\n\t\tinternalModel.setProperty(ASYNCMESSAGESQUEUE, newQueue);\n\t\tthis.resetAsyncMessagesTimer(internalModel);\n\t}\n\n\tisCollaborationEnabled(view: View): boolean {\n\t\tconst bindingContext = view?.getBindingContext && (view.getBindingContext() as Context);\n\t\treturn !!(bindingContext && ModelHelper.isCollaborationDraftSupported(bindingContext.getModel().getMetaModel()));\n\t}\n\n\t/**\n\t * Function to establish a connection with a collaborative draft service.\n\t * @param draftRootContext The draft root context\n\t * @param view  The view that is used to connect the websocket\n\t * @returns Promise\n\t */\n\tasync connect(draftRootContext: Context, view: FEView): Promise<void> {\n\t\tconst internalModel = view.getModel(\"internal\");\n\t\tconst me = CollaborationUtils.getMe(CommonUtils.getAppComponent(view));\n\n\t\t// Retrieving ME from shell service\n\t\tif (!me) {\n\t\t\t// no me = no shell = not sure what to do\n\t\t\treturn;\n\t\t}\n\n\t\tconst sDraftUUID = await draftRootContext.requestProperty(\"DraftAdministrativeData/DraftUUID\");\n\t\tif (!sDraftUUID) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst initialized = initializeCollaboration(\n\t\t\tme,\n\t\t\tsDraftUUID,\n\t\t\tinternalModel,\n\t\t\t(message: Message) => {\n\t\t\t\tthis.messageReceive(message, view);\n\t\t\t},\n\t\t\tview\n\t\t);\n\n\t\tif (initialized) {\n\t\t\tinternalModel.setProperty(MYACTIVITIES, []);\n\t\t\tinternalModel.setProperty(ASYNCMESSAGESQUEUE, []);\n\t\t\tinternalModel.setProperty(RETAINEDASYNCMESSAGES, []);\n\t\t}\n\t}\n\n\t/**\n\t * Function to close a connection with a collaborative draft service.\n\t * @param view Current View\n\t */\n\tdisconnect(view: FEView): void {\n\t\tconst internalModel = view.getModel(\"internal\");\n\t\tendCollaboration(internalModel);\n\t}\n\n\t/**\n\t * Function to update internal model when a user joins the draft.\n\t * @param activeUsers List of connected users\n\t * @param internalModel Internal model\n\t * @param sender User sending the JOIN or JOINECHO message\n\t * @param message The message\n\t * @param view Current View\n\t */\n\tuserJoinDraft(activeUsers: User[], internalModel: JSONModel, sender: User, message: Message, view: FEView): void {\n\t\tif (activeUsers.findIndex((user) => user.id === sender.id) === -1) {\n\t\t\tactiveUsers.unshift(sender);\n\t\t\tinternalModel.setProperty(ACTIVEUSERS, activeUsers);\n\t\t}\n\n\t\tif (message.userAction === Activity.Join) {\n\t\t\t// we echo our existence to the newly entered user and also send the current activity if there is any\n\t\t\tbroadcastCollaborationMessage(Activity.JoinEcho, this.getLockedProperties(internalModel), internalModel);\n\t\t}\n\n\t\tif (message.userAction === Activity.JoinEcho) {\n\t\t\tif (message.clientContent) {\n\t\t\t\t// another user was already typing therefore I want to see his activity immediately. Calling me again as a live change\n\t\t\t\tmessage.userAction = Activity.LockEcho;\n\t\t\t\tthis.messageReceive(message, view);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Function to update internal model when a user leaves the draft.\n\t * @param activeUsers List of connected users\n\t * @param internalModel Internal model\n\t * @param sender User sending the JOIN or JOINECHO message\n\t */\n\tuserLeaveDraft(activeUsers: User[], internalModel: JSONModel, sender: User): void {\n\t\t// Removing the active user. Not removing \"me\" if I had the screen open in another session\n\t\tactiveUsers = activeUsers.filter((user) => user.id !== sender.id || user.me);\n\t\tinternalModel.setProperty(ACTIVEUSERS, activeUsers);\n\t\tconst allActivities = internalModel.getProperty(ACTIVITIES) || {};\n\t\tconst removeUserActivities = function (bag: Record<string, unknown> | UserActivity[]): Record<string, unknown> | UserActivity[] {\n\t\t\tif (Array.isArray(bag)) {\n\t\t\t\treturn bag.filter((activity) => activity.id !== sender.id);\n\t\t\t} else {\n\t\t\t\tfor (const p in bag) {\n\t\t\t\t\tbag[p] = removeUserActivities(bag[p] as Record<string, unknown> | UserActivity[]);\n\t\t\t\t}\n\t\t\t\treturn bag;\n\t\t\t}\n\t\t};\n\t\tremoveUserActivities(allActivities);\n\t\tinternalModel.setProperty(ACTIVITIES, allActivities);\n\t}\n\n\t/**\n\t * Callback when a message is received from the websocket.\n\t * @param message The message received\n\t * @param view The view that was used initially when connecting the websocket\n\t */\n\tmessageReceive(message: Message, view: FEView): void {\n\t\tconst internalModel = view.getModel(\"internal\");\n\t\tconst activeUsers: User[] = internalModel.getProperty(ACTIVEUSERS);\n\t\tlet activities: UserActivity[];\n\t\tlet activityKey: string;\n\t\tconst metaPath = this.calculateMetaPath(view, message.clientContent);\n\t\tmessage.userAction = message.userAction || message.clientAction;\n\n\t\tconst sender: User = {\n\t\t\tid: message.userID,\n\t\t\tname: message.userDescription,\n\t\t\tinitials: CollaborationUtils.formatInitials(message.userDescription),\n\t\t\tcolor: CollaborationUtils.getUserColor(message.userID, activeUsers, [])\n\t\t};\n\n\t\tlet mactivity: UserActivity = sender;\n\n\t\t// eslint-disable-next-line default-case\n\t\tswitch (message.userAction) {\n\t\t\tcase Activity.Join:\n\t\t\tcase Activity.JoinEcho:\n\t\t\t\tthis.userJoinDraft(activeUsers, internalModel, sender, message, view);\n\t\t\t\tbreak;\n\n\t\t\tcase Activity.Leave:\n\t\t\t\tthis.userLeaveDraft(activeUsers, internalModel, sender);\n\t\t\t\tbreak;\n\n\t\t\tcase Activity.Change:\n\t\t\t\tthis.updateOnChange(view, message);\n\t\t\t\tbreak;\n\n\t\t\tcase Activity.Create:\n\t\t\t\t// For create we actually just need to refresh the table\n\t\t\t\tthis.updateOnCreate(view, message);\n\t\t\t\tbreak;\n\n\t\t\tcase Activity.Delete:\n\t\t\t\t// For now also refresh the page but in case of deletion we need to inform the user\n\t\t\t\tthis.updateOnDelete(view, message);\n\t\t\t\tbreak;\n\n\t\t\tcase Activity.Activate:\n\t\t\t\tthis.draftClosedByOtherUser(\n\t\t\t\t\tview,\n\t\t\t\t\tmessage.clientContent,\n\t\t\t\t\tCollaborationUtils.getText(\"C_COLLABORATIONDRAFT_ACTIVATE\", sender.name)\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase Activity.Discard:\n\t\t\t\tthis.draftClosedByOtherUser(\n\t\t\t\t\tview,\n\t\t\t\t\tmessage.clientContent,\n\t\t\t\t\tCollaborationUtils.getText(\"C_COLLABORATIONDRAFT_DISCARD\", sender.name)\n\t\t\t\t);\n\t\t\t\tbreak;\n\n\t\t\tcase Activity.Action:\n\t\t\t\tthis.updateOnAction(view, message);\n\t\t\t\tbreak;\n\n\t\t\tcase Activity.Lock:\n\t\t\tcase Activity.LockEcho:\n\t\t\t\tmactivity = sender;\n\t\t\t\tmactivity.key = getActivityKeyFromPath(message.clientContent);\n\n\t\t\t\t// stupid JSON model...\n\t\t\t\tlet initJSONModel = \"\";\n\t\t\t\tconst parts = metaPath.split(\"/\");\n\t\t\t\tfor (let i = 1; i < parts.length - 1; i++) {\n\t\t\t\t\tinitJSONModel += `/${parts[i]}`;\n\t\t\t\t\tif (!internalModel.getProperty(ACTIVITIES + initJSONModel)) {\n\t\t\t\t\t\tinternalModel.setProperty(ACTIVITIES + initJSONModel, {});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tactivities = internalModel.getProperty(ACTIVITIES + metaPath);\n\t\t\t\tactivities = activities?.slice ? activities.slice() : [];\n\t\t\t\tactivities.push(mactivity);\n\t\t\t\tinternalModel.setProperty(ACTIVITIES + metaPath, activities);\n\t\t\t\tif (message.userAction === Activity.LockEcho && this.checkPathForLock(internalModel, message.clientContent)) {\n\t\t\t\t\t// The current user has locked this path right after connection, before knowing it was already locked by someone else\n\t\t\t\t\t// --> remove the current lock\n\t\t\t\t\tthis.doSend(internalModel, Activity.Unlock, message.clientContent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase Activity.Unlock:\n\t\t\t\t// The user did a change but reverted it, therefore unblock the control\n\t\t\t\tactivities = internalModel.getProperty(ACTIVITIES + metaPath);\n\t\t\t\tactivityKey = getActivityKeyFromPath(message.clientContent);\n\t\t\t\tinternalModel.setProperty(ACTIVITIES + metaPath, activities?.filter((a) => a.key !== activityKey));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Displays a message that the current draft was closed be another user, and navigates back to a proper view.\n\t * @param view The view that was used initially when connecting the websocket\n\t * @param path The path of the context to navigate to\n\t * @param messageText The message to display\n\t */\n\tdraftClosedByOtherUser(view: FEView, path: string, messageText: string): void {\n\t\tthis.disconnect(view);\n\t\tMessageBox.information(messageText, {\n\t\t\tonClose: async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait view.getBindingContext().getBinding().resetChanges();\n\t\t\t\t\tif (InstanceManager.hasOpenDialog()) {\n\t\t\t\t\t\t// Close all open dialogs before navigating\n\t\t\t\t\t\tInstanceManager.closeAllDialogs(() => {});\n\t\t\t\t\t}\n\t\t\t\t\tthis.navigate(path, view);\n\t\t\t\t\treturn;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tLog.error(\"Pending Changes could not be reset - still navigating to active instance\");\n\t\t\t\t\tthis.navigate(path, view);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Updates data when a CHANGE message has been received.\n\t * @param view The view that was used initially when connecting the websocket\n\t * @param message The message received from the websocket\n\t */\n\tupdateOnChange(view: FEView, message: Message): void {\n\t\tconst updatedObjectsPaths = message.clientContent.split(\"|\");\n\n\t\tconst currentPage = this.getCurrentPage(view);\n\t\tconst currentContext = currentPage.getBindingContext();\n\t\tconst requestPromises = updatedObjectsPaths.map(async (path) => this.applyUpdatesForChange(view, path));\n\n\t\t// Simulate any change so the edit flow shows the draft indicator and sets the page to dirty\n\t\tcurrentPage.getController().editFlow.updateDocument(currentContext, Promise.all(requestPromises));\n\t}\n\n\t/**\n\t * Updates data corresponding to a path.\n\t * @param view The view that was used initially when connecting the websocket\n\t * @param propertyPathForUpdate Absolute path to the updated property\n\t * @returns A promise resolved when the data and its related side effects have been received\n\t */\n\tasync applyUpdatesForChange(view: FEView, propertyPathForUpdate: string): Promise<void> {\n\t\tconst metaModel = view.getModel().getMetaModel();\n\t\tconst metaContext = metaModel.getMetaContext(propertyPathForUpdate);\n\t\tconst dataModelObject = MetaModelConverter.getInvolvedDataModelObjects<Property>(metaContext);\n\t\tconst targetContextPath = propertyPathForUpdate.substring(0, propertyPathForUpdate.lastIndexOf(\"/\")); // Remove property name\n\t\tconst targetContext = this.findContextForUpdate(view, targetContextPath);\n\t\tconst parentCollectionPath = targetContextPath.substring(0, targetContextPath.lastIndexOf(\"(\"));\n\t\tconst parentContextPath = parentCollectionPath.substring(0, parentCollectionPath.lastIndexOf(\"/\"));\n\t\tconst parentContext = parentContextPath ? this.findContextForUpdate(view, parentContextPath) : undefined;\n\n\t\tif (!targetContext && !parentContext) {\n\t\t\treturn; // No context for update\n\t\t}\n\n\t\ttry {\n\t\t\tconst sideEffectsPromises: Promise<unknown>[] = [];\n\t\t\tconst sideEffectsService = CollaborationUtils.getAppComponent(view).getSideEffectsService();\n\n\t\t\tif (targetContext) {\n\t\t\t\t// We have a target context, so we can retrieve the updated property\n\t\t\t\tconst targetMetaPath = metaModel.getMetaPath(targetContext.getPath());\n\t\t\t\tconst relativeMetaPathForUpdate = metaModel.getMetaPath(propertyPathForUpdate).replace(targetMetaPath, \"\").slice(1);\n\t\t\t\tsideEffectsPromises.push(sideEffectsService.requestSideEffects([relativeMetaPathForUpdate], targetContext, SYNCGROUPID));\n\t\t\t}\n\n\t\t\t// Get the fieldGroupIds corresponding to pathForUpdate\n\t\t\tconst fieldGroupIds = sideEffectsService.computeFieldGroupIds(\n\t\t\t\tdataModelObject.targetEntityType.fullyQualifiedName,\n\t\t\t\tdataModelObject.targetObject!.fullyQualifiedName\n\t\t\t);\n\n\t\t\t// Execute the side effects for the fieldGroupIds\n\t\t\tif (fieldGroupIds.length) {\n\t\t\t\tconst pageController = view.getController();\n\t\t\t\tconst sideEffectsMapForFieldGroup = pageController._sideEffects.getSideEffectsMapForFieldGroups(\n\t\t\t\t\tfieldGroupIds,\n\t\t\t\t\ttargetContext || parentContext\n\t\t\t\t) as FieldSideEffectDictionary;\n\t\t\t\tObject.keys(sideEffectsMapForFieldGroup).forEach((sideEffectName) => {\n\t\t\t\t\tconst sideEffect = sideEffectsMapForFieldGroup[sideEffectName];\n\t\t\t\t\tsideEffectsPromises.push(\n\t\t\t\t\t\tpageController._sideEffects.requestSideEffects(\n\t\t\t\t\t\t\tsideEffect.sideEffects,\n\t\t\t\t\t\t\tsideEffect.context,\n\t\t\t\t\t\t\tSYNCGROUPID,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tawait Promise.all(sideEffectsPromises);\n\t\t} catch (err) {\n\t\t\tLog.error(\"Failed to update data after change:\" + err);\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * Updates data when a DELETE message has been received.\n\t * @param view The view that was used initially when connecting the websocket\n\t * @param message The message received from the websocket\n\t */\n\tupdateOnDelete(view: View, message: Message): void {\n\t\tconst currentPage = this.getCurrentPage(view);\n\t\tconst currentContext = currentPage.getBindingContext();\n\t\tconst currentPath = currentContext.getPath();\n\n\t\tconst deletedObjectPaths = message.clientContent.split(\"|\");\n\n\t\t// check if user currently displays a deleted object or one of its descendants\n\t\tconst deletedPathInUse = deletedObjectPaths.find((deletedPath) => currentPath.startsWith(deletedPath));\n\t\tif (deletedPathInUse) {\n\t\t\t// any other user deleted the object I'm currently looking at. Inform the user we will navigate to root now\n\t\t\tMessageBox.information(CollaborationUtils.getText(\"C_COLLABORATIONDRAFT_DELETE\", message.userDescription), {\n\t\t\t\tonClose: () => {\n\t\t\t\t\t// We retrieve the deleted context as a keep-alive, and disable its keepalive status,\n\t\t\t\t\t// so that it is properly destroyed when refreshing data\n\t\t\t\t\tconst targetContext = currentContext.getModel().getKeepAliveContext(deletedPathInUse);\n\t\t\t\t\ttargetContext.setKeepAlive(false);\n\t\t\t\t\tconst requestPromise = this.applyUpdatesForCollection(view, deletedObjectPaths[0]);\n\t\t\t\t\tcurrentPage.getController().editFlow.updateDocument(currentPage.getBindingContext(), requestPromise);\n\t\t\t\t\tcurrentPage.getController()._routing.navigateBackFromContext(targetContext);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst requestPromise = this.applyUpdatesForCollection(view, deletedObjectPaths[0]);\n\t\t\tcurrentPage.getController().editFlow.updateDocument(currentPage.getBindingContext(), requestPromise);\n\t\t}\n\t}\n\n\t/**\n\t * Updates data when a CREATE message has been received.\n\t * @param view The view that was used initially when connecting the websocket\n\t * @param message The message received from the websocket\n\t */\n\tupdateOnCreate(view: View, message: Message): void {\n\t\tconst currentPage = this.getCurrentPage(view);\n\t\tconst createdObjectPaths = message.clientContent.split(\"|\");\n\n\t\tconst requestPromise = this.applyUpdatesForCollection(view, createdObjectPaths[0]);\n\t\t// Simulate a change so the edit flow shows the draft indicator and sets the page to dirty\n\t\tcurrentPage.getController().editFlow.updateDocument(currentPage.getBindingContext(), requestPromise);\n\t}\n\n\t/**\n\t * Updates data in a collection.\n\t * @param view The view that was used initially when connecting the websocket\n\t * @param pathInCollection A path to an entity in the collection\n\t */\n\tasync applyUpdatesForCollection(view: View, pathInCollection: string): Promise<void> {\n\t\tconst appComponent = CollaborationUtils.getAppComponent(view);\n\t\tconst parentPath = pathInCollection.substring(0, pathInCollection.lastIndexOf(\"/\"));\n\t\tconst parentContext = this.findContextForUpdate(view, parentPath);\n\n\t\tif (parentContext) {\n\t\t\ttry {\n\t\t\t\tconst sideEffectsPromises: Promise<unknown>[] = [];\n\n\t\t\t\tconst metaModel = parentContext.getModel().getMetaModel();\n\t\t\t\tconst metaPathForUpdate = metaModel.getMetaPath(pathInCollection);\n\t\t\t\tconst parentMetaPath = metaModel.getMetaPath(parentContext.getPath());\n\t\t\t\tconst relativePath = metaPathForUpdate.replace(`${parentMetaPath}/`, \"\");\n\n\t\t\t\t// Reload the collection\n\t\t\t\tconst sideEffectsService = appComponent.getSideEffectsService();\n\t\t\t\tsideEffectsPromises.push(sideEffectsService.requestSideEffects([relativePath], parentContext, SYNCGROUPID));\n\n\t\t\t\t// Request the side effects for the collection\n\t\t\t\tsideEffectsPromises.push(\n\t\t\t\t\tsideEffectsService.requestSideEffectsForNavigationProperty(relativePath, parentContext, SYNCGROUPID, true)\n\t\t\t\t);\n\n\t\t\t\tawait Promise.all(sideEffectsPromises);\n\t\t\t} catch (err) {\n\t\t\t\tLog.error(\"Failed to update data after collection update:\" + err);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Updates data when a ACTION message has been received.\n\t * @param view The view that was used initially when connecting the websocket\n\t * @param message The message received from the websocket\n\t */\n\tupdateOnAction(view: FEView, message: Message): void {\n\t\tconst currentPage = this.getCurrentPage(view);\n\t\tconst pathsForAction = message.clientContent.split(\"|\");\n\t\tconst actionName = message.clientTriggeredActionName || \"\";\n\t\tconst requestedProperties = message.clientRequestedProperties?.split(\"|\");\n\t\tconst refreshListBinding = message.clientRefreshListBinding === \"true\";\n\n\t\tlet requestPromises: Promise<void>[] = [];\n\n\t\tif (refreshListBinding) {\n\t\t\trequestPromises.push(this.applyUpdatesForCollection(view, pathsForAction[0]));\n\t\t} else {\n\t\t\trequestPromises = pathsForAction.map(async (path) => this.requestUpdateForAction(view, path, actionName, requestedProperties));\n\t\t}\n\n\t\t// Simulate any change so the edit flow shows the draft indicator and sets the page to dirty\n\t\tcurrentPage.getController().editFlow.updateDocument(currentPage.getBindingContext(), Promise.all(requestPromises));\n\t}\n\n\t/**\n\t * Updates side-effects data when an action has been triggered on a context.\n\t * @param view The view that was used initially when connecting the websocket\n\t * @param pathForAction Path of the context to apply the action to\n\t * @param actionName Name of the action\n\t * @param requestedProperties\n\t * @returns Promise resolved when the side-effects data has been loaded\n\t */\n\tasync requestUpdateForAction(view: FEView, pathForAction: string, actionName: string, requestedProperties?: string[]): Promise<void> {\n\t\tconst targetContext = this.findContextForUpdate(view, pathForAction);\n\t\tif (!targetContext) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst appComponent = CollaborationUtils.getAppComponent(view);\n\t\tconst sideEffectService = appComponent.getSideEffectsService();\n\t\tconst sideEffectsFromAction = sideEffectService.getODataActionSideEffects(actionName, targetContext);\n\t\tconst sideEffectPromises: Promise<unknown>[] = [];\n\t\tif (sideEffectsFromAction) {\n\t\t\tif (sideEffectsFromAction.pathExpressions?.length) {\n\t\t\t\tsideEffectPromises.push(\n\t\t\t\t\tsideEffectService.requestSideEffects(sideEffectsFromAction.pathExpressions, targetContext, SYNCGROUPID)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (requestedProperties && requestedProperties.length > 0) {\n\t\t\t//clean-up of the properties to request list:\n\t\t\tconst metaModel = view.getModel().getMetaModel();\n\t\t\tconst metaPathForAction = this.calculateMetaPath(view, pathForAction);\n\t\t\tconst dataModelPath = MetaModelConverter.getInvolvedDataModelObjects(metaModel.getContext(metaPathForAction));\n\t\t\tconst propertiesToRequest = dataModelPath.targetEntityType.entityProperties\n\t\t\t\t.map((property: Property) => {\n\t\t\t\t\treturn property.name;\n\t\t\t\t})\n\t\t\t\t.filter((prop) => requestedProperties.includes(prop));\n\t\t\tif (propertiesToRequest.length > 0) {\n\t\t\t\tsideEffectPromises.push(sideEffectService.requestSideEffects(propertiesToRequest, targetContext, SYNCGROUPID));\n\t\t\t}\n\t\t}\n\n\t\tawait Promise.all(sideEffectPromises);\n\t}\n\n\t/**\n\t * Finds a context to apply an update message (CHANGE, CREATE, DELETE or ACTION).\n\t * @param view  The view that was used initially when connecting the websocket\n\t * @param path The path of the context to be found (shall point to an entity, not a property)\n\t * @returns A context if it could be found\n\t */\n\tfindContextForUpdate(view: View, path: string): Context | undefined {\n\t\tif (!path) {\n\t\t\treturn undefined;\n\t\t}\n\t\t// Find all potential paths\n\t\tconst targetPaths: string[] = [];\n\t\twhile (!path.endsWith(\")\")) {\n\t\t\ttargetPaths.unshift(path);\n\t\t\tpath = path.substring(0, path.lastIndexOf(\"/\"));\n\t\t}\n\t\ttargetPaths.unshift(path);\n\n\t\tconst parentCollectionPath = path.substring(0, path.lastIndexOf(\"(\")); // Remove the last key\n\n\t\tlet targetContext: Context | undefined;\n\t\tlet currentContext = this.getCurrentPage(view).getBindingContext() as Context | undefined;\n\t\twhile (currentContext && !targetContext) {\n\t\t\tif (targetPaths.includes(currentContext.getPath())) {\n\t\t\t\ttargetContext = currentContext;\n\t\t\t}\n\n\t\t\tcurrentContext = currentContext.getBinding()?.getContext() as Context | undefined;\n\t\t}\n\n\t\tif (targetContext) {\n\t\t\t// Found !\n\t\t\treturn targetContext;\n\t\t}\n\n\t\t// Try to find the target context in a listBinding\n\t\tconst model = this.getCurrentPage(view).getBindingContext().getModel();\n\t\tconst parentListBinding = model.getAllBindings().find((binding) => {\n\t\t\tconst bindingPath = binding.isRelative() ? binding.getResolvedPath() : binding.getPath();\n\t\t\treturn binding.isA(\"sap.ui.model.odata.v4.ODataListBinding\") && bindingPath === parentCollectionPath;\n\t\t}) as ODataListBinding | undefined;\n\t\t// We've found a list binding that could contain the target context --> look for it\n\t\ttargetContext = parentListBinding?.getAllCurrentContexts().find((context) => {\n\t\t\treturn targetPaths.includes(context.getPath());\n\t\t});\n\n\t\treturn targetContext;\n\t}\n\n\tnavigate(path: string, view: FEView): void {\n\t\t// TODO: routing.navigate doesn't consider semantic bookmarking\n\t\tconst currentPage = this.getCurrentPage(view);\n\t\tconst targetContext = view.getModel().bindContext(path).getBoundContext();\n\n\t\tif (currentPage.getController().editFlow.getCreationMode()) {\n\t\t\t// If the object was a newly created one, we navigate back\n\t\t\tcurrentPage.getController()._routing.navigateBackFromContext(targetContext);\n\t\t} else {\n\t\t\t// Otherwise we navigate to the context, but we force its recreation so that all $selects are properly computed by internalRouting\n\t\t\tcurrentPage.getController()._routing.navigateToContext(targetContext, { recreateContext: true });\n\t\t}\n\t}\n\n\tgetCurrentPage(view: View): FEView {\n\t\tconst appComponent = CollaborationUtils.getAppComponent(view);\n\t\treturn CommonUtils.getCurrentPageView(appComponent);\n\t}\n\n\t/**\n\t * Calculates the metapath from one or more data path(s).\n\t * @param view The current view\n\t * @param path One ore more data path(s), in case of multiple paths separated by '|'\n\t * @returns The calculated metaPath\n\t */\n\tcalculateMetaPath(view: FEView, path?: string): string {\n\t\tlet metaPath = \"\";\n\t\tif (path) {\n\t\t\t// in case more than one path is sent all of them have to use the same metapath therefore we just consider the first one\n\t\t\tconst dataPath = path.split(\"|\")[0];\n\t\t\tmetaPath = view.getModel().getMetaModel().getMetaPath(dataPath);\n\t\t}\n\t\treturn metaPath;\n\t}\n\n\tinit(): void {\n\t\tthis.initPromise = Promise.resolve(this);\n\t}\n}\n\nexport default class CollaborativeDraftServiceFactory extends ServiceFactory<CollaborativeDraftServiceFactory> {\n\tpublic async createInstance(oServiceContext: ServiceContext<CollaborativeDraftServiceFactory>): Promise<CollaborativeDraftService> {\n\t\tconst collaborativeDraftService = new CollaborativeDraftService(oServiceContext);\n\t\treturn collaborativeDraftService.initPromise;\n\t}\n}\n"],"mappings":"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","ignoreList":[]}