{"version":3,"file":"TelemetryServiceFactory.js","names":["ParameterMap","name","type","TelemetryService","_Service","_this","_len","arguments","length","args","Array","_key","call","this","isEnabled","_exports","_inheritsLoose","_proto","prototype","init","context","getContext","appComponent","scopeObject","fioriDefinition","getManifestEntry","appId","registrationIds","join","initialize","async","urlParams","URLSearchParams","window","location","search","get","toLowerCase","Promise","resolve","storeAction","action","sourceTemplate","telemetryEvent","template","storeAndFlush","e","Log","debug","_telemetryEvent","validateEventCountPolicy","validateEndpointPolicy","eventsAsStr","localStorage","getItem","EventStoreKey","events","JSON","parse","push","CountBeforeFlush","flush","incrementEventCountStore","clearEndpointStore","updateEndpointStore","telemetryEventStr","stringify","setItem","body","buildRequestBody","fetch","targetUrl","method","map","event","parameterPerType","paramPart","_ref","paramName","paramType","parameters","updateEventCountStore","value","EventCountStoreKey","eventCountStr","eventCount","parseInt","isNaN","MaxTelemetry","EndpointStoreKey","Date","now","removeItem","timestamp","lastCheckTime","EndpointRetryPeriod","Service","TelemetryServiceFactory","_ServiceFactory","apply","_proto2","createInstance","oServiceContext","instance","ServiceFactory"],"sources":["./TelemetryServiceFactory.ts"],"sourcesContent":["import Log from \"sap/base/Log\";\nimport type AppComponent from \"sap/fe/core/AppComponent\";\nimport type { TemplateType } from \"sap/fe/core/converters/ManifestSettings\";\nimport Service from \"sap/ui/core/service/Service\";\nimport ServiceFactory from \"sap/ui/core/service/ServiceFactory\";\nimport type { ServiceContext } from \"types/metamodel_types\";\n\ntype TelemetryServiceSettings = {};\nexport type TelemetryFiterBarSearchEventType = \"FE.FilterBarSearch\";\nexport type TelemetryRecommendationType = \"FE.Recommendations\";\n\nexport type TelemetryEvent = {\n\ttype: TelemetryFiterBarSearchEventType | TelemetryRecommendationType;\n\tparameters: Record<string, string | number | boolean>;\n};\n\nexport type RecommendationTelemetry = {\n\t// How many times do we re-read the data?\n\t// number of times recommendations were fetched in the current view (irrespective of page/table context)\n\tnumberOfTimesRecommendationsFetched: number;\n\t// How long did the recommendation call take?\n\t// maximum time taken to receive recommendations\n\tmaxTimeTakenToReceiveRecommendations: number;\n\t// manimum time taken to receive recommendations\n\tminTimeTakenToReceiveRecommendations: number;\n\t// average time taken to receive recommendations\n\taverageTimeTakenToReceiveRecommendations: number;\n\t//number of times, placeholder is not seen on UI\n\tnumberOfTimesNoPlaceholderIsShownOnUI: number;\n\t// number of Field having recommendations\n\tnumberOfRecommendedFields: number;\n\t// number of Fields directly accepted through Accept button\n\tnumberOfFieldsAcceptedThroughAcceptButton: number;\n\t// number of Fields ignored through Accept button\n\tnumberOfFieldsIgnoredThroughIgnoreButton: number;\n\t// number of times top recommendation was selected\n\tnumberOfTimesTopRecommendationsSelected: number;\n\t// number of times non-top recommendation was selected\n\tnumberOfTimesNonTopRecommendationsSelected: number;\n\t// number of times non-recommended value was selected\n\tnumberOfTimesNonRecommendedValueWasSelected: number;\n\t// number of times empty recommendations were received from backend\n\tnumberOfTimesEmptyRecommendations: number;\n\t// number of times formatter was called to show recommended state\n\tnumberofTimesFormatterCalled: number;\n\t// total numberOfRecommendationsReceived\n\ttotalNumberOfRecommendationsReceived: number;\n\t// number of times formatter not called\n\tnumberOfTimesFormatterNotCalled: number;\n\t// total time taken\n\ttotalTimeTaken: number;\n};\n\nexport type TelemetryFilterBarSearchEvent = TelemetryEvent & {\n\ttype: \"FE.FilterBarSearch\";\n\tparameters: {\n\t\tcountFilterActions: number; //  How many filterChanged actions are performed\n\t\tcountFilters: number; // How many different filters are applied\n\t\tcountVariantFilters: number; // How many filter belong to a variant\n\t\tvariantLayer: string; // Type of variant\n\t\tautoLoad: boolean; // Is the app using auto load of table data\n\t};\n\ttemplate?: TemplateType;\n};\n\nexport type TelemetryRecommendations = TelemetryEvent & {\n\ttype: \"FE.Recommendations\";\n\tparameters: RecommendationTelemetry;\n\ttemplate?: TemplateType;\n};\n\nconst ParameterMap = {\n\t\"FE.FilterBarSearch\": [\n\t\t{ name: \"countFilterActions\", type: \"number\" },\n\t\t{ name: \"countFilters\", type: \"number\" },\n\t\t{ name: \"countVariantFilters\", type: \"number\" },\n\t\t{ name: \"variantLayer\", type: \"string\" },\n\t\t{ name: \"autoLoad\", type: \"boolean\" }\n\t],\n\t\"FE.Recommendations\": [\n\t\t{\n\t\t\tname: \"numberOfTimesRecommendationsFetched\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"maxTimeTakenToReceiveRecommendations\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"minTimeTakenToReceiveRecommendations\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"averageTimeTakenToReceiveRecommendations\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"numberOfFieldsAcceptedThroughAcceptButton\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"numberOfFieldsIgnoredThroughIgnoreButton\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"numberOfTimesNoPlaceholderIsShownOnUI\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"numberOfRecommendedFields\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"numberOfTimesTopRecommendationsSelected\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"numberOfTimesNonTopRecommendationsSelected\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"numberOfTimesNonRecommendedValueWasSelected\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"numberOfTimesEmptyRecommendations\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"numberofTimesFormatterCalled\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"totalNumberOfRecommendationsReceived\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"numberOfTimesFormatterNotCalled\",\n\t\t\ttype: \"number\"\n\t\t},\n\t\t{\n\t\t\tname: \"totalTimeTaken\",\n\t\t\ttype: \"number\"\n\t\t}\n\t]\n};\n\nexport type TelemetryEvents = TelemetryFilterBarSearchEvent | TelemetryRecommendations;\n\nexport class TelemetryService extends Service<TelemetryServiceSettings> {\n\tappId?: string;\n\n\tappComponent!: AppComponent;\n\n\tisEnabled = false;\n\n\tstatic MaxTelemetry = 500;\n\n\tstatic CountBeforeFlush = 50;\n\n\tstatic EndpointRetryPeriod = 1000 * 60 * 60 * 24; // 1 day\n\n\tstatic targetUrl = \"/sap/bc/ui2/flp;sap-metrics-only\";\n\n\tstatic EventStoreKey = \"EventStore\";\n\n\tstatic EndpointStoreKey = \"EndpointStore\";\n\n\tstatic EventCountStoreKey = \"EventCountStore\";\n\n\tinit(): void {\n\t\tconst context = this.getContext();\n\t\tthis.appComponent = context?.scopeObject as AppComponent;\n\t\tconst fioriDefinition = this.appComponent.getManifestEntry(\"sap.fiori\");\n\n\t\tthis.appId = fioriDefinition?.registrationIds?.join(\"-\");\n\t}\n\n\tasync initialize(): Promise<this> {\n\t\t// const environmentCapabilitiesService = (await this.appComponent.getService(\n\t\t// \t\"environmentCapabilities\"\n\t\t// )) as EnvironmentCapabilitiesService;\n\t\t// const feDefinition = this.appComponent.getManifestEntry(\"sap.fe\");\n\t\t// if (\n\t\t// \twindow.localStorage &&\n\t\t// \tfeDefinition?.app?.enableTelemetry === true &&\n\t\t// \tenvironmentCapabilitiesService.getCapabilities().InsightsSupported &&\n\t\t// \tthis.appId !== undefined\n\t\t// ) {\n\t\t// \tthis.isEnabled = true;\n\t\t// }\n\n\t\tconst urlParams = new URLSearchParams(window.location.search);\n\t\tif (urlParams.get(\"sap-ui-xx-feEnableGSM\")?.toLowerCase() === \"true\") {\n\t\t\tthis.isEnabled = true;\n\t\t}\n\n\t\treturn Promise.resolve(this);\n\t}\n\n\t/**\n\t * Entry point for FE telemetry data reporting. It catches all exceptions so that\n\t * any unhandled errors do not affect regular FE app functionalities.\n\t * @param action A telemetry event that contain metrics to be reported to GSM.\n\t * @param sourceTemplate The template that this originated from.\n\t */\n\tasync storeAction(action: TelemetryEvents, sourceTemplate: TemplateType): Promise<void> {\n\t\tif (this.isEnabled) {\n\t\t\tconst telemetryEvent = {\n\t\t\t\t...action,\n\t\t\t\ttemplate: sourceTemplate\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tawait this.storeAndFlush(telemetryEvent);\n\t\t\t} catch (e) {\n\t\t\t\tLog.debug(e as string);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Instead of directly sending individual telemetry\n\t * events to backend, this API implements multiple strategies to reduce the frequency of sending\n\t * telemetry events, and automatically turn off sending telemetry after collecting adequate data\n\t * samples.\n\t * @param _telemetryEvent A telemetry event that contain metrics to be reported to GSM.\n\t */\n\tprivate async storeAndFlush(_telemetryEvent: TelemetryEvent): Promise<void> {\n\t\t// Skip if reach max count we should collect\n\t\tif (!this.validateEventCountPolicy()) {\n\t\t\treturn;\n\t\t}\n\t\t// Skip if the endpoint didn't work recently\n\t\tif (!this.validateEndpointPolicy()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fetch telemetry events from store\n\t\tconst eventsAsStr = window.localStorage.getItem(TelemetryService.EventStoreKey);\n\t\tlet events: TelemetryEvent[];\n\t\tif (!eventsAsStr) {\n\t\t\tevents = [];\n\t\t} else {\n\t\t\tevents = JSON.parse(eventsAsStr);\n\t\t}\n\t\tevents.push(_telemetryEvent);\n\n\t\t// Once we have CountBeforeFlush entries flush them\n\t\tif (events.length >= TelemetryService.CountBeforeFlush) {\n\t\t\ttry {\n\t\t\t\tawait this.flush(events);\n\t\t\t\t// Keep count of how many batches we have submitted in total\n\t\t\t\tthis.incrementEventCountStore(events.length);\n\t\t\t\tthis.clearEndpointStore();\n\t\t\t} catch {\n\t\t\t\t// Keep track if the endpoint was not reachable\n\t\t\t\tthis.updateEndpointStore();\n\t\t\t}\n\n\t\t\t// No matter endpoint is reachable or not, we clean the storage anyway.\n\t\t\t// To avoid risk of accumulating large amount of telemetry data.\n\t\t\t// Hope we will collect useful data in the future.\n\t\t\tevents = [];\n\t\t}\n\n\t\t// Save telemetry events back to store\n\t\tconst telemetryEventStr = JSON.stringify(events);\n\t\twindow.localStorage.setItem(TelemetryService.EventStoreKey, telemetryEventStr);\n\t}\n\n\t/**\n\t * Send a batch of telemetry events to GSM endpoint.\n\t * @param events An array of telemetry events\n\t * @returns The response from the GSM endpoint\n\t */\n\tprivate async flush(events: TelemetryEvent[]): Promise<Response | undefined> {\n\t\tconst body = this.buildRequestBody(events);\n\n\t\t// Send a batch of 50 events to backend.\n\t\treturn fetch(TelemetryService.targetUrl, {\n\t\t\tmethod: \"POST\",\n\t\t\tbody\n\t\t});\n\t}\n\n\t/**\n\t * Utility function to serialize telemetry event to string format accepted by GSM endpoint.\n\t * Example output of a batch of 2 telemetry events looks like:\n\t * ui5_action{ type=\"FE.FilterBarSearch\", countFilterActions=2, countFilters=1, countVariantFilters=1, variantLayer=\"variant0\", autoLoad=true } 1\n\t * ui5_action{ type=\"FE.FilterBarSearch\", countFilterActions=3, countFilters=1, countVariantFilters=0, variantLayer=\"variant1\", autoLoad=false } 1\n\t * This will then be used with the gsm endpoint.\n\t * @param events An array of telemetry events\n\t * @returns Serialized data to be posted to GSM endpoint\n\t */\n\tprivate buildRequestBody(events: TelemetryEvent[]): string | undefined {\n\t\t// This method is triggered when event size is greater or equal than TelemetryService.MaxTelemetry\n\t\t// Input is always an array list of events >= 0\n\n\t\treturn events\n\t\t\t.map((event) => {\n\t\t\t\tconst parameterPerType = ParameterMap[event.type];\n\t\t\t\tconst paramPart: string[] = parameterPerType.map(({ name: paramName, type: paramType }) => {\n\t\t\t\t\tswitch (paramType) {\n\t\t\t\t\t\tcase \"number\":\n\t\t\t\t\t\tcase \"boolean\":\n\t\t\t\t\t\t\treturn `${paramName}=${event.parameters[paramName]}`;\n\t\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn `${paramName}=\"${event.parameters[paramName]}`;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn `ui5_action{ type=\"${event.type}\", ${paramPart.join(\", \")} } 1\\n`;\n\t\t\t})\n\t\t\t.join(\"\");\n\t}\n\n\t/**\n\t * Set value to an entry in localStorage.\n\t * @param value New value in localStorage\n\t */\n\tprivate updateEventCountStore(value: number): void {\n\t\twindow.localStorage.setItem(TelemetryService.EventCountStoreKey, `${value}`);\n\t}\n\n\t/**\n\t * Add the input value to the existing value in an entry in localStorage.\n\t * @param value Amount incremented to an existing value\n\t */\n\tprivate incrementEventCountStore(value: number): void {\n\t\tconst eventCountStr = window.localStorage.getItem(TelemetryService.EventCountStoreKey);\n\n\t\t// If store is empty, treat it as having value 0. Increment from 0 by amount 'value'.\n\t\tif (!eventCountStr) {\n\t\t\tthis.updateEventCountStore(value);\n\t\t\treturn;\n\t\t}\n\n\t\t// validateEventCountPolicy already sanitizes invalid events\n\t\tconst eventCount = parseInt(eventCountStr, 10);\n\t\tthis.updateEventCountStore(eventCount + value);\n\t}\n\n\t/**\n\t * To avoid risk of filling backend storage with telemetry data, this policy\n\t * tracks total amount of telemetry events sent to backend from a client, and\n\t * terminates sending telemetry events if max threshold reached.\n\t *\n\t * This is a best effort implementation. If localStorage is cleared by FE end user,\n\t * telemetry events will be sent again.\n\t * @returns `true` - submitted telemetry event count doesn't exceed limit\n\t *  `true` - no valid count was found, restart from 0\n\t *  `false` - submitted teleemtry event count exceeds limit\n\t */\n\tprivate validateEventCountPolicy(): boolean {\n\t\tconst eventCountStr = window.localStorage.getItem(TelemetryService.EventCountStoreKey);\n\n\t\tif (!eventCountStr) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst eventCount = parseInt(eventCountStr, 10);\n\t\tif (isNaN(eventCount)) {\n\t\t\t// If invalid stored value found, reset it\n\t\t\tthis.updateEventCountStore(0);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn eventCount < TelemetryService.MaxTelemetry;\n\t\t}\n\t}\n\n\tprivate updateEndpointStore(): void {\n\t\twindow.localStorage.setItem(TelemetryService.EndpointStoreKey, `${Date.now()}`);\n\t}\n\n\tprivate clearEndpointStore(): void {\n\t\twindow.localStorage.removeItem(TelemetryService.EndpointStoreKey);\n\t}\n\n\t/**\n\t * Compare current timeInMilliseconds with the timeInMilliseconds stored in localStorage.\n\t * Usage: If connection to endpoint failed, it is likely the endpoint is not available on the target\n\t * system, stop collecting and send telemetry for period of time defined in TelemetryService.EndpointRetryPeriod.\n\t * @returns `true` - if there is no timestamp stored in localStorage.\n\t * \t`true` - if the elapsed time is greater than the value defined in TelemetryService.EndpointRetryPeriod.\n\t *  `false` - if the elapsed time is smaller than the value defined in TelemetryService.EndpointRetryPeriod.\n\t */\n\tprivate validateEndpointPolicy(): boolean {\n\t\tconst timestamp = window.localStorage.getItem(TelemetryService.EndpointStoreKey);\n\n\t\tif (!timestamp) {\n\t\t\treturn true;\n\t\t}\n\t\tconst now = Date.now();\n\n\t\tconst lastCheckTime = parseInt(timestamp, 10);\n\t\tif (isNaN(lastCheckTime)) {\n\t\t\t// time stamp of last failed endpoint connection is corrupted\n\t\t\tthis.updateEndpointStore();\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn now - lastCheckTime > TelemetryService.EndpointRetryPeriod;\n\t\t}\n\t}\n}\n\nexport default class TelemetryServiceFactory extends ServiceFactory<TelemetryServiceSettings> {\n\tasync createInstance(oServiceContext: ServiceContext<TelemetryServiceSettings>): Promise<TelemetryService> {\n\t\tconst instance = new TelemetryService(oServiceContext);\n\t\treturn instance.initialize();\n\t}\n}\n"],"mappings":";;;;yVAuEA,MAAMA,EAAe,CACpB,qBAAsB,CACrB,CAAEC,KAAM,qBAAsBC,KAAM,UACpC,CAAED,KAAM,eAAgBC,KAAM,UAC9B,CAAED,KAAM,sBAAuBC,KAAM,UACrC,CAAED,KAAM,eAAgBC,KAAM,UAC9B,CAAED,KAAM,WAAYC,KAAM,YAE3B,qBAAsB,CACrB,CACCD,KAAM,sCACNC,KAAM,UAEP,CACCD,KAAM,uCACNC,KAAM,UAEP,CACCD,KAAM,uCACNC,KAAM,UAEP,CACCD,KAAM,2CACNC,KAAM,UAEP,CACCD,KAAM,4CACNC,KAAM,UAEP,CACCD,KAAM,2CACNC,KAAM,UAEP,CACCD,KAAM,wCACNC,KAAM,UAEP,CACCD,KAAM,4BACNC,KAAM,UAEP,CACCD,KAAM,0CACNC,KAAM,UAEP,CACCD,KAAM,6CACNC,KAAM,UAEP,CACCD,KAAM,8CACNC,KAAM,UAEP,CACCD,KAAM,oCACNC,KAAM,UAEP,CACCD,KAAM,+BACNC,KAAM,UAEP,CACCD,KAAM,uCACNC,KAAM,UAEP,CACCD,KAAM,kCACNC,KAAM,UAEP,CACCD,KAAM,iBACNC,KAAM,YAGP,IAIWC,EAAgB,SAAAC,GAAA,SAAAD,IAAA,IAAAE,EAAA,QAAAC,EAAAC,UAAAC,OAAAC,EAAA,IAAAC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAA,CAAAF,EAAAE,GAAAJ,UAAAI,EAAA,CAAAN,EAAAD,EAAAQ,KAAAC,QAAAJ,IAAAI,KAAAR,EAK5BS,UAAY,MAAK,OAAAT,CAAA,CAAAU,EAAAZ,mBAAAa,EAAAb,EAAAC,GAAA,IAAAa,EAAAd,EAAAe,UAAAD,EAgBjBE,KAAA,SAAAA,IACC,MAAMC,EAAUP,KAAKQ,aACrBR,KAAKS,aAAeF,GAASG,YAC7B,MAAMC,EAAkBX,KAAKS,aAAaG,iBAAiB,aAE3DZ,KAAKa,MAAQF,GAAiBG,iBAAiBC,KAAK,IACrD,EAACX,EAEKY,WAANC,eAAMD,IAcL,MAAME,EAAY,IAAIC,gBAAgBC,OAAOC,SAASC,QACtD,GAAIJ,EAAUK,IAAI,0BAA0BC,gBAAkB,OAAQ,CACrExB,KAAKC,UAAY,IAClB,CAEA,OAAOwB,QAAQC,QAAQ1B,KACxB,EAEAI,EAMMuB,YAANV,eAAMU,EAAYC,EAAyBC,GAC1C,GAAI7B,KAAKC,UAAW,CACnB,MAAM6B,EAAiB,IACnBF,EACHG,SAAUF,GAGX,UACO7B,KAAKgC,cAAcF,EAC1B,CAAE,MAAOG,GACRC,EAAIC,MAAMF,EACX,CACD,CACD,EAEA7B,EAOc4B,cAAdf,eAAce,EAAcI,GAE3B,IAAKpC,KAAKqC,2BAA4B,CACrC,MACD,CAEA,IAAKrC,KAAKsC,yBAA0B,CACnC,MACD,CAGA,MAAMC,EAAcnB,OAAOoB,aAAaC,QAAQnD,EAAiBoD,eACjE,IAAIC,EACJ,IAAKJ,EAAa,CACjBI,EAAS,EACV,KAAO,CACNA,EAASC,KAAKC,MAAMN,EACrB,CACAI,EAAOG,KAAKV,GAGZ,GAAIO,EAAOhD,QAAUL,EAAiByD,iBAAkB,CACvD,UACO/C,KAAKgD,MAAML,GAEjB3C,KAAKiD,yBAAyBN,EAAOhD,QACrCK,KAAKkD,oBACN,CAAE,MAEDlD,KAAKmD,qBACN,CAKAR,EAAS,EACV,CAGA,MAAMS,EAAoBR,KAAKS,UAAUV,GACzCvB,OAAOoB,aAAac,QAAQhE,EAAiBoD,cAAeU,EAC7D,EAEAhD,EAKc4C,MAAd/B,eAAc+B,EAAML,GACnB,MAAMY,EAAOvD,KAAKwD,iBAAiBb,GAGnC,OAAOc,MAAMnE,EAAiBoE,UAAW,CACxCC,OAAQ,OACRJ,QAEF,EAEAnD,EASQoD,iBAAR,SAAQA,EAAiBb,GAIxB,OAAOA,EACLiB,IAAKC,IACL,MAAMC,EAAmB3E,EAAa0E,EAAMxE,MAC5C,MAAM0E,EAAsBD,EAAiBF,IAAII,IAA0C,IAAvC5E,KAAM6E,EAAW5E,KAAM6E,GAAWF,EACrF,OAAQE,GACP,IAAK,SACL,IAAK,UACJ,MAAO,GAAGD,KAAaJ,EAAMM,WAAWF,KACzC,IAAK,SACL,QACC,MAAO,GAAGA,MAAcJ,EAAMM,WAAWF,QAG5C,MAAO,qBAAqBJ,EAAMxE,UAAU0E,EAAUhD,KAAK,gBAE3DA,KAAK,GACR,EAEAX,EAIQgE,sBAAR,SAAQA,EAAsBC,GAC7BjD,OAAOoB,aAAac,QAAQhE,EAAiBgF,mBAAoB,GAAGD,IACrE,EAEAjE,EAIQ6C,yBAAR,SAAQA,EAAyBoB,GAChC,MAAME,EAAgBnD,OAAOoB,aAAaC,QAAQnD,EAAiBgF,oBAGnE,IAAKC,EAAe,CACnBvE,KAAKoE,sBAAsBC,GAC3B,MACD,CAGA,MAAMG,EAAaC,SAASF,EAAe,IAC3CvE,KAAKoE,sBAAsBI,EAAaH,EACzC,EAEAjE,EAWQiC,yBAAR,SAAQA,IACP,MAAMkC,EAAgBnD,OAAOoB,aAAaC,QAAQnD,EAAiBgF,oBAEnE,IAAKC,EAAe,CACnB,OAAO,IACR,CAEA,MAAMC,EAAaC,SAASF,EAAe,IAC3C,GAAIG,MAAMF,GAAa,CAEtBxE,KAAKoE,sBAAsB,GAC3B,OAAO,IACR,KAAO,CACN,OAAOI,EAAalF,EAAiBqF,YACtC,CACD,EAACvE,EAEO+C,oBAAR,SAAQA,IACP/B,OAAOoB,aAAac,QAAQhE,EAAiBsF,iBAAkB,GAAGC,KAAKC,QACxE,EAAC1E,EAEO8C,mBAAR,SAAQA,IACP9B,OAAOoB,aAAauC,WAAWzF,EAAiBsF,iBACjD,EAEAxE,EAQQkC,uBAAR,SAAQA,IACP,MAAM0C,EAAY5D,OAAOoB,aAAaC,QAAQnD,EAAiBsF,kBAE/D,IAAKI,EAAW,CACf,OAAO,IACR,CACA,MAAMF,EAAMD,KAAKC,MAEjB,MAAMG,EAAgBR,SAASO,EAAW,IAC1C,GAAIN,MAAMO,GAAgB,CAEzBjF,KAAKmD,sBACL,OAAO,KACR,KAAO,CACN,OAAO2B,EAAMG,EAAgB3F,EAAiB4F,mBAC/C,CACD,EAAC,OAAA5F,CAAA,CA9P2B,CAAS6F,GAAzB7F,EAOLqF,aAAe,IAAGzE,EAAAZ,mBAPbA,EASLyD,iBAAmB,GATdzD,EAWL4F,oBAAsB,IAAO,GAAK,GAAK,GAXlC5F,EAaLoE,UAAY,mCAbPpE,EAeLoD,cAAgB,aAfXpD,EAiBLsF,iBAAmB,gBAjBdtF,EAmBLgF,mBAAqB,kBAAiB,IA8OzBc,EAAuB,SAAAC,GAAA,SAAAD,IAAA,OAAAC,EAAAC,MAAAtF,KAAAN,YAAAM,IAAA,CAAAE,EAAAkF,EAAAjF,EAAAiF,EAAAC,GAAA,IAAAE,EAAAH,EAAA/E,UAAAkF,EACrCC,eAANvE,eAAMuE,EAAeC,GACpB,MAAMC,EAAW,IAAIpG,EAAiBmG,GACtC,OAAOC,EAAS1E,YACjB,EAAC,OAAAoE,CAAA,CAJ0C,CAASO,GAAczF,EAAAkF,EAAA,OAAAlF,CAAA","ignoreList":[]}