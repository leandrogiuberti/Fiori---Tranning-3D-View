{"version":3,"file":"CacheHandlerServiceFactory.js","names":["async","getMetadataETag","sUrl","sETag","mUpdatedMetaModelETags","Promise","resolve","jQuery","ajax","method","done","oResponse","sTextStatus","jqXHR","getResponseHeader","fail","CacheHandlerService","_Service","apply","this","arguments","_exports","_inheritsLoose","_proto","prototype","init","oContext","getContext","oFactory","factory","mSettings","settings","metaModel","Error","oMetaModel","oAppComponent","appComponent","oComponent","component","initPromise","fetchEntityContainer","then","mCacheNeedsInvalidate","exit","removeGlobalInstance","validateCacheKey","sCacheIdentifier","environmentService","bCacheNeedUpdate","sCacheKey","mCacheOutput","CacheManager","get","mMetaModelETags","getETags","JSON","stringify","mCachedETags","parse","cachedETags","aValidETags","all","Object","keys","map","includes","some","viewCacheKey","e","invalidateIfNeeded","sCacheKeys","sDataSourceETags","mCacheKeys","set","forEach","sMetaModelKey","metaModelETag","Date","toISOString","oManifestContent","getManifest","sManifestHash","hash","sapApp","viewData","getViewData","capabilities","getCapabilities","getInterface","Service","CacheHandlerServiceFactory","_ServiceFactory","_this","_len","length","args","Array","_key","call","_oInstanceRegistry","_proto2","createInstance","oServiceContext","sMetaModelId","getId","cacheHandlerInstance","assign","scopeObject","scopeType","catch","getInstance","ServiceFactory"],"sources":["./CacheHandlerServiceFactory.ts"],"sourcesContent":["import hash from \"sap/base/strings/hash\";\nimport type AppComponent from \"sap/fe/core/AppComponent\";\nimport type TemplateComponent from \"sap/fe/core/TemplateComponent\";\nimport type { EnvironmentCapabilitiesService } from \"sap/fe/core/services/EnvironmentServiceFactory\";\nimport type UIComponent from \"sap/ui/core/UIComponent\";\nimport CacheManager from \"sap/ui/core/cache/CacheManager\";\nimport Service from \"sap/ui/core/service/Service\";\nimport ServiceFactory from \"sap/ui/core/service/ServiceFactory\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\nimport jQuery from \"sap/ui/thirdparty/jquery\";\nimport type { ServiceContext } from \"types/metamodel_types\";\n\nasync function getMetadataETag(sUrl: string, sETag: string, mUpdatedMetaModelETags: Record<string, string | null>): Promise<boolean> {\n\treturn new Promise<boolean>(function (resolve): void {\n\t\t// There is an Url in the FE cache, that's not in the MetaModel yet -> we need to check the ETag\n\t\tjQuery\n\t\t\t.ajax(sUrl, { method: \"GET\" })\n\t\t\t.done(function (oResponse: unknown, sTextStatus: string, jqXHR: jQuery.XHR) {\n\t\t\t\t// ETag is not the same -> invalid\n\t\t\t\t// ETag is the same -> valid\n\t\t\t\t// If ETag is available use it, otherwise use Last-Modified\n\t\t\t\tmUpdatedMetaModelETags[sUrl] = jqXHR.getResponseHeader(\"ETag\") || jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\tresolve(sETag === mUpdatedMetaModelETags[sUrl]);\n\t\t\t})\n\t\t\t.fail(function () {\n\t\t\t\t// Case 2z - Make sure we update the map so that we invalidate the cache\n\t\t\t\tmUpdatedMetaModelETags[sUrl] = \"\";\n\t\t\t\tresolve(false);\n\t\t\t});\n\t});\n}\ntype CacheHandlerServiceSettings = {\n\tmetaModel: ODataMetaModel;\n};\n\nexport class CacheHandlerService extends Service<CacheHandlerServiceSettings> {\n\tinitPromise!: Promise<this>;\n\n\toFactory!: CacheHandlerServiceFactory;\n\n\toMetaModel!: ODataMetaModel;\n\n\toAppComponent!: AppComponent;\n\n\toComponent!: UIComponent;\n\n\tmCacheNeedsInvalidate!: Record<string, unknown>;\n\n\tinit(): void {\n\t\tconst oContext = this.getContext();\n\t\tthis.oFactory = oContext.factory;\n\t\tconst mSettings = oContext.settings;\n\t\tif (!mSettings.metaModel) {\n\t\t\tthrow new Error(\"a `metaModel` property is expected when instantiating the CacheHandlerService\");\n\t\t}\n\t\tthis.oMetaModel = mSettings.metaModel;\n\t\tthis.oAppComponent = mSettings.appComponent;\n\t\tthis.oComponent = mSettings.component;\n\t\tthis.initPromise = this.oMetaModel.fetchEntityContainer().then(() => {\n\t\t\treturn this;\n\t\t});\n\t\tthis.mCacheNeedsInvalidate = {};\n\t}\n\n\texit(): void {\n\t\t// Deregister global instance\n\t\tthis.oFactory.removeGlobalInstance(this.oMetaModel);\n\t}\n\n\tasync validateCacheKey(\n\t\tsCacheIdentifier: string,\n\t\toComponent: TemplateComponent,\n\t\tenvironmentService: EnvironmentCapabilitiesService\n\t): Promise<string | null> {\n\t\t// Keep track if the cache will anyway need to be updated\n\t\tlet bCacheNeedUpdate = true;\n\t\tlet sCacheKey: string | null;\n\n\t\ttry {\n\t\t\tconst mCacheOutput = await CacheManager.get(sCacheIdentifier);\n\t\t\t// We provide a default key so that an xml view cache is written\n\t\t\tconst mMetaModelETags = this.getETags(oComponent, environmentService);\n\t\t\tsCacheKey = JSON.stringify(mMetaModelETags);\n\t\t\t// Case #1a - No cache, so mCacheOuput is empty, cacheKey = current metamodel ETags\n\t\t\tif (mCacheOutput) {\n\t\t\t\t// Case #2 - Cache entry found, check if it's still valid\n\t\t\t\tconst mUpdatedMetaModelETags: Record<string, string | null> = {};\n\t\t\t\tconst mCachedETags = JSON.parse(mCacheOutput.cachedETags);\n\t\t\t\tconst aValidETags = await Promise.all(\n\t\t\t\t\tObject.keys(mCachedETags).map(async function (sUrl: string) {\n\t\t\t\t\t\t// Check validity of every single Url that's in the FE Cache object\n\t\t\t\t\t\tif (mCachedETags[sUrl]) {\n\t\t\t\t\t\t\tif (mMetaModelETags[sUrl]) {\n\t\t\t\t\t\t\t\t// Case #2a - Same number of ETags in the cache and in the metadata\n\t\t\t\t\t\t\t\tmUpdatedMetaModelETags[sUrl] = mMetaModelETags[sUrl];\n\t\t\t\t\t\t\t\treturn mCachedETags[sUrl] === mMetaModelETags[sUrl];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Case #2b - No ETag in the cache for that URL, cachedETags was enhanced\n\t\t\t\t\t\t\t\treturn getMetadataETag(sUrl, mCachedETags[sUrl], mUpdatedMetaModelETags);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Case #2z - Last Templating added an URL without ETag\n\t\t\t\t\t\t\tmUpdatedMetaModelETags[sUrl] = mMetaModelETags[sUrl];\n\t\t\t\t\t\t\treturn mCachedETags[sUrl] === mMetaModelETags[sUrl];\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t);\n\n\t\t\t\tbCacheNeedUpdate = aValidETags.includes(false);\n\t\t\t\t// Case #2a - Same number of ETags and all valid -> we return the viewCacheKey\n\t\t\t\t// Case #2b - Different number of ETags and still all valid -> we return the viewCacheKey\n\t\t\t\t// Case #2c - Same number of ETags but different values, main service Etag has changed, use that as cache key\n\t\t\t\t// Case #2d - Different number of ETags but different value, main service Etag or linked service Etag has changed, new ETags should be used as cacheKey\n\t\t\t\t// Case #2z - Cache has an invalid Etag - if there is an Etag provided from MetaModel use it as cacheKey\n\t\t\t\tif (\n\t\t\t\t\tObject.keys(mUpdatedMetaModelETags).some(function (sUrl: string) {\n\t\t\t\t\t\treturn !mUpdatedMetaModelETags[sUrl];\n\t\t\t\t\t})\n\t\t\t\t) {\n\t\t\t\t\t// At least one of the MetaModel URLs doesn't provide an ETag, so no caching\n\t\t\t\t\tsCacheKey = null;\n\t\t\t\t} else {\n\t\t\t\t\tsCacheKey = bCacheNeedUpdate ? JSON.stringify(mUpdatedMetaModelETags) : mCacheOutput.viewCacheKey;\n\t\t\t\t\tsCacheKey ??= JSON.stringify(mUpdatedMetaModelETags); // Special case where the cache key was not set\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tObject.keys(mMetaModelETags).some(function (sUrl: string) {\n\t\t\t\t\treturn !mMetaModelETags[sUrl];\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\t// Check if cache can be used (all the metadata and annotations have to provide at least a ETag or a Last-Modified header)\n\t\t\t\t// Case #1-b - No Cache, mCacheOuput is empty, but metamodel etags cannot be used, so no caching\n\t\t\t\tsCacheKey = null;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// Don't use view cache in case of issues with the LRU cache\n\t\t\tbCacheNeedUpdate = true;\n\t\t\tsCacheKey = null;\n\t\t}\n\n\t\tthis.mCacheNeedsInvalidate[sCacheIdentifier] = bCacheNeedUpdate;\n\t\treturn sCacheKey;\n\t}\n\n\tasync invalidateIfNeeded(\n\t\tsCacheKeys: string,\n\t\tsCacheIdentifier: string,\n\t\toComponent: TemplateComponent,\n\t\tenvironmentService: EnvironmentCapabilitiesService\n\t): Promise<void> {\n\t\t// Check FE cache after XML view is processed completely\n\t\tconst sDataSourceETags = JSON.stringify(this.getETags(oComponent, environmentService));\n\t\tif (this.mCacheNeedsInvalidate[sCacheIdentifier] || (sCacheKeys && sCacheKeys !== sDataSourceETags)) {\n\t\t\t// Something in the sources and/or its ETags changed -> update the FE cache\n\t\t\tconst mCacheKeys: Record<string, string> = {};\n\t\t\t// New ETags that need to be verified, may differ from the one used to generate the view\n\t\t\tmCacheKeys.cachedETags = sDataSourceETags;\n\t\t\t// Old ETags that are used for the xml view cache as key\n\t\t\tmCacheKeys.viewCacheKey = sCacheKeys;\n\t\t\treturn CacheManager.set(sCacheIdentifier, mCacheKeys);\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\tgetETags(oComponent: TemplateComponent, environmentService: EnvironmentCapabilitiesService): Record<string, string | null> {\n\t\tconst mMetaModelETags = this.oMetaModel.getETags();\n\t\t// ETags from UI5 are either a Date or a string, let's rationalize that\n\t\tObject.keys(mMetaModelETags).forEach(function (sMetaModelKey: string) {\n\t\t\tconst metaModelETag: string | null | Object = mMetaModelETags[sMetaModelKey];\n\t\t\tif (metaModelETag !== null && metaModelETag instanceof Date) {\n\t\t\t\t// MetaModel contains a Last-Modified timestamp for the URL\n\t\t\t\tmMetaModelETags[sMetaModelKey] = (mMetaModelETags[sMetaModelKey] as unknown as Date).toISOString();\n\t\t\t}\n\t\t});\n\n\t\t// add also the manifest hash as UI5 only considers the root component hash\n\t\tconst oManifestContent = this.oAppComponent.getManifest();\n\t\tconst sManifestHash = hash(\n\t\t\tJSON.stringify({\n\t\t\t\tsapApp: oManifestContent[\"sap.app\"],\n\t\t\t\tviewData: oComponent.getViewData()\n\t\t\t})\n\t\t);\n\t\tmMetaModelETags[\"manifest\"] = sManifestHash;\n\t\tconst capabilities = environmentService.getCapabilities();\n\t\tif (capabilities) {\n\t\t\tmMetaModelETags[\"toggles\"] = hash(JSON.stringify(capabilities));\n\t\t}\n\n\t\treturn mMetaModelETags;\n\t}\n\n\tgetInterface(): this {\n\t\treturn this;\n\t}\n}\n\nclass CacheHandlerServiceFactory extends ServiceFactory<CacheHandlerServiceSettings> {\n\t_oInstanceRegistry: Record<string, CacheHandlerService | null> = {};\n\n\tasync createInstance(oServiceContext: ServiceContext<CacheHandlerServiceSettings>): Promise<CacheHandlerService> {\n\t\tconst sMetaModelId = oServiceContext.settings.metaModel.getId();\n\t\tlet cacheHandlerInstance = this._oInstanceRegistry[sMetaModelId];\n\t\tif (!cacheHandlerInstance) {\n\t\t\tthis._oInstanceRegistry[sMetaModelId] = cacheHandlerInstance = new CacheHandlerService(\n\t\t\t\tObject.assign(\n\t\t\t\t\t{\n\t\t\t\t\t\tfactory: this,\n\t\t\t\t\t\tscopeObject: null,\n\t\t\t\t\t\tscopeType: \"service\"\n\t\t\t\t\t},\n\t\t\t\t\toServiceContext\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn cacheHandlerInstance.initPromise\n\t\t\t.then(() => {\n\t\t\t\treturn this._oInstanceRegistry[sMetaModelId] as CacheHandlerService;\n\t\t\t})\n\t\t\t.catch((e: unknown) => {\n\t\t\t\t// In case of error delete the global instance;\n\t\t\t\tthis._oInstanceRegistry[sMetaModelId] = null;\n\t\t\t\tthrow e;\n\t\t\t});\n\t}\n\n\tgetInstance(oMetaModel: ODataMetaModel): CacheHandlerService | null {\n\t\treturn this._oInstanceRegistry[oMetaModel.getId()];\n\t}\n\n\tremoveGlobalInstance(oMetaModel: ODataMetaModel): void {\n\t\tthis._oInstanceRegistry[oMetaModel.getId()] = null;\n\t}\n}\n\nexport default CacheHandlerServiceFactory;\n"],"mappings":"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","ignoreList":[]}