{"version":3,"file":"FiscalFormat.js","names":["FiscalFormat","formatOptions","locale","Locale","Localization","getLanguage","localeData","LocaleData","format","length","pattern","getCustomDateTimePattern","calendarType","replace","slice","lastIndexOf","formatArray","this","parseCalendarDatePattern","undefined","_setFormatRegex","_setParseRegex","_setValidationRegex","_exports","getDateInstance","_proto","prototype","getPattern","value","formatRegExPattern","formatRegExGroups","parse","parseRegExPattern","parseRegExReplacer","validate","validationRegExPattern","test","char","currentObject","digits","symbol","curChar","symbols","push","regExPattern","regExGroups","part","regex","year","i","toLocaleLowerCase","unshift","source","some","partEntry","toLowerCase","RegExp","join","filteredFormat","currGroup","group","getRegExReplacer","result","valuePart","stringGroup","_len","arguments","args","Array","_key","key","parseInt","parseYear","padStart","_FiscalFormat","regexFormatPatterns","period","quarter","week","day","regexParsePatterns","y","Y","P","W","d","Q","q","parsedYear","Number","currentYear","Date","getUTCFullYear","currentCentury","Math","floor","yearDiff"],"sources":["./FiscalFormat.ts"],"sourcesContent":["import Localization from \"sap/base/i18n/Localization\";\nimport type CalendarType from \"sap/base/i18n/date/CalendarType\";\nimport Locale from \"sap/ui/core/Locale\";\nimport LocaleData from \"sap/ui/core/LocaleData\";\n\n/**\n * Constructor for a new FiscalFormat\n * @param formatOptions Object that defines format options\n * @param formatOptions.format String with fiscal format\n * @param formatOptions.calendarType String with calendar type\n * <h3>Overview</h3>\n *\n * Formatting, Validating and Parsing Fiscal Dates\n * @author SAP SE\n * @since 1.110.0\n * @hideconstructor\n */\nexport default class FiscalFormat {\n\tprivate pattern: string | undefined;\n\n\tprivate formatRegExPattern!: RegExp;\n\n\tprivate formatRegExGroups!: string;\n\n\tprivate parseRegExPattern!: RegExp;\n\n\tprivate validationRegExPattern!: RegExp;\n\n\tprivate parseRegExReplacer!: (substring: string, ...args: string[]) => string;\n\n\tconstructor(formatOptions: { format: string; calendarType: CalendarType }) {\n\t\tconst locale = new Locale(Localization.getLanguage());\n\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t// @ts-ignore\n\t\tconst localeData = new LocaleData(locale);\n\n\t\tlet format = formatOptions.format;\n\t\tif (formatOptions.format.length > 4) {\n\t\t\tformat = \"yM\";\n\t\t} else if (formatOptions.format === \"PPP\") {\n\t\t\tformat = \"M\";\n\t\t}\n\n\t\tlet pattern = localeData.getCustomDateTimePattern(format, formatOptions.calendarType);\n\t\tpattern = pattern.replace(/([\\u4e00-\\u9faf\\u3000-\\u303f\\u3040-\\u309f\\u30a0-\\u30ff\\uff00-\\uffef])+/gi, \"\");\n\t\t// Parsing the \"yM\" format pattern to the pattern that would match the passed format\n\t\tif (formatOptions.format.length > 4) {\n\t\t\tpattern = pattern.replace(/y+/i, formatOptions.format.slice(0, formatOptions.format.lastIndexOf(\"Y\") + 1));\n\t\t\tpattern = pattern.replace(/m+/i, formatOptions.format.slice(formatOptions.format.lastIndexOf(\"Y\") + 1));\n\t\t} else if (formatOptions.format === \"PPP\") {\n\t\t\tpattern = \"PPP\";\n\t\t}\n\n\t\tconst formatArray = this.parseCalendarDatePattern(pattern);\n\t\tthis.pattern = formatArray.length > 1 ? pattern : undefined;\n\t\tthis._setFormatRegex(formatArray);\n\t\tthis._setParseRegex(formatArray);\n\t\tthis._setValidationRegex(formatArray);\n\t}\n\n\t/**\n\t * Get a date instance of the <code>FiscalFormat</code> class, which can be used for formatting.\n\t * @param formatOptions Object that defines format options\n\t * @param formatOptions.format Fiscal format\n\t * @param formatOptions.calendarType Calendar type\n\t * @returns Instance of the FiscalFormat\n\t */\n\tpublic static getDateInstance(formatOptions: { format: string; calendarType: CalendarType }): FiscalFormat {\n\t\treturn new FiscalFormat(formatOptions);\n\t}\n\n\tpublic getPattern(): string | undefined {\n\t\treturn this.pattern;\n\t}\n\n\t/**\n\t * Format the raw fiscal data to a locale-dependent format.\n\t * @param value The parameter containing a raw fiscal value\n\t * @returns The formatted value\n\t */\n\tpublic format(value: string | number | boolean): string | number | boolean {\n\t\tif (value == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (typeof value !== \"string\") {\n\t\t\treturn value;\n\t\t}\n\n\t\treturn value.replace(this.formatRegExPattern, this.formatRegExGroups);\n\t}\n\n\t/**\n\t * Parse from a locale-dependent format to a raw value.\n\t * @param value The string containing a parsed fiscal data value\n\t * @returns The raw value\n\t */\n\tpublic parse(value: string): string {\n\t\tif (!value) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn value.replace(this.parseRegExPattern, this.parseRegExReplacer);\n\t}\n\n\t/**\n\t * Validates the data input.\n\t * @param value The raw fiscal data\n\t * @returns If <code>true</code> the validation passes, otherwise <code>false</code>\n\t */\n\tpublic validate(value: string): boolean {\n\t\treturn this.validationRegExPattern.test(value);\n\t}\n\n\t/**\n\t * Parse the date pattern string and create a format array from it.\n\t * Array is used for data parsing and formatting.\n\t * @param pattern The calendar date pattern string\n\t * @returns Format array\n\t */\n\tprivate parseCalendarDatePattern(pattern: string): { digits: number; value: string; symbol: string }[] {\n\t\tconst formatArray = [];\n\t\tlet char,\n\t\t\tcurrentObject = { digits: 0, value: \"\", symbol: \"\" };\n\n\t\tfor (const curChar of pattern) {\n\t\t\tif (char !== curChar) {\n\t\t\t\tcurrentObject = { digits: 0, value: \"\", symbol: \"\" };\n\t\t\t} else {\n\t\t\t\tcurrentObject.digits += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (typeof FiscalFormat.symbols[curChar as keyof typeof FiscalFormat.symbols] === \"undefined\") {\n\t\t\t\tcurrentObject.value = curChar;\n\t\t\t} else {\n\t\t\t\tcurrentObject.symbol = curChar;\n\t\t\t\tcurrentObject.digits = 1;\n\t\t\t}\n\t\t\tchar = curChar;\n\t\t\tformatArray.push(currentObject);\n\t\t}\n\n\t\treturn formatArray;\n\t}\n\n\t/**\n\t * Creates the formatting regular expression based on the locale-dependent format.\n\t * @param formatArray An array with the locale-dependent format\n\t */\n\tprivate _setFormatRegex(formatArray: { digits: number; value: string; symbol: string }[]): void {\n\t\tconst regExPattern = [],\n\t\t\tregExGroups = [];\n\t\tlet part, symbol, regex, year;\n\t\tfor (let i = 0; i < formatArray.length; i++) {\n\t\t\tpart = formatArray[i];\n\t\t\tsymbol = part.symbol;\n\t\t\tregex = FiscalFormat.symbols[symbol as keyof typeof FiscalFormat.symbols].format;\n\n\t\t\tif (symbol === \"\") {\n\t\t\t\tregExGroups[i] = part.value;\n\t\t\t} else if (symbol.toLocaleLowerCase() === \"y\") {\n\t\t\t\tregExPattern.unshift(\"(\" + regex.source + \")\");\n\t\t\t\tregExGroups[i] = \"$\" + 1;\n\t\t\t} else {\n\t\t\t\tregExPattern.push(\"(\" + regex.source + \")\");\n\t\t\t\tyear = formatArray.some(function (partEntry) {\n\t\t\t\t\treturn partEntry.symbol.toLowerCase() === \"y\";\n\t\t\t\t});\n\t\t\t\tregExGroups[i] = year ? \"$\" + 2 : \"$\" + 1;\n\t\t\t}\n\t\t}\n\n\t\tthis.formatRegExPattern = new RegExp(regExPattern.join(\"\"));\n\t\tthis.formatRegExGroups = regExGroups.join(\"\");\n\t}\n\n\t/**\n\t * Creates the parsing regular expression based on the locale-dependent format.\n\t * @param formatArray An array with the locale-dependent format\n\t */\n\tprivate _setParseRegex(formatArray: { digits: number; value: string; symbol: string }[]): void {\n\t\tconst regExPattern = [],\n\t\t\tfilteredFormat: { [index: string]: { digits: number; value: string; symbol: string } } = {};\n\t\tlet symbol,\n\t\t\tregex,\n\t\t\tcurrGroup: number,\n\t\t\tgroup = 0;\n\t\tfor (const part of formatArray) {\n\t\t\tsymbol = part.symbol;\n\n\t\t\tif (symbol === \"\") {\n\t\t\t\tregExPattern.push(\"\\\\D+?\");\n\t\t\t} else {\n\t\t\t\tregex = FiscalFormat.symbols[symbol as keyof typeof FiscalFormat.symbols].parse;\n\t\t\t\tregExPattern.push(\"(\" + regex.source + \")\");\n\t\t\t\tcurrGroup = ++group;\n\t\t\t\tfilteredFormat[currGroup] = part;\n\t\t\t}\n\t\t}\n\t\tthis.parseRegExPattern = new RegExp(\"^\" + regExPattern.join(\"\") + \"$\");\n\t\tthis.parseRegExReplacer = this.getRegExReplacer(filteredFormat);\n\t}\n\n\t/**\n\t * Creates a function that is used to replace strings and then performs raw string parsing.\n\t * @param filteredFormat An array with the locale-dependent format\n\t * @returns Function that can be passed into the string.replace function\n\t */\n\tprivate getRegExReplacer(filteredFormat: {\n\t\t[index: string]: { digits: number; value: string; symbol: string };\n\t}): (substring: string, ...args: string[]) => string {\n\t\treturn function (...args: string[]) {\n\t\t\tconst result = [];\n\t\t\tlet valuePart, stringGroup;\n\t\t\tfor (const key in filteredFormat) {\n\t\t\t\tvaluePart = filteredFormat[key];\n\t\t\t\tstringGroup = args[parseInt(key, 10)];\n\t\t\t\tif (stringGroup.length < valuePart.digits) {\n\t\t\t\t\tif (valuePart.symbol.toLowerCase() === \"y\") {\n\t\t\t\t\t\tstringGroup = parseYear(stringGroup);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstringGroup = stringGroup.padStart(valuePart.digits, \"0\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (valuePart.symbol.toLowerCase() === \"y\") {\n\t\t\t\t\tresult.unshift(stringGroup);\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(stringGroup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result.join(\"\");\n\t\t};\n\t}\n\n\t/**\n\t * Creates the validation regular expression based on the format.\n\t * @param formatArray An array with the locale-dependent format\n\t */\n\tprivate _setValidationRegex(formatArray: { digits: number; value: string; symbol: string }[]): void {\n\t\tconst regExPattern = [];\n\t\tlet symbol, regex;\n\t\tfor (const part of formatArray) {\n\t\t\tsymbol = part.symbol;\n\t\t\tregex = FiscalFormat.symbols[symbol as keyof typeof FiscalFormat.symbols].format;\n\t\t\tif (symbol === \"\") {\n\t\t\t\tcontinue;\n\t\t\t} else if (symbol.toLowerCase() === \"y\") {\n\t\t\t\tregExPattern.unshift(regex.source);\n\t\t\t} else {\n\t\t\t\tregExPattern.push(regex.source);\n\t\t\t}\n\t\t}\n\t\tthis.validationRegExPattern = new RegExp(\"^(\" + regExPattern.join(\")(\") + \")$\");\n\t}\n\n\t/**\n\t * Regular expression patterns used to format fiscal date strings\n\t */\n\tprivate static regexFormatPatterns = {\n\t\tyear: /[1-9]\\d{3}/,\n\t\tperiod: /\\d{3}/,\n\t\tquarter: /[1-4]/,\n\t\tweek: /0[1-9]|[1-4]\\d|5[0-3]/,\n\t\tday: /371|370|3[0-6]\\d|[1-2]\\d{2}|[1-9]\\d|[1-9]/\n\t};\n\n\t/**\n\t * Regular expression patterns used for raw data parsing and validation\n\t */\n\tprivate static regexParsePatterns = {\n\t\tyear: /\\d{1,4}/,\n\t\tperiod: /\\d{1,3}/,\n\t\tquarter: /[1-4]/,\n\t\tweek: /\\d{1,2}/,\n\t\tday: /[1-9]/\n\t};\n\n\t/**\n\t * Mapping from specific calendar type to corresponding formatting/parsing expression\n\t */\n\tprivate static symbols = {\n\t\t\"\": { format: / /, parse: / / }, // \"text\"\n\t\ty: { format: FiscalFormat.regexFormatPatterns.year, parse: FiscalFormat.regexParsePatterns.year }, // \"year\"\n\t\tY: { format: FiscalFormat.regexFormatPatterns.year, parse: FiscalFormat.regexParsePatterns.year }, // \"weekYear\"\n\t\tP: { format: FiscalFormat.regexFormatPatterns.period, parse: FiscalFormat.regexParsePatterns.period }, // \"period\"\n\t\tW: { format: FiscalFormat.regexFormatPatterns.week, parse: FiscalFormat.regexParsePatterns.week }, // \"weekInYear\"\n\t\td: { format: FiscalFormat.regexFormatPatterns.day, parse: FiscalFormat.regexParsePatterns.day }, // \"dayInYear\"\n\t\tQ: { format: FiscalFormat.regexFormatPatterns.quarter, parse: FiscalFormat.regexParsePatterns.quarter }, // \"quarter\"\n\t\tq: { format: FiscalFormat.regexFormatPatterns.quarter, parse: FiscalFormat.regexParsePatterns.quarter } //\"quarterStandalone\"\n\t};\n}\n\n/**\n * Parses the Year format. This is how the DateFormat parses years, except those years consisting of 3 digits, since currency fiscal dates support only years consisting of 4 digits.\n * @param year Year string\n * @returns Year number\n */\nfunction parseYear(year: string): number {\n\tlet parsedYear = Number.parseInt(year, 10);\n\tconst currentYear = new Date().getUTCFullYear(),\n\t\tcurrentCentury = Math.floor(currentYear / 100),\n\t\tyearDiff = currentCentury * 100 + parsedYear - currentYear;\n\n\tif (year.length === 3) {\n\t\tparsedYear += Math.floor((currentCentury - 1) / 10) * 1000;\n\t} else if (yearDiff < -70) {\n\t\tparsedYear += (currentCentury + 1) * 100; // Take next century if \"year\" is 30 years in the future. Current year 1999 and we enter 28 it will we 2028\n\t} else if (yearDiff < 30) {\n\t\tparsedYear += currentCentury * 100; // Take next century if \"year\" is 30 years in the future. Current year 2000 and we enter 29 it will we 2029\n\t} else {\n\t\tparsedYear += (currentCentury - 1) * 100; // Any entered \"year\" that is more than 30 years in the future will be treated as from previous century\n\t}\n\treturn parsedYear;\n}\n"],"mappings":"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","ignoreList":[]}