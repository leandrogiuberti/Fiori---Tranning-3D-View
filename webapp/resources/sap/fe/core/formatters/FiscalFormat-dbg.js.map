{"version":3,"names":["FiscalFormat","formatOptions","locale","Locale","Localization","getLanguage","localeData","LocaleData","format","length","pattern","getCustomDateTimePattern","calendarType","replace","slice","lastIndexOf","formatArray","parseCalendarDatePattern","undefined","_setFormatRegex","_setParseRegex","_setValidationRegex","_exports","getDateInstance","_proto","prototype","getPattern","value","formatRegExPattern","formatRegExGroups","parse","parseRegExPattern","parseRegExReplacer","validate","validationRegExPattern","test","char","currentObject","digits","symbol","curChar","symbols","push","regExPattern","regExGroups","part","regex","year","i","toLocaleLowerCase","unshift","source","some","partEntry","toLowerCase","RegExp","join","filteredFormat","currGroup","group","getRegExReplacer","result","valuePart","stringGroup","_len","arguments","args","Array","_key","key","parseInt","parseYear","padStart","_FiscalFormat","regexFormatPatterns","period","quarter","week","day","regexParsePatterns","y","Y","P","W","d","Q","q","parsedYear","Number","currentYear","Date","getUTCFullYear","currentCentury","Math","floor","yearDiff"],"sourceRoot":".","sources":["FiscalFormat.ts"],"sourcesContent":["import Localization from \"sap/base/i18n/Localization\";\nimport type CalendarType from \"sap/base/i18n/date/CalendarType\";\nimport Locale from \"sap/ui/core/Locale\";\nimport LocaleData from \"sap/ui/core/LocaleData\";\n\n/**\n * Constructor for a new FiscalFormat\n * @param formatOptions Object that defines format options\n * @param formatOptions.format String with fiscal format\n * @param formatOptions.calendarType String with calendar type\n * <h3>Overview</h3>\n *\n * Formatting, Validating and Parsing Fiscal Dates\n * @author SAP SE\n * @since 1.110.0\n * @hideconstructor\n */\nexport default class FiscalFormat {\n\tprivate pattern: string | undefined;\n\n\tprivate formatRegExPattern!: RegExp;\n\n\tprivate formatRegExGroups!: string;\n\n\tprivate parseRegExPattern!: RegExp;\n\n\tprivate validationRegExPattern!: RegExp;\n\n\tprivate parseRegExReplacer!: (substring: string, ...args: string[]) => string;\n\n\tconstructor(formatOptions: { format: string; calendarType: CalendarType }) {\n\t\tconst locale = new Locale(Localization.getLanguage());\n\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t// @ts-ignore\n\t\tconst localeData = new LocaleData(locale);\n\n\t\tlet format = formatOptions.format;\n\t\tif (formatOptions.format.length > 4) {\n\t\t\tformat = \"yM\";\n\t\t} else if (formatOptions.format === \"PPP\") {\n\t\t\tformat = \"M\";\n\t\t}\n\n\t\tlet pattern = localeData.getCustomDateTimePattern(format, formatOptions.calendarType);\n\t\tpattern = pattern.replace(/([\\u4e00-\\u9faf\\u3000-\\u303f\\u3040-\\u309f\\u30a0-\\u30ff\\uff00-\\uffef])+/gi, \"\");\n\t\t// Parsing the \"yM\" format pattern to the pattern that would match the passed format\n\t\tif (formatOptions.format.length > 4) {\n\t\t\tpattern = pattern.replace(/y+/i, formatOptions.format.slice(0, formatOptions.format.lastIndexOf(\"Y\") + 1));\n\t\t\tpattern = pattern.replace(/m+/i, formatOptions.format.slice(formatOptions.format.lastIndexOf(\"Y\") + 1));\n\t\t} else if (formatOptions.format === \"PPP\") {\n\t\t\tpattern = \"PPP\";\n\t\t}\n\n\t\tconst formatArray = this.parseCalendarDatePattern(pattern);\n\t\tthis.pattern = formatArray.length > 1 ? pattern : undefined;\n\t\tthis._setFormatRegex(formatArray);\n\t\tthis._setParseRegex(formatArray);\n\t\tthis._setValidationRegex(formatArray);\n\t}\n\n\t/**\n\t * Get a date instance of the <code>FiscalFormat</code> class, which can be used for formatting.\n\t * @param formatOptions Object that defines format options\n\t * @param formatOptions.format Fiscal format\n\t * @param formatOptions.calendarType Calendar type\n\t * @returns Instance of the FiscalFormat\n\t */\n\tpublic static getDateInstance(formatOptions: { format: string; calendarType: CalendarType }): FiscalFormat {\n\t\treturn new FiscalFormat(formatOptions);\n\t}\n\n\tpublic getPattern(): string | undefined {\n\t\treturn this.pattern;\n\t}\n\n\t/**\n\t * Format the raw fiscal data to a locale-dependent format.\n\t * @param value The parameter containing a raw fiscal value\n\t * @returns The formatted value\n\t */\n\tpublic format(value: string | number | boolean): string | number | boolean {\n\t\tif (value == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (typeof value !== \"string\") {\n\t\t\treturn value;\n\t\t}\n\n\t\treturn value.replace(this.formatRegExPattern, this.formatRegExGroups);\n\t}\n\n\t/**\n\t * Parse from a locale-dependent format to a raw value.\n\t * @param value The string containing a parsed fiscal data value\n\t * @returns The raw value\n\t */\n\tpublic parse(value: string): string {\n\t\tif (!value) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn value.replace(this.parseRegExPattern, this.parseRegExReplacer);\n\t}\n\n\t/**\n\t * Validates the data input.\n\t * @param value The raw fiscal data\n\t * @returns If <code>true</code> the validation passes, otherwise <code>false</code>\n\t */\n\tpublic validate(value: string): boolean {\n\t\treturn this.validationRegExPattern.test(value);\n\t}\n\n\t/**\n\t * Parse the date pattern string and create a format array from it.\n\t * Array is used for data parsing and formatting.\n\t * @param pattern The calendar date pattern string\n\t * @returns Format array\n\t */\n\tprivate parseCalendarDatePattern(pattern: string): { digits: number; value: string; symbol: string }[] {\n\t\tconst formatArray = [];\n\t\tlet char,\n\t\t\tcurrentObject = { digits: 0, value: \"\", symbol: \"\" };\n\n\t\tfor (const curChar of pattern) {\n\t\t\tif (char !== curChar) {\n\t\t\t\tcurrentObject = { digits: 0, value: \"\", symbol: \"\" };\n\t\t\t} else {\n\t\t\t\tcurrentObject.digits += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (typeof FiscalFormat.symbols[curChar as keyof typeof FiscalFormat.symbols] === \"undefined\") {\n\t\t\t\tcurrentObject.value = curChar;\n\t\t\t} else {\n\t\t\t\tcurrentObject.symbol = curChar;\n\t\t\t\tcurrentObject.digits = 1;\n\t\t\t}\n\t\t\tchar = curChar;\n\t\t\tformatArray.push(currentObject);\n\t\t}\n\n\t\treturn formatArray;\n\t}\n\n\t/**\n\t * Creates the formatting regular expression based on the locale-dependent format.\n\t * @param formatArray An array with the locale-dependent format\n\t */\n\tprivate _setFormatRegex(formatArray: { digits: number; value: string; symbol: string }[]): void {\n\t\tconst regExPattern = [],\n\t\t\tregExGroups = [];\n\t\tlet part, symbol, regex, year;\n\t\tfor (let i = 0; i < formatArray.length; i++) {\n\t\t\tpart = formatArray[i];\n\t\t\tsymbol = part.symbol;\n\t\t\tregex = FiscalFormat.symbols[symbol as keyof typeof FiscalFormat.symbols].format;\n\n\t\t\tif (symbol === \"\") {\n\t\t\t\tregExGroups[i] = part.value;\n\t\t\t} else if (symbol.toLocaleLowerCase() === \"y\") {\n\t\t\t\tregExPattern.unshift(\"(\" + regex.source + \")\");\n\t\t\t\tregExGroups[i] = \"$\" + 1;\n\t\t\t} else {\n\t\t\t\tregExPattern.push(\"(\" + regex.source + \")\");\n\t\t\t\tyear = formatArray.some(function (partEntry) {\n\t\t\t\t\treturn partEntry.symbol.toLowerCase() === \"y\";\n\t\t\t\t});\n\t\t\t\tregExGroups[i] = year ? \"$\" + 2 : \"$\" + 1;\n\t\t\t}\n\t\t}\n\n\t\tthis.formatRegExPattern = new RegExp(regExPattern.join(\"\"));\n\t\tthis.formatRegExGroups = regExGroups.join(\"\");\n\t}\n\n\t/**\n\t * Creates the parsing regular expression based on the locale-dependent format.\n\t * @param formatArray An array with the locale-dependent format\n\t */\n\tprivate _setParseRegex(formatArray: { digits: number; value: string; symbol: string }[]): void {\n\t\tconst regExPattern = [],\n\t\t\tfilteredFormat: { [index: string]: { digits: number; value: string; symbol: string } } = {};\n\t\tlet symbol,\n\t\t\tregex,\n\t\t\tcurrGroup: number,\n\t\t\tgroup = 0;\n\t\tfor (const part of formatArray) {\n\t\t\tsymbol = part.symbol;\n\n\t\t\tif (symbol === \"\") {\n\t\t\t\tregExPattern.push(\"\\\\D+?\");\n\t\t\t} else {\n\t\t\t\tregex = FiscalFormat.symbols[symbol as keyof typeof FiscalFormat.symbols].parse;\n\t\t\t\tregExPattern.push(\"(\" + regex.source + \")\");\n\t\t\t\tcurrGroup = ++group;\n\t\t\t\tfilteredFormat[currGroup] = part;\n\t\t\t}\n\t\t}\n\t\tthis.parseRegExPattern = new RegExp(\"^\" + regExPattern.join(\"\") + \"$\");\n\t\tthis.parseRegExReplacer = this.getRegExReplacer(filteredFormat);\n\t}\n\n\t/**\n\t * Creates a function that is used to replace strings and then performs raw string parsing.\n\t * @param filteredFormat An array with the locale-dependent format\n\t * @returns Function that can be passed into the string.replace function\n\t */\n\tprivate getRegExReplacer(filteredFormat: {\n\t\t[index: string]: { digits: number; value: string; symbol: string };\n\t}): (substring: string, ...args: string[]) => string {\n\t\treturn function (...args: string[]) {\n\t\t\tconst result = [];\n\t\t\tlet valuePart, stringGroup;\n\t\t\tfor (const key in filteredFormat) {\n\t\t\t\tvaluePart = filteredFormat[key];\n\t\t\t\tstringGroup = args[parseInt(key, 10)];\n\t\t\t\tif (stringGroup.length < valuePart.digits) {\n\t\t\t\t\tif (valuePart.symbol.toLowerCase() === \"y\") {\n\t\t\t\t\t\tstringGroup = parseYear(stringGroup);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstringGroup = stringGroup.padStart(valuePart.digits, \"0\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (valuePart.symbol.toLowerCase() === \"y\") {\n\t\t\t\t\tresult.unshift(stringGroup);\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(stringGroup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result.join(\"\");\n\t\t};\n\t}\n\n\t/**\n\t * Creates the validation regular expression based on the format.\n\t * @param formatArray An array with the locale-dependent format\n\t */\n\tprivate _setValidationRegex(formatArray: { digits: number; value: string; symbol: string }[]): void {\n\t\tconst regExPattern = [];\n\t\tlet symbol, regex;\n\t\tfor (const part of formatArray) {\n\t\t\tsymbol = part.symbol;\n\t\t\tregex = FiscalFormat.symbols[symbol as keyof typeof FiscalFormat.symbols].format;\n\t\t\tif (symbol === \"\") {\n\t\t\t\tcontinue;\n\t\t\t} else if (symbol.toLowerCase() === \"y\") {\n\t\t\t\tregExPattern.unshift(regex.source);\n\t\t\t} else {\n\t\t\t\tregExPattern.push(regex.source);\n\t\t\t}\n\t\t}\n\t\tthis.validationRegExPattern = new RegExp(\"^(\" + regExPattern.join(\")(\") + \")$\");\n\t}\n\n\t/**\n\t * Regular expression patterns used to format fiscal date strings\n\t */\n\tprivate static regexFormatPatterns = {\n\t\tyear: /[1-9]\\d{3}/,\n\t\tperiod: /\\d{3}/,\n\t\tquarter: /[1-4]/,\n\t\tweek: /0[1-9]|[1-4]\\d|5[0-3]/,\n\t\tday: /371|370|3[0-6]\\d|[1-2]\\d{2}|[1-9]\\d|[1-9]/\n\t};\n\n\t/**\n\t * Regular expression patterns used for raw data parsing and validation\n\t */\n\tprivate static regexParsePatterns = {\n\t\tyear: /\\d{1,4}/,\n\t\tperiod: /\\d{1,3}/,\n\t\tquarter: /[1-4]/,\n\t\tweek: /\\d{1,2}/,\n\t\tday: /[1-9]/\n\t};\n\n\t/**\n\t * Mapping from specific calendar type to corresponding formatting/parsing expression\n\t */\n\tprivate static symbols = {\n\t\t\"\": { format: / /, parse: / / }, // \"text\"\n\t\ty: { format: FiscalFormat.regexFormatPatterns.year, parse: FiscalFormat.regexParsePatterns.year }, // \"year\"\n\t\tY: { format: FiscalFormat.regexFormatPatterns.year, parse: FiscalFormat.regexParsePatterns.year }, // \"weekYear\"\n\t\tP: { format: FiscalFormat.regexFormatPatterns.period, parse: FiscalFormat.regexParsePatterns.period }, // \"period\"\n\t\tW: { format: FiscalFormat.regexFormatPatterns.week, parse: FiscalFormat.regexParsePatterns.week }, // \"weekInYear\"\n\t\td: { format: FiscalFormat.regexFormatPatterns.day, parse: FiscalFormat.regexParsePatterns.day }, // \"dayInYear\"\n\t\tQ: { format: FiscalFormat.regexFormatPatterns.quarter, parse: FiscalFormat.regexParsePatterns.quarter }, // \"quarter\"\n\t\tq: { format: FiscalFormat.regexFormatPatterns.quarter, parse: FiscalFormat.regexParsePatterns.quarter } //\"quarterStandalone\"\n\t};\n}\n\n/**\n * Parses the Year format. This is how the DateFormat parses years, except those years consisting of 3 digits, since currency fiscal dates support only years consisting of 4 digits.\n * @param year Year string\n * @returns Year number\n */\nfunction parseYear(year: string): number {\n\tlet parsedYear = Number.parseInt(year, 10);\n\tconst currentYear = new Date().getUTCFullYear(),\n\t\tcurrentCentury = Math.floor(currentYear / 100),\n\t\tyearDiff = currentCentury * 100 + parsedYear - currentYear;\n\n\tif (year.length === 3) {\n\t\tparsedYear += Math.floor((currentCentury - 1) / 10) * 1000;\n\t} else if (yearDiff < -70) {\n\t\tparsedYear += (currentCentury + 1) * 100; // Take next century if \"year\" is 30 years in the future. Current year 1999 and we enter 28 it will we 2028\n\t} else if (yearDiff < 30) {\n\t\tparsedYear += currentCentury * 100; // Take next century if \"year\" is 30 years in the future. Current year 2000 and we enter 29 it will we 2029\n\t} else {\n\t\tparsedYear += (currentCentury - 1) * 100; // Any entered \"year\" that is more than 30 years in the future will be treated as from previous century\n\t}\n\treturn parsedYear;\n}\n"],"mappings":"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","ignoreList":[],"file":"FiscalFormat-dbg.js"}