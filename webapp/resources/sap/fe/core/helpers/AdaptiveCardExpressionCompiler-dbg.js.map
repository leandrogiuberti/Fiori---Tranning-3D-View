{"version":3,"names":["BINDING_INDICATOR","SetOperatorMap","needParenthesis","expr","isConstant","isPathInModelExpression","isBindingToolkitExpression","_type","wrapBindingExpression","expression","embeddedInBinding","parenthesisRequired","arguments","length","undefined","compileComparisonExpression","navPathForPathsInModel","compileOperand","operand","compiledOperand","compileToAdaptiveExpression","operand1","operand2","operator","retExp","Log","warning","compileConstant","value","Error","toString","escapeXmlAttribute","_exports","getAdaptiveCompilerResult","compiledExpression","pathsInExpression","getPropertyPathsInExpression","map","path","replaceAll","pathsToQuery","ret","wrapPrimitive","compilePathInModelExpression","comparisonExpression","condition","truthyOption","onTrue","falsyOption","onFalse","ifElseExpression","setExpressions","operands","builtInFuncForOperator","totalExpression","join","notExpression","truthyExpression","err","message","String","error","compilePathInModel","modelName","propertyPathPrefix","replace","expressionForBinding","type","parameters","targetType","formatOptions","constraints","getPathInModel","getPathsInComparisonExpression","pathsInCondition","pathsInTruthyOption","pathsInFalsyOption","pathsInSetExpressions","reduce","allPaths","pathsInNotExpression","pathsInTruthyExpression","Array","from","Set"],"sourceRoot":".","sources":["AdaptiveCardExpressionCompiler.ts"],"sourcesContent":["// This file holds the expression compiler for generating adaptive card expression binding strings from binding toolkit expression.\n// NOTE: The conversion of only a few logical operations is implemented below as of now. This shall be enhanced as and when needed.\n\nimport Log from \"sap/base/Log\";\nimport {\n\tescapeXmlAttribute,\n\tisBindingToolkitExpression,\n\tisConstant,\n\tisPathInModelExpression,\n\twrapPrimitive,\n\ttype BindingToolkitExpression,\n\ttype ComparisonExpression,\n\ttype ConstantExpression,\n\ttype ExpressionOrPrimitive,\n\ttype PathInModelExpression,\n\ttype PrimitiveType\n} from \"sap/fe/base/BindingToolkit\";\n\nconst BINDING_INDICATOR = \"$\";\n\nexport type CompiledAdaptiveCardExpression = string | undefined | null;\n\nexport type QueryInfo = {\n\tpathsToQuery: string[];\n};\n\nexport type AdaptiveCompilerResult = QueryInfo & {\n\tcompiledExpression: CompiledAdaptiveCardExpression;\n};\n\nconst SetOperatorMap = {\n\t\"||\": \"or\",\n\t\"&&\": \"and\"\n};\n\n/**\n * Check if the adaptive card expression needs parenthesis.\n * @param expr Expression to be checked\n * @returns Boolean\n */\nconst needParenthesis = function <T extends PrimitiveType>(expr: ExpressionOrPrimitive<T>): boolean {\n\treturn (\n\t\t!isConstant(expr) &&\n\t\t!isPathInModelExpression(expr) &&\n\t\tisBindingToolkitExpression(expr) &&\n\t\texpr._type !== \"IfElse\" &&\n\t\texpr._type !== \"Comparison\" &&\n\t\texpr._type !== \"Not\"\n\t);\n};\n\n/**\n * Wrap the compiled binding string as required depending on its context.\n * @param expression The compiled expression\n * @param embeddedInBinding True if the compiled expression is to be embedded in a binding\n * @param parenthesisRequired True if the embedded binding needs to be wrapped in parethesis so that it is evaluated as one\n * @returns Finalized compiled expression\n */\nfunction wrapBindingExpression(\n\texpression: string,\n\tembeddedInBinding: boolean,\n\tparenthesisRequired = false\n): CompiledAdaptiveCardExpression {\n\tif (embeddedInBinding) {\n\t\tif (parenthesisRequired) {\n\t\t\treturn `(${expression})`;\n\t\t} else {\n\t\t\treturn expression;\n\t\t}\n\t} else {\n\t\treturn `${BINDING_INDICATOR}{${expression}}`;\n\t}\n}\n\n/**\n * Compile a comparison expression.\n * @param expression The comparison expression.\n * @param navPathForPathsInModel Navigation path prefix to append to paths when we compile binding expression with 'path in model'\n * @returns The compiled expression. Needs wrapping before it can be used as an expression binding.\n */\nfunction compileComparisonExpression(expression: ComparisonExpression, navPathForPathsInModel: string): string {\n\tfunction compileOperand(operand: BindingToolkitExpression<unknown>): CompiledAdaptiveCardExpression {\n\t\tconst compiledOperand = compileToAdaptiveExpression(operand, navPathForPathsInModel, true) ?? \"undefined\";\n\t\treturn wrapBindingExpression(compiledOperand, true, needParenthesis(operand));\n\t}\n\tconst { operand1, operand2, operator } = expression;\n\tlet retExp;\n\tswitch (operator) {\n\t\tcase \"===\":\n\t\t\tretExp = `equals(${compileOperand(operand1)},${compileOperand(operand2)})`;\n\t\t\tbreak;\n\t\tcase \"!==\":\n\t\t\tretExp = `not(equals(${compileOperand(operand1)},${compileOperand(operand2)}))`;\n\t\t\tbreak;\n\t\tcase \">=\":\n\t\t\tretExp = `greaterOrEquals(${compileOperand(expression.operand1)},${compileOperand(operand2)})`;\n\t\t\tbreak;\n\t\tcase \">\":\n\t\t\tretExp = `greater(${compileOperand(operand1)},${compileOperand(operand2)})`;\n\t\t\tbreak;\n\t\tcase \"<=\":\n\t\t\tretExp = `lessOrEquals(${compileOperand(operand1)},${compileOperand(operand2)})`;\n\t\t\tbreak;\n\t\tcase \"<\":\n\t\t\tretExp = `less(${compileOperand(operand1)},${compileOperand(operand2)})`;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLog.warning(`Adaptive card expression compiler: ${operator} not supported.`);\n\t}\n\n\treturn `${retExp}`;\n}\n\n/**\n * Compiles a Constant Binding Expression.\n * @param expr\n * @param embeddedInBinding\n * @returns The compiled string\n */\n\nexport function compileConstant<T extends PrimitiveType>(\n\texpr: ConstantExpression<T>,\n\tembeddedInBinding: boolean\n): CompiledAdaptiveCardExpression {\n\tif (expr.value === null || expr.value === undefined) {\n\t\treturn expr.value;\n\t}\n\tif (typeof expr.value === \"object\") {\n\t\t// NOTE: These need to be supported as and when needed.\n\t\tthrow Error(`${expr.toString()} : object as value not supported.`);\n\t}\n\n\tif (embeddedInBinding) {\n\t\tswitch (typeof expr.value) {\n\t\t\tcase \"number\":\n\t\t\tcase \"bigint\":\n\t\t\tcase \"boolean\":\n\t\t\t\treturn expr.value.toString();\n\t\t\tcase \"string\":\n\t\t\t\treturn `'${escapeXmlAttribute(expr.value.toString())}'`;\n\t\t\tdefault:\n\t\t\t\treturn \"\";\n\t\t}\n\t} else {\n\t\treturn expr.value.toString();\n\t}\n}\n/**\n * Get the adaptive compiler result for the binding expression.\n *\n * This would contain 2 parts:\n * 1. compiledExpression: Compiled adaptive binding expression.\n * 2. pathsToQuery: Paths encountered during the compilation process that need to be queried before resolving the binding during templating process.\n * @template T The target type\n * @param expression The expression to compile\n * @param navPathForPathsInModel Navigation path prefix to append to paths when we compile binding expression with 'path in model'\n * @returns The compiler result containing corresponding expression binding or undefined in case unsupported expression type is encountered and the paths encountered during the expression parsing.\n */\nexport function getAdaptiveCompilerResult<T extends PrimitiveType>(\n\texpression: ExpressionOrPrimitive<T>,\n\tnavPathForPathsInModel = \"\"\n): AdaptiveCompilerResult {\n\tconst compiledExpression = compileToAdaptiveExpression(expression, navPathForPathsInModel);\n\tlet pathsInExpression = getPropertyPathsInExpression(expression);\n\n\t// considering parent navigation path prefix that might be forced by the caller.\n\tif (navPathForPathsInModel && pathsInExpression.length > 0) {\n\t\tpathsInExpression = pathsInExpression.map((path) => `${navPathForPathsInModel.replaceAll(\"/\", \".\")}.${path}`);\n\t}\n\n\treturn {\n\t\tpathsToQuery: pathsInExpression,\n\t\tcompiledExpression\n\t};\n}\n\n/**\n * Compile an binding expression into an adaptive expression.\n *\n * Expression types supported:\n * 1. Constant\n * 2. PathInModel\n * 3. Comparison\n * 4. IfElse\n * 5. Set\n * 6. Not\n * 7. Truthy\n * 8. Unresolvable\n *\n * Expression types not supported as of now(and need to be implemented as and when required):\n * 1. Ref\n * 2. Function\n * 3. EmbeddedExpressionBinding\n * 4. EmbeddedBinding\n * 5. Concat\n * 6. Length\n * 7. Formatter\n * 8. ComplexType\n * If a unsupported expression type is encountered while compiling the expression, then an error shall be logged and undefined is returned.\n * @template T The target type\n * @param expression The expression to compile\n * @param navPathForPathsInModel Navigation path prefix to append to paths when we compile binding expression with 'path in model'\n * @param embeddedInBinding Whether the expression to compile is embedded into another expression\n * @returns The corresponding expression binding or undefined in case unsupported expression type is encountered.\n */\nexport function compileToAdaptiveExpression<T extends PrimitiveType>(\n\texpression: ExpressionOrPrimitive<T>,\n\tnavPathForPathsInModel = \"\",\n\tembeddedInBinding = false\n): CompiledAdaptiveCardExpression {\n\tlet ret: CompiledAdaptiveCardExpression;\n\n\ttry {\n\t\tconst expr = wrapPrimitive(expression);\n\n\t\tswitch (expr._type) {\n\t\t\tcase \"Unresolvable\":\n\t\t\t\tret = undefined;\n\t\t\t\tbreak;\n\t\t\tcase \"Constant\":\n\t\t\t\tret = compileConstant(expr, embeddedInBinding);\n\t\t\t\tbreak;\n\t\t\tcase \"PathInModel\":\n\t\t\t\tret = compilePathInModelExpression(expr, navPathForPathsInModel, embeddedInBinding);\n\t\t\t\tbreak;\n\t\t\tcase \"Comparison\": {\n\t\t\t\tconst comparisonExpression = compileComparisonExpression(expr, navPathForPathsInModel);\n\n\t\t\t\tret = wrapBindingExpression(comparisonExpression, embeddedInBinding);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"IfElse\": {\n\t\t\t\tconst condition = compileToAdaptiveExpression(expr.condition, navPathForPathsInModel, true);\n\t\t\t\tconst truthyOption = compileToAdaptiveExpression(expr.onTrue, navPathForPathsInModel, true);\n\t\t\t\tconst falsyOption = compileToAdaptiveExpression(expr.onFalse, navPathForPathsInModel, true);\n\t\t\t\tconst ifElseExpression = `if(${condition},${truthyOption},${falsyOption})`;\n\n\t\t\t\tret = wrapBindingExpression(ifElseExpression, embeddedInBinding);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Set\": {\n\t\t\t\tconst setExpressions = expr.operands.map((operand) => compileToAdaptiveExpression(operand, navPathForPathsInModel, true));\n\t\t\t\tconst builtInFuncForOperator = SetOperatorMap[expr.operator];\n\t\t\t\tconst totalExpression = `${builtInFuncForOperator}(${setExpressions.join(\",\")})`;\n\n\t\t\t\tret = wrapBindingExpression(totalExpression, embeddedInBinding);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Not\": {\n\t\t\t\tconst notExpression = `not(${compileToAdaptiveExpression(expr.operand, navPathForPathsInModel, true)})`;\n\t\t\t\tret = wrapBindingExpression(notExpression, embeddedInBinding);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Truthy\": {\n\t\t\t\tconst truthyExpression = `not(not(${compileToAdaptiveExpression(expr.operand, navPathForPathsInModel, true)}))`;\n\t\t\t\tret = wrapBindingExpression(truthyExpression, embeddedInBinding);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Ref\":\n\t\t\tcase \"Function\":\n\t\t\tcase \"EmbeddedExpressionBinding\":\n\t\t\tcase \"EmbeddedBinding\":\n\t\t\tcase \"Concat\":\n\t\t\tcase \"Length\":\n\t\t\tcase \"Formatter\":\n\t\t\tcase \"ComplexType\":\n\t\t\tdefault:\n\t\t\t\t// NOTE: These need to be supported as and when needed.\n\t\t\t\tthrow Error(`${expr._type} : expression type is not supported.`);\n\t\t}\n\t} catch (err: unknown) {\n\t\tconst message = err instanceof Error ? err.message : String(err);\n\t\tLog.error(`Adaptive card expression compiler : ${message}`);\n\t}\n\n\treturn ret;\n}\n\n/**\n * Compile a binding expression path.\n * @param expression The expression to compile.\n * @param navPathForPathsInModel Navigation path prefix to append to paths when we compile binding expression with 'path in model'\n * @returns The compiled path.\n */\nfunction compilePathInModel<T extends PrimitiveType>(expression: PathInModelExpression<T>, navPathForPathsInModel: string): string {\n\tconst { modelName, path } = expression;\n\n\tif (modelName) {\n\t\t// NOTE: Named model not supported\n\t\tthrow Error(`${modelName}>${path} : path in model not supported.`);\n\t}\n\tconst propertyPathPrefix = navPathForPathsInModel ? `${navPathForPathsInModel}.` : navPathForPathsInModel;\n\tconst ret = `${propertyPathPrefix}${path}`;\n\n\treturn ret.replace(\"/\", \".\");\n}\n\n/**\n * Generates the binding string for a Binding expression.\n * @param expressionForBinding The expression to compile\n * @param navPathForPathsInModel Navigation path prefix to append to paths when we compile binding expression with 'path in model'\n * @param embeddedInBinding Whether the expression to compile is embedded into another expression\n * @returns The corresponding expression binding\n */\nfunction compilePathInModelExpression<T extends PrimitiveType>(\n\texpressionForBinding: PathInModelExpression<T>,\n\tnavPathForPathsInModel: string,\n\tembeddedInBinding: boolean\n): CompiledAdaptiveCardExpression {\n\tif (\n\t\texpressionForBinding.type ||\n\t\texpressionForBinding.parameters ||\n\t\texpressionForBinding.targetType ||\n\t\texpressionForBinding.formatOptions ||\n\t\texpressionForBinding.constraints\n\t) {\n\t\t// NOTE: This is now a complex binding definition. Not supported as of now.\n\t\tthrow Error(`${expressionForBinding.toString()} : complex binding not supported.`);\n\t} else if (embeddedInBinding) {\n\t\treturn `${compilePathInModel(expressionForBinding, navPathForPathsInModel)}`;\n\t} else {\n\t\treturn `${BINDING_INDICATOR}{${compilePathInModel(expressionForBinding, navPathForPathsInModel)}}`;\n\t}\n}\n\n/**\n * Gets the property paths in the expression that might be encountered during expression compilation.\n * @template T The target type\n * @param expression The expression to compile\n * @returns The corresponding expression binding or undefined in case unsupported expression type is encountered.\n */\nexport function getPropertyPathsInExpression<T extends PrimitiveType>(expression: ExpressionOrPrimitive<T>): string[] {\n\tlet ret: string[] = [];\n\n\ttry {\n\t\tconst expr = wrapPrimitive(expression);\n\n\t\tswitch (expr._type) {\n\t\t\tcase \"Unresolvable\":\n\t\t\t\tthrow Error(`${expr._type} : expression type is not supported.`);\n\t\t\tcase \"Constant\":\n\t\t\t\tbreak;\n\t\t\tcase \"PathInModel\":\n\t\t\t\tret = [...ret, getPathInModel(expr)];\n\t\t\t\tbreak;\n\t\t\tcase \"Comparison\": {\n\t\t\t\tret = [...ret, ...getPathsInComparisonExpression(expr)];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"IfElse\": {\n\t\t\t\tconst pathsInCondition = getPropertyPathsInExpression(expr.condition);\n\t\t\t\tconst pathsInTruthyOption = getPropertyPathsInExpression(expr.onTrue);\n\t\t\t\tconst pathsInFalsyOption = getPropertyPathsInExpression(expr.onFalse);\n\t\t\t\tret = [...ret, ...pathsInCondition, ...pathsInTruthyOption, ...pathsInFalsyOption];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Set\": {\n\t\t\t\tconst pathsInSetExpressions = expr.operands.reduce(\n\t\t\t\t\t(allPaths, operand) => [...allPaths, ...getPropertyPathsInExpression(operand)],\n\t\t\t\t\t[] as string[]\n\t\t\t\t);\n\t\t\t\tret = [...ret, ...pathsInSetExpressions];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Not\": {\n\t\t\t\tconst pathsInNotExpression = getPropertyPathsInExpression(expr.operand);\n\t\t\t\tret = [...ret, ...pathsInNotExpression];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Truthy\": {\n\t\t\t\tconst pathsInTruthyExpression = getPropertyPathsInExpression(expr.operand);\n\t\t\t\tret = [...ret, ...pathsInTruthyExpression];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Ref\":\n\t\t\tcase \"Function\":\n\t\t\tcase \"EmbeddedExpressionBinding\":\n\t\t\tcase \"EmbeddedBinding\":\n\t\t\tcase \"Concat\":\n\t\t\tcase \"Length\":\n\t\t\tcase \"Formatter\":\n\t\t\tcase \"ComplexType\":\n\t\t\tdefault:\n\t\t\t\t// NOTE: These need to be supported as and when needed.\n\t\t\t\tthrow Error(`${expr._type} : expression type is not supported.`);\n\t\t}\n\t} catch (err: unknown) {\n\t\tconst message = err instanceof Error ? err.message : String(err);\n\t\tLog.error(`Adaptive card expression compiler : paths in expression : ${message}`);\n\t}\n\n\t// removing duplicates\n\tret = Array.from(new Set(ret));\n\n\treturn ret;\n}\n\nfunction getPathInModel<T extends PrimitiveType>(expression: PathInModelExpression<T>): string {\n\tif (expression.type || expression.parameters || expression.targetType || expression.formatOptions || expression.constraints) {\n\t\t// NOTE: This is now a complex binding definition. Not supported as of now.\n\t\tthrow Error(`${expression.toString()} : complex binding not supported.`);\n\t}\n\n\tconst { modelName, path } = expression;\n\n\tif (modelName) {\n\t\t// NOTE: Named model not supported\n\t\tthrow Error(`${modelName}>${path} : path in model not supported.`);\n\t}\n\n\treturn path.replaceAll(\"/\", \".\");\n}\n\nfunction getPathsInComparisonExpression(expression: ComparisonExpression): string[] {\n\tconst { operand1, operand2 } = expression;\n\treturn [...getPropertyPathsInExpression(operand1), ...getPropertyPathsInExpression(operand2)];\n}\n"],"mappings":"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","ignoreList":[],"file":"AdaptiveCardExpressionCompiler-dbg.js"}