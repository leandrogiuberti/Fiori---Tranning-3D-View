{"version":3,"file":"AppStartupHelper.js","names":["AppStartupHelper","_getKeysFromStartupParams","aKeyNames","oStartupParameters","bAllFound","aKeys","map","name","length","value","undefined","_createFilterFromKeys","bDraftMode","oMetaModel","bFilterCaseSensitive","ModelHelper","isFilteringCaseSensitive","bFilterOnActiveEntity","aFilters","key","Filter","path","operator","FilterOperator","EQ","value1","caseSensitive","oDraftFilter","filters","and","push","_sanitizeKeys","keys","entityType","forEach","propertyType","$Type","trim","formattedGuid","unFormattedGuid","matchFormatted","exec","matchUnformatted","replace","_requestObjectsFromParameters","async","aStartupPages","oModel","aContextPromises","getMetaModel","getObject","pageInfo","contextPath","technicalKeys","this","SemanticKeyHelper","getPathContent","context","bindContext","getBoundContext","Promise","resolve","semanticKeys","oFilter","draftMode","oListBind","bindList","$select","join","requestContexts","all","_getRightMostTargetName","route","manifestRouting","Array","isArray","target","reverseTargets","reverse","find","targetID","currentTarget","targets","includes","_getReachablePageInfoFromRoute","oRoute","oManifestRouting","sPattern","pattern","endsWith","sTargetName","oTarget","aPatternSegments","split","pageLevel","options","settings","allowDeepLinking","sContextPath","entitySet","metaContext","createBindingContext","objectPath","getInvolvedDataModelObjects","targetEntitySet","oEntityType","semanticKeyNames","semKey","$PropertyPath","technicalKeyNames","every","aSemantickKeys","aTechnicalKeys","targetResolutionValue","_getReachablePages","aRoutes","routes","mPagesByLevel","oPageInfo","aReachablePages","level","_getStartupPagesFromStartupParams","inboundParameterForTargetResolution","parameterValueForTargetResolution","result","current","findRecursive","aCurrentLevelPages","lastPage","nextPage","indexOf","pop","currentPage","slice","_getDeepLinkObject","aContexts","hash","oContext","getPath","getDeepLinkStartupHash","targetResolutionParameter","requestObject","startupPages","allContexts","contextsForStartup","foundContexts","getCreateStartupHash","oRouter","then","oEntitySetAnnotations","sMetaPath","bCreatable","bNewActionOperationAvailable","oInsertRestrictions","Insertable","getDefaultCreateHash","sDefaultCreateHash","preferredMode","sHash","substring","getRouteInfoByHash","Error","verifyEditAnnotations","metaModel","entitySetAnnotations","updateHidden","operationAvailable"],"sources":["./AppStartupHelper.ts"],"sourcesContent":["import type { PropertyPath } from \"@sap-ux/vocabularies-types\";\nimport type { StartupParameters } from \"sap/fe/core/AppComponent\";\nimport type { RoutingConfiguration, RoutingRoute } from \"sap/ui/core/Manifest\";\nimport type Router from \"sap/ui/core/routing/Router\";\nimport Filter from \"sap/ui/model/Filter\";\nimport FilterOperator from \"sap/ui/model/FilterOperator\";\nimport type Context from \"sap/ui/model/odata/v4/Context\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\nimport type ODataModel from \"sap/ui/model/odata/v4/ODataModel\";\nimport type { ExpandPathType, MetaModelEntitySetAnnotation } from \"types/metamodel_types\";\nimport { getInvolvedDataModelObjects } from \"../converters/MetaModelConverter\";\nimport ModelHelper from \"./ModelHelper\";\nimport SemanticKeyHelper from \"./SemanticKeyHelper\";\n\ntype ValuedKey = {\n\tname: string;\n\tvalue: string;\n};\n\ntype PageInfo = {\n\tpattern: string;\n\tcontextPath: string;\n\tdraftMode: boolean;\n\ttechnicalKeys: ValuedKey[] | undefined;\n\tsemanticKeys: ValuedKey[] | undefined;\n\ttarget: string;\n\tpageLevel: number;\n\ttargetResolutionValue: string | undefined;\n};\n\nconst AppStartupHelper = {\n\t/**\n\t * Retrieves a set of key values from the startup parameters.\n\t * @param aKeyNames The array of key names\n\t * @param oStartupParameters The startup parameters\n\t * @returns An array of pairs \\{name, value\\} if all the key values could be found in the startup parameters. Otherwise, it is undefined.\n\t */\n\t_getKeysFromStartupParams: function (aKeyNames: string[], oStartupParameters: StartupParameters | null): ValuedKey[] | undefined {\n\t\tlet bAllFound = true;\n\t\tconst aKeys = aKeyNames.map((name) => {\n\t\t\tif (oStartupParameters?.[name] && oStartupParameters[name].length === 1) {\n\t\t\t\treturn { name, value: oStartupParameters[name][0] as string };\n\t\t\t} else {\n\t\t\t\t// A unique key value couldn't be found in the startup parameters\n\t\t\t\tbAllFound = false;\n\t\t\t\treturn { name, value: \"\" };\n\t\t\t}\n\t\t});\n\n\t\treturn bAllFound ? aKeys : undefined;\n\t},\n\n\t/**\n\t * Creates a filter from a list of key values.\n\t * @param aKeys Array of semantic keys or technical keys (with values)\n\t * @param bDraftMode True if the entity supports draft mode\n\t * @param oMetaModel The metamodel\n\t * @returns The filter\n\t */\n\t_createFilterFromKeys: function (aKeys: ValuedKey[], bDraftMode: Boolean, oMetaModel: ODataMetaModel): Filter {\n\t\tconst bFilterCaseSensitive = ModelHelper.isFilteringCaseSensitive(oMetaModel);\n\n\t\tlet bFilterOnActiveEntity = false;\n\t\tconst aFilters = aKeys.map((key) => {\n\t\t\tif (key.name === \"IsActiveEntity\") {\n\t\t\t\tbFilterOnActiveEntity = true;\n\t\t\t}\n\t\t\treturn new Filter({\n\t\t\t\tpath: key.name,\n\t\t\t\toperator: FilterOperator.EQ,\n\t\t\t\tvalue1: key.value,\n\t\t\t\tcaseSensitive: bFilterCaseSensitive\n\t\t\t});\n\t\t});\n\t\tif (bDraftMode && !bFilterOnActiveEntity) {\n\t\t\tconst oDraftFilter = new Filter({\n\t\t\t\tfilters: [new Filter(\"IsActiveEntity\", \"EQ\", false), new Filter(\"SiblingEntity/IsActiveEntity\", \"EQ\", null)],\n\t\t\t\tand: false\n\t\t\t});\n\t\t\taFilters.push(oDraftFilter);\n\t\t}\n\n\t\treturn new Filter(aFilters, true);\n\t},\n\n\t/**\n\t * Makes sure key values have the correct format.\n\t * This is to handle special cases, for example, where Boolean values are 'X' or '', or guid values have the following format: guid'00000000-0000-0000-0000-000000000000'.\".\n\t * @param keys\n\t * @param entityType\n\t */\n\t_sanitizeKeys: function (keys: ValuedKey[], entityType: Record<string, { $Type: string }>): void {\n\t\tkeys.forEach((key) => {\n\t\t\tconst propertyType = entityType[key.name].$Type;\n\t\t\tswitch (propertyType) {\n\t\t\t\tcase \"Edm.Boolean\":\n\t\t\t\t\tif (key.value !== \"true\" && key.value !== \"false\") {\n\t\t\t\t\t\t// If the value is neither \"true\" nor \"false\", it's considered as false if it contains only whitespaces (e.g. to handle 'X'/'' for true/false values)\n\t\t\t\t\t\tkey.value = key.value.trim().length ? \"true\" : \"false\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Edm.Guid\": {\n\t\t\t\t\tconst formattedGuid = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i; // XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n\t\t\t\t\tconst unFormattedGuid = /[0-9a-f]{32}/i;\n\t\t\t\t\tconst matchFormatted = formattedGuid.exec(key.value);\n\t\t\t\t\tconst matchUnformatted = unFormattedGuid.exec(key.value);\n\t\t\t\t\tif (matchFormatted) {\n\t\t\t\t\t\tkey.value = matchFormatted[0];\n\t\t\t\t\t} else if (matchUnformatted) {\n\t\t\t\t\t\t// Reformat the guid value properly\n\t\t\t\t\t\tkey.value = matchUnformatted[0].replace(\n\t\t\t\t\t\t\t/^([0-9a-f]{8})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{12})$/i,\n\t\t\t\t\t\t\t\"$1-$2-$3-$4-$5\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Loads all contexts for a list of page infos.\n\t * @param aStartupPages The list of page infos\n\t * @param oModel The model used to load the contexts\n\t * @returns A Promise for all contexts\n\t */\n\t_requestObjectsFromParameters: async function (aStartupPages: PageInfo[], oModel: ODataModel): Promise<Context[][]> {\n\t\t// Load the respective objects for all object pages found in aExternallyNavigablePages\n\t\tconst aContextPromises = aStartupPages.map(async (pageInfo) => {\n\t\t\tconst entityType = oModel.getMetaModel().getObject(`${pageInfo.contextPath}/`);\n\t\t\tif (pageInfo.technicalKeys) {\n\t\t\t\tthis._sanitizeKeys(pageInfo.technicalKeys, entityType);\n\t\t\t\t// Create a context with the proper path\n\t\t\t\tconst path = `${pageInfo.contextPath}(${SemanticKeyHelper.getPathContent(pageInfo.technicalKeys, entityType)})`;\n\t\t\t\tconst context = oModel.bindContext(path).getBoundContext();\n\t\t\t\treturn Promise.resolve([context]);\n\t\t\t} else {\n\t\t\t\tconst aKeys = pageInfo.semanticKeys ?? [];\n\t\t\t\tthis._sanitizeKeys(aKeys, entityType);\n\t\t\t\tconst oFilter = this._createFilterFromKeys(aKeys, pageInfo.draftMode, oModel.getMetaModel());\n\n\t\t\t\t// only request a minimum of fields to boost backend performance since this is only used to check if an object exists\n\t\t\t\tconst oListBind = oModel.bindList(pageInfo.contextPath, undefined, undefined, oFilter, {\n\t\t\t\t\t$select: aKeys\n\t\t\t\t\t\t.map((key) => {\n\t\t\t\t\t\t\treturn key.name;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.join(\",\")\n\t\t\t\t});\n\t\t\t\treturn oListBind.requestContexts(0, 2);\n\t\t\t}\n\t\t});\n\n\t\treturn Promise.all(aContextPromises);\n\t},\n\n\t/**\n\t * Returns the rightmost target name for a given route.\n\t * @param route\n\t * @param manifestRouting\n\t * @returns The target name (or undefined if no valid target was found)\n\t */\n\t_getRightMostTargetName(route: RoutingRoute, manifestRouting: RoutingConfiguration | undefined): string | undefined {\n\t\tif (Array.isArray(route.target)) {\n\t\t\t// Get the rightmost target for this route (ignore targets corresponding to reuse components)\n\t\t\tconst reverseTargets = [...route.target].reverse();\n\t\t\treturn reverseTargets.find((targetID) => {\n\t\t\t\tconst currentTarget = manifestRouting?.targets?.[targetID];\n\t\t\t\treturn (\n\t\t\t\t\tcurrentTarget?.name &&\n\t\t\t\t\t[\"sap.fe.templates.ListReport\", \"sap.fe.templates.ObjectPage\", \"sap.fe.core.fpm\"].includes(currentTarget.name)\n\t\t\t\t);\n\t\t\t});\n\t\t} else {\n\t\t\treturn route.target;\n\t\t}\n\t},\n\n\t/**\n\t * Creates a PageInfo from a route if it's reachable from the startup parameters.\n\t * @param oRoute The route\n\t * @param oManifestRouting The app manifest routing section\n\t * @param oStartupParameters The startup parameters\n\t * @param oMetaModel The app metamodel\n\t * @returns A page info if the page is reachable, undefined otherwise\n\t */\n\t_getReachablePageInfoFromRoute: function (\n\t\toRoute: RoutingRoute,\n\t\toManifestRouting: RoutingConfiguration | undefined,\n\t\toStartupParameters: StartupParameters | null,\n\t\toMetaModel: ODataMetaModel\n\t): PageInfo | undefined {\n\t\t// Remove trailing ':?query:' and '/'\n\t\tlet sPattern: string = oRoute.pattern!.replace(\":?query:\", \"\");\n\t\tsPattern = sPattern.replace(/\\/$/, \"\");\n\n\t\tif (!sPattern || !sPattern.endsWith(\")\")) {\n\t\t\t// Ignore level-0 routes (ListReport) or routes corresponding to a 1-1 relation (no keys in the URL in this case)\n\t\t\treturn undefined;\n\t\t}\n\n\t\tsPattern = sPattern.replace(/\\(\\{[^}]*\\}\\)/g, \"(#)\"); // Replace keys with #\n\n\t\tconst sTargetName = this._getRightMostTargetName(oRoute, oManifestRouting);\n\t\tif (!sTargetName) {\n\t\t\t// No target found for this route\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst oTarget = oManifestRouting?.targets?.[sTargetName];\n\n\t\tconst aPatternSegments = sPattern.split(\"/\");\n\t\tconst pageLevel = aPatternSegments.length - 1;\n\n\t\tif (pageLevel !== 0 && oTarget?.options?.settings?.allowDeepLinking !== true) {\n\t\t\t// The first level of object page allows deep linking by default.\n\t\t\t// Otherwise, the target must allow deep linking explicitely in the manifest\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet sContextPath = \"\";\n\t\tif (oTarget?.options?.settings?.entitySet) {\n\t\t\tsContextPath = `/${oTarget.options.settings.entitySet}`;\n\t\t} else if (oTarget?.options?.settings?.contextPath) {\n\t\t\tconst metaContext = oMetaModel.createBindingContext(oTarget.options.settings.contextPath)!;\n\t\t\tconst objectPath = getInvolvedDataModelObjects(metaContext);\n\t\t\tif (objectPath.targetEntitySet) {\n\t\t\t\tsContextPath = `/${objectPath.targetEntitySet.name}`;\n\t\t\t}\n\t\t}\n\n\t\tif (!sContextPath) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst oEntityType = sContextPath && oMetaModel.getObject(`/$EntityContainer${sContextPath}/`);\n\n\t\tif (!oEntityType) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Get the semantic key values for the entity\n\t\tlet semanticKeyNames = (\n\t\t\toMetaModel.getObject(`/$EntityContainer${sContextPath}/@com.sap.vocabularies.Common.v1.SemanticKey`) as\n\t\t\t\t| ExpandPathType<PropertyPath>[]\n\t\t\t\t| undefined\n\t\t)?.map((semKey) => {\n\t\t\treturn semKey.$PropertyPath;\n\t\t});\n\n\t\t// If we're on a first level object page and the semantic keys are the same as the technical keys, we use technical keys directly,\n\t\t// to avoid the additional query used to load the object from its semantic keys in _requestObjectsFromParameters\n\t\tconst technicalKeyNames = oEntityType[\"$Key\"];\n\t\tif (\n\t\t\tpageLevel === 0 &&\n\t\t\tsemanticKeyNames &&\n\t\t\tsemanticKeyNames.length === technicalKeyNames.length &&\n\t\t\tsemanticKeyNames.every((key) => technicalKeyNames.includes(key))\n\t\t) {\n\t\t\tsemanticKeyNames = undefined;\n\t\t}\n\n\t\tconst aSemantickKeys = semanticKeyNames ? this._getKeysFromStartupParams(semanticKeyNames, oStartupParameters) : undefined;\n\n\t\t// Get the technical keys only if we couldn't find the semantic key values, and on first level OP\n\t\tconst aTechnicalKeys =\n\t\t\t!aSemantickKeys && pageLevel === 0 ? this._getKeysFromStartupParams(technicalKeyNames, oStartupParameters) : undefined;\n\n\t\tif (aSemantickKeys === undefined && aTechnicalKeys === undefined) {\n\t\t\t// We couldn't find the semantic/technical keys in the startup parameters\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// The startup parameters contain values for all semantic keys (or technical keys) --> we can store the page info in the corresponding level\n\t\tconst draftMode =\n\t\t\toMetaModel.getObject(`/$EntityContainer${sContextPath}@com.sap.vocabularies.Common.v1.DraftRoot`) ||\n\t\t\toMetaModel.getObject(`/$EntityContainer${sContextPath}@com.sap.vocabularies.Common.v1.DraftNode`)\n\t\t\t\t? true\n\t\t\t\t: false;\n\n\t\treturn {\n\t\t\tpattern: sPattern,\n\t\t\tcontextPath: sContextPath,\n\t\t\tdraftMode,\n\t\t\ttechnicalKeys: aTechnicalKeys,\n\t\t\tsemanticKeys: aSemantickKeys,\n\t\t\ttarget: sTargetName,\n\t\t\ttargetResolutionValue: oTarget?.options?.settings?.targetResolutionValue as string | undefined,\n\t\t\tpageLevel\n\t\t};\n\t},\n\n\t/**\n\t * Returns the list of all pages that allow deeplink and that can be reached using the startup parameters.\n\t * @param oManifestRouting The routing information from the app manifest\n\t * @param oStartupParameters The startup parameters\n\t * @param oMetaModel The metamodel\n\t * @returns The reachable pages\n\t */\n\t_getReachablePages: function (\n\t\toManifestRouting: RoutingConfiguration | undefined,\n\t\toStartupParameters: StartupParameters | null,\n\t\toMetaModel: ODataMetaModel\n\t): PageInfo[][] {\n\t\tconst aRoutes: RoutingRoute[] = oManifestRouting?.routes ?? [];\n\t\tconst mPagesByLevel: Record<number, PageInfo[]> = {};\n\n\t\taRoutes.forEach((oRoute) => {\n\t\t\tconst oPageInfo = this._getReachablePageInfoFromRoute(oRoute, oManifestRouting, oStartupParameters, oMetaModel);\n\n\t\t\tif (oPageInfo) {\n\t\t\t\tif (!mPagesByLevel[oPageInfo.pageLevel]) {\n\t\t\t\t\tmPagesByLevel[oPageInfo.pageLevel] = [];\n\t\t\t\t}\n\t\t\t\tmPagesByLevel[oPageInfo.pageLevel].push(oPageInfo);\n\t\t\t}\n\t\t});\n\n\t\t// A page is reachable only if all its parents are also reachable\n\t\t// So if we couldn't find any pages for a given level, all pages with a higher level won't be reachable anyway\n\t\tconst aReachablePages: PageInfo[][] = [];\n\t\tlet level = 0;\n\t\twhile (mPagesByLevel[level]) {\n\t\t\taReachablePages.push(mPagesByLevel[level]);\n\t\t\tlevel++;\n\t\t}\n\n\t\treturn aReachablePages;\n\t},\n\n\t/**\n\t * Get the list of startup pages.\n\t * @param oManifestRouting The routing information from the app manifest\n\t * @param oStartupParameters The startup parameters\n\t * @param oMetaModel The metamodel\n\t * @param inboundParameterForTargetResolution The target resolution parameter from the app manifest\n\t * @returns An array of startup page infos\n\t */\n\t_getStartupPagesFromStartupParams: function (\n\t\toManifestRouting: RoutingConfiguration | undefined,\n\t\toStartupParameters: StartupParameters | null,\n\t\toMetaModel: ODataMetaModel,\n\t\tinboundParameterForTargetResolution: string | undefined\n\t): PageInfo[] {\n\t\tconst parameterValueForTargetResolution =\n\t\t\tinboundParameterForTargetResolution &&\n\t\t\toStartupParameters &&\n\t\t\toStartupParameters[inboundParameterForTargetResolution] &&\n\t\t\toStartupParameters[inboundParameterForTargetResolution][0];\n\n\t\t// Find all pages that can be reached with the startup parameters\n\t\tconst aReachablePages = this._getReachablePages(oManifestRouting, oStartupParameters, oMetaModel);\n\n\t\tif (aReachablePages.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Find the longest sequence of pages that can be reached (recursively)\n\t\tlet result: PageInfo[] = [];\n\t\tconst current: PageInfo[] = [];\n\n\t\tfunction findRecursive(level: number): void {\n\t\t\tconst aCurrentLevelPages = aReachablePages[level];\n\t\t\tconst lastPage = current.length ? current[current.length - 1] : undefined;\n\n\t\t\tif (aCurrentLevelPages) {\n\t\t\t\taCurrentLevelPages.forEach(function (nextPage) {\n\t\t\t\t\tif (!lastPage || nextPage.pattern.indexOf(lastPage.pattern) === 0) {\n\t\t\t\t\t\t// We only consider pages that can be reached from the page at the previous level,\n\t\t\t\t\t\t// --> their pattern must be the pattern of the previous page with another segment appended\n\t\t\t\t\t\tcurrent.push(nextPage);\n\t\t\t\t\t\tfindRecursive(level + 1);\n\t\t\t\t\t\tcurrent.pop();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (current.length > result.length) {\n\t\t\t\tconst currentPage = current.slice(-1)[0];\n\t\t\t\tif (parameterValueForTargetResolution) {\n\t\t\t\t\tif (currentPage.targetResolutionValue === parameterValueForTargetResolution) {\n\t\t\t\t\t\tresult = current.slice(); // We have found a sequence longer than our previous best with the right target resolution parameter --> store it as the new longest\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresult = current.slice(); // We have found a sequence longer than our previous best --> store it as the new longest\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfindRecursive(0);\n\t\treturn result;\n\t},\n\n\t/**\n\t * Creates the startup object from the list of pages and contexts.\n\t * @param aStartupPages The pages\n\t * @param aContexts The contexts\n\t * @returns An object containing either a hash or a context to navigate to, or an empty object if no deep link was found\n\t */\n\t_getDeepLinkObject: function (aStartupPages: PageInfo[], aContexts: Context[]): { hash?: string; context?: Context } {\n\t\tif (aContexts.length === 1) {\n\t\t\treturn { context: aContexts[0] };\n\t\t} else if (aContexts.length > 1) {\n\t\t\t// Navigation to a deeper level --> use the pattern of the deepest object page\n\t\t\t// and replace the parameters by the ID from the contexts\n\t\t\tlet hash = aStartupPages[aStartupPages.length - 1].pattern;\n\t\t\taContexts.forEach(function (oContext) {\n\t\t\t\thash = hash.replace(\"(#)\", `(${oContext.getPath().split(\"(\")[1]}`);\n\t\t\t});\n\n\t\t\treturn { hash };\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\n\t/**\n\t * Calculates startup parameters for a deeplink case, from startup parameters and routing information.\n\t * @param oManifestRouting The routing information from the app manifest\n\t * @param oStartupParameters The startup parameters\n\t * @param oModel The OData model\n\t * @param targetResolutionParameter The inbound parameter for target resolution\n\t * @returns An object containing either a hash or a context to navigate to, or an empty object if no deep link was found\n\t */\n\tgetDeepLinkStartupHash: async function (\n\t\toManifestRouting: RoutingConfiguration | undefined,\n\t\toStartupParameters: StartupParameters | null,\n\t\toModel: ODataModel,\n\t\ttargetResolutionParameter: string | undefined\n\t): Promise<{ hash?: string; context?: Context }> {\n\t\tawait oModel.getMetaModel().requestObject(\"/$EntityContainer/\");\n\n\t\t// Check if semantic keys are present in url parameters for every object page at each level\n\t\tconst startupPages = this._getStartupPagesFromStartupParams(\n\t\t\toManifestRouting,\n\t\t\toStartupParameters,\n\t\t\toModel.getMetaModel(),\n\t\t\ttargetResolutionParameter\n\t\t);\n\n\t\t// Load the contexts\n\t\tconst allContexts = await this._requestObjectsFromParameters(startupPages, oModel);\n\t\tif (allContexts.length) {\n\t\t\t// Make sure we only get 1 context per promise, and flatten the array\n\t\t\tconst contextsForStartup: Context[] = [];\n\t\t\tallContexts.forEach(function (foundContexts) {\n\t\t\t\tif (foundContexts.length === 1) {\n\t\t\t\t\tcontextsForStartup.push(foundContexts[0]);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn contextsForStartup.length === allContexts.length ? this._getDeepLinkObject(startupPages, contextsForStartup) : {};\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\n\t/**\n\t * Calculates the new hash based on the startup parameters.\n\t * @param oStartupParameters The startup parameter values (map parameter name -> array of values)\n\t * @param sContextPath The context path for the startup of the app (generally the path to the main entity set)\n\t * @param oRouter The router instance\n\t * @param oMetaModel The meta model\n\t * @returns A promise containing the hash to navigate to, or an empty string if there's no need to navigate\n\t */\n\tgetCreateStartupHash: async function (\n\t\toStartupParameters: StartupParameters,\n\t\tsContextPath: string,\n\t\toRouter: Router,\n\t\toMetaModel: ODataMetaModel\n\t): Promise<string> {\n\t\treturn oMetaModel.requestObject(`${sContextPath}@`).then((oEntitySetAnnotations: MetaModelEntitySetAnnotation) => {\n\t\t\tlet sMetaPath = \"\";\n\t\t\tlet bCreatable = true;\n\n\t\t\tif (\n\t\t\t\toEntitySetAnnotations[\"@com.sap.vocabularies.Common.v1.DraftRoot\"] &&\n\t\t\t\toEntitySetAnnotations[\"@com.sap.vocabularies.Common.v1.DraftRoot\"][\"NewAction\"]\n\t\t\t) {\n\t\t\t\tsMetaPath = `${sContextPath}@com.sap.vocabularies.Common.v1.DraftRoot/NewAction@Org.OData.Core.V1.OperationAvailable`;\n\t\t\t} else if (\n\t\t\t\toEntitySetAnnotations[\"@com.sap.vocabularies.Session.v1.StickySessionSupported\"] &&\n\t\t\t\toEntitySetAnnotations[\"@com.sap.vocabularies.Session.v1.StickySessionSupported\"][\"NewAction\"]\n\t\t\t) {\n\t\t\t\tsMetaPath = `${sContextPath}@com.sap.vocabularies.Session.v1.StickySessionSupported/NewAction@Org.OData.Core.V1.OperationAvailable`;\n\t\t\t}\n\n\t\t\tif (sMetaPath) {\n\t\t\t\tconst bNewActionOperationAvailable = oMetaModel.getObject(sMetaPath);\n\t\t\t\tif (bNewActionOperationAvailable === false) {\n\t\t\t\t\tbCreatable = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst oInsertRestrictions = oEntitySetAnnotations[\"@Org.OData.Capabilities.V1.InsertRestrictions\"];\n\t\t\t\tif (oInsertRestrictions && oInsertRestrictions.Insertable === false) {\n\t\t\t\t\tbCreatable = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bCreatable) {\n\t\t\t\treturn this.getDefaultCreateHash(oStartupParameters, sContextPath, oRouter);\n\t\t\t} else {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Calculates the hash to create a new object.\n\t * @param oStartupParameters The startup parameter values (map parameter name -> array of values)\n\t * @param sContextPath The context path of the entity set to be used for the creation\n\t * @param oRouter The router instance\n\t * @returns The hash\n\t */\n\tgetDefaultCreateHash: function (\n\t\toStartupParameters: StartupParameters | null | undefined,\n\t\tsContextPath: string,\n\t\toRouter: Router\n\t): string {\n\t\tlet sDefaultCreateHash = oStartupParameters && oStartupParameters.preferredMode ? oStartupParameters.preferredMode[0] : \"create\";\n\t\tlet sHash = \"\";\n\n\t\tsDefaultCreateHash =\n\t\t\tsDefaultCreateHash.includes(\":\") && sDefaultCreateHash.length > sDefaultCreateHash.indexOf(\":\") + 1\n\t\t\t\t? sDefaultCreateHash.substring(0, sDefaultCreateHash.indexOf(\":\"))\n\t\t\t\t: \"create\";\n\t\tsHash = `${sContextPath.substring(1)}(...)?i-action=${sDefaultCreateHash}`;\n\t\tif (oRouter.getRouteInfoByHash(sHash)) {\n\t\t\treturn sHash;\n\t\t} else {\n\t\t\tthrow new Error(`No route match for creating a new ${sContextPath.substring(1)}`);\n\t\t}\n\t},\n\n\t/**\n\t * Verifies whether the entity in the given context path is editable by looking at the following annotations:\n\t *\n\t * - @Core.OperationAvailable of the edit action\n\t * - @UI.UpdateHidden\n\t *\n\t * Only static values (true/false) are considered here as we don't have the actual binding context to evaluate dynamic bindings.\n\t * @param contextPath\n\t * @param metaModel\n\t * @returns Whether the entity is editable or not\n\t */\n\tverifyEditAnnotations: async function (contextPath: string, metaModel: ODataMetaModel): Promise<boolean> {\n\t\tconst entitySetAnnotations: MetaModelEntitySetAnnotation = await metaModel.requestObject(`${contextPath}@`);\n\t\tconst updateHidden = entitySetAnnotations?.[\"@com.sap.vocabularies.UI.v1.UpdateHidden\"];\n\t\tlet operationAvailable = true;\n\n\t\tif (entitySetAnnotations?.[\"@com.sap.vocabularies.Common.v1.DraftRoot\"]?.[\"EditAction\"]) {\n\t\t\toperationAvailable = metaModel.getObject(\n\t\t\t\t`${contextPath}@com.sap.vocabularies.Common.v1.DraftRoot/EditAction@Org.OData.Core.V1.OperationAvailable`\n\t\t\t);\n\t\t}\n\n\t\treturn operationAvailable !== false && updateHidden !== true;\n\t}\n};\n\nexport default AppStartupHelper;\n"],"mappings":"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","ignoreList":[]}