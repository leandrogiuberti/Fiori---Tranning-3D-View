{"version":3,"file":"AdaptiveCardExpressionCompiler.js","names":["BINDING_INDICATOR","SetOperatorMap","needParenthesis","expr","isConstant","isPathInModelExpression","isBindingToolkitExpression","_type","wrapBindingExpression","expression","embeddedInBinding","parenthesisRequired","arguments","length","undefined","compileComparisonExpression","navPathForPathsInModel","compileOperand","operand","compiledOperand","compileToAdaptiveExpression","operand1","operand2","operator","retExp","Log","warning","compileConstant","value","Error","toString","escapeXmlAttribute","_exports","getAdaptiveCompilerResult","compiledExpression","pathsInExpression","getPropertyPathsInExpression","map","path","replaceAll","pathsToQuery","ret","wrapPrimitive","compilePathInModelExpression","comparisonExpression","condition","truthyOption","onTrue","falsyOption","onFalse","ifElseExpression","setExpressions","operands","builtInFuncForOperator","totalExpression","join","notExpression","truthyExpression","err","message","String","error","compilePathInModel","modelName","propertyPathPrefix","replace","expressionForBinding","type","parameters","targetType","formatOptions","constraints","getPathInModel","getPathsInComparisonExpression","pathsInCondition","pathsInTruthyOption","pathsInFalsyOption","pathsInSetExpressions","reduce","allPaths","pathsInNotExpression","pathsInTruthyExpression","Array","from","Set"],"sources":["./AdaptiveCardExpressionCompiler.ts"],"sourcesContent":["// This file holds the expression compiler for generating adaptive card expression binding strings from binding toolkit expression.\n// NOTE: The conversion of only a few logical operations is implemented below as of now. This shall be enhanced as and when needed.\n\nimport Log from \"sap/base/Log\";\nimport {\n\tescapeXmlAttribute,\n\tisBindingToolkitExpression,\n\tisConstant,\n\tisPathInModelExpression,\n\twrapPrimitive,\n\ttype BindingToolkitExpression,\n\ttype ComparisonExpression,\n\ttype ConstantExpression,\n\ttype ExpressionOrPrimitive,\n\ttype PathInModelExpression,\n\ttype PrimitiveType\n} from \"sap/fe/base/BindingToolkit\";\n\nconst BINDING_INDICATOR = \"$\";\n\nexport type CompiledAdaptiveCardExpression = string | undefined | null;\n\nexport type QueryInfo = {\n\tpathsToQuery: string[];\n};\n\nexport type AdaptiveCompilerResult = QueryInfo & {\n\tcompiledExpression: CompiledAdaptiveCardExpression;\n};\n\nconst SetOperatorMap = {\n\t\"||\": \"or\",\n\t\"&&\": \"and\"\n};\n\n/**\n * Check if the adaptive card expression needs parenthesis.\n * @param expr Expression to be checked\n * @returns Boolean\n */\nconst needParenthesis = function <T extends PrimitiveType>(expr: ExpressionOrPrimitive<T>): boolean {\n\treturn (\n\t\t!isConstant(expr) &&\n\t\t!isPathInModelExpression(expr) &&\n\t\tisBindingToolkitExpression(expr) &&\n\t\texpr._type !== \"IfElse\" &&\n\t\texpr._type !== \"Comparison\" &&\n\t\texpr._type !== \"Not\"\n\t);\n};\n\n/**\n * Wrap the compiled binding string as required depending on its context.\n * @param expression The compiled expression\n * @param embeddedInBinding True if the compiled expression is to be embedded in a binding\n * @param parenthesisRequired True if the embedded binding needs to be wrapped in parethesis so that it is evaluated as one\n * @returns Finalized compiled expression\n */\nfunction wrapBindingExpression(\n\texpression: string,\n\tembeddedInBinding: boolean,\n\tparenthesisRequired = false\n): CompiledAdaptiveCardExpression {\n\tif (embeddedInBinding) {\n\t\tif (parenthesisRequired) {\n\t\t\treturn `(${expression})`;\n\t\t} else {\n\t\t\treturn expression;\n\t\t}\n\t} else {\n\t\treturn `${BINDING_INDICATOR}{${expression}}`;\n\t}\n}\n\n/**\n * Compile a comparison expression.\n * @param expression The comparison expression.\n * @param navPathForPathsInModel Navigation path prefix to append to paths when we compile binding expression with 'path in model'\n * @returns The compiled expression. Needs wrapping before it can be used as an expression binding.\n */\nfunction compileComparisonExpression(expression: ComparisonExpression, navPathForPathsInModel: string): string {\n\tfunction compileOperand(operand: BindingToolkitExpression<unknown>): CompiledAdaptiveCardExpression {\n\t\tconst compiledOperand = compileToAdaptiveExpression(operand, navPathForPathsInModel, true) ?? \"undefined\";\n\t\treturn wrapBindingExpression(compiledOperand, true, needParenthesis(operand));\n\t}\n\tconst { operand1, operand2, operator } = expression;\n\tlet retExp;\n\tswitch (operator) {\n\t\tcase \"===\":\n\t\t\tretExp = `equals(${compileOperand(operand1)},${compileOperand(operand2)})`;\n\t\t\tbreak;\n\t\tcase \"!==\":\n\t\t\tretExp = `not(equals(${compileOperand(operand1)},${compileOperand(operand2)}))`;\n\t\t\tbreak;\n\t\tcase \">=\":\n\t\t\tretExp = `greaterOrEquals(${compileOperand(expression.operand1)},${compileOperand(operand2)})`;\n\t\t\tbreak;\n\t\tcase \">\":\n\t\t\tretExp = `greater(${compileOperand(operand1)},${compileOperand(operand2)})`;\n\t\t\tbreak;\n\t\tcase \"<=\":\n\t\t\tretExp = `lessOrEquals(${compileOperand(operand1)},${compileOperand(operand2)})`;\n\t\t\tbreak;\n\t\tcase \"<\":\n\t\t\tretExp = `less(${compileOperand(operand1)},${compileOperand(operand2)})`;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLog.warning(`Adaptive card expression compiler: ${operator} not supported.`);\n\t}\n\n\treturn `${retExp}`;\n}\n\n/**\n * Compiles a Constant Binding Expression.\n * @param expr\n * @param embeddedInBinding\n * @returns The compiled string\n */\n\nexport function compileConstant<T extends PrimitiveType>(\n\texpr: ConstantExpression<T>,\n\tembeddedInBinding: boolean\n): CompiledAdaptiveCardExpression {\n\tif (expr.value === null || expr.value === undefined) {\n\t\treturn expr.value;\n\t}\n\tif (typeof expr.value === \"object\") {\n\t\t// NOTE: These need to be supported as and when needed.\n\t\tthrow Error(`${expr.toString()} : object as value not supported.`);\n\t}\n\n\tif (embeddedInBinding) {\n\t\tswitch (typeof expr.value) {\n\t\t\tcase \"number\":\n\t\t\tcase \"bigint\":\n\t\t\tcase \"boolean\":\n\t\t\t\treturn expr.value.toString();\n\t\t\tcase \"string\":\n\t\t\t\treturn `'${escapeXmlAttribute(expr.value.toString())}'`;\n\t\t\tdefault:\n\t\t\t\treturn \"\";\n\t\t}\n\t} else {\n\t\treturn expr.value.toString();\n\t}\n}\n/**\n * Get the adaptive compiler result for the binding expression.\n *\n * This would contain 2 parts:\n * 1. compiledExpression: Compiled adaptive binding expression.\n * 2. pathsToQuery: Paths encountered during the compilation process that need to be queried before resolving the binding during templating process.\n * @template T The target type\n * @param expression The expression to compile\n * @param navPathForPathsInModel Navigation path prefix to append to paths when we compile binding expression with 'path in model'\n * @returns The compiler result containing corresponding expression binding or undefined in case unsupported expression type is encountered and the paths encountered during the expression parsing.\n */\nexport function getAdaptiveCompilerResult<T extends PrimitiveType>(\n\texpression: ExpressionOrPrimitive<T>,\n\tnavPathForPathsInModel = \"\"\n): AdaptiveCompilerResult {\n\tconst compiledExpression = compileToAdaptiveExpression(expression, navPathForPathsInModel);\n\tlet pathsInExpression = getPropertyPathsInExpression(expression);\n\n\t// considering parent navigation path prefix that might be forced by the caller.\n\tif (navPathForPathsInModel && pathsInExpression.length > 0) {\n\t\tpathsInExpression = pathsInExpression.map((path) => `${navPathForPathsInModel.replaceAll(\"/\", \".\")}.${path}`);\n\t}\n\n\treturn {\n\t\tpathsToQuery: pathsInExpression,\n\t\tcompiledExpression\n\t};\n}\n\n/**\n * Compile an binding expression into an adaptive expression.\n *\n * Expression types supported:\n * 1. Constant\n * 2. PathInModel\n * 3. Comparison\n * 4. IfElse\n * 5. Set\n * 6. Not\n * 7. Truthy\n * 8. Unresolvable\n *\n * Expression types not supported as of now(and need to be implemented as and when required):\n * 1. Ref\n * 2. Function\n * 3. EmbeddedExpressionBinding\n * 4. EmbeddedBinding\n * 5. Concat\n * 6. Length\n * 7. Formatter\n * 8. ComplexType\n * If a unsupported expression type is encountered while compiling the expression, then an error shall be logged and undefined is returned.\n * @template T The target type\n * @param expression The expression to compile\n * @param navPathForPathsInModel Navigation path prefix to append to paths when we compile binding expression with 'path in model'\n * @param embeddedInBinding Whether the expression to compile is embedded into another expression\n * @returns The corresponding expression binding or undefined in case unsupported expression type is encountered.\n */\nexport function compileToAdaptiveExpression<T extends PrimitiveType>(\n\texpression: ExpressionOrPrimitive<T>,\n\tnavPathForPathsInModel = \"\",\n\tembeddedInBinding = false\n): CompiledAdaptiveCardExpression {\n\tlet ret: CompiledAdaptiveCardExpression;\n\n\ttry {\n\t\tconst expr = wrapPrimitive(expression);\n\n\t\tswitch (expr._type) {\n\t\t\tcase \"Unresolvable\":\n\t\t\t\tret = undefined;\n\t\t\t\tbreak;\n\t\t\tcase \"Constant\":\n\t\t\t\tret = compileConstant(expr, embeddedInBinding);\n\t\t\t\tbreak;\n\t\t\tcase \"PathInModel\":\n\t\t\t\tret = compilePathInModelExpression(expr, navPathForPathsInModel, embeddedInBinding);\n\t\t\t\tbreak;\n\t\t\tcase \"Comparison\": {\n\t\t\t\tconst comparisonExpression = compileComparisonExpression(expr, navPathForPathsInModel);\n\n\t\t\t\tret = wrapBindingExpression(comparisonExpression, embeddedInBinding);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"IfElse\": {\n\t\t\t\tconst condition = compileToAdaptiveExpression(expr.condition, navPathForPathsInModel, true);\n\t\t\t\tconst truthyOption = compileToAdaptiveExpression(expr.onTrue, navPathForPathsInModel, true);\n\t\t\t\tconst falsyOption = compileToAdaptiveExpression(expr.onFalse, navPathForPathsInModel, true);\n\t\t\t\tconst ifElseExpression = `if(${condition},${truthyOption},${falsyOption})`;\n\n\t\t\t\tret = wrapBindingExpression(ifElseExpression, embeddedInBinding);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Set\": {\n\t\t\t\tconst setExpressions = expr.operands.map((operand) => compileToAdaptiveExpression(operand, navPathForPathsInModel, true));\n\t\t\t\tconst builtInFuncForOperator = SetOperatorMap[expr.operator];\n\t\t\t\tconst totalExpression = `${builtInFuncForOperator}(${setExpressions.join(\",\")})`;\n\n\t\t\t\tret = wrapBindingExpression(totalExpression, embeddedInBinding);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Not\": {\n\t\t\t\tconst notExpression = `not(${compileToAdaptiveExpression(expr.operand, navPathForPathsInModel, true)})`;\n\t\t\t\tret = wrapBindingExpression(notExpression, embeddedInBinding);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Truthy\": {\n\t\t\t\tconst truthyExpression = `not(not(${compileToAdaptiveExpression(expr.operand, navPathForPathsInModel, true)}))`;\n\t\t\t\tret = wrapBindingExpression(truthyExpression, embeddedInBinding);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Ref\":\n\t\t\tcase \"Function\":\n\t\t\tcase \"EmbeddedExpressionBinding\":\n\t\t\tcase \"EmbeddedBinding\":\n\t\t\tcase \"Concat\":\n\t\t\tcase \"Length\":\n\t\t\tcase \"Formatter\":\n\t\t\tcase \"ComplexType\":\n\t\t\tdefault:\n\t\t\t\t// NOTE: These need to be supported as and when needed.\n\t\t\t\tthrow Error(`${expr._type} : expression type is not supported.`);\n\t\t}\n\t} catch (err: unknown) {\n\t\tconst message = err instanceof Error ? err.message : String(err);\n\t\tLog.error(`Adaptive card expression compiler : ${message}`);\n\t}\n\n\treturn ret;\n}\n\n/**\n * Compile a binding expression path.\n * @param expression The expression to compile.\n * @param navPathForPathsInModel Navigation path prefix to append to paths when we compile binding expression with 'path in model'\n * @returns The compiled path.\n */\nfunction compilePathInModel<T extends PrimitiveType>(expression: PathInModelExpression<T>, navPathForPathsInModel: string): string {\n\tconst { modelName, path } = expression;\n\n\tif (modelName) {\n\t\t// NOTE: Named model not supported\n\t\tthrow Error(`${modelName}>${path} : path in model not supported.`);\n\t}\n\tconst propertyPathPrefix = navPathForPathsInModel ? `${navPathForPathsInModel}.` : navPathForPathsInModel;\n\tconst ret = `${propertyPathPrefix}${path}`;\n\n\treturn ret.replace(\"/\", \".\");\n}\n\n/**\n * Generates the binding string for a Binding expression.\n * @param expressionForBinding The expression to compile\n * @param navPathForPathsInModel Navigation path prefix to append to paths when we compile binding expression with 'path in model'\n * @param embeddedInBinding Whether the expression to compile is embedded into another expression\n * @returns The corresponding expression binding\n */\nfunction compilePathInModelExpression<T extends PrimitiveType>(\n\texpressionForBinding: PathInModelExpression<T>,\n\tnavPathForPathsInModel: string,\n\tembeddedInBinding: boolean\n): CompiledAdaptiveCardExpression {\n\tif (\n\t\texpressionForBinding.type ||\n\t\texpressionForBinding.parameters ||\n\t\texpressionForBinding.targetType ||\n\t\texpressionForBinding.formatOptions ||\n\t\texpressionForBinding.constraints\n\t) {\n\t\t// NOTE: This is now a complex binding definition. Not supported as of now.\n\t\tthrow Error(`${expressionForBinding.toString()} : complex binding not supported.`);\n\t} else if (embeddedInBinding) {\n\t\treturn `${compilePathInModel(expressionForBinding, navPathForPathsInModel)}`;\n\t} else {\n\t\treturn `${BINDING_INDICATOR}{${compilePathInModel(expressionForBinding, navPathForPathsInModel)}}`;\n\t}\n}\n\n/**\n * Gets the property paths in the expression that might be encountered during expression compilation.\n * @template T The target type\n * @param expression The expression to compile\n * @returns The corresponding expression binding or undefined in case unsupported expression type is encountered.\n */\nexport function getPropertyPathsInExpression<T extends PrimitiveType>(expression: ExpressionOrPrimitive<T>): string[] {\n\tlet ret: string[] = [];\n\n\ttry {\n\t\tconst expr = wrapPrimitive(expression);\n\n\t\tswitch (expr._type) {\n\t\t\tcase \"Unresolvable\":\n\t\t\t\tthrow Error(`${expr._type} : expression type is not supported.`);\n\t\t\tcase \"Constant\":\n\t\t\t\tbreak;\n\t\t\tcase \"PathInModel\":\n\t\t\t\tret = [...ret, getPathInModel(expr)];\n\t\t\t\tbreak;\n\t\t\tcase \"Comparison\": {\n\t\t\t\tret = [...ret, ...getPathsInComparisonExpression(expr)];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"IfElse\": {\n\t\t\t\tconst pathsInCondition = getPropertyPathsInExpression(expr.condition);\n\t\t\t\tconst pathsInTruthyOption = getPropertyPathsInExpression(expr.onTrue);\n\t\t\t\tconst pathsInFalsyOption = getPropertyPathsInExpression(expr.onFalse);\n\t\t\t\tret = [...ret, ...pathsInCondition, ...pathsInTruthyOption, ...pathsInFalsyOption];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Set\": {\n\t\t\t\tconst pathsInSetExpressions = expr.operands.reduce(\n\t\t\t\t\t(allPaths, operand) => [...allPaths, ...getPropertyPathsInExpression(operand)],\n\t\t\t\t\t[] as string[]\n\t\t\t\t);\n\t\t\t\tret = [...ret, ...pathsInSetExpressions];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Not\": {\n\t\t\t\tconst pathsInNotExpression = getPropertyPathsInExpression(expr.operand);\n\t\t\t\tret = [...ret, ...pathsInNotExpression];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Truthy\": {\n\t\t\t\tconst pathsInTruthyExpression = getPropertyPathsInExpression(expr.operand);\n\t\t\t\tret = [...ret, ...pathsInTruthyExpression];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"Ref\":\n\t\t\tcase \"Function\":\n\t\t\tcase \"EmbeddedExpressionBinding\":\n\t\t\tcase \"EmbeddedBinding\":\n\t\t\tcase \"Concat\":\n\t\t\tcase \"Length\":\n\t\t\tcase \"Formatter\":\n\t\t\tcase \"ComplexType\":\n\t\t\tdefault:\n\t\t\t\t// NOTE: These need to be supported as and when needed.\n\t\t\t\tthrow Error(`${expr._type} : expression type is not supported.`);\n\t\t}\n\t} catch (err: unknown) {\n\t\tconst message = err instanceof Error ? err.message : String(err);\n\t\tLog.error(`Adaptive card expression compiler : paths in expression : ${message}`);\n\t}\n\n\t// removing duplicates\n\tret = Array.from(new Set(ret));\n\n\treturn ret;\n}\n\nfunction getPathInModel<T extends PrimitiveType>(expression: PathInModelExpression<T>): string {\n\tif (expression.type || expression.parameters || expression.targetType || expression.formatOptions || expression.constraints) {\n\t\t// NOTE: This is now a complex binding definition. Not supported as of now.\n\t\tthrow Error(`${expression.toString()} : complex binding not supported.`);\n\t}\n\n\tconst { modelName, path } = expression;\n\n\tif (modelName) {\n\t\t// NOTE: Named model not supported\n\t\tthrow Error(`${modelName}>${path} : path in model not supported.`);\n\t}\n\n\treturn path.replaceAll(\"/\", \".\");\n}\n\nfunction getPathsInComparisonExpression(expression: ComparisonExpression): string[] {\n\tconst { operand1, operand2 } = expression;\n\treturn [...getPropertyPathsInExpression(operand1), ...getPropertyPathsInExpression(operand2)];\n}\n"],"mappings":"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","ignoreList":[]}