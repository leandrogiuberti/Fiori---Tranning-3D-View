{"version":3,"names":["evaluateExpression","bindingToolkitExpression","modelData","missingModels","Set","transformedExpression","transformRecursively","pathInModel","modelName","currentModelData","undefined","add","unresolvableExpression","constant","ObjectPath","get","path","replace","isConstant","value","Error","Array","from","join","_exports"],"sourceRoot":".","sources":["BindingToolkitEvaluator.ts"],"sourcesContent":["import type { PrimitiveType } from \"@sap-ux/vocabularies-types\";\nimport ObjectPath from \"sap/base/util/ObjectPath\";\nimport type { BindingToolkitExpression, PathInModelExpression } from \"sap/fe/base/BindingToolkit\";\nimport { constant, isConstant, transformRecursively, unresolvableExpression } from \"sap/fe/base/BindingToolkit\";\n\n/**\n * Evaluates a binding toolkit expression based on available data and without data binding.\n *\n * This is an experimental feature that aims to replace code where we resolve $Path manually for a more complete solution.\n * It might not work in all scenario especially when multiple models are involved.\n * @param bindingToolkitExpression The expression to evaluate\n * @param modelData The data that will be used to resolve the expression\n * @returns The result of the expression or throws an error if the expression cannot be resolved\n */\nexport function evaluateExpression<T extends PrimitiveType>(\n\tbindingToolkitExpression: BindingToolkitExpression<T>,\n\tmodelData: Record<string, undefined | Record<string, unknown>>\n): unknown {\n\tconst missingModels = new Set<string>();\n\tconst transformedExpression = transformRecursively(\n\t\tbindingToolkitExpression,\n\t\t\"PathInModel\",\n\t\t(pathInModel: PathInModelExpression<unknown>) => {\n\t\t\t// undefined modelName needs to be treated as empty string for the lookup\n\t\t\tconst modelName = pathInModel.modelName ?? \"\";\n\t\t\tconst currentModelData = modelData[modelName];\n\t\t\tif (currentModelData === undefined) {\n\t\t\t\tmissingModels.add(modelName);\n\t\t\t\treturn unresolvableExpression;\n\t\t\t}\n\t\t\treturn constant<PrimitiveType>(ObjectPath.get(pathInModel.path.replace(/\\//g, \".\"), currentModelData));\n\t\t},\n\t\ttrue\n\t);\n\tif (isConstant(transformedExpression)) {\n\t\treturn transformedExpression.value;\n\t} else {\n\t\tthrow new Error(\n\t\t\t`Expression cannot be resolved not constant as data from the following models: ${Array.from(missingModels).join(\n\t\t\t\t\",\"\n\t\t\t)} is missing`\n\t\t);\n\t}\n}\n"],"mappings":";;;;;;;;;;;;EAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACO,SAASA,kBAAkBA,CACjCC,wBAAqD,EACrDC,SAA8D,EACpD;IACV,MAAMC,aAAa,GAAG,IAAIC,GAAG,CAAS,CAAC;IACvC,MAAMC,qBAAqB,GAAGC,oBAAoB,CACjDL,wBAAwB,EACxB,aAAa,EACZM,WAA2C,IAAK;MAChD;MACA,MAAMC,SAAS,GAAGD,WAAW,CAACC,SAAS,IAAI,EAAE;MAC7C,MAAMC,gBAAgB,GAAGP,SAAS,CAACM,SAAS,CAAC;MAC7C,IAAIC,gBAAgB,KAAKC,SAAS,EAAE;QACnCP,aAAa,CAACQ,GAAG,CAACH,SAAS,CAAC;QAC5B,OAAOI,sBAAsB;MAC9B;MACA,OAAOC,QAAQ,CAAgBC,UAAU,CAACC,GAAG,CAACR,WAAW,CAACS,IAAI,CAACC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,EAAER,gBAAgB,CAAC,CAAC;IACvG,CAAC,EACD,IACD,CAAC;IACD,IAAIS,UAAU,CAACb,qBAAqB,CAAC,EAAE;MACtC,OAAOA,qBAAqB,CAACc,KAAK;IACnC,CAAC,MAAM;MACN,MAAM,IAAIC,KAAK,CACd,iFAAiFC,KAAK,CAACC,IAAI,CAACnB,aAAa,CAAC,CAACoB,IAAI,CAC9G,GACD,CAAC,aACF,CAAC;IACF;EACD;EAACC,QAAA,CAAAxB,kBAAA,GAAAA,kBAAA;EAAA,OAAAwB,QAAA;AAAA","ignoreList":[],"file":"BindingToolkitEvaluator-dbg.js"}