{"version":3,"file":"PasteHelper.js","names":["getInfoForEntityProperty","propertyPath","rowBindingPath","metaContext","metaModel","enablePastingOfComputedProperties","arguments","length","undefined","forceIgnore","property","getProperty","formatOptions","parseKeepsEmptyString","type","getUI5Type","isIgnored","computed","ignore","displayErrorMessages","errorMessages","messageDetails","resourceBundle","Library","getResourceBundleFor","errorCorrectionMessage","getText","noteMessage","pasteErrorMessage","unshift","MessageBox","error","title","details","join","PasteHelper","formatCustomMessage","validationMessages","iRowNumber","errorMessage","numberMessages","i18nRow","forEach","message","indexMessage","messageText","getColumnInfo","table","columns","ignoreNavigationProperty","model","getRowBinding","getModel","getMetaModel","resolve","getPath","getContext","getMetaContext","entityTypeProperties","MetaModelConverter","getInvolvedDataModelObjects","targetEntityType","entityProperties","columnArrangementProperty","tableDefinition","getParent","getTableDefinition","getColumnFromPropertyInfos","dataProperty","hasValueHelp","text","push","exportSettings","includes","path","control","propertyInfo","getEnhancedFetchedPropertyInfos","propertyInfoDict","Object","assign","map","key","columnInfos","getColumns","column","infoProperty","getPropertyKey","propertyInfos","this","hasValueHelpProperty","columnToPush","exportDataPointTargetValue","find","p","name","annotations","Common","ValueList","parsePastedData","async","rawData","pasteInfos","pastedColumnCount","firstEditableColumnIndex","I","computedProperties","filter","info","computedProperty","columnPosition","indexOf","isColEmpty","every","row","parseResult","parsedData","errors","CorePasteHelper","parse","oElement","_updateContexts","contexts","data","index","setPropertyPromises","rowContext","getPropertyEditMode","FieldEditMode","Editable","setProperty","Log","warning","getIndex","Promise","allSettled","getPasteInformationForReponsiveTable","cellSelection","posFirstSelectedRow","numberOfNewCreationRows","posFirstInlineCreationRowInTable","getCurrentContexts","findIndex","context","isTransient","rows","updatedRowCount","slice","lastInlineCreationRowInSelection","pop","posLastInlineCreationRowInSelection","Math","min","getPasteInformationForGridTable","tableRowcCount","getLength","getPasteInformation","pasteInformation","getCreationMode","getName","CreationMode","InlineCreationRows","pasteRangeData","pasteInfo","createEmptyRows","requestContexts","posFirstInlineCreationRow","focusRow","updatedColCount","keys","pasteData","controller","editFlow","aData","then","aParsedData","all","validateDocument","getBindingContext","mData","customValidationFunction","aValidationMessages","aErrorMessages","reduce","aMessages","aCustomMessages","messages","aRowMessages","mError","transientContexts","lastTransientContext","lastTransientContextHasErrorMessage","Messaging","getMessageModel","getData","getTargets","newContexts","aValidatedData","createMultipleDocuments","createAtEnd","onBeforeCreate","delete","catch","oError"],"sources":["./PasteHelper.ts"],"sourcesContent":["import type { ArrayWithIndex, Property } from \"@sap-ux/vocabularies-types\";\nimport Log from \"sap/base/Log\";\nimport type PageController from \"sap/fe/core/PageController\";\nimport * as MetaModelConverter from \"sap/fe/core/converters/MetaModelConverter\";\nimport type TableAPI from \"sap/fe/macros/table/TableAPI\";\nimport type { EnhancedFEPropertyInfo } from \"sap/fe/macros/table/TableAPI\";\nimport MessageBox from \"sap/m/MessageBox\";\nimport Library from \"sap/ui/core/Lib\";\nimport Messaging from \"sap/ui/core/Messaging\";\nimport type Message from \"sap/ui/core/message/Message\";\nimport * as CorePasteHelper from \"sap/ui/core/util/PasteHelper\";\nimport type Table from \"sap/ui/mdc/Table\";\nimport type Column from \"sap/ui/mdc/table/Column\";\nimport type Context from \"sap/ui/model/Context\";\nimport type ODataType from \"sap/ui/model/odata/type/ODataType\";\nimport type ODataV4Context from \"sap/ui/model/odata/v4/Context\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\nimport { CreationMode } from \"../converters/ManifestSettings\";\nimport { FieldEditMode } from \"../templating/UIFormatters\";\n\nexport type customValidationMessage = {\n\tmessageText?: string;\n\tmessageTarget?: string;\n};\n\ntype PasteInformation = {\n\trows: ODataV4Context[];\n\tcolumns: Column[];\n\tupdatedRowCount: number;\n\tnumberOfNewCreationRows: number;\n};\n\nconst getInfoForEntityProperty = function (\n\tpropertyPath: string,\n\trowBindingPath: string,\n\tmetaContext: Context,\n\tmetaModel: ODataMetaModel,\n\tenablePastingOfComputedProperties = false,\n\tforceIgnore = false\n): PasteColumnInfo {\n\tconst property = metaContext.getProperty(propertyPath),\n\t\tformatOptions = { parseKeepsEmptyString: true },\n\t\ttype = metaModel.getUI5Type(`${rowBindingPath}/${propertyPath}`, formatOptions);\n\tlet isIgnored, computed;\n\tif (enablePastingOfComputedProperties === true) {\n\t\tisIgnored = !property;\n\t\tcomputed = metaContext.getProperty(`${propertyPath}@Org.OData.Core.V1.Computed`);\n\t} else {\n\t\tisIgnored = !property || metaContext.getProperty(`${propertyPath}@Org.OData.Core.V1.Computed`);\n\t}\n\n\treturn {\n\t\tproperty: propertyPath,\n\t\tignore: forceIgnore || isIgnored,\n\t\tcomputed: computed,\n\t\ttype: type\n\t};\n};\n\nconst displayErrorMessages = function (errorMessages: string[]): void {\n\tconst messageDetails = [...errorMessages];\n\tconst resourceBundle = Library.getResourceBundleFor(\"sap.fe.core\")!,\n\t\terrorCorrectionMessage = resourceBundle.getText(\"C_PASTE_HELPER_SAPFE_PASTE_ERROR_CORRECTION_MESSAGE\"),\n\t\tnoteMessage = resourceBundle.getText(\"C_PASTE_HELPER_SAPFE_PASTE_ERROR_CORRECTION_NOTE\");\n\tlet pasteErrorMessage;\n\n\tif (messageDetails.length > 1) {\n\t\tpasteErrorMessage = resourceBundle.getText(\"C_PASTE_HELPER_SAPFE_PASTE_ERROR_MESSAGE_PLURAL\", [messageDetails.length]);\n\t} else {\n\t\tpasteErrorMessage = resourceBundle.getText(\"C_PASTE_HELPER_SAPFE_PASTE_ERROR_MESSAGE_SINGULAR\");\n\t}\n\tmessageDetails.unshift(\"\"); // To show space between the short text and the list of errors\n\tmessageDetails.unshift(noteMessage);\n\tmessageDetails.unshift(errorCorrectionMessage);\n\tMessageBox.error(pasteErrorMessage, {\n\t\ttitle: resourceBundle.getText(\"C_COMMON_SAPFE_ERROR_MESSAGES_PAGE_TITLE_ERROR\"),\n\t\tdetails: messageDetails.join(\"<br>\")\n\t});\n};\n\ntype PasteColumnInfo = {\n\tproperty: string | undefined;\n\ttype?: ODataType | null;\n\tignore: boolean;\n\tcomputed?: boolean;\n};\n\nconst PasteHelper = {\n\tdisplayErrorMessages: displayErrorMessages,\n\tformatCustomMessage: function (validationMessages: customValidationMessage[], iRowNumber: number): string {\n\t\tlet errorMessage = \"\";\n\t\tconst numberMessages = validationMessages.length;\n\t\tconst resourceBundle = Library.getResourceBundleFor(\"sap.fe.core\")!,\n\t\t\ti18nRow = resourceBundle.getText(\"T_MESSAGE_GROUP_DESCRIPTION_TABLE_ROW\");\n\t\tif (numberMessages > 0) {\n\t\t\terrorMessage += `${i18nRow} ${iRowNumber}: `;\n\t\t\tvalidationMessages.forEach((message, indexMessage) => {\n\t\t\t\tif (message.messageText) {\n\t\t\t\t\terrorMessage += message.messageText + (indexMessage + 1 !== numberMessages ? \" \" : \"\");\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn errorMessage;\n\t},\n\t/**\n\t * Get details about table columns.\n\t * @param table The table which contains the columns to be analyzed\n\t * @param columns A list of columns to be analyzed. If undefined, all columns from the table are analyzed\n\t * @param ignoreNavigationProperty If true, navigation properties are ignored\n\t * @returns An array of objects providing details about columns.\n\t */\n\tgetColumnInfo: function (table: Table, columns?: Column[], ignoreNavigationProperty = true): PasteColumnInfo[] {\n\t\tconst model = table.getRowBinding().getModel(),\n\t\t\tmetaModel = model.getMetaModel(),\n\t\t\trowBindingPath = model.resolve(table.getRowBinding().getPath(), table.getRowBinding().getContext()),\n\t\t\tmetaContext = metaModel.getMetaContext(rowBindingPath),\n\t\t\tentityTypeProperties = MetaModelConverter.getInvolvedDataModelObjects(metaContext).targetEntityType.entityProperties,\n\t\t\tcolumnArrangementProperty: string[] = [],\n\t\t\ttableDefinition = (table.getParent() as TableAPI).getTableDefinition();\n\t\tfunction getColumnFromPropertyInfos(\n\t\t\tdataProperty: EnhancedFEPropertyInfo,\n\t\t\thasValueHelp: boolean,\n\t\t\tproperty: string\n\t\t): PasteColumnInfo | undefined {\n\t\t\t// If we have a textArrangement, we want to remove it if it has a ValueList associated.\n\t\t\tif (dataProperty.text && hasValueHelp) {\n\t\t\t\tcolumnArrangementProperty.push(dataProperty.text);\n\t\t\t}\n\t\t\t// Non exported columns should be part of the columnInfos\n\t\t\tif (dataProperty.exportSettings !== null) {\n\t\t\t\t// Check a navigation property within the current Complex property --> ignore\n\t\t\t\tif (ignoreNavigationProperty && property.includes(\"/\")) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tproperty: dataProperty.path,\n\t\t\t\t\t\tignore: true\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tlet forceIgnore = false;\n\t\t\t\t\tif (dataProperty.path) {\n\t\t\t\t\t\tforceIgnore = columnArrangementProperty.includes(dataProperty.path);\n\t\t\t\t\t}\n\t\t\t\t\t// The object this is weird in a function, so changing it to PasteHelper instead.\n\t\t\t\t\treturn PasteHelper.getInfoForEntityProperty(\n\t\t\t\t\t\tdataProperty.path!,\n\t\t\t\t\t\trowBindingPath,\n\t\t\t\t\t\tmetaContext,\n\t\t\t\t\t\tmetaModel,\n\t\t\t\t\t\ttableDefinition.control.enablePastingOfComputedProperties,\n\t\t\t\t\t\tforceIgnore\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst propertyInfo = (table.getParent() as TableAPI).getEnhancedFetchedPropertyInfos();\n\t\tconst propertyInfoDict: Record<string, EnhancedFEPropertyInfo> = Object.assign(\n\t\t\t{},\n\t\t\t...propertyInfo.map((property) => ({ [property.key]: property }))\n\t\t);\n\t\tconst columnInfos: PasteColumnInfo[] = [];\n\t\t(columns ?? table.getColumns()).forEach((column) => {\n\t\t\tconst infoProperty = propertyInfoDict[column.getPropertyKey()];\n\t\t\t// Check if it's a complex property (property associated to multiple simple properties)\n\t\t\tif (infoProperty.propertyInfos) {\n\t\t\t\t// Get data from simple property\n\t\t\t\tinfoProperty.propertyInfos.forEach((property: string) => {\n\t\t\t\t\tconst dataProperty = propertyInfoDict[property],\n\t\t\t\t\t\thasValueHelp = this.hasValueHelpProperty(entityTypeProperties, dataProperty),\n\t\t\t\t\t\tcolumnToPush = getColumnFromPropertyInfos(dataProperty, hasValueHelp, property);\n\t\t\t\t\tif (columnToPush) {\n\t\t\t\t\t\tcolumnInfos.push(columnToPush);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (infoProperty.exportDataPointTargetValue) {\n\t\t\t\t\tcolumnInfos.push({\n\t\t\t\t\t\tproperty: \"targetValueFromDataPoint\",\n\t\t\t\t\t\tignore: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// Non exported columns should be part of the columnInfos\n\t\t\t} else if (infoProperty.exportSettings !== null) {\n\t\t\t\tif (infoProperty.path) {\n\t\t\t\t\tcolumnInfos.push(\n\t\t\t\t\t\tPasteHelper.getInfoForEntityProperty(\n\t\t\t\t\t\t\tinfoProperty.path,\n\t\t\t\t\t\t\trowBindingPath,\n\t\t\t\t\t\t\tmetaContext,\n\t\t\t\t\t\t\tmetaModel,\n\t\t\t\t\t\t\ttableDefinition.control.enablePastingOfComputedProperties\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// Empty column --> ignore\n\t\t\t\t\tcolumnInfos.push({\n\t\t\t\t\t\tproperty: \"unused\",\n\t\t\t\t\t\ttype: null,\n\t\t\t\t\t\tignore: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn columnInfos;\n\t},\n\tgetInfoForEntityProperty: getInfoForEntityProperty,\n\n\t/**\n\t * Returns whether a property has a value list or not.\n\t * @param entityTypeProperties The entity properties\n\t * @param dataProperty The property we want to check\n\t * @returns Boolean `true` if the property has a value list.\n\t */\n\thasValueHelpProperty: function (\n\t\tentityTypeProperties: ArrayWithIndex<Property, \"name\" | \"fullyQualifiedName\">,\n\t\tdataProperty: EnhancedFEPropertyInfo\n\t): boolean {\n\t\tconst property = entityTypeProperties.find((p) => p.name === dataProperty.path);\n\t\tif (property) {\n\t\t\treturn !!property.annotations?.Common?.ValueList;\n\t\t}\n\t\treturn false;\n\t},\n\n\t/**\n\t * Transform an array of data by parsing it into an array of objects, facilitating the mapping of columns and data.\n\t * @param rawData The table which contains the columns to be analyzed\n\t * @param table The table which receives the data\n\t * @param columns A list of columns to be used to map the data. If undefined, all table columns are used\n\t * @param ignoreNavigationProperty If true, navigation properties are ignored\n\t * @returns A collection of objects that associates data with corresponding columns.\n\t */\n\tparsePastedData: async function (\n\t\trawData: unknown[][],\n\t\ttable: Table,\n\t\tcolumns?: Column[],\n\t\tignoreNavigationProperty = true\n\t): Promise<Record<string, unknown>[]> {\n\t\tconst pasteInfos = this.getColumnInfo(table, columns, ignoreNavigationProperty);\n\t\tconst tableDefinition = (table.getParent() as TableAPI).getTableDefinition();\n\t\t// Check if we have data for at least the first editable column\n\t\tconst pastedColumnCount = rawData.length ? rawData[0].length : 0;\n\t\tlet firstEditableColumnIndex = -1;\n\t\tfor (let I = 0; I < pasteInfos.length && firstEditableColumnIndex < 0; I++) {\n\t\t\tif (!pasteInfos[I].ignore && !pasteInfos[I].computed) {\n\t\t\t\tfirstEditableColumnIndex = I;\n\t\t\t}\n\t\t}\n\n\t\tif (tableDefinition.control.enablePastingOfComputedProperties) {\n\t\t\tconst computedProperties = pasteInfos.filter(function (info) {\n\t\t\t\treturn info.computed;\n\t\t\t});\n\t\t\t//for each computed property, check if the column is empty . If yes, ignore it\n\t\t\tcomputedProperties.forEach(function (computedProperty) {\n\t\t\t\tconst columnPosition = pasteInfos.indexOf(computedProperty);\n\t\t\t\tconst isColEmpty = rawData.every((row) => row[columnPosition] === \"\");\n\t\t\t\tif (isColEmpty) {\n\t\t\t\t\tcomputedProperty.ignore = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tconst parseResult = await (firstEditableColumnIndex < 0 || firstEditableColumnIndex > pastedColumnCount - 1\n\t\t\t? { parsedData: [], errors: null } // We don't have data for an editable column --> return empty parsed data\n\t\t\t: CorePasteHelper.parse(rawData, pasteInfos));\n\t\tif (parseResult.errors) {\n\t\t\tconst errorMessages = parseResult.errors.map(function (oElement) {\n\t\t\t\treturn oElement.message;\n\t\t\t});\n\t\t\tthis.displayErrorMessages(errorMessages);\n\t\t\treturn []; // Errors --> return nothing\n\t\t} else {\n\t\t\treturn parseResult.parsedData;\n\t\t}\n\t},\n\n\t/**\n\t * Update an array of contexts.\n\t * @param table The table which contains the contexts to be updated\n\t * @param contexts Array of contexts to be updated\n\t * @param data Array of object containing the data to be used to update the contexts\n\t * @returns Promise\n\t */\n\t_updateContexts: async function (\n\t\ttable: Table,\n\t\tcontexts: (ODataV4Context | undefined)[],\n\t\tdata: Record<string, unknown>[]\n\t): Promise<void> {\n\t\tlet index = 0;\n\t\tconst setPropertyPromises = [];\n\t\tfor (const row of data) {\n\t\t\tconst rowContext = contexts[index++];\n\t\t\tif (rowContext) {\n\t\t\t\tfor (const dataProperty in row) {\n\t\t\t\t\tif ((table.getParent() as TableAPI).getPropertyEditMode(dataProperty, rowContext) === FieldEditMode.Editable) {\n\t\t\t\t\t\tsetPropertyPromises.push(rowContext.setProperty(dataProperty, row[dataProperty]));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLog.warning(`Property ${dataProperty} is not editable for row ${rowContext.getIndex()}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tawait Promise.allSettled(setPropertyPromises);\n\t},\n\n\t/**\n\t *  Get information about the paste operation on ResponsiveTable.\n\t * @param rawData\n\t * @param cellSelection\n\t * @param cellSelection.columns\n\t * @param cellSelection.rows\n\t * @param posFirstSelectedRow\n\t * @param table\n\t * @returns Objet containing Information about the pasting operation\n\t */\n\tgetPasteInformationForReponsiveTable: function (\n\t\trawData: string[][],\n\t\tcellSelection: { columns: Column[]; rows: ODataV4Context[] },\n\t\tposFirstSelectedRow: number,\n\t\ttable: Table\n\t): PasteInformation {\n\t\tlet numberOfNewCreationRows = 0;\n\t\tconst posFirstInlineCreationRowInTable = table\n\t\t\t.getRowBinding()\n\t\t\t.getCurrentContexts()\n\t\t\t.findIndex((context) => context.isTransient());\n\t\tconst rows = cellSelection.rows;\n\t\tlet updatedRowCount = 0;\n\t\tconst columns =\n\t\t\tcellSelection.columns.length > 1\n\t\t\t\t? cellSelection.columns\n\t\t\t\t: table.getColumns().slice(table.getColumns().indexOf(cellSelection.columns[0]));\n\n\t\t// only one cell is selected\n\t\tif (cellSelection.columns.length === 1 && cellSelection.rows.length === 1) {\n\t\t\t// check if the inline creation row is in the targeted range\n\t\t\tif (\n\t\t\t\tposFirstSelectedRow <= posFirstInlineCreationRowInTable &&\n\t\t\t\tposFirstSelectedRow + rawData.length > posFirstInlineCreationRowInTable\n\t\t\t) {\n\t\t\t\tnumberOfNewCreationRows = rawData.length - (posFirstInlineCreationRowInTable - posFirstSelectedRow) - 1;\n\t\t\t\tupdatedRowCount = rawData.length;\n\t\t\t} else {\n\t\t\t\t// the inline creation row is not in the targeted range\n\t\t\t\tnumberOfNewCreationRows = 0;\n\t\t\t\tupdatedRowCount = rawData.length;\n\t\t\t}\n\t\t} else {\n\t\t\t// multiple cells are selected\n\t\t\tconst lastInlineCreationRowInSelection = rows.filter((context) => context.isTransient())?.pop();\n\t\t\tconst posLastInlineCreationRowInSelection = lastInlineCreationRowInSelection\n\t\t\t\t? rows.indexOf(lastInlineCreationRowInSelection)\n\t\t\t\t: -1;\n\t\t\tupdatedRowCount = Math.min(rawData.length, cellSelection.rows.length);\n\t\t\t// check if the inline creation row is in the selected range\n\t\t\tif (posLastInlineCreationRowInSelection > -1) {\n\t\t\t\tupdatedRowCount = posLastInlineCreationRowInSelection === cellSelection.rows.length - 1 ? rawData.length : updatedRowCount;\n\t\t\t\tnumberOfNewCreationRows =\n\t\t\t\t\tposLastInlineCreationRowInSelection === cellSelection.rows.length - 1\n\t\t\t\t\t\t? rawData.length - posLastInlineCreationRowInSelection - 1\n\t\t\t\t\t\t: 0;\n\t\t\t}\n\t\t}\n\t\treturn { rows, columns, updatedRowCount, numberOfNewCreationRows };\n\t},\n\n\t/**\n\t *  Get information about the paste operation on GridTable.\n\t * @param rawData\n\t * @param cellSelection\n\t * @param cellSelection.columns\n\t * @param cellSelection.rows\n\t * @param posFirstSelectedRow\n\t * @param table\n\t * @returns Objet containing Information about the pasting operation\n\t */\n\tgetPasteInformationForGridTable: function (\n\t\trawData: string[][],\n\t\tcellSelection: { columns: Column[]; rows: ODataV4Context[] },\n\t\tposFirstSelectedRow: number,\n\t\ttable: Table\n\t): PasteInformation {\n\t\tlet numberOfNewCreationRows = 0;\n\t\tconst rows = cellSelection.rows;\n\t\tlet updatedRowCount = 0;\n\t\tconst tableRowcCount = table.getRowBinding().getLength();\n\t\tlet columns =\n\t\t\tcellSelection.columns.length > 1\n\t\t\t\t? cellSelection.columns\n\t\t\t\t: table.getColumns().slice(table.getColumns().indexOf(cellSelection.columns[0]));\n\t\tif (cellSelection.columns.length === 1 && cellSelection.rows.length === 1) {\n\t\t\tnumberOfNewCreationRows =\n\t\t\t\tposFirstSelectedRow + rawData.length > tableRowcCount ? posFirstSelectedRow + rawData.length - tableRowcCount : 0;\n\t\t\tcolumns = table.getColumns().slice(table.getColumns().indexOf(cellSelection.columns[0]));\n\t\t\tupdatedRowCount = rawData.length;\n\t\t} else {\n\t\t\t// multiple cells are selected\n\t\t\tnumberOfNewCreationRows =\n\t\t\t\tposFirstSelectedRow + rows.length >= tableRowcCount ? posFirstSelectedRow + rawData.length - tableRowcCount : 0;\n\t\t\tupdatedRowCount = numberOfNewCreationRows === 0 ? Math.min(rawData.length, cellSelection.rows.length) : rawData.length;\n\t\t}\n\t\treturn { rows, columns, updatedRowCount, numberOfNewCreationRows };\n\t},\n\n\t/**\n\t *  Get information about the paste operation.\n\t * @param rawData\n\t * @param cellSelection\n\t * @param cellSelection.columns\n\t * @param cellSelection.rows\n\t * @param posFirstSelectedRow\n\t * @param table\n\t * @returns Objet containing Information about the pasting operation\n\t */\n\tgetPasteInformation: function (\n\t\trawData: string[][],\n\t\tcellSelection: { columns: Column[]; rows: ODataV4Context[] },\n\t\tposFirstSelectedRow: number,\n\t\ttable: Table\n\t): PasteInformation | null {\n\t\tlet pasteInformation: PasteInformation | null = null;\n\n\t\tswitch (table.data(\"tableType\")) {\n\t\t\tcase \"GridTable\":\n\t\t\t\tpasteInformation = this.getPasteInformationForGridTable(rawData, cellSelection, posFirstSelectedRow, table);\n\t\t\t\tbreak;\n\t\t\tcase \"ResponsiveTable\":\n\t\t\t\tpasteInformation = this.getPasteInformationForReponsiveTable(rawData, cellSelection, posFirstSelectedRow, table);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLog.warning(`Paste operation is not supported for table type ${table.data(\"tableType\")}`);\n\t\t}\n\n\t\tif (\n\t\t\tpasteInformation &&\n\t\t\tpasteInformation?.numberOfNewCreationRows > 0 &&\n\t\t\t(table.getParent() as TableAPI & { getCreationMode: Function }).getCreationMode().getName() !== CreationMode.InlineCreationRows\n\t\t) {\n\t\t\tpasteInformation.updatedRowCount -= pasteInformation.numberOfNewCreationRows;\n\t\t\tpasteInformation.numberOfNewCreationRows = 0;\n\t\t}\n\n\t\treturn pasteInformation;\n\t},\n\n\t/**\n\t * Paste data into a table using a selection of column and rows.\n\t * @param rawData The data to be pasted into the table\n\t * @param cellSelection The columns and the rows to be updated\n\t * @param cellSelection.columns The columns to be updated\n\t * @param cellSelection.rows The rows to be updated\n\t * @param table The table\n\t * @returns Object containing information about the paste\n\t */\n\tpasteRangeData: async function (\n\t\trawData: string[][],\n\t\tcellSelection: { columns: Column[]; rows: ODataV4Context[] },\n\t\ttable: Table\n\t): Promise<\n\t\t| {\n\t\t\t\tupdatedRowCount: number;\n\t\t\t\tupdatedColCount: number;\n\t\t\t\tnumberOfNewCreationRows: number;\n\t\t\t\tposFirstInlineCreationRow: number | undefined;\n\t\t  }\n\t\t| undefined\n\t> {\n\t\tconst posFirstSelectedRow = cellSelection.rows[0].getIndex()!;\n\n\t\tconst pasteInfo = this.getPasteInformation(rawData, cellSelection, posFirstSelectedRow, table);\n\t\tif (!pasteInfo) return;\n\n\t\tconst parsedData = await this.parsePastedData(rawData, table, pasteInfo.columns, false);\n\t\tif (parsedData.length > 0) {\n\t\t\tif (pasteInfo.numberOfNewCreationRows > 0) {\n\t\t\t\tawait (table.getParent() as TableAPI).createEmptyRows(\n\t\t\t\t\ttable.getRowBinding(),\n\t\t\t\t\ttable,\n\t\t\t\t\tfalse,\n\t\t\t\t\tpasteInfo.numberOfNewCreationRows,\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t//load missing rows if needed including the newly created rows\n\t\t\tpasteInfo.rows = await table.getRowBinding().requestContexts(posFirstSelectedRow, pasteInfo.updatedRowCount);\n\t\t\tawait this._updateContexts(table, pasteInfo.rows, parsedData);\n\n\t\t\t// focusing on the first available creation row\n\t\t\tconst posFirstInlineCreationRow = pasteInfo.rows.find((context) => context.isTransient())?.getIndex();\n\t\t\tif (posFirstInlineCreationRow) {\n\t\t\t\ttable.focusRow(posFirstInlineCreationRow);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tupdatedRowCount: pasteInfo.updatedRowCount,\n\t\t\t\tupdatedColCount: Object.keys(parsedData[0]).length,\n\t\t\t\tnumberOfNewCreationRows: pasteInfo.numberOfNewCreationRows < 0 ? 0 : pasteInfo.numberOfNewCreationRows,\n\t\t\t\tposFirstInlineCreationRow\n\t\t\t};\n\t\t}\n\t},\n\tpasteData: async function (rawData: string[][], table: Table, controller: PageController): Promise<Context[] | undefined> {\n\t\tconst editFlow = controller.editFlow;\n\t\tconst tableDefinition = (table.getParent() as TableAPI).getTableDefinition();\n\t\tlet aData: Record<string, unknown>[] = [];\n\t\treturn this.parsePastedData(rawData, table)\n\t\t\t.then(async (aParsedData: Record<string, unknown>[]) => {\n\t\t\t\taData = aParsedData || [];\n\t\t\t\treturn Promise.all(\n\t\t\t\t\taData.map(async (mData) =>\n\t\t\t\t\t\teditFlow.validateDocument(table.getBindingContext() as ODataV4Context, {\n\t\t\t\t\t\t\tdata: mData,\n\t\t\t\t\t\t\tcustomValidationFunction: tableDefinition?.control?.customValidationFunction\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t})\n\t\t\t.then((aValidationMessages) => {\n\t\t\t\tconst aErrorMessages: { messages: { messageTarget?: string; messageText: string }[]; row: number }[] =\n\t\t\t\t\taValidationMessages.reduce(\n\t\t\t\t\t\tfunction (aMessages, aCustomMessages, index) {\n\t\t\t\t\t\t\tif (aCustomMessages.length > 0) {\n\t\t\t\t\t\t\t\taMessages.push({ messages: aCustomMessages, row: index + 1 });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn aMessages;\n\t\t\t\t\t\t},\n\t\t\t\t\t\t[] as { messages: { messageTarget?: string; messageText: string }[]; row: number }[]\n\t\t\t\t\t);\n\t\t\t\tif (aErrorMessages.length > 0) {\n\t\t\t\t\tconst aRowMessages = aErrorMessages.map((mError) => this.formatCustomMessage(mError.messages, mError.row));\n\t\t\t\t\tthis.displayErrorMessages(aRowMessages);\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t\treturn aData;\n\t\t\t})\n\t\t\t.then(async (aValidatedData): Promise<Context[] | undefined> => {\n\t\t\t\t// remove the last transient context if it exists\n\t\t\t\tconst transientContexts = table\n\t\t\t\t\t.getRowBinding()\n\t\t\t\t\t.getCurrentContexts()\n\t\t\t\t\t.filter((context) => context.isTransient());\n\t\t\t\tconst lastTransientContext = transientContexts.pop();\n\t\t\t\t//check if the last transient context has an error message\n\t\t\t\tconst lastTransientContextHasErrorMessage = !!Messaging.getMessageModel()\n\t\t\t\t\t.getData()\n\t\t\t\t\t.find((message: Message) => lastTransientContext && message.getTargets()[0].includes(lastTransientContext.getPath()));\n\t\t\t\tconst newContexts =\n\t\t\t\t\taValidatedData.length > 0\n\t\t\t\t\t\t? await editFlow.createMultipleDocuments(\n\t\t\t\t\t\t\t\ttable.getRowBinding(),\n\t\t\t\t\t\t\t\taValidatedData,\n\t\t\t\t\t\t\t\ttableDefinition?.control?.createAtEnd,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tcontroller.editFlow.onBeforeCreate\n\t\t\t\t\t\t  )\n\t\t\t\t\t\t: undefined;\n\t\t\t\t// if the last transient context has no error message, delete it and recreate a new one at the last position\n\t\t\t\tif (lastTransientContext && !lastTransientContextHasErrorMessage) {\n\t\t\t\t\tlastTransientContext?.delete();\n\t\t\t\t\tawait (table.getParent() as TableAPI).createEmptyRows(table.getRowBinding(), table, false, 1);\n\t\t\t\t}\n\t\t\t\treturn newContexts;\n\t\t\t})\n\t\t\t.catch((oError) => {\n\t\t\t\tLog.error(\"Error while pasting data\", oError);\n\t\t\t\treturn undefined;\n\t\t\t});\n\t}\n};\n\nexport default PasteHelper;\n"],"mappings":";;;;uTAgCA,MAAMA,EAA2B,SAChCC,EACAC,EACAC,EACAC,GAGkB,IAFlBC,EAAiCC,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,GAAG,MAAK,IACzCG,EAAWH,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,GAAG,MAEd,MAAMI,EAAWP,EAAYQ,YAAYV,GACxCW,EAAgB,CAAEC,sBAAuB,MACzCC,EAAOV,EAAUW,WAAW,GAAGb,KAAkBD,IAAgBW,GAClE,IAAII,EAAWC,EACf,GAAIZ,IAAsC,KAAM,CAC/CW,GAAaN,EACbO,EAAWd,EAAYQ,YAAY,GAAGV,+BACvC,KAAO,CACNe,GAAaN,GAAYP,EAAYQ,YAAY,GAAGV,+BACrD,CAEA,MAAO,CACNS,SAAUT,EACViB,OAAQT,GAAeO,EACvBC,SAAUA,EACVH,KAAMA,EAER,EAEA,MAAMK,EAAuB,SAAUC,GACtC,MAAMC,EAAiB,IAAID,GAC3B,MAAME,EAAiBC,EAAQC,qBAAqB,eACnDC,EAAyBH,EAAeI,QAAQ,uDAChDC,EAAcL,EAAeI,QAAQ,oDACtC,IAAIE,EAEJ,GAAIP,EAAed,OAAS,EAAG,CAC9BqB,EAAoBN,EAAeI,QAAQ,kDAAmD,CAACL,EAAed,QAC/G,KAAO,CACNqB,EAAoBN,EAAeI,QAAQ,oDAC5C,CACAL,EAAeQ,QAAQ,IACvBR,EAAeQ,QAAQF,GACvBN,EAAeQ,QAAQJ,GACvBK,EAAWC,MAAMH,EAAmB,CACnCI,MAAOV,EAAeI,QAAQ,kDAC9BO,QAASZ,EAAea,KAAK,SAE/B,EASA,MAAMC,EAAc,CACnBhB,qBAAsBA,EACtBiB,oBAAqB,SAAUC,EAA+CC,GAC7E,IAAIC,EAAe,GACnB,MAAMC,EAAiBH,EAAmB9B,OAC1C,MAAMe,EAAiBC,EAAQC,qBAAqB,eACnDiB,EAAUnB,EAAeI,QAAQ,yCAClC,GAAIc,EAAiB,EAAG,CACvBD,GAAgB,GAAGE,KAAWH,MAC9BD,EAAmBK,QAAQ,CAACC,EAASC,KACpC,GAAID,EAAQE,YAAa,CACxBN,GAAgBI,EAAQE,aAAeD,EAAe,IAAMJ,EAAiB,IAAM,GACpF,GAEF,CACA,OAAOD,CACR,EAQAO,cAAe,SAAUC,EAAcC,GAAwE,IAApDC,EAAwB3C,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,GAAG,KACrF,MAAM4C,EAAQH,EAAMI,gBAAgBC,WACnChD,EAAY8C,EAAMG,eAClBnD,EAAiBgD,EAAMI,QAAQP,EAAMI,gBAAgBI,UAAWR,EAAMI,gBAAgBK,cACtFrD,EAAcC,EAAUqD,eAAevD,GACvCwD,EAAuBC,EAAmBC,4BAA4BzD,GAAa0D,iBAAiBC,iBACpGC,EAAsC,GACtCC,EAAmBjB,EAAMkB,YAAyBC,qBACnD,SAASC,EACRC,EACAC,EACA3D,GAGA,GAAI0D,EAAaE,MAAQD,EAAc,CACtCN,EAA0BQ,KAAKH,EAAaE,KAC7C,CAEA,GAAIF,EAAaI,iBAAmB,KAAM,CAEzC,GAAIvB,GAA4BvC,EAAS+D,SAAS,KAAM,CACvD,MAAO,CACN/D,SAAU0D,EAAaM,KACvBxD,OAAQ,KAEV,KAAO,CACN,IAAIT,EAAc,MAClB,GAAI2D,EAAaM,KAAM,CACtBjE,EAAcsD,EAA0BU,SAASL,EAAaM,KAC/D,CAEA,OAAOvC,EAAYnC,yBAClBoE,EAAaM,KACbxE,EACAC,EACAC,EACA4D,EAAgBW,QAAQtE,kCACxBI,EAEF,CACD,CACD,CAEA,MAAMmE,EAAgB7B,EAAMkB,YAAyBY,kCACrD,MAAMC,EAA2DC,OAAOC,OACvE,CAAC,KACEJ,EAAaK,IAAKvE,IAAQ,CAAQ,CAACA,EAASwE,KAAMxE,MAEtD,MAAMyE,EAAiC,IACtCnC,GAAWD,EAAMqC,cAAc1C,QAAS2C,IACxC,MAAMC,EAAeR,EAAiBO,EAAOE,kBAE7C,GAAID,EAAaE,cAAe,CAE/BF,EAAaE,cAAc9C,QAAShC,IACnC,MAAM0D,EAAeU,EAAiBpE,GACrC2D,EAAeoB,KAAKC,qBAAqBhC,EAAsBU,GAC/DuB,EAAexB,EAA2BC,EAAcC,EAAc3D,GACvE,GAAIiF,EAAc,CACjBR,EAAYZ,KAAKoB,EAClB,IAED,GAAIL,EAAaM,2BAA4B,CAC5CT,EAAYZ,KAAK,CAChB7D,SAAU,2BACVQ,OAAQ,MAEV,CAED,MAAO,GAAIoE,EAAad,iBAAmB,KAAM,CAChD,GAAIc,EAAaZ,KAAM,CACtBS,EAAYZ,KACXpC,EAAYnC,yBACXsF,EAAaZ,KACbxE,EACAC,EACAC,EACA4D,EAAgBW,QAAQtE,mCAG3B,KAAO,CAEN8E,EAAYZ,KAAK,CAChB7D,SAAU,SACVI,KAAM,KACNI,OAAQ,MAEV,CACD,IAED,OAAOiE,CACR,EACAnF,yBAA0BA,EAQ1B0F,qBAAsB,SACrBhC,EACAU,GAEA,MAAM1D,EAAWgD,EAAqBmC,KAAMC,GAAMA,EAAEC,OAAS3B,EAAaM,MAC1E,GAAIhE,EAAU,CACb,QAASA,EAASsF,aAAaC,QAAQC,SACxC,CACA,OAAO,KACR,EAUAC,gBAAiBC,eAChBC,EACAtD,EACAC,GAEqC,IADrCC,EAAwB3C,UAAAC,OAAA,GAAAD,UAAA,KAAAE,UAAAF,UAAA,GAAG,KAE3B,MAAMgG,EAAab,KAAK3C,cAAcC,EAAOC,EAASC,GACtD,MAAMe,EAAmBjB,EAAMkB,YAAyBC,qBAExD,MAAMqC,EAAoBF,EAAQ9F,OAAS8F,EAAQ,GAAG9F,OAAS,EAC/D,IAAIiG,GAA4B,EAChC,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAW/F,QAAUiG,EAA2B,EAAGC,IAAK,CAC3E,IAAKH,EAAWG,GAAGvF,SAAWoF,EAAWG,GAAGxF,SAAU,CACrDuF,EAA2BC,CAC5B,CACD,CAEA,GAAIzC,EAAgBW,QAAQtE,kCAAmC,CAC9D,MAAMqG,EAAqBJ,EAAWK,OAAO,SAAUC,GACtD,OAAOA,EAAK3F,QACb,GAEAyF,EAAmBhE,QAAQ,SAAUmE,GACpC,MAAMC,EAAiBR,EAAWS,QAAQF,GAC1C,MAAMG,EAAaX,EAAQY,MAAOC,GAAQA,EAAIJ,KAAoB,IAClE,GAAIE,EAAY,CACfH,EAAiB3F,OAAS,IAC3B,CACD,EACD,CAEA,MAAMiG,QAAqBX,EAA2B,GAAKA,EAA2BD,EAAoB,EACvG,CAAEa,WAAY,GAAIC,OAAQ,MAC1BC,EAAgBC,MAAMlB,EAASC,IAClC,GAAIa,EAAYE,OAAQ,CACvB,MAAMjG,EAAgB+F,EAAYE,OAAOpC,IAAI,SAAUuC,GACtD,OAAOA,EAAS7E,OACjB,GACA8C,KAAKtE,qBAAqBC,GAC1B,MAAO,EACR,KAAO,CACN,OAAO+F,EAAYC,UACpB,CACD,EASAK,gBAAiBrB,eAChBrD,EACA2E,EACAC,GAEA,IAAIC,EAAQ,EACZ,MAAMC,EAAsB,GAC5B,IAAK,MAAMX,KAAOS,EAAM,CACvB,MAAMG,EAAaJ,EAASE,KAC5B,GAAIE,EAAY,CACf,IAAK,MAAM1D,KAAgB8C,EAAK,CAC/B,GAAKnE,EAAMkB,YAAyB8D,oBAAoB3D,EAAc0D,KAAgBE,EAAcC,SAAU,CAC7GJ,EAAoBtD,KAAKuD,EAAWI,YAAY9D,EAAc8C,EAAI9C,IACnE,KAAO,CACN+D,EAAIC,QAAQ,YAAYhE,6BAAwC0D,EAAWO,aAC5E,CACD,CACD,CACD,OACMC,QAAQC,WAAWV,EAC1B,EAYAW,qCAAsC,SACrCnC,EACAoC,EACAC,EACA3F,GAEA,IAAI4F,EAA0B,EAC9B,MAAMC,EAAmC7F,EACvCI,gBACA0F,qBACAC,UAAWC,GAAYA,EAAQC,eACjC,MAAMC,EAAOR,EAAcQ,KAC3B,IAAIC,EAAkB,EACtB,MAAMlG,EACLyF,EAAczF,QAAQzC,OAAS,EAC5BkI,EAAczF,QACdD,EAAMqC,aAAa+D,MAAMpG,EAAMqC,aAAa2B,QAAQ0B,EAAczF,QAAQ,KAG9E,GAAIyF,EAAczF,QAAQzC,SAAW,GAAKkI,EAAcQ,KAAK1I,SAAW,EAAG,CAE1E,GACCmI,GAAuBE,GACvBF,EAAsBrC,EAAQ9F,OAASqI,EACtC,CACDD,EAA0BtC,EAAQ9F,QAAUqI,EAAmCF,GAAuB,EACtGQ,EAAkB7C,EAAQ9F,MAC3B,KAAO,CAENoI,EAA0B,EAC1BO,EAAkB7C,EAAQ9F,MAC3B,CACD,KAAO,CAEN,MAAM6I,EAAmCH,EAAKtC,OAAQoC,GAAYA,EAAQC,gBAAgBK,MAC1F,MAAMC,EAAsCF,EACzCH,EAAKlC,QAAQqC,IACZ,EACJF,EAAkBK,KAAKC,IAAInD,EAAQ9F,OAAQkI,EAAcQ,KAAK1I,QAE9D,GAAI+I,GAAuC,EAAG,CAC7CJ,EAAkBI,IAAwCb,EAAcQ,KAAK1I,OAAS,EAAI8F,EAAQ9F,OAAS2I,EAC3GP,EACCW,IAAwCb,EAAcQ,KAAK1I,OAAS,EACjE8F,EAAQ9F,OAAS+I,EAAsC,EACvD,CACL,CACD,CACA,MAAO,CAAEL,OAAMjG,UAASkG,kBAAiBP,0BAC1C,EAYAc,gCAAiC,SAChCpD,EACAoC,EACAC,EACA3F,GAEA,IAAI4F,EAA0B,EAC9B,MAAMM,EAAOR,EAAcQ,KAC3B,IAAIC,EAAkB,EACtB,MAAMQ,EAAiB3G,EAAMI,gBAAgBwG,YAC7C,IAAI3G,EACHyF,EAAczF,QAAQzC,OAAS,EAC5BkI,EAAczF,QACdD,EAAMqC,aAAa+D,MAAMpG,EAAMqC,aAAa2B,QAAQ0B,EAAczF,QAAQ,KAC9E,GAAIyF,EAAczF,QAAQzC,SAAW,GAAKkI,EAAcQ,KAAK1I,SAAW,EAAG,CAC1EoI,EACCD,EAAsBrC,EAAQ9F,OAASmJ,EAAiBhB,EAAsBrC,EAAQ9F,OAASmJ,EAAiB,EACjH1G,EAAUD,EAAMqC,aAAa+D,MAAMpG,EAAMqC,aAAa2B,QAAQ0B,EAAczF,QAAQ,KACpFkG,EAAkB7C,EAAQ9F,MAC3B,KAAO,CAENoI,EACCD,EAAsBO,EAAK1I,QAAUmJ,EAAiBhB,EAAsBrC,EAAQ9F,OAASmJ,EAAiB,EAC/GR,EAAkBP,IAA4B,EAAIY,KAAKC,IAAInD,EAAQ9F,OAAQkI,EAAcQ,KAAK1I,QAAU8F,EAAQ9F,MACjH,CACA,MAAO,CAAE0I,OAAMjG,UAASkG,kBAAiBP,0BAC1C,EAYAiB,oBAAqB,SACpBvD,EACAoC,EACAC,EACA3F,GAEA,IAAI8G,EAA4C,KAEhD,OAAQ9G,EAAM4E,KAAK,cAClB,IAAK,YACJkC,EAAmBpE,KAAKgE,gCAAgCpD,EAASoC,EAAeC,EAAqB3F,GACrG,MACD,IAAK,kBACJ8G,EAAmBpE,KAAK+C,qCAAqCnC,EAASoC,EAAeC,EAAqB3F,GAC1G,MACD,QACCoF,EAAIC,QAAQ,mDAAmDrF,EAAM4E,KAAK,gBAG5E,GACCkC,GACAA,GAAkBlB,wBAA0B,GAC3C5F,EAAMkB,YAAyD6F,kBAAkBC,YAAcC,EAAaC,mBAC5G,CACDJ,EAAiBX,iBAAmBW,EAAiBlB,wBACrDkB,EAAiBlB,wBAA0B,CAC5C,CAEA,OAAOkB,CACR,EAWAK,eAAgB9D,eACfC,EACAoC,EACA1F,GAUA,MAAM2F,EAAsBD,EAAcQ,KAAK,GAAGZ,WAElD,MAAM8B,EAAY1E,KAAKmE,oBAAoBvD,EAASoC,EAAeC,EAAqB3F,GACxF,IAAKoH,EAAW,OAEhB,MAAM/C,QAAmB3B,KAAKU,gBAAgBE,EAAStD,EAAOoH,EAAUnH,QAAS,OACjF,GAAIoE,EAAW7G,OAAS,EAAG,CAC1B,GAAI4J,EAAUxB,wBAA0B,EAAG,OACnC5F,EAAMkB,YAAyBmG,gBACrCrH,EAAMI,gBACNJ,EACA,MACAoH,EAAUxB,wBACV,KAEF,CAGAwB,EAAUlB,WAAalG,EAAMI,gBAAgBkH,gBAAgB3B,EAAqByB,EAAUjB,uBACtFzD,KAAKgC,gBAAgB1E,EAAOoH,EAAUlB,KAAM7B,GAGlD,MAAMkD,EAA4BH,EAAUlB,KAAKpD,KAAMkD,GAAYA,EAAQC,gBAAgBX,WAC3F,GAAIiC,EAA2B,CAC9BvH,EAAMwH,SAASD,EAChB,CACA,MAAO,CACNpB,gBAAiBiB,EAAUjB,gBAC3BsB,gBAAiBzF,OAAO0F,KAAKrD,EAAW,IAAI7G,OAC5CoI,wBAAyBwB,EAAUxB,wBAA0B,EAAI,EAAIwB,EAAUxB,wBAC/E2B,4BAEF,CACD,EACAI,UAAWtE,eAAgBC,EAAqBtD,EAAc4H,GAC7D,MAAMC,EAAWD,EAAWC,SAC5B,MAAM5G,EAAmBjB,EAAMkB,YAAyBC,qBACxD,IAAI2G,EAAmC,GACvC,OAAOpF,KAAKU,gBAAgBE,EAAStD,GACnC+H,KAAK1E,UACLyE,EAAQE,GAAe,GACvB,OAAOzC,QAAQ0C,IACdH,EAAM5F,IAAImB,SACTwE,EAASK,iBAAiBlI,EAAMmI,oBAAuC,CACtEvD,KAAMwD,EACNC,yBAA0BpH,GAAiBW,SAASyG,+BAKvDN,KAAMO,IACN,MAAMC,EACLD,EAAoBE,OACnB,SAAUC,EAAWC,EAAiB7D,GACrC,GAAI6D,EAAgBlL,OAAS,EAAG,CAC/BiL,EAAUjH,KAAK,CAAEmH,SAAUD,EAAiBvE,IAAKU,EAAQ,GAC1D,CACA,OAAO4D,CACR,EACA,IAEF,GAAIF,EAAe/K,OAAS,EAAG,CAC9B,MAAMoL,EAAeL,EAAerG,IAAK2G,GAAWnG,KAAKrD,oBAAoBwJ,EAAOF,SAAUE,EAAO1E,MACrGzB,KAAKtE,qBAAqBwK,GAC1B,MAAO,EACR,CACA,OAAOd,IAEPC,KAAK1E,UAEL,MAAMyF,EAAoB9I,EACxBI,gBACA0F,qBACAlC,OAAQoC,GAAYA,EAAQC,eAC9B,MAAM8C,EAAuBD,EAAkBxC,MAE/C,MAAM0C,IAAwCC,EAAUC,kBACtDC,UACArG,KAAMlD,GAAqBmJ,GAAwBnJ,EAAQwJ,aAAa,GAAG1H,SAASqH,EAAqBvI,YAC3G,MAAM6I,EACLC,EAAe9L,OAAS,QACfqK,EAAS0B,wBACfvJ,EAAMI,gBACNkJ,EACArI,GAAiBW,SAAS4H,YAC1B,KACA5B,EAAWC,SAAS4B,gBAEpBhM,UAEJ,GAAIsL,IAAyBC,EAAqC,CACjED,GAAsBW,eACf1J,EAAMkB,YAAyBmG,gBAAgBrH,EAAMI,gBAAiBJ,EAAO,MAAO,EAC5F,CACA,OAAOqJ,IAEPM,MAAOC,IACPxE,EAAIpG,MAAM,2BAA4B4K,GACtC,OAAOnM,WAEV,GACC,OAEa2B,CAAW","ignoreList":[]}