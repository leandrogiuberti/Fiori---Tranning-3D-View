{"version":3,"file":"TitleHelper.js","names":["formatValueRecursively","bindingExpressionToEnhance","fullContextPath","transformRecursively","expression","outExpression","modelName","undefined","oPropertyDataModelPath","enhanceDataModelPath","path","formatWithTypeInformation","targetObject","_exports","getPropertyDefinition","propertyDataModelObject","propertyPathOrProperty","isPropertyPathExpression","$target","isOrHasActiveEntity","draftRoot","targetEntitySet","annotations","Common","DraftRoot","draftNode","DraftNode","not","Draft","IsNewObject","isTitleEmptyBooleanExpression","titleValueExpression","_type","constant","value","isEmpty","getTitleBindingWithTextArrangement","propertyDataModelPath","propertyBindingExpression","formatOptions","targetDisplayModeOverride","displayMode","propertyDefinition","targetDisplayMode","UIFormatters","getDisplayMode","commonText","Text","relativeLocation","getRelativePaths","params","getExpressionFromAnnotation","targetExpression","splitTitleOnTwoLines","ifElse","UI","TextArrangement","addTextArrangementToTitleBindingExpression","getCreateModeTitle","targetNavigationPath","getTargetNavigationPath","baseKey","fullKey","baseTranslation","pathInModel","fullTranslation","formatResult","valueFormatters","formatCreationTitle","shouldForceEmptyString","Core","Computed","IsInactive","getTitleValueExpressionFromHeaderInfo","headerInfoTitle","getTextBindingExpression","$Type","Value","Target","connectedFieldsPath","getLabelForConnectedFields","getTitleBindingExpression","headerInfo","viewData","customFormatter","formatter","formatTitle","createModeTitle","isHeaderInfoTitleEmpty","extIdHeaderInfoTitle","isDataField","Title","ExternalID","isConstant","toString","compileExpression","isPathAnnotationExpression","getContextRelativeTargetObjectPath","Array","isArray","isProperty","isTitleEmpty","forceEmptyString","formattedExpression","or","isUndefinedExpression","IsCreateMode","resourceModel","getText"],"sources":["./TitleHelper.ts"],"sourcesContent":["import type { EntitySet, Property, PropertyPath } from \"@sap-ux/vocabularies-types\";\nimport type { ConnectedFields, DataFieldAbstractTypes, DataFieldTypes, HeaderInfoType } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type { BindingToolkitExpression, PathInModelExpression } from \"sap/fe/base/BindingToolkit\";\nimport {\n\tcompileExpression,\n\tconstant,\n\tformatResult,\n\tformatWithTypeInformation,\n\tgetExpressionFromAnnotation,\n\tifElse,\n\tisConstant,\n\tisEmpty,\n\tisUndefinedExpression,\n\tnot,\n\tor,\n\tpathInModel,\n\ttransformRecursively\n} from \"sap/fe/base/BindingToolkit\";\nimport valueFormatters from \"sap/fe/core/formatters/ValueFormatter\";\nimport { Draft, UI } from \"sap/fe/core/helpers/BindingHelper\";\nimport { isPathAnnotationExpression, isProperty, isPropertyPathExpression } from \"sap/fe/core/helpers/TypeGuards\";\nimport type { ViewData } from \"sap/fe/core/services/TemplatedViewServiceFactory\";\nimport { getLabelForConnectedFields } from \"sap/fe/core/templating/DataFieldFormatters\";\nimport type { DataModelObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport {\n\tenhanceDataModelPath,\n\tgetContextRelativeTargetObjectPath,\n\tgetRelativePaths,\n\tgetTargetNavigationPath\n} from \"sap/fe/core/templating/DataModelPathHelper\";\nimport type { DisplayMode } from \"sap/fe/core/templating/UIFormatters\";\nimport * as UIFormatters from \"sap/fe/core/templating/UIFormatters\";\nimport { isDataField } from \"../converters/annotations/DataField\";\n\ntype BindingExpressionTuple = [BindingToolkitExpression<string>, BindingToolkitExpression<string>] | [BindingToolkitExpression<string>];\n\nexport const formatValueRecursively = function (\n\tbindingExpressionToEnhance: BindingToolkitExpression<string>,\n\tfullContextPath: DataModelObjectPath<Property | PropertyPath>\n): BindingToolkitExpression<string> {\n\treturn transformRecursively(bindingExpressionToEnhance, \"PathInModel\", (expression) => {\n\t\tlet outExpression = expression;\n\t\tif (expression.modelName === undefined) {\n\t\t\t// In case of default model we then need to resolve the text arrangement property\n\t\t\tconst oPropertyDataModelPath = enhanceDataModelPath<Property>(fullContextPath, expression.path);\n\t\t\toutExpression = formatWithTypeInformation(oPropertyDataModelPath.targetObject!, expression);\n\t\t}\n\t\treturn outExpression;\n\t});\n};\n\n/**\n * Get property definition from data model object path.\n * @param propertyDataModelObject The property data model object\n * @returns The property\n */\nconst getPropertyDefinition = (propertyDataModelObject: DataModelObjectPath<Property | PropertyPath>): Property | undefined => {\n\tconst propertyPathOrProperty = propertyDataModelObject.targetObject;\n\treturn isPropertyPathExpression(propertyPathOrProperty) ? propertyPathOrProperty.$target : propertyPathOrProperty;\n};\n\n/**\n * Checks whether an associated active entity exists.\n * @param fullContextPath The full path to the context\n * @returns The expression-binding string\n */\nconst isOrHasActiveEntity = (fullContextPath: DataModelObjectPath<unknown>): boolean | BindingToolkitExpression<boolean> => {\n\tconst draftRoot = (fullContextPath.targetEntitySet as EntitySet | undefined)?.annotations?.Common?.DraftRoot;\n\tconst draftNode = (fullContextPath.targetEntitySet as EntitySet | undefined)?.annotations?.Common?.DraftNode;\n\tif (!!draftRoot || !!draftNode) {\n\t\treturn not(Draft.IsNewObject);\n\t}\n\treturn true;\n};\n\n/**\n * Checks if title value expression is empty.\n * @param titleValueExpression The title value expression\n * @returns The expression-binding string\n */\nconst isTitleEmptyBooleanExpression = (titleValueExpression: BindingToolkitExpression<string>): BindingToolkitExpression<boolean> =>\n\ttitleValueExpression._type === \"Constant\" ? constant(!titleValueExpression.value) : isEmpty(titleValueExpression);\n\n/**\n * Retrieves the title expression binding.\n * @param propertyDataModelPath The full path to the property context\n * @param propertyBindingExpression The binding expression of the property above\n * @param [formatOptions] The format options of the field\n * @param formatOptions.displayMode\n * @returns The expression-binding parameters\n */\nconst getTitleBindingWithTextArrangement = function (\n\tpropertyDataModelPath: DataModelObjectPath<Property>,\n\tpropertyBindingExpression: BindingToolkitExpression<string>,\n\tformatOptions?: Partial<{ displayMode?: DisplayMode; splitTitleOnTwoLines?: boolean }>\n): BindingExpressionTuple {\n\tconst targetDisplayModeOverride = formatOptions?.displayMode;\n\tconst propertyDefinition = getPropertyDefinition(propertyDataModelPath);\n\tconst targetDisplayMode = targetDisplayModeOverride || UIFormatters.getDisplayMode(propertyDataModelPath);\n\tconst commonText = propertyDefinition?.annotations?.Common?.Text;\n\tconst relativeLocation = getRelativePaths(propertyDataModelPath);\n\n\tif (propertyDefinition) {\n\t\tpropertyBindingExpression = formatWithTypeInformation(propertyDefinition, propertyBindingExpression);\n\t}\n\n\tlet params: BindingExpressionTuple = [propertyBindingExpression];\n\tif (targetDisplayMode !== \"Value\" && commonText) {\n\t\tswitch (targetDisplayMode) {\n\t\t\tcase \"Description\":\n\t\t\t\tparams = [getExpressionFromAnnotation(commonText, relativeLocation)];\n\t\t\t\tbreak;\n\t\t\tcase \"DescriptionValue\":\n\t\t\t\tconst targetExpression =\n\t\t\t\t\tformatOptions?.splitTitleOnTwoLines === undefined\n\t\t\t\t\t\t? ifElse(!!commonText.annotations?.UI?.TextArrangement, propertyBindingExpression, constant(\"\"))\n\t\t\t\t\t\t: ifElse(!!formatOptions?.splitTitleOnTwoLines, constant(\"\"), propertyBindingExpression);\n\t\t\t\tparams = [getExpressionFromAnnotation(commonText, relativeLocation), targetExpression];\n\t\t\t\tbreak;\n\t\t\tcase \"ValueDescription\":\n\t\t\t\tparams = [\n\t\t\t\t\tpropertyBindingExpression,\n\t\t\t\t\tifElse(!!formatOptions?.splitTitleOnTwoLines, constant(\"\"), getExpressionFromAnnotation(commonText, relativeLocation))\n\t\t\t\t];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn params;\n};\n\n/**\n * Recursively add the text arrangement to a title binding expression.\n * @param bindingExpressionToEnhance The binding expression to be enhanced\n * @param path The data field data model object path\n * @returns An updated expression containing the text arrangement binding parameters\n */\nconst addTextArrangementToTitleBindingExpression = function (\n\tbindingExpressionToEnhance: BindingToolkitExpression<string>,\n\tpath: DataModelObjectPath<Property>\n): BindingToolkitExpression<string> {\n\treturn transformRecursively(bindingExpressionToEnhance, \"PathInModel\", (expression: PathInModelExpression<unknown>) => {\n\t\tif (expression.modelName !== undefined) return expression;\n\t\t// In case of default model we then need to resolve the text arrangement property\n\t\tconst propertyDataModelPath = enhanceDataModelPath<Property>(path, expression.path);\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\treturn getTitleBindingWithTextArrangement(propertyDataModelPath, expression) as unknown as BindingToolkitExpression<any>;\n\t});\n};\n\n/**\n * Gets binding expression for create mode title.\n * @param path The meta path pointing to the property used for the title\n * @returns The expression-binding string\n */\nexport const getCreateModeTitle = function (path: DataModelObjectPath<Property>): BindingToolkitExpression<string> {\n\tconst targetNavigationPath = getTargetNavigationPath(path, true);\n\tconst baseKey = \"T_NEW_OBJECT\";\n\tconst fullKey = targetNavigationPath ? `${baseKey}|${targetNavigationPath}` : baseKey;\n\n\tconst baseTranslation = pathInModel(baseKey, \"sap.fe.i18n\");\n\tconst fullTranslation = pathInModel(fullKey, \"sap.fe.i18n\");\n\n\treturn formatResult([baseTranslation, fullTranslation], valueFormatters.formatCreationTitle);\n};\n\n/**\n * Checks whether an empty string should be used.\n * @param path The meta path pointing to the property used for the title\n * @returns The expression-binding string\n */\nconst shouldForceEmptyString = (path: DataModelObjectPath<Property | PropertyPath>): BindingToolkitExpression<boolean> => {\n\tconst propertyDefinition = getPropertyDefinition(path);\n\tif (propertyDefinition && propertyDefinition.annotations?.Core?.Computed) {\n\t\treturn UI.IsInactive;\n\t} else {\n\t\treturn constant(false);\n\t}\n};\n\n/**\n * Gets title value expression from object page header info.\n * @param fullContextPath The full path to the context\n * @param headerInfoTitle The title value from the object page header info\n * @param getTextBindingExpression The function to get the text binding expression\n * @returns The expression-binding string\n */\nconst getTitleValueExpressionFromHeaderInfo = function (\n\tfullContextPath: DataModelObjectPath<Property>,\n\theaderInfoTitle: DataFieldAbstractTypes,\n\tgetTextBindingExpression: Function\n): BindingToolkitExpression<string> | undefined {\n\tlet titleValueExpression: BindingToolkitExpression<string> | undefined;\n\tif (headerInfoTitle.$Type === UIAnnotationTypes.DataField) {\n\t\ttitleValueExpression = getExpressionFromAnnotation(headerInfoTitle.Value);\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\tif ((headerInfoTitle as DataFieldTypes).Value?.$target?.annotations.Common?.Text?.annotations?.UI?.TextArrangement) {\n\t\t\t// In case an explicit text arrangement was set we make use of it in the description as well\n\t\t\ttitleValueExpression = addTextArrangementToTitleBindingExpression(titleValueExpression, fullContextPath);\n\t\t}\n\t\ttitleValueExpression = formatValueRecursively(titleValueExpression, fullContextPath);\n\t}\n\tif (\n\t\theaderInfoTitle.$Type === UIAnnotationTypes.DataFieldForAnnotation &&\n\t\theaderInfoTitle.Target.$target?.$Type === UIAnnotationTypes.ConnectedFieldsType\n\t) {\n\t\tconst connectedFieldsPath = enhanceDataModelPath<ConnectedFields>(\n\t\t\tfullContextPath,\n\t\t\t\"$Type/@UI.HeaderInfo/Title/Target/$AnnotationPath\"\n\t\t);\n\t\ttitleValueExpression = getLabelForConnectedFields(\n\t\t\tconnectedFieldsPath,\n\t\t\tgetTextBindingExpression,\n\t\t\tfalse\n\t\t) as BindingToolkitExpression<string>;\n\t}\n\treturn titleValueExpression;\n};\n\n/**\n * Creates binding expression for Object Page, Quick View, and other titles.\n * @param path The data model object path\n * @param getTextBindingExpression The function to get the text binding expression\n * @param [formatOptions] The format options of the field\n * @param formatOptions.displayMode\n * @param [headerInfo] The object page header info\n * @param [viewData] The associated view data\n * @param customFormatter\n * @returns The compiled expression-binding string\n */\nexport const getTitleBindingExpression = function (\n\tpath: DataModelObjectPath<Property>,\n\tgetTextBindingExpression: Function,\n\tformatOptions?: Partial<{ displayMode?: DisplayMode; splitTitleOnTwoLines?: boolean }>,\n\theaderInfo?: HeaderInfoType,\n\tviewData?: ViewData,\n\tcustomFormatter?: string\n): string | undefined {\n\tconst formatter = customFormatter || valueFormatters.formatTitle;\n\n\tlet createModeTitle: BindingToolkitExpression<string> | string = getCreateModeTitle(path);\n\tlet titleValueExpression;\n\tlet isHeaderInfoTitleEmpty = false;\n\n\t//If the title contains a guid with an external ID we want to behave as if the title annotation would point to the target\n\t//of the externalID annotation\n\tlet extIdHeaderInfoTitle;\n\tif (isDataField(headerInfo?.Title) && headerInfo?.Title.Value?.$target?.annotations?.Common?.ExternalID) {\n\t\textIdHeaderInfoTitle = {\n\t\t\t...headerInfo.Title,\n\t\t\tValue: { ...headerInfo.Title.Value, $target: { ...headerInfo.Title.Value.$target } }\n\t\t};\n\t\textIdHeaderInfoTitle.Value.path = headerInfo.Title.Value.$target?.annotations?.Common?.ExternalID.path;\n\t\textIdHeaderInfoTitle.Value.$target = headerInfo.Title.Value.$target?.annotations?.Common?.ExternalID.$target;\n\t}\n\n\t// If we have a headerInfo but no title, or empty title we need to display an empty string when we are on an active object\n\t// received header info for object page\n\tif (headerInfo?.Title?.$Type && viewData) {\n\t\tif (extIdHeaderInfoTitle === undefined) {\n\t\t\ttitleValueExpression = getTitleValueExpressionFromHeaderInfo(path, headerInfo.Title, getTextBindingExpression);\n\t\t} else {\n\t\t\ttitleValueExpression = getTitleValueExpressionFromHeaderInfo(path, extIdHeaderInfoTitle, getTextBindingExpression);\n\t\t}\n\t\tcreateModeTitle = getCreateModeTitle(path);\n\t\tif (isConstant(titleValueExpression) && titleValueExpression.value === \"\") {\n\t\t\tisHeaderInfoTitleEmpty = true;\n\t\t}\n\t} else if (headerInfo && (headerInfo.Title === undefined || headerInfo.Title.toString() === \"\")) {\n\t\tisHeaderInfoTitleEmpty = true;\n\t\t// received header info for objectPage\n\t\tif (!viewData) {\n\t\t\ttitleValueExpression = constant(\"\");\n\t\t}\n\t}\n\tif (titleValueExpression && isConstant(titleValueExpression)) {\n\t\treturn compileExpression(titleValueExpression);\n\t}\n\n\t// needed for quickview\n\tif (isPathAnnotationExpression(path.targetObject)) {\n\t\tpath = enhanceDataModelPath(path, path.targetObject.path);\n\t}\n\n\tconst propertyBindingExpression: BindingToolkitExpression<unknown> = pathInModel(getContextRelativeTargetObjectPath(path));\n\tlet params: BindingExpressionTuple | undefined;\n\tif (titleValueExpression) {\n\t\tparams = Array.isArray(titleValueExpression) ? (titleValueExpression as unknown as BindingExpressionTuple) : [titleValueExpression];\n\t} else if (path.targetObject && isProperty(path.targetObject)) {\n\t\tparams = getTitleBindingWithTextArrangement(path, propertyBindingExpression, formatOptions);\n\t}\n\tconst isTitleEmpty = params === undefined || isTitleEmptyBooleanExpression(params[0]);\n\tconst forceEmptyString = shouldForceEmptyString(path);\n\tconst formattedExpression = params != undefined && formatResult(params, formatter);\n\ttitleValueExpression = ifElse(\n\t\tisTitleEmpty,\n\t\tifElse(\n\t\t\tor(isHeaderInfoTitleEmpty && isOrHasActiveEntity(path), forceEmptyString),\n\t\t\t\"\",\n\t\t\tifElse(\n\t\t\t\tisUndefinedExpression(constant(customFormatter)),\n\t\t\t\tifElse(\n\t\t\t\t\tor(UI.IsCreateMode, not(isOrHasActiveEntity(path))),\n\t\t\t\t\tcreateModeTitle,\n\t\t\t\t\tpathInModel(\"T_ANNOTATION_HELPER_DEFAULT_HEADER_TITLE_NO_HEADER_INFO\", \"sap.fe.i18n\")\n\t\t\t\t),\n\t\t\t\tifElse(\n\t\t\t\t\tnot(isOrHasActiveEntity(path)),\n\t\t\t\t\tviewData?.resourceModel.getText(\"T_NEW_OBJECT\"),\n\t\t\t\t\tviewData?.resourceModel.getText(\"T_ANNOTATION_HELPER_DEFAULT_HEADER_TITLE_NO_HEADER_INFO\")\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\tformattedExpression\n\t);\n\n\treturn compileExpression(titleValueExpression);\n};\n"],"mappings":"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","ignoreList":[]}