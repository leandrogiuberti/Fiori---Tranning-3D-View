/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 *      (c) Copyright 2009-2025 SAP SE. All rights reserved
 */
sap.ui.define(["sap/base/Log","sap/fe/base/BindingToolkit"],function(e,t){"use strict";var r={};var n=t.wrapPrimitive;var o=t.isPathInModelExpression;var s=t.isConstant;var a=t.isBindingToolkitExpression;var i=t.escapeXmlAttribute;const c="$";const p={"||":"or","&&":"and"};const u=function(e){return!s(e)&&!o(e)&&a(e)&&e._type!=="IfElse"&&e._type!=="Comparison"&&e._type!=="Not"};function l(e,t){let r=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(t){if(r){return`(${e})`}else{return e}}else{return`${c}{${e}}`}}function d(t,r){function n(e){const t=m(e,r,true)??"undefined";return l(t,true,u(e))}const{operand1:o,operand2:s,operator:a}=t;let i;switch(a){case"===":i=`equals(${n(o)},${n(s)})`;break;case"!==":i=`not(equals(${n(o)},${n(s)}))`;break;case">=":i=`greaterOrEquals(${n(t.operand1)},${n(s)})`;break;case">":i=`greater(${n(o)},${n(s)})`;break;case"<=":i=`lessOrEquals(${n(o)},${n(s)})`;break;case"<":i=`less(${n(o)},${n(s)})`;break;default:e.warning(`Adaptive card expression compiler: ${a} not supported.`)}return`${i}`}function f(e,t){if(e.value===null||e.value===undefined){return e.value}if(typeof e.value==="object"){throw Error(`${e.toString()} : object as value not supported.`)}if(t){switch(typeof e.value){case"number":case"bigint":case"boolean":return e.value.toString();case"string":return`'${i(e.value.toString())}'`;default:return""}}else{return e.value.toString()}}r.compileConstant=f;function $(e){let t=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"";const r=m(e,t);let n=h(e);if(t&&n.length>0){n=n.map(e=>`${t.replaceAll("/",".")}.${e}`)}return{pathsToQuery:n,compiledExpression:r}}r.getAdaptiveCompilerResult=$;function m(t){let r=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"";let o=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let s;try{const e=n(t);switch(e._type){case"Unresolvable":s=undefined;break;case"Constant":s=f(e,o);break;case"PathInModel":s=g(e,r,o);break;case"Comparison":{const t=d(e,r);s=l(t,o);break}case"IfElse":{const t=m(e.condition,r,true);const n=m(e.onTrue,r,true);const a=m(e.onFalse,r,true);const i=`if(${t},${n},${a})`;s=l(i,o);break}case"Set":{const t=e.operands.map(e=>m(e,r,true));const n=p[e.operator];const a=`${n}(${t.join(",")})`;s=l(a,o);break}case"Not":{const t=`not(${m(e.operand,r,true)})`;s=l(t,o);break}case"Truthy":{const t=`not(not(${m(e.operand,r,true)}))`;s=l(t,o);break}case"Ref":case"Function":case"EmbeddedExpressionBinding":case"EmbeddedBinding":case"Concat":case"Length":case"Formatter":case"ComplexType":default:throw Error(`${e._type} : expression type is not supported.`)}}catch(t){const r=t instanceof Error?t.message:String(t);e.error(`Adaptive card expression compiler : ${r}`)}return s}r.compileToAdaptiveExpression=m;function b(e,t){const{modelName:r,path:n}=e;if(r){throw Error(`${r}>${n} : path in model not supported.`)}const o=t?`${t}.`:t;const s=`${o}${n}`;return s.replace("/",".")}function g(e,t,r){if(e.type||e.parameters||e.targetType||e.formatOptions||e.constraints){throw Error(`${e.toString()} : complex binding not supported.`)}else if(r){return`${b(e,t)}`}else{return`${c}{${b(e,t)}}`}}function h(t){let r=[];try{const e=n(t);switch(e._type){case"Unresolvable":throw Error(`${e._type} : expression type is not supported.`);case"Constant":break;case"PathInModel":r=[...r,y(e)];break;case"Comparison":{r=[...r,...E(e)];break}case"IfElse":{const t=h(e.condition);const n=h(e.onTrue);const o=h(e.onFalse);r=[...r,...t,...n,...o];break}case"Set":{const t=e.operands.reduce((e,t)=>[...e,...h(t)],[]);r=[...r,...t];break}case"Not":{const t=h(e.operand);r=[...r,...t];break}case"Truthy":{const t=h(e.operand);r=[...r,...t];break}case"Ref":case"Function":case"EmbeddedExpressionBinding":case"EmbeddedBinding":case"Concat":case"Length":case"Formatter":case"ComplexType":default:throw Error(`${e._type} : expression type is not supported.`)}}catch(t){const r=t instanceof Error?t.message:String(t);e.error(`Adaptive card expression compiler : paths in expression : ${r}`)}r=Array.from(new Set(r));return r}r.getPropertyPathsInExpression=h;function y(e){if(e.type||e.parameters||e.targetType||e.formatOptions||e.constraints){throw Error(`${e.toString()} : complex binding not supported.`)}const{modelName:t,path:r}=e;if(t){throw Error(`${t}>${r} : path in model not supported.`)}return r.replaceAll("/",".")}function E(e){const{operand1:t,operand2:r}=e;return[...h(t),...h(r)]}return r},false);
//# sourceMappingURL=AdaptiveCardExpressionCompiler.js.map