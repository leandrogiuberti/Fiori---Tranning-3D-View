{"version":3,"file":"RecommendationHelper.js","names":["recommendationHelper","sortRecommendationsData","incompletenessInfo","recommendationDataSorted","recommendations","sort","param1","param2","probability","info","additionalValues","transformRecommendationsForInternalStorage","data","hasOwnProperty","this","Array","isArray","forEach","dataObj","Object","values","valObj","clearRecommendations","view","inputBindingContext","internalModel","getModel","currentContext","getProperty","createMode","getBindingContext","getPath","setProperty","_exports"],"sources":["./RecommendationHelper.ts"],"sourcesContent":["import type { FEView } from \"sap/fe/core/BaseController\";\nimport type Context from \"sap/ui/model/Context\";\n\nexport type RecommendationValueType = {\n\tvalue: string | number;\n\tprobability: number | undefined;\n};\n\nexport type RecommendationDataForNavPropertyType = {\n\t[key: string]: PropertyIncompletenessInfoType | InternalPropertyAdditionalValue | KeyPropertiesDataType;\n};\n\nexport type KeyPropertiesDataType = {\n\t[key: string]: string | number;\n};\n\ntype PropertyIncompletenessInfoType = {\n\trecommendations: RecommendationValueType[];\n};\n\nexport type InternalPropertyAdditionalValue = {\n\tadditionalValues: RecommendationValueType[];\n\trecommendations?: RecommendationValueType[];\n};\n\ntype BaseStaticIncompletenessInfo = {\n\tkeyProperties: Record<string, unknown>;\n};\n\ntype BaseDynamicIncompletenessInfoType = Record<string, PropertyIncompletenessInfoType | RecommendationDataForNavPropertyType[]>;\n\nexport type InCompletenessInfoType = BaseStaticIncompletenessInfo & BaseDynamicIncompletenessInfoType;\n\nexport const recommendationHelper = {\n\t/**\n\t * This function will take recommendation data for a field and sort it in descending order based on probability of the value.\n\t * @param incompletenessInfo The set of recommended data for a field\n\t */\n\tsortRecommendationsData(incompletenessInfo: PropertyIncompletenessInfoType): void {\n\t\tconst recommendationDataSorted: RecommendationValueType[] = incompletenessInfo.recommendations;\n\t\trecommendationDataSorted.sort((param1: RecommendationValueType, param2: RecommendationValueType) => {\n\t\t\tif (param1.probability && param2.probability) {\n\t\t\t\tif (param1.probability < param2.probability) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else if (param1.probability > param2.probability) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t});\n\n\t\tconst info: InternalPropertyAdditionalValue | PropertyIncompletenessInfoType =\n\t\t\tincompletenessInfo as InternalPropertyAdditionalValue;\n\t\tdelete info.recommendations;\n\t\tinfo.additionalValues = recommendationDataSorted;\n\t},\n\n\t// The incompletenessinfo can be either for direct fields or fields through navigation property.\n\t// If the property is from the 1:n navigation then the information will be in the form of array of objects, where each object will be data\n\t// for a specific context in 1:n. The format of data for each object would be similar to that of fields at first level.\n\t// This may be the scenario for multiple levels i.e. 1:n navigation data inside another 1:n navigation and so on.\n\t// As we do not know the definite number of levels we use recursion to update data for all properties(for navigation properties as well, the data will\n\t// be nested but will follow same structure for each field info).\n\t// For reference of how data will look like, check CustomAction.js -> function setCustomRecommendation\n\t/**\n\t * This function will go through entire recommendation data for both direct fields and fields from navigation property and for each field update the recommendation info in descending order.\n\t * As with our use case we want recommendations that are in the order of probability for given value.\n\t * @param data Incompleteness info data\n\t */\n\ttransformRecommendationsForInternalStorage(data: InCompletenessInfoType | PropertyIncompletenessInfoType): void {\n\t\tif (data.hasOwnProperty(\"recommendations\")) {\n\t\t\tthis.sortRecommendationsData(data as PropertyIncompletenessInfoType);\n\t\t\treturn;\n\t\t} else if (Array.isArray(data)) {\n\t\t\t// we expect the data in array format for fields from 1:n navigation paths\n\t\t\t(data as RecommendationDataForNavPropertyType[]).forEach((dataObj: RecommendationDataForNavPropertyType) => {\n\t\t\t\t// for each entry in 1:n navigation we update the 'recommendations' object to sort in descending order of proability\n\t\t\t\tObject.values(dataObj).forEach(\n\t\t\t\t\t(valObj: PropertyIncompletenessInfoType | InternalPropertyAdditionalValue | KeyPropertiesDataType) => {\n\t\t\t\t\t\tif (typeof valObj === \"object\") {\n\t\t\t\t\t\t\tthis.transformRecommendationsForInternalStorage(valObj as PropertyIncompletenessInfoType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t} else {\n\t\t\t// for direct fields we check for the data value against the given Field and sort its recommendation data\n\t\t\t// from the given information\n\t\t\tObject.values(data).forEach((valObj: PropertyIncompletenessInfoType) => {\n\t\t\t\tif (typeof valObj === \"object\") {\n\t\t\t\t\tthis.transformRecommendationsForInternalStorage(valObj);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * This function check if we are in create mode, then explicity empty recommendations data from model.\n\t * Else if we are same page as before and after some actions then do not empty recommendations data.\n\t * @param view\n\t * @param inputBindingContext Context\n\t */\n\tclearRecommendations: (view: FEView, inputBindingContext?: Context): void => {\n\t\tconst internalModel = view.getModel(\"internal\");\n\t\tconst currentContext = internalModel.getProperty(\"/currentCtxt\") as Context | undefined;\n\t\tconst createMode = view.getBindingContext(\"pageInternal\")?.getProperty(\"createMode\") as boolean | undefined;\n\t\tif (currentContext?.getPath() !== inputBindingContext?.getPath() || createMode === true) {\n\t\t\tinternalModel.setProperty(\"/recommendationsData\", {});\n\t\t}\n\t}\n};\n"],"mappings":";;;;kDAiCO,MAAMA,EAAuB,CAKnCC,wBAAwBC,GACvB,MAAMC,EAAsDD,EAAmBE,gBAC/ED,EAAyBE,KAAK,CAACC,EAAiCC,KAC/D,GAAID,EAAOE,aAAeD,EAAOC,YAAa,CAC7C,GAAIF,EAAOE,YAAcD,EAAOC,YAAa,CAC5C,OAAO,CACR,MAAO,GAAIF,EAAOE,YAAcD,EAAOC,YAAa,CACnD,OAAQ,CACT,CACD,CACA,OAAO,IAGR,MAAMC,EACLP,SACMO,EAAKL,gBACZK,EAAKC,iBAAmBP,CACzB,EAcAQ,2CAA2CC,GAC1C,GAAIA,EAAKC,eAAe,mBAAoB,CAC3CC,KAAKb,wBAAwBW,GAC7B,MACD,MAAO,GAAIG,MAAMC,QAAQJ,GAAO,CAE9BA,EAAgDK,QAASC,IAEzDC,OAAOC,OAAOF,GAASD,QACrBI,IACA,UAAWA,IAAW,SAAU,CAC/BP,KAAKH,2CAA2CU,EACjD,KAIJ,KAAO,CAGNF,OAAOC,OAAOR,GAAMK,QAASI,IAC5B,UAAWA,IAAW,SAAU,CAC/BP,KAAKH,2CAA2CU,EACjD,GAEF,CACD,EAQAC,qBAAsBA,CAACC,EAAcC,KACpC,MAAMC,EAAgBF,EAAKG,SAAS,YACpC,MAAMC,EAAiBF,EAAcG,YAAY,gBACjD,MAAMC,EAAaN,EAAKO,kBAAkB,iBAAiBF,YAAY,cACvE,GAAID,GAAgBI,YAAcP,GAAqBO,WAAaF,IAAe,KAAM,CACxFJ,EAAcO,YAAY,uBAAwB,CAAC,EACpD,IAEAC,EAAAjC,uBAAA,OAAAiC,CAAA","ignoreList":[]}