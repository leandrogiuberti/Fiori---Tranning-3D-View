{"version":3,"file":"StandardRecommendationHelper.js","names":["rootContext","standardRecommendationHelper","storeRecommendations","recommendations","internalModel","recommendationsContexts","recommendationsData","getProperty","clearRecommendationsDataFromModelForGivenContexts","enhanceRecommendationModel","updateFetchedContextPaths","updateContextsKeysInModel","setProperty","refresh","ignoreRecommendationForContexts","contexts","recommendationContexts","recommendationData","ignoredContextPaths","forEach","context","ignoredContextPath","getPath","push","filter","contextInfo","startsWith","Object","keys","data","clearIgnoredContexts","contextPath","checkIfRecommendationRoleExistsForContext","recommendationsRegistry","dataModelObject","MetaModelConverter","getInvolvedDataModelObjectsForTargetPath","getModel","getMetaModel","entityType","targetEntityType","name","roles","includes","hasOwnProperty","keysData","metaModel","metaPath","getMetaPath","dataModel","getInvolvedDataModelObjects","getMetaContext","semanticKeysForGivenMetaPath","annotations","Common","SemanticKey","map","i","value","target","idx","lastIndexOf","find","substring","recommendation","AIRecommendedFieldPath","recommendationValues","isPlaceholderValueFound","_AIAltvRecmddFldVals","alternativeRecommendation","recommendationValue","AIRecommendedFieldValue","probability","AIRecommendedFieldScoreValue","undefined","text","AIRecommendedFieldDescription","additionalValues","getStandardRecommendations","bindingContext","propertyPath","fullPath","getDisplayModeForTargetPath","targetPath","involvedDataModelObject","displayMode","getDisplayMode","isRecommendationFieldNull","key","property","isPathAnnotationExpression","targetObject","Text","path","fetchedContextPaths","getContextsWithNoRecommendations","contextsInfo","resetRecommendations","recommendationsDataInModel","getCurrentRootContext","setCurrentRootContext","addContextIdentifierText","params","viewPath","index","identifierValues","contextIdentifier","idPath","contextText","this","getTextForKey","contextIdentifierText","getEntityName","typeName","UI","HeaderInfo","TypeName","compileExpression","getExpressionFromAnnotation","keyPath","isPropertyPathExpression","$target","evaluateExpression","getObject","_exports"],"sources":["./StandardRecommendationHelper.ts"],"sourcesContent":["import type { Property } from \"@sap-ux/vocabularies-types\";\nimport type { CompiledBindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport { compileExpression, getExpressionFromAnnotation } from \"sap/fe/base/BindingToolkit\";\nimport * as MetaModelConverter from \"sap/fe/core/converters/MetaModelConverter\";\nimport type { RecommendationsRegistry } from \"sap/fe/core/services/SideEffectsServiceFactory\";\nimport type Context from \"sap/ui/model/Context\";\nimport type JSONModel from \"sap/ui/model/json/JSONModel\";\nimport type ODataV4Context from \"sap/ui/model/odata/v4/Context\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\nimport type { AcceptAllParams } from \"../controllerextensions/Recommendations\";\nimport type { DataModelObjectPath } from \"../templating/DataModelPathHelper\";\nimport { getDisplayMode } from \"../templating/UIFormatters\";\nimport { evaluateExpression } from \"./BindingToolkitEvaluator\";\nimport type { RecommendationValueType } from \"./RecommendationHelper\";\nimport { isPathAnnotationExpression, isPropertyPathExpression } from \"./TypeGuards\";\n\nexport type StandardRecommendationResponse = {\n\tAIRecommendedFieldPath?: string;\n\tAIRecommendedFieldValue?: string;\n\tAIRecommendedFieldDescription?: string;\n\t_AIAltvRecmddFldVals?: AlternativeRecommendationResponseType[];\n};\n\nexport type RecommendationContextsInfo = {\n\tcontext?: ODataV4Context;\n\tcontextIdentifier?: string[];\n};\n\nexport type AlternativeRecommendationResponseType = {\n\tAIRecommendedFieldValue: string;\n\tAIRecommendedFieldScoreValue?: number;\n};\n\nexport type StandardRecommendationDataType = {\n\tvalue?: string;\n\ttext?: string;\n\tadditionalValues?: RecommendationValueType[];\n};\n\ntype StandardBaseRecommendation = {\n\tversion?: number;\n\tkeys?: Record<string, string[]>;\n};\n\nexport type BaseDynamicRecommendation = Record<string, StandardRecommendationDataType>;\n\nexport type RecommendationInfo = StandardBaseRecommendation & BaseDynamicRecommendation;\n\nlet rootContext: ODataV4Context;\n\nexport const standardRecommendationHelper = {\n\t/**\n\t * This function will process and set the recommendations according to data received from backend.\n\t * @param recommendations The data received from backend\n\t * @param internalModel The internal json model\n\t * @param recommendationsContexts The contexts for which recommendations are being fetched\n\t */\n\tstoreRecommendations: (\n\t\trecommendations: StandardRecommendationResponse[],\n\t\tinternalModel: JSONModel,\n\t\trecommendationsContexts: ODataV4Context[]\n\t): void => {\n\t\tconst recommendationsData = (internalModel.getProperty(\"/recommendationsData\") as RecommendationInfo) || {};\n\t\tstandardRecommendationHelper.clearRecommendationsDataFromModelForGivenContexts(recommendationsData, recommendationsContexts);\n\t\tstandardRecommendationHelper.enhanceRecommendationModel(recommendations, recommendationsData);\n\t\tstandardRecommendationHelper.updateFetchedContextPaths(recommendationsContexts, internalModel);\n\t\tstandardRecommendationHelper.updateContextsKeysInModel(recommendationsData, recommendationsContexts);\n\t\t//Setting the version to 2.0 to segregate the processing\n\t\trecommendationsData[\"version\"] = 2.0;\n\t\tinternalModel.setProperty(\"/recommendationsData\", recommendationsData);\n\t\tinternalModel.refresh(true);\n\t},\n\n\tignoreRecommendationForContexts: (contexts: ODataV4Context[], internalModel: JSONModel): void => {\n\t\tlet recommendationContexts: RecommendationContextsInfo[] = internalModel.getProperty(\"/recommendationContexts\") || [];\n\t\tconst recommendationData = internalModel.getProperty(\"/recommendationsData\");\n\t\tconst ignoredContextPaths = internalModel.getProperty(\"/ignoredContextPaths\") || [];\n\t\tcontexts.forEach((context: ODataV4Context) => {\n\t\t\tconst ignoredContextPath = context.getPath();\n\t\t\tignoredContextPaths.push(ignoredContextPath);\n\t\t\t// delete recommendation data for a context or its children filter recommendationContexts which do not match\n\t\t\t// a path. This will be the list of recommendations contexts to be kept in model\n\t\t\trecommendationContexts = recommendationContexts.filter((contextInfo: RecommendationContextsInfo) => {\n\t\t\t\treturn !(contextInfo?.context as ODataV4Context).getPath().startsWith(ignoredContextPath);\n\t\t\t});\n\t\t\tObject.keys(recommendationData).forEach((data) => {\n\t\t\t\tif (data.startsWith(ignoredContextPath)) {\n\t\t\t\t\tdelete recommendationData[data];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tinternalModel.setProperty(\"/recommendationsData\", recommendationData);\n\t\tinternalModel.setProperty(\"/recommendationContexts\", recommendationContexts);\n\t\tinternalModel.setProperty(\"/ignoredContextPaths\", ignoredContextPaths);\n\t},\n\n\tclearIgnoredContexts: (internalModel: JSONModel, contextPath: string): void => {\n\t\tlet ignoredContextPaths = internalModel.getProperty(\"/ignoredContextPaths\") || [];\n\t\tignoredContextPaths = ignoredContextPaths.filter((ignoredContextPath: string) => {\n\t\t\treturn !ignoredContextPath.startsWith(contextPath);\n\t\t});\n\t\tinternalModel.setProperty(\"/ignoredContextPaths\", ignoredContextPaths);\n\t},\n\n\t/**\n\t * This function checks if there are recommendation roles for context entity type.\n\t * @param contextInfo Contains context and contextIdentifier\n\t * @param recommendationsRegistry Registry which holds the recommendation roles for all entity types\n\t * @returns Boolean value based on whether recommendation role exists for entityType annotation or not\n\t */\n\tcheckIfRecommendationRoleExistsForContext: (\n\t\tcontextInfo: RecommendationContextsInfo,\n\t\trecommendationsRegistry: RecommendationsRegistry\n\t): boolean => {\n\t\tconst dataModelObject = MetaModelConverter.getInvolvedDataModelObjectsForTargetPath(\n\t\t\t(contextInfo?.context as ODataV4Context).getPath(),\n\t\t\t(contextInfo?.context as ODataV4Context).getModel()?.getMetaModel()\n\t\t);\n\t\tconst entityType = dataModelObject?.targetEntityType.name as string;\n\t\treturn Object.keys(recommendationsRegistry.roles).includes(entityType);\n\t},\n\n\t/**\n\t * This function updates recommendation data with keys of all contexts. This must be shown in the Accept Recommendations Dialog based on the use case.\n\t * @param recommendationsData\n\t * @param recommendationContexts\n\t */\n\tupdateContextsKeysInModel: (recommendationsData: RecommendationInfo, recommendationContexts: ODataV4Context[]): void => {\n\t\tif (!recommendationsData.hasOwnProperty(\"keys\")) {\n\t\t\trecommendationsData[\"keys\"] = {};\n\t\t}\n\t\tconst keysData = recommendationsData[\"keys\"];\n\t\trecommendationContexts.forEach((context: ODataV4Context) => {\n\t\t\tconst metaModel = context.getModel()?.getMetaModel();\n\t\t\tconst metaPath = metaModel.getMetaPath(context?.getPath());\n\t\t\tconst dataModel = MetaModelConverter.getInvolvedDataModelObjects(metaModel.getMetaContext(metaPath));\n\t\t\tconst semanticKeysForGivenMetaPath = dataModel.targetEntityType.annotations.Common?.SemanticKey;\n\t\t\tif (semanticKeysForGivenMetaPath) {\n\t\t\t\tif (keysData && !keysData.hasOwnProperty(metaPath) && semanticKeysForGivenMetaPath) {\n\t\t\t\t\tkeysData[metaPath] = semanticKeysForGivenMetaPath.map((i) => i.value);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * This function clears the old recommendations for the context.\n\t * @param recommendationsData The recommendation data which is stored\n\t * @param recommendationsContexts The contexts for which recommendations are being fetched\n\t */\n\tclearRecommendationsDataFromModelForGivenContexts: (\n\t\trecommendationsData: RecommendationInfo,\n\t\trecommendationsContexts?: ODataV4Context[]\n\t): void => {\n\t\tif (recommendationsContexts) {\n\t\t\tObject.keys(recommendationsData).forEach((target) => {\n\t\t\t\tconst idx = target.lastIndexOf(\")\");\n\t\t\t\tif (\n\t\t\t\t\trecommendationsContexts.find((context) => {\n\t\t\t\t\t\treturn context.getPath() === target.substring(0, idx + 1);\n\t\t\t\t\t})\n\t\t\t\t) {\n\t\t\t\t\tdelete recommendationsData[target];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * This function will enhance the recommendations according to data received from backend.\n\t * @param recommendations The data received from backend\n\t * @param recommendationsData The existing recommendation Model\n\t */\n\tenhanceRecommendationModel: (\n\t\trecommendations: Array<StandardRecommendationResponse>,\n\t\trecommendationsData: Record<string, object>\n\t): void => {\n\t\trecommendations?.forEach((recommendation: StandardRecommendationResponse) => {\n\t\t\tconst target = recommendation.AIRecommendedFieldPath;\n\t\t\tif (target) {\n\t\t\t\t// loop through all the recommendations sent from backend\n\t\t\t\tconst recommendationValues: RecommendationValueType[] = [];\n\t\t\t\tlet isPlaceholderValueFound = false;\n\n\t\t\t\t// set the other alternatives as recommendations\n\t\t\t\trecommendation._AIAltvRecmddFldVals?.forEach((alternativeRecommendation: AlternativeRecommendationResponseType) => {\n\t\t\t\t\tconst recommendationValue: RecommendationValueType = {\n\t\t\t\t\t\tvalue: alternativeRecommendation.AIRecommendedFieldValue,\n\t\t\t\t\t\tprobability: alternativeRecommendation.AIRecommendedFieldScoreValue\n\t\t\t\t\t};\n\t\t\t\t\tif (recommendation.AIRecommendedFieldValue === alternativeRecommendation.AIRecommendedFieldValue) {\n\t\t\t\t\t\tisPlaceholderValueFound = true;\n\t\t\t\t\t}\n\n\t\t\t\t\trecommendationValues.push(recommendationValue);\n\t\t\t\t});\n\t\t\t\trecommendationsData[target] = {\n\t\t\t\t\tvalue: isPlaceholderValueFound ? recommendation.AIRecommendedFieldValue : undefined,\n\t\t\t\t\ttext: isPlaceholderValueFound ? recommendation.AIRecommendedFieldDescription : undefined,\n\t\t\t\t\tadditionalValues: recommendationValues\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * This function returns recommendations from standard recommendations model.\n\t * @param bindingContext Binding Context of the field\n\t * @param propertyPath Property path of the field\n\t * @param recommendationData Object containing recommendations\n\t * @returns Recommendation data for the field\n\t */\n\tgetStandardRecommendations: function (\n\t\tbindingContext: Context,\n\t\tpropertyPath: string,\n\t\trecommendationData: RecommendationInfo\n\t): StandardRecommendationDataType | undefined {\n\t\tif (bindingContext && propertyPath) {\n\t\t\tconst fullPath = bindingContext.getPath() + \"/\" + propertyPath;\n\t\t\treturn recommendationData[fullPath] || undefined;\n\t\t}\n\t},\n\t/**\n\t * Fetches the display mode for a given target path.\n\t * @param targetPath\n\t * @param metaModel\n\t * @returns Display mode for target path\n\t */\n\tgetDisplayModeForTargetPath(targetPath: string, metaModel: ODataMetaModel): string {\n\t\tconst involvedDataModelObject = MetaModelConverter.getInvolvedDataModelObjectsForTargetPath<Property>(targetPath, metaModel);\n\t\tconst displayMode = involvedDataModelObject && getDisplayMode(involvedDataModelObject);\n\t\treturn displayMode ? displayMode : \"DescriptionValue\";\n\t},\n\n\t/**\n\t * Function which informs whether a recommendation field is null or not.\n\t * @param context\n\t * @param key\n\t * @param propertyPath\n\t * @returns boolean value based on whether a recommendation field is null or not\n\t */\n\n\tisRecommendationFieldNull(context: ODataV4Context, key: string, propertyPath: string): boolean {\n\t\tconst property = MetaModelConverter.getInvolvedDataModelObjectsForTargetPath<Property>(key, context.getModel()?.getMetaModel());\n\t\tif (!context?.getProperty(propertyPath)) {\n\t\t\tconst displayMode = standardRecommendationHelper.getDisplayModeForTargetPath(key, context?.getModel()?.getMetaModel());\n\t\t\tif (displayMode && displayMode !== \"Value\") {\n\t\t\t\tconst text =\n\t\t\t\t\tisPathAnnotationExpression(property?.targetObject?.annotations?.Common?.Text) &&\n\t\t\t\t\tproperty?.targetObject?.annotations?.Common?.Text?.path;\n\t\t\t\treturn text ? !context?.getProperty(text) : true;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tupdateFetchedContextPaths: function (contexts: ODataV4Context[], internalModel: JSONModel): void {\n\t\tconst fetchedContextPaths: string[] = [];\n\t\tcontexts?.forEach((context) => {\n\t\t\tconst contextPath = context?.getPath();\n\t\t\tif (contextPath && !fetchedContextPaths.includes(contextPath)) {\n\t\t\t\tfetchedContextPaths.push(contextPath);\n\t\t\t}\n\t\t});\n\n\t\tinternalModel?.setProperty(\"/fetchedContextPaths\", fetchedContextPaths);\n\t\tinternalModel.refresh();\n\t},\n\n\tgetContextsWithNoRecommendations: function (\n\t\tcontextsInfo: RecommendationContextsInfo[],\n\t\tinternalModel: JSONModel\n\t): RecommendationContextsInfo[] {\n\t\tconst fetchedContextPaths = internalModel.getProperty(\"/fetchedContextPaths\") || [];\n\t\tconst ignoredContextPaths = internalModel.getProperty(\"/ignoredContextPaths\") || [];\n\t\treturn contextsInfo.filter((contextInfo) => {\n\t\t\tconst contextPath = (contextInfo?.context as ODataV4Context).getPath();\n\t\t\treturn !fetchedContextPaths.includes(contextPath) && !ignoredContextPaths.includes(contextPath);\n\t\t});\n\t},\n\n\tresetRecommendations: function (internalModel: JSONModel): void {\n\t\t// we have version key maintained only for standard solution of recommendations\n\t\t//and only if this is standard implementation, we should reset recommendations\n\t\tconst recommendationsDataInModel = internalModel.getProperty(\"/recommendationsData\");\n\t\tif (recommendationsDataInModel && recommendationsDataInModel.hasOwnProperty(\"version\")) {\n\t\t\tinternalModel.setProperty(\"/recommendationsData\", {});\n\t\t\tinternalModel?.setProperty(\"/fetchedContextPaths\", []);\n\t\t\tinternalModel?.setProperty(\"/ignoredContextPaths\", []);\n\t\t\tinternalModel.refresh(true);\n\t\t}\n\t},\n\n\tgetCurrentRootContext: function (): ODataV4Context | undefined {\n\t\treturn rootContext;\n\t},\n\n\tsetCurrentRootContext: function (context: ODataV4Context): void {\n\t\trootContext = context;\n\t},\n\t/**\n\t * Adds the text of ContextIdentifier else will add its value to the acceptAllParams.\n\t * @param params\n\t * @param viewPath Context Path of view\n\t */\n\taddContextIdentifierText(params: AcceptAllParams, viewPath: string | undefined): void {\n\t\tfor (const recommendationData of params?.recommendationData || []) {\n\t\t\tlet index = 0;\n\t\t\tconst identifierValues: string[] = [];\n\t\t\t// for recommendation fields which are directly on page, we do not want to show identifier values\n\t\t\t// so we exclude that calculation\n\t\t\tif (recommendationData.context?.getPath() !== viewPath) {\n\t\t\t\tif (recommendationData.contextIdentifier && recommendationData.context) {\n\t\t\t\t\trecommendationData.contextIdentifier.forEach((contextIdentifier) => {\n\t\t\t\t\t\tconst idPath = `${recommendationData.context?.getPath()})/${contextIdentifier}`;\n\t\t\t\t\t\tconst contextText = this.getTextForKey(recommendationData.context as ODataV4Context, idPath, contextIdentifier);\n\t\t\t\t\t\tif (contextText) {\n\t\t\t\t\t\t\tidentifierValues.push(index === 0 ? `${contextText}` : ` ${contextText}`);\n\t\t\t\t\t\t\tindex = index + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\trecommendationData.contextIdentifierText = identifierValues;\n\t\t}\n\t},\n\t/**\n\t * Fetches table name based on the context.\n\t * @param context\n\t * @returns Table name\n\t */\n\n\tgetEntityName(context: ODataV4Context): CompiledBindingToolkitExpression | undefined {\n\t\tconst dataModelObject = MetaModelConverter.getInvolvedDataModelObjectsForTargetPath(\n\t\t\tcontext.getPath(),\n\t\t\tcontext.getModel()?.getMetaModel()\n\t\t);\n\t\tconst typeName = dataModelObject?.targetEntityType?.annotations?.UI?.HeaderInfo?.TypeName;\n\t\treturn typeName && compileExpression(getExpressionFromAnnotation(typeName));\n\t},\n\t/**\n\t * Fetches Text for key if it exists else will return its value.\n\t * @param context\n\t * @param keyPath\n\t * @param key\n\t * @returns Text or Value for a key\n\t */\n\n\tgetTextForKey(context: ODataV4Context, keyPath: string, key: string): string {\n\t\tlet value = \"\";\n\t\tconst involvedDataModelObject: DataModelObjectPath<Property> | undefined =\n\t\t\tMetaModelConverter.getInvolvedDataModelObjectsForTargetPath<Property>(keyPath, context?.getModel()?.getMetaModel());\n\t\tconst targetObject = involvedDataModelObject?.targetObject;\n\t\tconst property =\n\t\t\t((isPathAnnotationExpression(targetObject) || isPropertyPathExpression(targetObject)) && targetObject.$target) ||\n\t\t\t(targetObject as Property);\n\t\tconst text = getExpressionFromAnnotation(property?.annotations?.Common?.Text);\n\t\tif (text) {\n\t\t\ttry {\n\t\t\t\tvalue = evaluateExpression(text, { \"\": context.getObject() }) as string;\n\t\t\t\tvalue = value ? value : context.getProperty(key);\n\t\t\t} catch {\n\t\t\t\tvalue = context.getProperty(key);\n\t\t\t}\n\t\t}\n\t\treturn value ?? context.getProperty(key);\n\t}\n};\n"],"mappings":"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","ignoreList":[]}