{"version":3,"file":"ContextPathHelper.js","names":["isPathOnDraftRoot","path","metaModel","matches","exec","entitySetPath","getObject","_exports","createFilterFromPath","keys","unquoteAndDecode","value","indexOf","lastIndexOf","length","decodeURIComponent","substring","keyValues","split","finalKeys","finalKeyValues","includes","filter","singleKey","element","startsWith","filteringCaseSensitive","ModelHelper","isFilteringCaseSensitive","filters","keyPart","keyValue","Filter","operator","FilterOperator","EQ","value1","caseSensitive","mKeyValues","forEach","sKeyAssignment","aParts","failed","map","semanticKey","key","undefined","draftFilter","and","push","async","getContextFromKeys","model","getMetaModel","absolutePath","metaContext","getMetaContext","objectPath","getInvolvedDataModelObjects","technicalKeys","targetEntityType","property","name","listBinding","bindList","getPath","$select","join","$$groupId","contexts","requestContexts","getDraftOrActiveContext","context","getModel","resolvePath","pathToResolve","routingService","router","currentHashNoParams","getHashChanger","getHash","rootEntityName","semanticKeys","SemanticKeyHelper","getSemanticKeys","$PropertyPath","lastSemanticMapping","getLastSemanticMapping","semanticPath","technicalPath","setLastSemanticMapping"],"sources":["./ContextPathHelper.ts"],"sourcesContent":["import { getInvolvedDataModelObjects } from \"sap/fe/core/converters/MetaModelConverter\";\nimport ModelHelper from \"sap/fe/core/helpers/ModelHelper\";\nimport SemanticKeyHelper from \"sap/fe/core/helpers/SemanticKeyHelper\";\nimport type { RoutingService } from \"sap/fe/core/services/RoutingServiceFactory\";\nimport type Router from \"sap/ui/core/routing/Router\";\nimport Filter from \"sap/ui/model/Filter\";\nimport FilterOperator from \"sap/ui/model/FilterOperator\";\nimport type Context from \"sap/ui/model/odata/v4/Context\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\nimport type ODataModel from \"sap/ui/model/odata/v4/ODataModel\";\n\n/**\n * Checks if a path refers to a draft root path.\n * @param path The path to test\n * @param metaModel The associated metadata model\n * @returns `true` if the path is a draft root path\n */\nexport function isPathOnDraftRoot(path: string, metaModel: ODataMetaModel): boolean {\n\t// Check if the path follows the pattern '/aaa(bbb)'\n\tconst matches = /^[/]?(\\w+)\\([^/]+\\)$/.exec(path);\n\tif (!matches) {\n\t\treturn false;\n\t}\n\n\t// Check if the entity set supports draft\n\tconst entitySetPath = `/${matches[1]}`;\n\treturn metaModel.getObject(`${entitySetPath}@com.sap.vocabularies.Common.v1.DraftRoot`) ? true : false;\n}\n\n/**\n * Creates the filter to retrieve the draft or active instance from a path.\n * @param path The semantic or technical path\n * @param keys The semantic or technical keys for the path\n * @param metaModel The instance of the metamodel\n * @returns The filter\n */\nexport function createFilterFromPath(path: string, keys: string[], metaModel: ODataMetaModel): Filter | null {\n\tconst unquoteAndDecode = function (value: string): string {\n\t\tif (value.indexOf(\"'\") === 0 && value.lastIndexOf(\"'\") === value.length - 1) {\n\t\t\t// Remove the quotes from the value and decode special chars\n\t\t\tvalue = decodeURIComponent(value.substring(1, value.length - 1));\n\t\t}\n\t\treturn value;\n\t};\n\tconst keyValues = path.substring(path.indexOf(\"(\") + 1, path.length - 1).split(\",\");\n\n\tlet finalKeys = keys;\n\tlet finalKeyValues = keyValues;\n\t// If we have technical keys, IsActiveEntity will be present. We need to remove it as we're already adding them at the end.\n\tif (keys.includes(\"IsActiveEntity\")) {\n\t\tfinalKeys = keys.filter((singleKey) => !singleKey.includes(\"IsActiveEntity\"));\n\t\tfinalKeyValues = keyValues.filter((element) => !element.startsWith(\"IsActiveEntity\"));\n\t}\n\n\tif (finalKeys.length != finalKeyValues.length) {\n\t\treturn null;\n\t}\n\n\tconst filteringCaseSensitive = ModelHelper.isFilteringCaseSensitive(metaModel);\n\tlet filters: Filter[];\n\tif (finalKeys.length === 1) {\n\t\t// If this is a technical key, the equal is present because there's at least 2 parameters, a technical key and IsActiveEntity\n\t\tif (finalKeyValues[0].indexOf(\"=\") > 0) {\n\t\t\tconst keyPart = finalKeyValues[0].split(\"=\");\n\t\t\tfinalKeyValues[0] = keyPart[1];\n\t\t}\n\t\t// Take the first key value\n\t\tconst keyValue = unquoteAndDecode(finalKeyValues[0]);\n\t\tfilters = [\n\t\t\tnew Filter({\n\t\t\t\tpath: finalKeys[0],\n\t\t\t\toperator: FilterOperator.EQ,\n\t\t\t\tvalue1: keyValue,\n\t\t\t\tcaseSensitive: filteringCaseSensitive\n\t\t\t})\n\t\t];\n\t} else {\n\t\tconst mKeyValues: Record<string, unknown> = {};\n\t\t// Create a map of all key values\n\t\tfinalKeyValues.forEach(function (sKeyAssignment: string) {\n\t\t\tconst aParts = sKeyAssignment.split(\"=\"),\n\t\t\t\tkeyValue = unquoteAndDecode(aParts[1]);\n\n\t\t\tmKeyValues[aParts[0]] = keyValue;\n\t\t});\n\n\t\tlet failed = false;\n\t\tfilters = finalKeys.map(function (semanticKey) {\n\t\t\tconst key = semanticKey,\n\t\t\t\tvalue = mKeyValues[key];\n\n\t\t\tif (value !== undefined) {\n\t\t\t\treturn new Filter({\n\t\t\t\t\tpath: key,\n\t\t\t\t\toperator: FilterOperator.EQ,\n\t\t\t\t\tvalue1: value,\n\t\t\t\t\tcaseSensitive: filteringCaseSensitive\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tfailed = true;\n\t\t\t\treturn new Filter({\n\t\t\t\t\tpath: \"XX\"\n\t\t\t\t}); // will be ignored anyway since we return after\n\t\t\t}\n\t\t});\n\n\t\tif (failed) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// Add a draft filter to make sure we take the draft entity if there is one\n\t// Or the active entity otherwise\n\tconst draftFilter = new Filter({\n\t\tfilters: [new Filter(\"IsActiveEntity\", \"EQ\", false), new Filter(\"SiblingEntity/IsActiveEntity\", \"EQ\", null)],\n\t\tand: false\n\t});\n\tfilters.push(draftFilter);\n\n\treturn new Filter(filters, true);\n}\n\n/**\n * Loads a context from a list of keys (semantic or technical).\n * @param keys The keys\n * @param keyValues The key values in a string, e.g. /entity(aa=xx,bb=xx,...)\n * @param model\n * @returns The context (or null if none could be found)\n */\nasync function getContextFromKeys(keys: string[], keyValues: string, model: ODataModel): Promise<Context | null> {\n\tconst metaModel = model.getMetaModel();\n\tif (!keys || keys.length === 0) {\n\t\t// No semantic/technical keys\n\t\treturn null;\n\t}\n\n\t// Create a set of filters corresponding to all keys\n\tconst filter = createFilterFromPath(keyValues, keys, metaModel);\n\tif (filter === null) {\n\t\t// Couldn't interpret the path as a semantic one\n\t\treturn null;\n\t}\n\n\t// Retrieve the entity keys to add them in the $select query parameter\n\tconst absolutePath = keyValues.startsWith(\"/\") ? keyValues : `/${keyValues}`;\n\tconst metaContext = metaModel.getMetaContext(absolutePath);\n\tconst objectPath = getInvolvedDataModelObjects(metaContext);\n\tconst technicalKeys = objectPath.targetEntityType.keys.map((property) => property.name);\n\n\t// Load the corresponding object\n\tconst listBinding = model.bindList(metaContext.getPath(), undefined, undefined, filter, {\n\t\t$select: technicalKeys.join(\",\"),\n\t\t$$groupId: \"$auto.Heroes\"\n\t});\n\n\tconst contexts = await listBinding.requestContexts(0, 2);\n\tif (contexts.length) {\n\t\treturn contexts[0];\n\t} else {\n\t\t// No data could be loaded\n\t\treturn null;\n\t}\n}\n\n/**\n * Get the draft (if it exists) or the active context for a given draft-root context.\n * @param context\n * @returns The draft context if there's one, the active context otherwise\n */\nexport async function getDraftOrActiveContext(context: Context): Promise<Context | null> {\n\tconst model = context.getModel();\n\tconst metaModel = model.getMetaModel();\n\tconst objectPath = getInvolvedDataModelObjects(metaModel.getMetaContext(context.getPath()));\n\tconst keys = objectPath.targetEntityType.keys.map((property) => property.name);\n\n\treturn getContextFromKeys(keys, context.getPath(), model);\n}\n\n/**\n * Transforms a patch (semantic or not) into a technical path.\n * @param pathToResolve The path (semantic or not)\n * @param model\n * @param routingService\n * @param router\n * @returns The technical path corresponding to the pathToResolve\n */\nexport async function resolvePath(\n\tpathToResolve: string,\n\tmodel: ODataModel,\n\troutingService: RoutingService,\n\trouter: Router\n): Promise<string> {\n\tconst metaModel = model.getMetaModel();\n\tlet currentHashNoParams = router.getHashChanger().getHash().split(\"?\")[0];\n\tif (currentHashNoParams?.lastIndexOf(\"/\") === currentHashNoParams?.length - 1) {\n\t\t// Remove trailing '/'\n\t\tcurrentHashNoParams = currentHashNoParams.substring(0, currentHashNoParams.length - 1);\n\t}\n\n\t// If the app is displaying a sub-OP (or below), then we just return the original path\n\tif (!isPathOnDraftRoot(currentHashNoParams, metaModel)) {\n\t\treturn pathToResolve;\n\t}\n\n\tlet rootEntityName = currentHashNoParams?.substring(0, currentHashNoParams.indexOf(\"(\"));\n\tif (rootEntityName[0] === \"/\") {\n\t\trootEntityName = rootEntityName.substring(1);\n\t}\n\n\tconst semanticKeys = SemanticKeyHelper.getSemanticKeys(metaModel, rootEntityName)?.map((key) => key.$PropertyPath);\n\tif (semanticKeys === undefined) {\n\t\t// If we don't have semantic keys, the path we have is technical and can be used as is.\n\t\treturn pathToResolve;\n\t}\n\n\tconst lastSemanticMapping = routingService.getLastSemanticMapping();\n\n\tif (lastSemanticMapping?.semanticPath === pathToResolve) {\n\t\t// This semantic path has been resolved previously\n\t\treturn lastSemanticMapping.technicalPath;\n\t}\n\n\t// We need resolve the semantic path to get the technical keys\n\tconst context = await getContextFromKeys(semanticKeys, currentHashNoParams, model);\n\tconst technicalPath = context?.getPath();\n\n\tif (technicalPath && technicalPath !== pathToResolve) {\n\t\t// The semantic path was resolved (otherwise keep the original value for target)\n\t\troutingService.setLastSemanticMapping({\n\t\t\ttechnicalPath: technicalPath,\n\t\t\tsemanticPath: pathToResolve\n\t\t});\n\t\treturn technicalPath;\n\t}\n\n\treturn pathToResolve;\n}\n"],"mappings":"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","ignoreList":[]}