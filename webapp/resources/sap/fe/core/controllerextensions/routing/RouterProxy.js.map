{"version":3,"file":"RouterProxy.js","names":["enumState","EQUAL","COMPATIBLE","ANCESTOR","DIFFERENT","enumURLParams","LAYOUTPARAM","IAPPSTATEPARAM","createGuardFromHash","sGuardHash","hashTraker","_guardHash","replace","hashTracker","undefined","check","sHash","indexOf","this","removeAppStateInHash","RegExp","RouterProxy","_dec","defineUI5Class","_class","_BaseObject","_this","_len","arguments","length","args","Array","_key","call","bIsRebuildHistoryRunning","bIsComputingTitleHierachy","bIsGuardCrossAllowed","sIAppStateKey","_bActivateRouteMatchSynchro","_bApplyRestore","_pathMappings","restoreHistoryTriggered","appStateUpdating","_inheritsLoose","_proto","prototype","init","oAppComponent","isfclEnabled","getService","then","asyncInit","catch","oError","Log","error","_fnHashGuard","hashGuard","bind","window","addEventListener","_bDisableOnHashChange","_bIgnoreRestore","_bForceFocus","_oShellServices","getShellServices","initRaw","getRouter","routingHints","getRoutingService","getRoutingHints","waitForRouteMatchBeforeNavigation","history","replaceState","Object","assign","feLevel","state","location","fclEnabled","_fnBlockingNavFilter","_blockingNavigationFilter","registerNavigationFilter","destroy","unregisterNavigationFilter","removeEventListener","setAppStateInHash","sAppStateKey","sNewHash","includes","findAppStateInHash","aAppState","match","getDecodedWindowHash","decodeURI","hash","oRouter","_oRouter","_oManagedHistory","_oNavigationGuard","sCurrentAppHash","getHash","push","_extractStateFromHash","appName","getAppNameFromHash","getFullHash","splitHash","appSpecificRoute","getHashChanger","shellPart","isFocusForced","setFocusForced","bForced","removeIAppStateKey","setAppStateUpdating","updatingAppState","isAppStateUpdating","removeRestoreHistoryFlagFromHash","navToHash","async","bPreserveHistory","bDisablePreservationCache","bForceFocus","bPreserveShellBackNavigationHandler","startsWith","substring","setBackNavigation","_oRouteMatchSynchronization","waitFor","_internalNavToHash","checkHashWithGuard","oResourceBundle","Library","getResourceBundleFor","confirm","getText","Promise","resolve","oNewState","aCurrentHashKeys","extractEntitySetsFromHash","keys","every","key","index","oHistoryAction","_pushNewState","storeFocusInfoForCurrentHash","_rebuildBrowserHistory","restoreHistory","sTargetHash","checkRestoreHistoryWasTriggered","resetRestoreHistoryFlag","navBack","sCurrentHash","sPreviousHash","i","back","navTo","sRouteName","oParameters","getURL","noPreservationCache","bIsStickyMode","exitFromApp","backToPreviousApp","isCurrentStateImpactedBy","oLocalGuard","isNavigationFinalized","setNavigationGuard","discardNavigationGuard","hasNavigationGuard","isGuardCrossAllowedByUser","activateRouteMatchSynchronization","resolveRouteMatch","Synchronization","sHashNoParams","split","aTokens","names","forEach","sToken","oState","screenMode","aLayout","sLayout","bRebuildOnly","bDisableHistoryPreservation","lastIndex","iPopCount","pop","preserved","oLastRemovedItem","oTopState","_compareCacheStates","sPreviousIAppStateKey","oComparisonStateResult","bHasSameHash","focusControlId","secondaryFocusControlId","focusInfo","secondaryFocusInfo","type","steps","_disableEventOnHashChange","stop","_enableEventOnHashChange","bIgnoreCurrentHash","initialize","that","oTargetState","newLevel","replaceAsync","replaceHash","setTimeout","backReplaceAsync","backAsync","setHash","go","getLastHistoryEntry","setPathMapping","mappings","filter","mapping","oldPath","newPath","currentAppName","isInitialized","find","m","encodeURI","aHashSplit","sAppHash","oState1","oState2","equal","parentOf","splitAppSpecificRoute","routeSplit","shift","checkIfBackIsOutOfGuard","segments","previousHash","checkIfBackExitsApp","checkIfBackHasSameContext","oCurrentState","oPreviousState","restoreFocusForCurrentHash","currentHash","stateForHash","focusApplied","focusControl","Element","getElementById","useSecondary","getFocusDomRef","getParent","isA","getBusy","focus","getActiveElement","getId","parentTable","preventScroll","getFocusInfo","findLayoutForHash","hashNoParam","targetState","BaseObject"],"sources":["./RouterProxy.ts"],"sourcesContent":["import Log from \"sap/base/Log\";\nimport type ResourceBundle from \"sap/base/i18n/ResourceBundle\";\nimport { defineUI5Class } from \"sap/fe/base/ClassSupport\";\nimport type AppComponent from \"sap/fe/core/AppComponent\";\nimport Synchronization from \"sap/fe/core/helpers/Synchronization\";\nimport type { IShellServices } from \"sap/fe/core/services/ShellServicesFactory\";\nimport type MTable from \"sap/m/Table\";\nimport BaseObject from \"sap/ui/base/Object\";\nimport Element from \"sap/ui/core/Element\";\nimport Library from \"sap/ui/core/Lib\";\nimport type Router from \"sap/ui/core/routing/Router\";\nimport type Table from \"sap/ui/mdc/Table\";\nimport type UITable from \"sap/ui/table/Table\";\n\nconst enumState = {\n\tEQUAL: 0,\n\tCOMPATIBLE: 1,\n\tANCESTOR: 2,\n\tDIFFERENT: 3\n};\nconst enumURLParams = {\n\tLAYOUTPARAM: \"layout\",\n\tIAPPSTATEPARAM: \"sap-iapp-state\"\n};\n\ntype RouterState = {\n\tkeys: string[];\n\thash: string;\n\tpreserved?: boolean;\n\tsLayout?: string;\n\tscreenMode: number;\n\tfocusControlId?: string;\n\tsecondaryFocusControlId?: string;\n\tfocusInfo?: {\n\t\tpreventScroll?: boolean;\n\t\ttargetInfo?: unknown;\n\t};\n\tsecondaryFocusInfo?: {\n\t\tpreventScroll?: boolean;\n\t};\n};\n\ntype OtherHistoryAction = { type: \"append\" | \"none\" | \"replace\" };\nexport type BackHistoryAction = { type: \"back\" | \"back-replace\"; steps: number };\ntype HystoryAction = BackHistoryAction | OtherHistoryAction;\n\ntype NavigationGuard = { _guardHash: string; hashTracker: string | undefined; check: (hash: string) => boolean };\n/**\n * Creates a HashGuard object.\n * @param sGuardHash The hash used for the guard.\n * @param [hashTraker] Optional hash tracker used for additional guard checks.\n * @returns The created hash guard.\n */\nfunction createGuardFromHash(sGuardHash: string, hashTraker?: string): NavigationGuard {\n\treturn {\n\t\t_guardHash: sGuardHash.replace(/\\?[^?]*$/, \"\"), // Remove query part\n\t\thashTracker: hashTraker ? hashTraker.replace(/\\?[^?]*$/, \"\") : undefined,\n\t\tcheck: function (sHash: string): boolean {\n\t\t\treturn sHash.indexOf(this._guardHash) === 0 || (this.hashTracker ? sHash.indexOf(this.hashTracker) === 0 : false);\n\t\t}\n\t};\n}\n/**\n * Returns a hash without its iAppState part.\n * @param sHash The hash\n * @returns The hash without the iAppState\n */\nfunction removeAppStateInHash(sHash: string): string {\n\treturn sHash.replace(new RegExp(`[&?]*${enumURLParams.IAPPSTATEPARAM}=[^&]*`), \"\");\n}\n\n@defineUI5Class(\"sap.fe.core.RouterProxy\")\nclass RouterProxy extends BaseObject {\n\tbIsRebuildHistoryRunning = false;\n\n\tbIsComputingTitleHierachy = false;\n\n\tbIsGuardCrossAllowed = false;\n\n\tsIAppStateKey: string | null = null;\n\n\t_oShellServices!: IShellServices;\n\n\tfclEnabled!: boolean;\n\n\t_fnBlockingNavFilter!: Function;\n\n\t_fnHashGuard!: (this: Window, popStateEvent: PopStateEvent) => unknown;\n\n\t_bDisableOnHashChange!: boolean;\n\n\t_bIgnoreRestore!: boolean;\n\n\t_bForceFocus!: boolean;\n\n\t_oRouter!: Router;\n\n\t_oManagedHistory!: RouterState[];\n\n\t_oNavigationGuard!: NavigationGuard | null;\n\n\toResourceBundle?: ResourceBundle;\n\n\t_oRouteMatchSynchronization?: Synchronization;\n\n\t_bActivateRouteMatchSynchro = false;\n\n\t_bApplyRestore = false;\n\n\t_pathMappings: { oldPath: string; newPath: string }[] = [];\n\n\trestoreHistoryTriggered = false;\n\n\troutingHints?: Record<string, { parentOf: string[] }>;\n\n\tappName!: string;\n\n\tappStateUpdating = false;\n\n\tinit(oAppComponent: AppComponent, isfclEnabled: boolean): void {\n\t\t// Save the name of the app (including startup parameters) for rebuilding full hashes later\n\t\toAppComponent\n\t\t\t.getService(\"shellServices\")\n\t\t\t.then(() => this.asyncInit(oAppComponent, isfclEnabled))\n\t\t\t.catch(function (oError: unknown) {\n\t\t\t\tLog.error(\"Cannot retrieve the shell services\", oError as string);\n\t\t\t});\n\t\tthis._fnHashGuard = this.hashGuard.bind(this);\n\t\twindow.addEventListener(\"popstate\", this._fnHashGuard);\n\t\tthis._bDisableOnHashChange = false;\n\t\tthis._bIgnoreRestore = false;\n\t\tthis._bForceFocus = true; // Trigger the focus mechanism for the first view displayed by the app\n\t}\n\n\tasyncInit(oAppComponent: AppComponent, isfclEnabled: boolean): void {\n\t\tthis._oShellServices = oAppComponent.getShellServices();\n\t\tthis.initRaw(oAppComponent.getRouter());\n\t\tthis.routingHints = oAppComponent.getRoutingService().getRoutingHints();\n\t\t// We want to wait until the initial routeMatched is done before doing any navigation\n\t\tthis.waitForRouteMatchBeforeNavigation();\n\n\t\t// Set feLevel=0 for the first Application page in the history\n\t\thistory.replaceState(\n\t\t\tObject.assign(\n\t\t\t\t{\n\t\t\t\t\tfeLevel: 0\n\t\t\t\t},\n\t\t\t\thistory.state\n\t\t\t),\n\t\t\t\"\",\n\t\t\twindow.location as unknown as string\n\t\t);\n\t\tthis.fclEnabled = isfclEnabled;\n\n\t\tthis._fnBlockingNavFilter = this._blockingNavigationFilter.bind(this);\n\t\tthis._oShellServices.registerNavigationFilter(this._fnBlockingNavFilter);\n\t}\n\n\tdestroy(): void {\n\t\tif (this._oShellServices) {\n\t\t\tthis._oShellServices.unregisterNavigationFilter(this._fnBlockingNavFilter);\n\t\t}\n\t\twindow.removeEventListener(\"popstate\", this._fnHashGuard);\n\t}\n\n\t/**\n\t * Adds an iAppState inside a hash (or replaces an existing one).\n\t * @param sHash The hash\n\t * @param sAppStateKey The iAppState to add\n\t * @returns The hash with the app state\n\t */\n\tsetAppStateInHash(sHash: string, sAppStateKey: string): string {\n\t\tlet sNewHash: string;\n\n\t\tif (sHash.includes(enumURLParams.IAPPSTATEPARAM)) {\n\t\t\t// If there's already an iAppState parameter in the hash, replace it\n\t\t\tsNewHash = sHash.replace(\n\t\t\t\tnew RegExp(`${enumURLParams.IAPPSTATEPARAM}=[^&]*`),\n\t\t\t\t`${enumURLParams.IAPPSTATEPARAM}=${sAppStateKey}`\n\t\t\t);\n\t\t} else {\n\t\t\t// Add the iAppState parameter in the hash\n\t\t\tif (!sHash.includes(\"?\")) {\n\t\t\t\tsNewHash = `${sHash}?`;\n\t\t\t} else {\n\t\t\t\tsNewHash = `${sHash}&`;\n\t\t\t}\n\t\t\tsNewHash += `${enumURLParams.IAPPSTATEPARAM}=${sAppStateKey}`;\n\t\t}\n\n\t\treturn sNewHash;\n\t}\n\n\t/**\n\t * Returns the iAppState part from a hash (or null if not found).\n\t * @param sHash The hash\n\t * @returns The iAppState part of the hash\n\t */\n\tfindAppStateInHash(sHash: string): string | null {\n\t\tconst aAppState = sHash.match(new RegExp(`\\\\?.*${enumURLParams.IAPPSTATEPARAM}=([^&]*)`));\n\t\treturn aAppState && aAppState.length > 1 ? aAppState[1] : null;\n\t}\n\n\tprivate getDecodedWindowHash(): string {\n\t\treturn decodeURI(window.location.hash);\n\t}\n\n\t/**\n\t * Raw initialization (for unit tests).\n\t * @param oRouter The router used by this proxy\n\t */\n\tinitRaw(oRouter: Router): void {\n\t\tthis._oRouter = oRouter;\n\t\tthis._oManagedHistory = [];\n\t\tthis._oNavigationGuard = null;\n\n\t\tconst sCurrentAppHash = this.getHash();\n\t\tthis._oManagedHistory.push(this._extractStateFromHash(sCurrentAppHash));\n\n\t\tthis.appName = this.getAppNameFromHash(this.getDecodedWindowHash());\n\n\t\t// Set the iAppState if the initial hash contains one\n\t\tthis.sIAppStateKey = this.findAppStateInHash(sCurrentAppHash);\n\t}\n\n\t/**\n\t * Return the full app-specific hash part from window.location.hash.\n\t *\n\t * Compared to {@link getHash} this function includes sub-routes of nested components.\n\t * @returns The app-specific hash part (i.e., without the shell part), or an empty string if there is none.\n\t */\n\tgetFullHash(): string {\n\t\tconst splitHash = this._oShellServices.splitHash(this.getDecodedWindowHash());\n\n\t\tif (\"appSpecificRoute\" in splitHash) {\n\t\t\treturn splitHash.appSpecificRoute?.replace(/^&\\//, \"\") ?? \"\"; // remove the leading \"&/\"\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tgetHash(): string {\n\t\treturn this._oRouter.getHashChanger().getHash() ?? \"\";\n\t}\n\n\tprotected getAppNameFromHash(hash: string): string {\n\t\tconst splitHash = this._oShellServices?.splitHash(hash) as { shellPart: string; appSpecificRoute: string } | undefined;\n\t\treturn splitHash?.shellPart ?? \"\";\n\t}\n\n\tisFocusForced(): boolean {\n\t\treturn this._bForceFocus;\n\t}\n\n\tsetFocusForced(bForced: boolean): void {\n\t\tthis._bForceFocus = bForced;\n\t}\n\n\t/**\n\t * Resets the internal variable sIAppStateKey.\n\t *\n\t */\n\tremoveIAppStateKey(): void {\n\t\tthis.sIAppStateKey = null;\n\t}\n\n\tsetAppStateUpdating(updatingAppState: boolean): void {\n\t\tthis.appStateUpdating = updatingAppState;\n\t}\n\n\tisAppStateUpdating(): boolean {\n\t\treturn this.appStateUpdating;\n\t}\n\n\tprivate removeRestoreHistoryFlagFromHash(hash: string): string {\n\t\treturn hash.replace(\"restoreHistory=true&\", \"\").replace(/[?&]restoreHistory=true/, \"\");\n\t}\n\n\t/**\n\t * Navigates to a specific hash.\n\t * @param sHash Hash to be navigated to\n\t * @param bPreserveHistory If set to true, non-ancestor entries in history will be retained\n\t * @param bDisablePreservationCache If set to true, cache preservation mechanism is disabled for the current navigation\n\t * @param bForceFocus If set to true, the logic to set the focus once the navigation is finalized will be triggered (onPageReady)\n\t * @param bPreserveShellBackNavigationHandler If not set to false, the back navigation is set to undefined\n\t * @returns Promise (resolved when the navigation is finalized) that returns 'true' if a navigation took place, 'false' if the navigation didn't happen\n\t */\n\tasync navToHash(\n\t\tsHash: string,\n\t\tbPreserveHistory?: boolean,\n\t\tbDisablePreservationCache?: boolean,\n\t\tbForceFocus?: boolean,\n\t\tbPreserveShellBackNavigationHandler?: boolean\n\t): Promise<boolean> {\n\t\tsHash = sHash.startsWith(\"/\") ? sHash.substring(1) : sHash;\n\t\tif (bPreserveShellBackNavigationHandler !== false) {\n\t\t\tawait this._oShellServices.setBackNavigation();\n\t\t}\n\t\tsHash = this.removeRestoreHistoryFlagFromHash(sHash);\n\t\tif (this._oRouteMatchSynchronization) {\n\t\t\treturn this._oRouteMatchSynchronization.waitFor().then(async () => {\n\t\t\t\tthis._oRouteMatchSynchronization = undefined;\n\t\t\t\treturn this._internalNavToHash(sHash, bPreserveHistory, bDisablePreservationCache, bForceFocus);\n\t\t\t});\n\t\t} else {\n\t\t\tif (this._bActivateRouteMatchSynchro) {\n\t\t\t\tthis.waitForRouteMatchBeforeNavigation();\n\t\t\t}\n\t\t\treturn this._internalNavToHash(sHash, bPreserveHistory, bDisablePreservationCache, bForceFocus);\n\t\t}\n\t}\n\n\tasync _internalNavToHash(\n\t\tsHash: string,\n\t\tbPreserveHistory?: boolean,\n\t\tbDisablePreservationCache?: boolean,\n\t\tbForceFocus?: boolean\n\t): Promise<boolean> {\n\t\t// Add the app state in the hash if needed\n\t\tif (this.fclEnabled && this.sIAppStateKey && !this.findAppStateInHash(sHash)) {\n\t\t\tsHash = this.setAppStateInHash(sHash, this.sIAppStateKey);\n\t\t}\n\n\t\tif (!this.checkHashWithGuard(sHash)) {\n\t\t\tif (!this.oResourceBundle) {\n\t\t\t\tthis.oResourceBundle = Library.getResourceBundleFor(\"sap.fe.core\")!;\n\t\t\t}\n\n\t\t\t// We have to use a confirm here for UI consistency reasons, as with some scenarios\n\t\t\t// in the EditFlow we rely on a UI5 mechanism that displays a confirm dialog.\n\t\t\t// eslint-disable-next-line no-alert\n\t\t\tif (!confirm(this.oResourceBundle.getText(\"C_ROUTER_PROXY_SAPFE_EXIT_NOTSAVED_MESSAGE\"))) {\n\t\t\t\t// The user clicked on Cancel --> cancel navigation\n\t\t\t\treturn Promise.resolve(false);\n\t\t\t}\n\t\t\tthis.bIsGuardCrossAllowed = true;\n\t\t}\n\n\t\t// In case the navigation will cause a new view to be displayed, we force the focus\n\t\t// I.e. if the keys for the hash we're navigating to is a superset of the current hash keys.\n\t\tconst oNewState = this._extractStateFromHash(sHash);\n\t\tif (!this._bForceFocus) {\n\t\t\t// If the focus was already forced, keep it\n\t\t\tconst aCurrentHashKeys = RouterProxy.extractEntitySetsFromHash(this.getHash());\n\t\t\tthis._bForceFocus =\n\t\t\t\tbForceFocus ||\n\t\t\t\t(aCurrentHashKeys.length < oNewState.keys.length &&\n\t\t\t\t\taCurrentHashKeys.every(function (key: string, index: number) {\n\t\t\t\t\t\treturn key === oNewState.keys[index];\n\t\t\t\t\t}));\n\t\t}\n\n\t\tconst oHistoryAction = this._pushNewState(oNewState, false, bPreserveHistory, bDisablePreservationCache);\n\t\tthis.storeFocusInfoForCurrentHash();\n\n\t\treturn this._rebuildBrowserHistory(oHistoryAction, false);\n\t}\n\n\t/**\n\t * Clears browser history if entries have been added without using the RouterProxy.\n\t * Updates the internal history accordingly.\n\t * @returns Promise that is resolved once the history is rebuilt\n\t */\n\tasync restoreHistory(): Promise<void | boolean> {\n\t\tif (this._bApplyRestore) {\n\t\t\tthis._bApplyRestore = false;\n\t\t\tlet sTargetHash = this.getHash();\n\t\t\tsTargetHash = this.removeRestoreHistoryFlagFromHash(sTargetHash);\n\t\t\tconst oNewState = this._extractStateFromHash(sTargetHash);\n\n\t\t\tconst oHistoryAction = this._pushNewState(oNewState, true, false, true);\n\n\t\t\tthis.restoreHistoryTriggered = true;\n\t\t\treturn this._rebuildBrowserHistory(oHistoryAction, true);\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t * Checks if RestoreHistory has been triggered on the RouterProxy.\n\t * @returns True if it has been triggered\n\t */\n\tcheckRestoreHistoryWasTriggered(): boolean {\n\t\treturn this.restoreHistoryTriggered;\n\t}\n\n\t/**\n\t * Resets the flag that says if RestoreHistory has been triggered on the RouterProxy.\n\t */\n\tresetRestoreHistoryFlag(): void {\n\t\tthis.restoreHistoryTriggered = false;\n\t}\n\n\t/**\n\t * Navigates back in the history.\n\t * @returns Promise that is resolved when the navigation is finalized\n\t */\n\tasync navBack(): Promise<void | boolean> {\n\t\tconst sCurrentHash = this.getHash();\n\t\tlet sPreviousHash;\n\n\t\t// Look for the current hash in the managed history\n\t\tfor (let i = this._oManagedHistory.length - 1; i > 0; i--) {\n\t\t\tif (this._oManagedHistory[i].hash === sCurrentHash) {\n\t\t\t\tsPreviousHash = this._oManagedHistory[i - 1].hash;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sPreviousHash) {\n\t\t\treturn this.navToHash(sPreviousHash);\n\t\t} else {\n\t\t\t// We couldn't find a previous hash in history\n\t\t\t// This can happen when navigating from a transient hash in a create app, and\n\t\t\t// in that case history.back would go back to the FLP\n\t\t\twindow.history.back();\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t * Navigates to a route with parameters.\n\t * @param sRouteName The route name to be navigated to\n\t * @param oParameters Parameters for the navigation\n\t * @param oParameters.noPreservationCache\n\t * @param oParameters.bIsStickyMode\n\t * @returns Promise that is resolved when the navigation is finalized\n\t */\n\tasync navTo(sRouteName: string, oParameters?: { noPreservationCache?: boolean; bIsStickyMode?: boolean }): Promise<boolean> {\n\t\tconst sHash = this._oRouter.getURL(sRouteName, oParameters);\n\t\treturn this.navToHash(sHash!, false, oParameters?.noPreservationCache, false, !oParameters?.bIsStickyMode);\n\t}\n\n\t/**\n\t * Exits the current app by navigating back\n\t * to the previous app (if any) or the FLP.\n\t * @returns Promise that is resolved when we exit the app\n\t */\n\texitFromApp(): void {\n\t\treturn this._oShellServices.backToPreviousApp();\n\t}\n\n\t/**\n\t * Checks whether a given hash can have an impact on the current state\n\t * i.e. if the hash is equal, compatible or an ancestor of the current state.\n\t * @param sHash `true` if there is an impact\n\t * @returns If there is an impact\n\t */\n\tisCurrentStateImpactedBy(sHash: string): boolean {\n\t\tif (sHash[0] === \"/\") {\n\t\t\tsHash = sHash.substring(1);\n\t\t}\n\t\tconst oLocalGuard = createGuardFromHash(sHash);\n\t\treturn oLocalGuard.check(this.getHash());\n\t}\n\n\t/**\n\t * Checks if a navigation is currently being processed.\n\t * @returns `false` if a navigation has been triggered in the RouterProxy and is not yet finalized\n\t */\n\tisNavigationFinalized(): boolean {\n\t\treturn !this.bIsRebuildHistoryRunning;\n\t}\n\n\t/**\n\t * Sets the last state as a guard.\n\t * Each future navigation will be checked against this guard, and a confirmation dialog will\n\t * be displayed before the navigation goes to an ancestor of the guard.\n\t * @param sHash The hash for the guard.\n\t * @param [hashTraker] Optional hash tracker used for additional guard checks.\n\t */\n\tsetNavigationGuard(sHash: string, hashTraker?: string): void {\n\t\tthis._oNavigationGuard = createGuardFromHash(sHash, hashTraker);\n\t\tthis.bIsGuardCrossAllowed = false;\n\t}\n\n\t/**\n\t * Disables the navigation guard.\n\t */\n\tdiscardNavigationGuard(): void {\n\t\tthis._oNavigationGuard = null;\n\t}\n\n\t/**\n\t * Checks for the availability of the navigation guard.\n\t * @returns `true` if navigating guard is available\n\t */\n\thasNavigationGuard(): boolean {\n\t\treturn this._oNavigationGuard !== null;\n\t}\n\n\t/**\n\t * Tests a hash against the navigation guard.\n\t * @param sHash The hash to be tested\n\t * @returns `true` if navigating to the hash doesn't cross the guard\n\t */\n\tcheckHashWithGuard(sHash: string): boolean {\n\t\treturn this._oNavigationGuard === null || this._oNavigationGuard.check(sHash);\n\t}\n\n\t/**\n\t * Checks if the user allowed the navigation guard to be crossed.\n\t * @returns `true` if crossing the guard has been allowed by the user\n\t */\n\tisGuardCrossAllowedByUser(): boolean {\n\t\treturn this.bIsGuardCrossAllowed;\n\t}\n\n\t/**\n\t * Activates the synchronization for routeMatchedEvent.\n\t * The next NavToHash call will create a Synchronization object that will be resolved\n\t * by the corresponding onRouteMatched event, preventing another NavToHash to happen in parallel.\n\t */\n\tactivateRouteMatchSynchronization(): void {\n\t\tthis._bActivateRouteMatchSynchro = true;\n\t}\n\n\t/**\n\t * Resolve the routeMatch synchronization object, unlocking potential pending NavToHash calls.\n\t */\n\tresolveRouteMatch(): void {\n\t\tif (this._oRouteMatchSynchronization) {\n\t\t\tthis._oRouteMatchSynchronization.resolve();\n\t\t}\n\t}\n\n\t/**\n\t * Makes sure no navigation can happen before a routeMatch happened.\n\t */\n\twaitForRouteMatchBeforeNavigation(): void {\n\t\tthis._oRouteMatchSynchronization = new Synchronization();\n\t\tthis._bActivateRouteMatchSynchro = false;\n\t}\n\n\tstatic extractEntitySetsFromHash(sHash: string | undefined): string[] {\n\t\tif (sHash === undefined) {\n\t\t\tsHash = \"\";\n\t\t}\n\t\tconst sHashNoParams = sHash.split(\"?\")[0]; // remove params\n\t\tconst aTokens = sHashNoParams.split(\"/\");\n\t\tconst names: string[] = [];\n\n\t\taTokens.forEach((sToken) => {\n\t\t\tif (sToken.length) {\n\t\t\t\tnames.push(sToken.split(\"(\")[0]);\n\t\t\t}\n\t\t});\n\n\t\treturn names;\n\t}\n\n\t/**\n\t * Builds a state from a hash.\n\t * @param sHash The hash to be used as entry\n\t * @returns The state\n\t */\n\t_extractStateFromHash(sHash: string): RouterState {\n\t\tif (sHash === undefined) {\n\t\t\tsHash = \"\";\n\t\t}\n\n\t\tconst oState: RouterState = {\n\t\t\tkeys: RouterProxy.extractEntitySetsFromHash(sHash),\n\t\t\thash: sHash,\n\t\t\tscreenMode: 0 // will be updated in a sec\n\t\t};\n\n\t\t// Retrieve layout (if any)\n\t\tconst aLayout = sHash.match(new RegExp(`\\\\?.*${enumURLParams.LAYOUTPARAM}=([^&]*)`));\n\t\toState.sLayout = aLayout && aLayout.length > 1 ? aLayout[1] : undefined;\n\t\tif (oState.sLayout === \"MidColumnFullScreen\") {\n\t\t\toState.screenMode = 1;\n\t\t} else if (oState.sLayout === \"EndColumnFullScreen\") {\n\t\t\toState.screenMode = 2;\n\t\t} else {\n\t\t\toState.screenMode = 0;\n\t\t}\n\t\treturn oState;\n\t}\n\n\t/**\n\t * Adds a new state into the internal history structure.\n\t * Makes sure this new state is added after an ancestor.\n\t * Also sets the iAppState key in the whole history.\n\t * @param oNewState The new state to be added\n\t * @param bRebuildOnly `true` if we're rebuilding the history after a shell menu navigation\n\t * @param bPreserveHistory If set to true, non-ancestor entries in history will be retained\n\t * @param bDisableHistoryPreservation Disable the mechanism to retained marked entries in cache\n\t * @returns The new state\n\t * @final\n\t */\n\t_pushNewState(\n\t\toNewState: RouterState,\n\t\tbRebuildOnly: boolean,\n\t\tbPreserveHistory?: boolean,\n\t\tbDisableHistoryPreservation?: boolean\n\t): HystoryAction {\n\t\tconst sCurrentHash = this.removeRestoreHistoryFlagFromHash(this.getHash());\n\t\tlet lastIndex = this._oManagedHistory.length - 1;\n\t\tlet iPopCount = bRebuildOnly ? 1 : 0;\n\n\t\t// 1. Do some cleanup in the managed history : in case the user has navigated back in the browser history, we need to remove\n\t\t// the states ahead in history and make sure the top state corresponds to the current page\n\t\t// We don't do that when restoring the history, as the current state has been added on top of the browser history\n\t\t// and is not reflected in the managed history\n\t\tif (!bRebuildOnly) {\n\t\t\twhile (lastIndex >= 0 && this._oManagedHistory[lastIndex].hash !== sCurrentHash) {\n\t\t\t\tthis._oManagedHistory.pop();\n\t\t\t\tlastIndex--;\n\t\t\t}\n\n\t\t\tif (this._oManagedHistory.length === 0) {\n\t\t\t\t// We couldn't find the current location in the history. This can happen if a browser reload\n\t\t\t\t// happened, causing a reinitialization of the managed history.\n\t\t\t\t// In that case, we use the current location as the new starting point in the managed history\n\t\t\t\tthis._oManagedHistory.push(this._extractStateFromHash(sCurrentHash));\n\t\t\t\thistory.replaceState(Object.assign({ feLevel: 0 }, history.state), \"\");\n\t\t\t}\n\t\t}\n\n\t\t// 2. Mark the top state as preserved if required\n\t\tif (bPreserveHistory && !bDisableHistoryPreservation) {\n\t\t\tthis._oManagedHistory[this._oManagedHistory.length - 1].preserved = true;\n\t\t}\n\n\t\t// 3. Then pop all states until we find an ancestor of the new state, or we find a state that need to be preserved\n\t\tlet oLastRemovedItem;\n\t\twhile (this._oManagedHistory.length > 0) {\n\t\t\tconst oTopState = this._oManagedHistory[this._oManagedHistory.length - 1];\n\t\t\tif (\n\t\t\t\t(bDisableHistoryPreservation || !oTopState.preserved) &&\n\t\t\t\tthis._compareCacheStates(oTopState, oNewState) !== enumState.ANCESTOR\n\t\t\t) {\n\t\t\t\t// The top state is not an ancestor of oNewState and is not preserved --> we can pop it\n\t\t\t\toLastRemovedItem = this._oManagedHistory.pop();\n\t\t\t\tiPopCount++;\n\t\t\t} else if (oTopState.preserved && removeAppStateInHash(oTopState.hash) === removeAppStateInHash(oNewState.hash)) {\n\t\t\t\t// We try to add a state that is already in cache (due to preserved flag) but with a different iapp-state\n\t\t\t\t// --> we should delete the previous entry (it will be later replaced by the new one) and stop popping\n\t\t\t\toLastRemovedItem = this._oManagedHistory.pop();\n\t\t\t\tiPopCount++;\n\t\t\t\toNewState.preserved = true;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tbreak; // Ancestor or preserved state found --> we stop popping out states\n\t\t\t}\n\t\t}\n\n\t\t// 4. iAppState management\n\t\tthis.sIAppStateKey = this.findAppStateInHash(oNewState.hash);\n\t\tif (!this.fclEnabled && oLastRemovedItem) {\n\t\t\tconst sPreviousIAppStateKey = this.findAppStateInHash(oLastRemovedItem.hash);\n\t\t\tconst oComparisonStateResult = this._compareCacheStates(oLastRemovedItem, oNewState);\n\t\t\t// if current state doesn't contain a i-appstate and this state should replace a state containing a iAppState\n\t\t\t// then the previous iAppState is preserved\n\t\t\tif (\n\t\t\t\t!this.sIAppStateKey &&\n\t\t\t\tsPreviousIAppStateKey &&\n\t\t\t\t(oComparisonStateResult === enumState.EQUAL || oComparisonStateResult === enumState.COMPATIBLE)\n\t\t\t) {\n\t\t\t\toNewState.hash = this.setAppStateInHash(oNewState.hash, sPreviousIAppStateKey);\n\t\t\t}\n\t\t}\n\n\t\t// 5. Now we can push the state at the top of the internal history\n\t\tconst bHasSameHash = oLastRemovedItem && oNewState.hash === oLastRemovedItem.hash;\n\t\tif (this._oManagedHistory.length === 0 || this._oManagedHistory[this._oManagedHistory.length - 1].hash !== oNewState.hash) {\n\t\t\tthis._oManagedHistory.push(oNewState);\n\t\t\tif (oLastRemovedItem && removeAppStateInHash(oLastRemovedItem.hash) === removeAppStateInHash(oNewState.hash)) {\n\t\t\t\toNewState.focusControlId = oLastRemovedItem.focusControlId;\n\t\t\t\toNewState.secondaryFocusControlId = oLastRemovedItem.secondaryFocusControlId;\n\t\t\t\toNewState.focusInfo = oLastRemovedItem.focusInfo;\n\t\t\t\toNewState.secondaryFocusInfo = oLastRemovedItem.secondaryFocusInfo;\n\t\t\t}\n\t\t}\n\n\t\t// 6. Determine which actions to do on the history\n\t\tif (iPopCount === 0) {\n\t\t\t// No state was popped --> append\n\t\t\treturn { type: \"append\" };\n\t\t} else if (iPopCount === 1) {\n\t\t\t// Only 1 state was popped --> replace current hash unless hash is the same (then nothing to do)\n\t\t\treturn bHasSameHash ? { type: \"none\" } : { type: \"replace\" };\n\t\t} else {\n\t\t\t// More than 1 state was popped --> go bakc in history and replace hash if necessary\n\t\t\treturn bHasSameHash ? { type: \"back\", steps: iPopCount - 1 } : { type: \"back-replace\", steps: iPopCount - 1 };\n\t\t}\n\t}\n\n\t_blockingNavigationFilter(): \"Custom\" | \"Continue\" {\n\t\treturn this._bDisableOnHashChange ? \"Custom\" : \"Continue\";\n\t}\n\n\t/**\n\t * Disable the routing by calling the router stop method.\n\t * @final\n\t */\n\t_disableEventOnHashChange(): void {\n\t\tthis._bDisableOnHashChange = true;\n\t\tthis._oRouter.stop();\n\t}\n\n\t/**\n\t * Enable the routing by calling the router initialize method.\n\t * @param [bIgnoreCurrentHash] Ignore the last hash event triggered before the router has initialized\n\t * @final\n\t */\n\t_enableEventOnHashChange(bIgnoreCurrentHash: boolean | undefined): void {\n\t\tthis._bDisableOnHashChange = false;\n\t\tthis._oRouter.initialize(bIgnoreCurrentHash);\n\t}\n\n\t/**\n\t * Synchronizes the browser history with the internal history of the routerProxy, and triggers a navigation if needed.\n\t * @param oHistoryAction Specifies the navigation action to be performed\n\t * @param bRebuildOnly `true` if internal history is currently being rebuilt\n\t * @returns Promise (resolved when the navigation is finalized) that returns 'true' if a navigation took place, 'false' if the navigation didn't happen\n\t * @final\n\t */\n\tasync _rebuildBrowserHistory(oHistoryAction: HystoryAction, bRebuildOnly: boolean): Promise<boolean> {\n\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\tconst that = this;\n\t\treturn new Promise((resolve) => {\n\t\t\tthis.bIsRebuildHistoryRunning = true;\n\t\t\tconst oTargetState = this._oManagedHistory[this._oManagedHistory.length - 1],\n\t\t\t\tnewLevel = this._oManagedHistory.length - 1;\n\n\t\t\tfunction replaceAsync(): void {\n\t\t\t\tif (!bRebuildOnly) {\n\t\t\t\t\tthat._enableEventOnHashChange(true);\n\t\t\t\t}\n\n\t\t\t\t(that._oRouter.getHashChanger().replaceHash as Function)(oTargetState.hash);\n\t\t\t\thistory.replaceState(Object.assign({ feLevel: newLevel }, history.state), \"\");\n\n\t\t\t\tif (bRebuildOnly) {\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t// Timeout to let 'hashchange' event be processed before by the HashChanger, so that\n\t\t\t\t\t\t// onRouteMatched notification isn't raised\n\t\t\t\t\t\tthat._enableEventOnHashChange(true);\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\n\t\t\t\tthat.bIsRebuildHistoryRunning = false;\n\t\t\t\tresolve(true); // a navigation occurred\n\t\t\t}\n\n\t\t\t// Async callbacks when navigating back, in order to let all notifications and events get processed\n\t\t\tfunction backReplaceAsync(): void {\n\t\t\t\twindow.removeEventListener(\"popstate\", backReplaceAsync);\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t// Timeout to let 'hashchange' event be processed before by the HashChanger\n\t\t\t\t\treplaceAsync();\n\t\t\t\t}, 0);\n\t\t\t}\n\n\t\t\tfunction backAsync(): void {\n\t\t\t\twindow.removeEventListener(\"popstate\", backAsync);\n\t\t\t\tthat.bIsRebuildHistoryRunning = false;\n\t\t\t\tresolve(true); // a navigation occurred\n\t\t\t}\n\n\t\t\tthat._bIgnoreRestore = true;\n\n\t\t\tswitch (oHistoryAction.type) {\n\t\t\t\tcase \"replace\":\n\t\t\t\t\tconst focusInfo = history.state?.focusInfo;\n\t\t\t\t\t(that._oRouter.getHashChanger().replaceHash as Function)(oTargetState.hash);\n\t\t\t\t\thistory.replaceState(\n\t\t\t\t\t\tObject.assign(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfeLevel: newLevel,\n\t\t\t\t\t\t\t\tfocusInfo: focusInfo\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\thistory.state\n\t\t\t\t\t\t),\n\t\t\t\t\t\t\"\"\n\t\t\t\t\t);\n\t\t\t\t\tthat.bIsRebuildHistoryRunning = false;\n\t\t\t\t\tresolve(true); // a navigation occurred\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"append\":\n\t\t\t\t\tthat._oRouter.getHashChanger().setHash(oTargetState.hash);\n\t\t\t\t\thistory.replaceState(Object.assign({ feLevel: newLevel }, history.state), \"\");\n\t\t\t\t\tthat.bIsRebuildHistoryRunning = false;\n\t\t\t\t\tresolve(true); // a navigation occurred\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"back\":\n\t\t\t\t\twindow.addEventListener(\"popstate\", backAsync);\n\t\t\t\t\thistory.go(-oHistoryAction.steps);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"back-replace\":\n\t\t\t\t\tthis._disableEventOnHashChange();\n\t\t\t\t\twindow.addEventListener(\"popstate\", backReplaceAsync);\n\t\t\t\t\thistory.go(-oHistoryAction.steps);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// No navigation\n\t\t\t\t\tthis.bIsRebuildHistoryRunning = false;\n\t\t\t\t\tresolve(false); // no navigation --> resolve to false\n\t\t\t}\n\t\t});\n\t}\n\n\tgetLastHistoryEntry(): RouterState {\n\t\treturn this._oManagedHistory[this._oManagedHistory.length - 1];\n\t}\n\n\tsetPathMapping(mappings: { oldPath: string; newPath: string }[]): void {\n\t\tthis._pathMappings = mappings.filter((mapping) => {\n\t\t\treturn mapping.oldPath !== mapping.newPath;\n\t\t});\n\t}\n\n\thashGuard(): void {\n\t\tlet sHash = this.getDecodedWindowHash();\n\t\tconst currentAppName = this.getAppNameFromHash(sHash);\n\t\tif (currentAppName != this.appName) {\n\t\t\t// When doing external navigation in another window, the current window location is temporarily modified with the URL of the target app\n\t\t\t// In this case, we don't want to update the internally managed history, so we simply do nothing\n\t\t\treturn;\n\t\t}\n\n\t\tif (sHash.includes(\"restoreHistory=true\")) {\n\t\t\tthis._bApplyRestore = true;\n\t\t} else if (!this.bIsRebuildHistoryRunning && this._oRouter.isInitialized()) {\n\t\t\t// Check if the hash needs to be changed (this happens in FCL when switching b/w edit and read-only with 3 columns open)\n\t\t\tconst mapping = this._pathMappings.find((m) => {\n\t\t\t\treturn sHash.includes(m.oldPath);\n\t\t\t});\n\t\t\tif (mapping) {\n\t\t\t\t// Replace the current hash\n\t\t\t\tsHash = sHash.replace(mapping.oldPath, mapping.newPath);\n\t\t\t\thistory.replaceState(Object.assign({}, history.state), \"\", encodeURI(sHash));\n\t\t\t}\n\n\t\t\tconst aHashSplit = sHash.split(\"&/\");\n\t\t\tconst sAppHash = aHashSplit[1] ? aHashSplit[1] : \"\";\n\t\t\tif (this.checkHashWithGuard(sAppHash)) {\n\t\t\t\tconst oNewState = this._extractStateFromHash(sAppHash);\n\t\t\t\tthis._pushNewState(oNewState, false, false, this.isAppStateUpdating() ? false : true);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Compares 2 states.\n\t * @param {object} oState1\n\t * @param {object} oState2\n\t * @returns {number} The result of the comparison:\n\t *        - enumState.EQUAL if oState1 and oState2 are equal\n\t *        - enumState.COMPATIBLE if oState1 and oState2 are compatible\n\t *        - enumState.ANCESTOR if oState1 is an ancestor of oState2\n\t *        - enumState.DIFFERENT if the 2 states are different\n\t */\n\n\t_compareCacheStates(oState1: RouterState, oState2: RouterState): number {\n\t\t// First compare object keys\n\t\tif (oState1.keys.length > oState2.keys.length) {\n\t\t\treturn enumState.DIFFERENT;\n\t\t}\n\t\tlet equal = true;\n\t\tlet index;\n\n\t\tfor (index = 0; equal && index < oState1.keys.length; index++) {\n\t\t\tif (oState1.keys[index] !== oState2.keys[index]) {\n\t\t\t\tequal = false;\n\t\t\t}\n\t\t}\n\n\t\tif (!equal) {\n\t\t\t// Check routingHints\n\t\t\tif (oState1.keys.length === 1 && oState2.keys.length === 1 && this.routingHints?.[oState1.keys[0]]) {\n\t\t\t\tif (this.routingHints[oState1.keys[0]].parentOf && this.routingHints[oState1.keys[0]].parentOf.includes(oState2.keys[0])) {\n\t\t\t\t\treturn enumState.ANCESTOR;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Some objects keys are different\n\t\t\treturn enumState.DIFFERENT;\n\t\t}\n\n\t\t// All keys from oState1 are in oState2 --> check if ancestor\n\t\tif (oState1.keys.length < oState2.keys.length || oState1.screenMode < oState2.screenMode) {\n\t\t\treturn enumState.ANCESTOR;\n\t\t}\n\t\tif (oState1.screenMode > oState2.screenMode) {\n\t\t\treturn enumState.DIFFERENT; // Not sure this case can happen...\n\t\t}\n\n\t\t// At this stage, the 2 states have the same object keys (in the same order) and same screenmode\n\t\t// They can be either compatible or equal\n\t\treturn oState1.sLayout === oState2.sLayout ? enumState.EQUAL : enumState.COMPATIBLE;\n\t}\n\n\t/**\n\t * Split the app-specific route at the \"&/\" separator.\n\t *\n\t * The app-specific route consists of one or more segments separated by \"&/\".\n\t * @example\n\t * splitAppSpecificRoute(\"&/Entity('abc')/NextEntity('xyz')\");\n\t * // [\"Entity('abc')/NextEntity('xyz')\"]\n\t *\n\t * splitAppSpecificRoute(\"&/Entity('abc')/NextEntity('xyz')&/Prefix/NestedRoute\");\n\t * // [\"Entity('abc')/NextEntity('xyz')\", \"Prefix/NestedRoute\"]\n\t * @param appSpecificRoute\tThe app-specific route.\n\t * @returns An array of app-specific route segments.\n\t */\n\tprivate static splitAppSpecificRoute(appSpecificRoute: string | undefined): string[] {\n\t\tconst routeSplit = appSpecificRoute?.split(\"&/\") ?? [];\n\t\tif (!routeSplit[0]) {\n\t\t\trouteSplit.shift(); // remove the leading empty segment (the app-specific route starts with \"&/\")\n\t\t}\n\t\treturn routeSplit;\n\t}\n\n\t/**\n\t * Checks if back exits the present guard set.\n\t * @returns `true` if back exits the guard\n\t */\n\tcheckIfBackIsOutOfGuard(): boolean {\n\t\t// We use window.location.hash instead of HashChanger.getInstance().getHash() because the latter\n\t\t// replaces characters in the URL (e.g. %24 replaced by $) and it causes issues when comparing\n\t\t// with the URLs in the managed history\n\t\tconst splitHash = this.getFullHash();\n\n\t\tconst segments = RouterProxy.splitAppSpecificRoute(splitHash);\n\n\t\tif (segments.length > 1) {\n\t\t\t// there is a nested route involved -> assume we are still inside the guard\n\t\t\treturn false;\n\t\t}\n\n\t\tconst hash = segments[0] ?? \"\";\n\n\t\tlet previousHash;\n\t\tif (this._oNavigationGuard) {\n\t\t\tfor (let i = this._oManagedHistory.length - 1; i > 0; i--) {\n\t\t\t\tif (this._oManagedHistory[i].hash === hash) {\n\t\t\t\t\tpreviousHash = this._oManagedHistory[i - 1].hash;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn !previousHash || !this.checkHashWithGuard(previousHash);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks if a back navigation will exit the app.\n\t * @returns True if back exits the app\n\t */\n\tcheckIfBackExitsApp(): boolean {\n\t\tconst splitHash = this.getFullHash();\n\n\t\tconst segments = RouterProxy.splitAppSpecificRoute(splitHash);\n\n\t\tif (segments.length > 1) {\n\t\t\t// there is a nested route involved -> assume we are still inside the app\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the current hash is the first one in the history, then a navback will exit the app\n\t\tconst hash = segments[0] ?? \"\";\n\t\treturn this._oManagedHistory.length > 0 && this._oManagedHistory[0].hash === hash;\n\t}\n\n\t/**\n\t * Checks if the last 2 entries in the history share the same context.\n\t * @returns `true` if they share the same context.\n\t */\n\tcheckIfBackHasSameContext(): boolean {\n\t\tif (this._oManagedHistory.length < 2) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst oCurrentState = this._oManagedHistory[this._oManagedHistory.length - 1];\n\t\tconst oPreviousState = this._oManagedHistory[this._oManagedHistory.length - 2];\n\n\t\treturn oCurrentState.hash.split(\"?\")[0] === oPreviousState.hash.split(\"?\")[0];\n\t}\n\n\t/**\n\t * Restores the focus for the current hash, if we can find it in the history.\n\t * @returns True if focus was set, false otherwise.\n\t */\n\trestoreFocusForCurrentHash(): boolean {\n\t\tconst currentHash = removeAppStateInHash(this.getHash());\n\t\tconst stateForHash = this._oManagedHistory.find((state) => {\n\t\t\treturn removeAppStateInHash(state.hash) === currentHash;\n\t\t});\n\n\t\tlet focusApplied = false;\n\t\tif (stateForHash?.focusControlId) {\n\t\t\tlet focusControl = Element.getElementById(stateForHash.focusControlId);\n\t\t\tlet focusInfo = stateForHash.focusInfo;\n\t\t\tlet useSecondary = false;\n\t\t\tif ((!focusControl || !focusControl.getFocusDomRef()) && stateForHash.secondaryFocusControlId) {\n\t\t\t\t// The control for focus is either not found or is not displayed on screen (no focusDomRef)\n\t\t\t\t// --> try the secondary control if there's one\n\t\t\t\tfocusControl = Element.getElementById(stateForHash.secondaryFocusControlId);\n\t\t\t\tfocusInfo = stateForHash.secondaryFocusInfo;\n\t\t\t\tuseSecondary = true;\n\t\t\t}\n\t\t\tif (\n\t\t\t\t// if the control is a busy table, we don't want to focus it\n\t\t\t\t// tables have their own handling to restore focus, so we don't want to interfere with that\n\t\t\t\t// unless the table was a secondary control, where we want to focus on it anyway\n\t\t\t\tfocusControl?.getParent()?.isA<Table>(\"sap.ui.mdc.Table\") &&\n\t\t\t\t(focusControl as MTable | UITable).getBusy() &&\n\t\t\t\t!useSecondary\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfocusControl?.focus(focusInfo);\n\t\t\tfocusApplied = focusControl !== undefined;\n\t\t}\n\n\t\treturn focusApplied;\n\t}\n\n\t/**\n\t * Stores the ID of the currently focused control in the history for the current hash.\n\t *\n\t */\n\tprivate storeFocusInfoForCurrentHash(): void {\n\t\tconst currentHash = removeAppStateInHash(this.getHash());\n\t\tconst stateForHash = this._oManagedHistory.find((state) => {\n\t\t\treturn removeAppStateInHash(state.hash) === currentHash;\n\t\t});\n\t\tif (stateForHash) {\n\t\t\tconst focusControl = Element.getActiveElement();\n\t\t\tstateForHash.focusControlId = focusControl?.getId();\n\t\t\tif (focusControl) {\n\t\t\t\t// The secondary focus control is the parent table if there's one\n\t\t\t\tlet parentTable = focusControl.getParent();\n\t\t\t\twhile (parentTable && !parentTable.isA<UITable>(\"sap.ui.table.Table\") && !parentTable.isA<MTable>(\"sap.m.Table\")) {\n\t\t\t\t\tparentTable = parentTable.getParent();\n\t\t\t\t}\n\t\t\t\tstateForHash.secondaryFocusControlId = parentTable?.getId();\n\t\t\t\tstateForHash.secondaryFocusInfo = { preventScroll: true };\n\t\t\t}\n\t\t\tstateForHash.focusInfo = focusControl?.getFocusInfo();\n\t\t}\n\t}\n\n\t/**\n\t * Finds a layout value for a hash in the history.\n\t * @param hash The hash to look for in the history.\n\t * @returns A layout value if it could be found, undefined otherwise.\n\t */\n\tfindLayoutForHash(hash: string): string | undefined {\n\t\tif (!this.fclEnabled) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Remove all query parameters from the hash\n\t\tconst hashNoParam = hash.split(\"?\")[0];\n\n\t\t// Look for the state backwards, so that we find the last state in the history (e.g. if we have 2 states with the same hash but 2 different layouts)\n\t\tlet targetState: RouterState | undefined;\n\t\tfor (let index = this._oManagedHistory.length - 1; index >= 0 && targetState === undefined; index--) {\n\t\t\tif (this._oManagedHistory[index].hash.split(\"?\")[0] === hashNoParam) {\n\t\t\t\ttargetState = this._oManagedHistory[index];\n\t\t\t}\n\t\t}\n\n\t\treturn targetState?.sLayout;\n\t}\n}\n\nexport default RouterProxy;\n"],"mappings":"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","ignoreList":[]}