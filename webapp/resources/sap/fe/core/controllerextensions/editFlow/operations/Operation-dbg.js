/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 *      (c) Copyright 2009-2025 SAP SE. All rights reserved
 */
sap.ui.define(["sap/fe/base/BindingToolkit", "sap/fe/core/controls/Any", "sap/fe/core/helpers/TypeGuards", "sap/fe/core/library", "sap/fe/core/templating/ActionHelper", "sap/m/MessageBox", "../../../converters/MetaModelConverter", "../../../helpers/ResourceModelHelper", "./ODataOperation", "./OperationMessage", "./OperationParameters", "./actionHelper"], function (BindingToolkit, Any, TypeGuards, FELibrary, ActionHelper, MessageBox, MetaModelConverter, ResourceModelHelper, ODataOperation, OperationMessage, OperationParameters, actionHelper) {
  "use strict";

  var _exports = {};
  var getInvolvedDataModelObjects = MetaModelConverter.getInvolvedDataModelObjects;
  var convertTypes = MetaModelConverter.convertTypes;
  var getIsActionCriticalExpression = ActionHelper.getIsActionCriticalExpression;
  var isRejected = TypeGuards.isRejected;
  var isConstant = BindingToolkit.isConstant;
  var compileExpression = BindingToolkit.compileExpression;
  var compileConstant = BindingToolkit.compileConstant;
  const InvocationGrouping = FELibrary.InvocationGrouping;
  let Operation = /*#__PURE__*/function () {
    /**
     * Creates an instance of Operation.
     * This instance is used to execute an OData operation, which can be an action or an action import.
     * The operation can be executed with or without a parameter dialog.
     * If the operation is executed with a parameter dialog, the parameters are collected from the user.
     * If the operation is executed without a parameter dialog, the parameters must be provided in the constructor.
     * The operation can be executed with multiple contexts, which are used to execute the operation on each context.
     * The operation can be executed with a message handler, which is used to handle the messages generated by the operation.
     * The operation can be executed with OData properties, which are used to configure the OData operation.
     * The operation can be executed with OData events, which are used to handle the OData responses and side effects.
     * The operation can be executed with binding parameters, which are used to bind the operation to the context.
     * The operation can be executed with a default values extension function, which is used to set the default values for the parameters.
     * @param appComponent The application component
     * @param model The OData model where the operation is executed
     * @param convertedAction The converted action to execute
     * @param parameters The operation parameters
     * @param parameters.contexts The contexts for the operation
     * @param parameters.messageHandler The message handler to use for the operation
     * @param parameters.view The view where the operation is executed
     * @param parameters.parameterValues The values for the parameters of the operation
     * @param parameters.label The label for the operation
     * @param parameters.invocationGrouping The invocation grouping for the operation
     * @param parameters.skipParameterDialog If set to true the parameter dialog is skipped and the parameters are used directly
     * @param parameters.skipMessages Whether to skip the messages for the operation
     * @param parameters.entitySetName The entity set name for the operation
     * @param parameters.oDataProperties The OData properties for the operation
     * @param parameters.oDataProperties.ghostContextBindingProtection Whether to enable ghost context binding protection
     * @param parameters.oDataProperties.enhance$select Whether to enhance the $select parameter for requesting the sap messages
     * @param parameters.oDataProperties.disableStrictHandling Whether to disable the oData strict handling
     * @param parameters.oDataProperties.disableSideEffects Whether to disable side effects
     * @param parameters.oDataProperties.ignoreETag Whether to ignore the ETag
     * @param parameters.oDataProperties.groupId The group ID for the operation
     * @param parameters.oDataProperties.replaceWithRVC Whether this operation binding's parent context, which must belong to a list binding, is replaced with the operation's return value context (see below) and that list context is returned instead
     * @param parameters.oDataProperties.deferredSubmit If true the operation is not submitted immediately and must be submitted by the developer
     * @param parameters.oDataEvents The OData events for the operation
     * @param parameters.oDataEvents.onParameterDialogOpened The function to call when the parameter dialog is opened
     * @param parameters.oDataEvents.onParameterDialogClosed The function to call when the parameter dialog is closed
     * @param parameters.oDataEvents.onMessagePageNavigationCallback The function to call before page navigation is triggered
     * @param parameters.oDataEvents.onMessageCollected The function to call when the messages are collected
     * @param parameters.oDataEvents.onStrictResponse The function to call when the strict response is received
     * @param parameters.oDataEvents.onStrictCancel The function to call when the strict handling is canceled
     * @param parameters.oDataEvents.onStrictValidation The function to call when the strict validation is triggered
     * @param parameters.oDataEvents.onODataResponse The function to call when the OData response is received
     * @param parameters.oDataEvents.onODataSubmit The function to call when the OData submit is triggered
     * @param parameters.oDataEvents.onRequestSideEffects The function to call when the request side effects are triggered
     * @param parameters.isCreateAction Whether the operation is a create action
     * @param parameters.bindingParameters The binding parameters for the operation
     * @param parameters.defaultValuesExtensionFunction The default values extension function for the operation
     * @param parameters.closeParameterDialog The function to close the parameter dialog
     */
    function Operation(appComponent, model, convertedAction, parameters) {
      this.executionPromise = new Promise((resolve, reject) => {
        this.executionResolve = resolve;
        this.executionReject = reject;
      });
      this.parametersValues = {};
      this.numberOfODataExecutions = 0;
      this.externalParametersValues = false;
      this.appComponent = appComponent;
      this.model = model;
      this.convertedAction = convertedAction;
      this.parameters = parameters;
      this.contexts = parameters.contexts ?? [];
      this.setMessageCollectedPromise();

      // If entitySetName is not provided, it is derived from the first context as fallback.
      this.entitySetName = parameters.entitySetName ?? (this.convertedAction.isBound && this.contexts[0] !== undefined ? this.model.getMetaModel().getMetaContext(this.contexts[0].getPath()).getObject("@sapui.name") : undefined);
      this.operationMessage = new OperationMessage({
        messageHandler: this.parameters.messageHandler,
        action: this.convertedAction,
        contexts: this.contexts,
        label: this.parameters.label,
        invocationGrouping: this.parameters.invocationGrouping,
        disableNotification: this.parameters.skipMessages,
        entitySetName: this.entitySetName,
        events: {
          onMessageCollected: () => {
            // Due to the mess into the message handling
            // the dialog should be closed or not only after the messages are collected
            // it means in the middle of the message handling workflow via
            // a callback function
            this.manageDialogOnMessages();
            this.messageCollectedResolve();
          },
          onMessagePageNavigationCallback: () => {
            this.operationParameters.closeParameterDialog();
          }
        }
      });
      this.operationParameters = new OperationParameters(this.appComponent, this.model, this.convertedAction, this.parameters.skipParameterDialog, {
        contexts: this.contexts,
        defaultValuesExtensionFunction: this.parameters.defaultValuesExtensionFunction,
        isCreateAction: this.parameters.isCreateAction,
        label: this.parameters.label,
        parameterValues: this.parameters.parameterValues,
        entitySetName: this.entitySetName,
        view: this.parameters.view,
        messageHandler: this.parameters.messageHandler,
        events: {
          onParameterDialogOpened: this.operationMessage.onParameterDialogOpened.bind(this.operationMessage),
          onParameterDialogClosed: this.operationMessage.onParameterDialogClosed.bind(this.operationMessage)
        }
      });
    }
    _exports = Operation;
    var _proto = Operation.prototype;
    _proto.clear = function clear() {
      this.operationParameters.closeParameterDialog();
      this.odataOperation?.clear();
    }

    /**
     * Set the values related to the parameters  for the operation
     * If the values are set the operation parameter dialog is skipped.
     * @param parametersValues The values for the parameters
     */;
    _proto.setDefaultParametersValues = function setDefaultParametersValues(parametersValues) {
      this.parametersValues = parametersValues;
      this.externalParametersValues = true;
    }

    /**
     * Executes the operation.
     * @returns A promise containing the results
     */;
    _proto.execute = async function execute() {
      this.internalExecution();
      return this.executionPromise;
    }

    /**
     * Executes the operation.
     */;
    _proto.internalExecution = async function internalExecution() {
      let operationResult = [];
      try {
        this.numberOfODataExecutions++;
        if (!this.externalParametersValues) {
          this.parametersValues = await this.operationParameters.getOperationParameters();
        }
        if (this.numberOfODataExecutions === 1) {
          await this.confirmAction();
        }
        this.odataOperation = new ODataOperation(this.convertedAction, {
          appComponent: this.appComponent,
          contexts: this.contexts,
          model: this.model,
          label: this.parameters.label,
          invocationGrouping: this.parameters.invocationGrouping,
          disableStrictHandling: this.parameters.oDataProperties?.disableStrictHandling,
          disableSideEffects: this.parameters.oDataProperties?.disableSideEffects,
          ghostContextBindingProtection: this.parameters.oDataProperties?.ghostContextBindingProtection,
          events: {
            onStrictValidation: this.parameters.oDataEvents?.onStrictValidation,
            onStrictCancel: this.parameters.oDataEvents?.onStrictCancel,
            onStrictResponse: messages412 => {
              this.parameters.messageHandler.addWarningMessagesToMessageHandler(messages412);
              this.operationMessage.onStrictHandling();
            },
            onODataResponse: this.parameters.oDataEvents?.onODataResponse,
            onODataSubmit: this.parameters.oDataEvents?.onODataSubmit,
            onRequestSideEffects: this.parameters.oDataEvents?.onRequestSideEffects
          },
          parametersValues: this.parametersValues
        }, {
          enhance$select: this.parameters.oDataProperties?.enhance$select,
          groupId: this.parameters.oDataProperties?.groupId,
          replaceWithRVC: this.parameters.oDataProperties?.replaceWithRVC,
          ignoreETag: this.parameters.oDataProperties?.ignoreETag,
          bindingParameters: this.parameters.bindingParameters,
          deferredSubmit: this.parameters.oDataProperties?.deferredSubmit
        });
        operationResult = await this.odataOperation.execute();
        this.operationMessage.reactToOperations(operationResult);
        if (this.operationParameters.isParameterDialog()) {
          if (!operationResult.some(isRejected)) {
            this.closeDialog();
          } else {
            await this.messageCollectedPromise;
          }
        }
        if (this.operationParameters.isParameterDialogOpened()) {
          this.setMessageCollectedPromise();
          this.internalExecution();
        } else {
          this.executionResolve(operationResult);
        }
      } catch (e) {
        this.executionReject(e);
      }
    }

    /**
     * Manages the parameter dialog after the messages.
     */;
    _proto.manageDialogOnMessages = function manageDialogOnMessages() {
      const isErrorIntoParameterDialog = this.operationMessage.isErrorIntoParameterDialog();
      if (actionHelper.isStaticAction(this.convertedAction) || this.contexts.length === 0) {
        // Don't close the dialog if the action is static or an import
        return this.resetDialog();
      } else if (this.parameters.invocationGrouping === InvocationGrouping.ChangeSet) {
        // When the end user cancel the process on the strict dialog, we need to keep the parameter dialog (only on ChangeSet) #6376592
        if (isErrorIntoParameterDialog || this.odataOperation?.isStrictCanceled() === true) {
          return this.resetDialog();
        } else {
          return this.closeDialog();
        }
      } else if (this.parameters.contexts && this.parameters.contexts.length > 1 || !isErrorIntoParameterDialog) {
        // does not matter if error is in APD or not, if there are multiple contexts selected or if the error is not the APD, we close it.
        return this.closeDialog();
      }
      return this.resetDialog();
    }

    /**
     * Sets the message collected promise.
     * This promise is resolved when the messages are collected.
     */;
    _proto.setMessageCollectedPromise = function setMessageCollectedPromise() {
      this.messageCollectedPromise = new Promise(resolve => {
        this.messageCollectedResolve = resolve;
      });
    }

    /**
     * Closes the parameter dialog.
     */;
    _proto.closeDialog = function closeDialog() {
      this.operationParameters.closeParameterDialog();
    }

    /**
     * Resets the parameter dialog.
     */;
    _proto.resetDialog = function resetDialog() {
      this.operationParameters.resetParameterDialogState();
    }

    /**
     * Gets the result of the operation.
     * @returns The result
     */;
    _proto.getOperationResults = async function getOperationResults() {
      return this.executionPromise;
    }

    /**
     * Checks if action is critical.
     * @returns True if the action is critical, otherwise false
     */;
    _proto.isActionCritical = async function isActionCritical() {
      //only works with single context (as former code);
      const context = this.parameters.contexts?.[0];
      // default is true.
      let isActionCriticalValue = true;
      const isActionCriticalBindingExp = getIsActionCriticalExpression(this.convertedAction, convertTypes(this.model.getMetaModel()));
      if (isConstant(isActionCriticalBindingExp)) {
        isActionCriticalValue = compileConstant(isActionCriticalBindingExp, false, undefined, true);
      } else if (context) {
        const anyObject = new Any({
          anyBoolean: compileExpression(isActionCriticalBindingExp)
        });
        anyObject.setModel(context.getModel());
        anyObject.setBindingContext(context);
        const booleanBinding = anyObject.getBinding("anyBoolean");
        if (booleanBinding) {
          if (booleanBinding.isA("sap.ui.model.CompositeBinding")) {
            await Promise.all(booleanBinding.getBindings().map(nestedBinding => nestedBinding.requestValue?.()));
          } else {
            await booleanBinding.requestValue?.();
          }
        }
      }
      return isActionCriticalValue;
    }

    /**
     * Manages the message box to display when an action is critical.
     * @returns A promise which is resolved if the action is not critical or the message box is closed.
     */;
    _proto.confirmAction = async function confirmAction() {
      if (!this.operationParameters.isParameterDialog()) {
        const isCritical = await this.isActionCritical();
        if (isCritical) {
          const actionName = actionHelper.getActionName(this.convertedAction);
          await new Promise((resolve, reject) => {
            const boundActionName = actionName.includes(".") ? actionName.split(".")[actionName.split(".").length - 1] : actionName;
            const suffixResourceKey = boundActionName && this.entitySetName ? `${this.entitySetName}|${boundActionName}` : "";
            MessageBox.confirm(ResourceModelHelper.getResourceModel(this.parameters.view ?? this.appComponent).getText("C_OPERATIONS_ACTION_CONFIRM_MESSAGE", undefined, suffixResourceKey), {
              title: this.getConfirmTitle(suffixResourceKey),
              onClose: action => {
                if (action === MessageBox.Action.OK) {
                  resolve(true);
                } else {
                  reject(new Error(FELibrary.Constants.CancelActionDialog));
                }
              }
            });
          });
        }
      }
    };
    _proto.getConfirmTitle = function getConfirmTitle(suffixResourceKey) {
      // A title only exists if it has been defined in the extension. Otherwise "Confirmation"
      // is used from the MessageBox control.
      if (!this.parameters.view) {
        return undefined;
      }
      const key = "C_OPERATIONS_ACTION_CONFIRM_TITLE";
      const resourceModel = ResourceModelHelper.getResourceModel(this.parameters.view ?? this.appComponent);
      const titleOverrideExists = resourceModel.checkIfResourceKeyExists(`${key}|${suffixResourceKey}`);
      if (titleOverrideExists) {
        return resourceModel.getText(key, undefined, suffixResourceKey);
      }
    }

    /**
     * Returns the converted operation from its name.
     * The operation can be an action or an action import.
     * For the bound operation, the context must be provided and one of the following formats is expected:
     *  - short name (e.g. "MyAction")
     *  - short name with entityType (e.g. "MyEntitytype.MyAction")
     *  - fully qualified name (e.g. "MyService.MyAction")
     *  - fully qualified name with the overlay (e.g. "MyService.MyAction(MyEntityType)")
     *  - fully qualified name with the parenthesis for the operations (e.g. "MyService.MyFunction()")
     * For the imports, one of the following formats is expected:
     *  - short name (e.g. "MyActionImport")
     *  - fully qualified name with entity container (e.g. "MyService.entityContainer/MyActionImport")
     *  - fully qualified name of the related operation (e.g. "MyService.MyActionImport")
     *  - fully qualified name of the related operation with parenthesis (e.g. "MyService.MyActionImport()").
     * @param name The name of the operation
     * @param model The OData model
     * @param context The context of the operation for bound actions
     * @returns The converted operation
     */;
    Operation.getOperationFromName = function getOperationFromName(name, model, context) {
      const metaModel = model.getMetaModel();
      const convertedMetaModel = convertTypes(metaModel);
      if (context) {
        //looking for bound action
        const sourceEntityType = getInvolvedDataModelObjects(metaModel.getMetaContext(context.getPath())).targetEntityType.name;
        const actionName = name.replace(/\(.*\)$/g, "") // remove the part related to the overlay
        .replace(`${convertedMetaModel.namespace}.`, "") // remove the part related to the service name
        .split(".").pop(); // remove the part related to the entity type
        return convertedMetaModel.actions.find(action => {
          return action.name === actionName && action.isBound && action.sourceEntityType && sourceEntityType === action.sourceEntityType.name;
        });
      }
      const importName = name.replace(`${convertedMetaModel.entityContainer.fullyQualifiedName}/`, "").replace(`${convertedMetaModel.namespace}.`, "").replace("()", "");
      // Remove the entityContainer part (sap.fe.MyService.EntityContainer/myImport) or the service name (sap.fe.MyService.myImport) and the parenthesis (sap.fe.MyService.myImport())
      return convertedMetaModel.actionImports.find(actionImport => {
        return actionImport.name === importName;
      });
    };
    return Operation;
  }();
  _exports = Operation;
  return _exports;
}, false);
//# sourceMappingURL=Operation-dbg.js.map
