import type { ActionImport, Action as EdmAction, PrimitiveType } from "@sap-ux/vocabularies-types";
import { compileConstant, compileExpression, isConstant } from "sap/fe/base/BindingToolkit";
import type { BindContextParameters } from "sap/fe/core/controllerextensions/editFlow/draft";
import Any from "sap/fe/core/controls/Any";
import { isRejected } from "sap/fe/core/helpers/TypeGuards";
import FELibrary from "sap/fe/core/library";
import { getIsActionCriticalExpression } from "sap/fe/core/templating/ActionHelper";
import MessageBox from "sap/m/MessageBox";
import type Message from "sap/ui/core/message/Message";
import type CompositeBinding from "sap/ui/model/CompositeBinding";
import type Context from "sap/ui/model/odata/v4/Context";
import type ODataModel from "sap/ui/model/odata/v4/ODataModel";
import type ODataPropertyBinding from "sap/ui/model/odata/v4/ODataPropertyBinding";
import type AppComponent from "../../../AppComponent";
import type { FEView } from "../../../BaseController";
import { convertTypes, getInvolvedDataModelObjects } from "../../../converters/MetaModelConverter";
import * as ResourceModelHelper from "../../../helpers/ResourceModelHelper";
import type { ActionSideEffectsType } from "../../../services/SideEffectsServiceFactory";
import type MessageHandler from "../../MessageHandler";
import type { OperationResult } from "./ODataOperation";
import ODataOperation from "./ODataOperation";
import OperationMessage from "./OperationMessage";
import OperationParameters from "./OperationParameters";
import actionHelper from "./actionHelper";

const InvocationGrouping = FELibrary.InvocationGrouping;

export type OperationParametersType = {
	messageHandler: MessageHandler;
	view?: FEView;
	parameterValues?: Record<string, PrimitiveType>[];
	label?: string;
	invocationGrouping?: string;
	skipParameterDialog?: boolean;
	skipMessages?: boolean;
	entitySetName?: string;
	oDataProperties?: {
		ghostContextBindingProtection?: boolean;
		enhance$select?: boolean;
		disableStrictHandling?: boolean;
		disableSideEffects?: boolean;
		ignoreETag?: boolean;
		groupId?: string;
		replaceWithRVC?: boolean;
		deferredSubmit?: boolean;
	};
	isCreateAction?: boolean;
	contexts?: Context[];
	bindingParameters?: BindContextParameters;
	defaultValuesExtensionFunction?: string;
	oDataEvents?: {
		onODataResponse?: () => void;
		onODataSubmit?: () => void;
		onRequestSideEffects?: (
			sideEffects: ActionSideEffectsType,
			operation: EdmAction | ActionImport,
			sideEffectsPromises: Promise<unknown>[]
		) => void;
		onStrictCancel?: () => void;
		onStrictValidation?: () => void;
	};
};

export default class Operation {
	private readonly contexts: Context[];

	private readonly entitySetName: string | undefined;

	private executionResolve!: Function;

	private executionReject!: Function;

	private readonly executionPromise = new Promise<PromiseSettledResult<OperationResult>[]>((resolve, reject) => {
		this.executionResolve = resolve;
		this.executionReject = reject;
	});

	private messageCollectedResolve!: Function;

	private messageCollectedPromise!: Promise<void>;

	private readonly operationMessage: OperationMessage;

	private readonly operationParameters: OperationParameters;

	private parametersValues: Record<string, PrimitiveType> = {};

	private numberOfODataExecutions = 0;

	private externalParametersValues = false;

	private odataOperation: ODataOperation | undefined;

	/**
	 * Creates an instance of Operation.
	 * This instance is used to execute an OData operation, which can be an action or an action import.
	 * The operation can be executed with or without a parameter dialog.
	 * If the operation is executed with a parameter dialog, the parameters are collected from the user.
	 * If the operation is executed without a parameter dialog, the parameters must be provided in the constructor.
	 * The operation can be executed with multiple contexts, which are used to execute the operation on each context.
	 * The operation can be executed with a message handler, which is used to handle the messages generated by the operation.
	 * The operation can be executed with OData properties, which are used to configure the OData operation.
	 * The operation can be executed with OData events, which are used to handle the OData responses and side effects.
	 * The operation can be executed with binding parameters, which are used to bind the operation to the context.
	 * The operation can be executed with a default values extension function, which is used to set the default values for the parameters.
	 * @param appComponent The application component
	 * @param model The OData model where the operation is executed
	 * @param convertedAction The converted action to execute
	 * @param parameters The operation parameters
	 * @param parameters.contexts The contexts for the operation
	 * @param parameters.messageHandler The message handler to use for the operation
	 * @param parameters.view The view where the operation is executed
	 * @param parameters.parameterValues The values for the parameters of the operation
	 * @param parameters.label The label for the operation
	 * @param parameters.invocationGrouping The invocation grouping for the operation
	 * @param parameters.skipParameterDialog If set to true the parameter dialog is skipped and the parameters are used directly
	 * @param parameters.skipMessages Whether to skip the messages for the operation
	 * @param parameters.entitySetName The entity set name for the operation
	 * @param parameters.oDataProperties The OData properties for the operation
	 * @param parameters.oDataProperties.ghostContextBindingProtection Whether to enable ghost context binding protection
	 * @param parameters.oDataProperties.enhance$select Whether to enhance the $select parameter for requesting the sap messages
	 * @param parameters.oDataProperties.disableStrictHandling Whether to disable the oData strict handling
	 * @param parameters.oDataProperties.disableSideEffects Whether to disable side effects
	 * @param parameters.oDataProperties.ignoreETag Whether to ignore the ETag
	 * @param parameters.oDataProperties.groupId The group ID for the operation
	 * @param parameters.oDataProperties.replaceWithRVC Whether this operation binding's parent context, which must belong to a list binding, is replaced with the operation's return value context (see below) and that list context is returned instead
	 * @param parameters.oDataProperties.deferredSubmit If true the operation is not submitted immediately and must be submitted by the developer
	 * @param parameters.oDataEvents The OData events for the operation
	 * @param parameters.oDataEvents.onParameterDialogOpened The function to call when the parameter dialog is opened
	 * @param parameters.oDataEvents.onParameterDialogClosed The function to call when the parameter dialog is closed
	 * @param parameters.oDataEvents.onMessagePageNavigationCallback The function to call before page navigation is triggered
	 * @param parameters.oDataEvents.onMessageCollected The function to call when the messages are collected
	 * @param parameters.oDataEvents.onStrictResponse The function to call when the strict response is received
	 * @param parameters.oDataEvents.onStrictCancel The function to call when the strict handling is canceled
	 * @param parameters.oDataEvents.onStrictValidation The function to call when the strict validation is triggered
	 * @param parameters.oDataEvents.onODataResponse The function to call when the OData response is received
	 * @param parameters.oDataEvents.onODataSubmit The function to call when the OData submit is triggered
	 * @param parameters.oDataEvents.onRequestSideEffects The function to call when the request side effects are triggered
	 * @param parameters.isCreateAction Whether the operation is a create action
	 * @param parameters.bindingParameters The binding parameters for the operation
	 * @param parameters.defaultValuesExtensionFunction The default values extension function for the operation
	 * @param parameters.closeParameterDialog The function to close the parameter dialog
	 */
	constructor(
		private readonly appComponent: AppComponent,
		private readonly model: ODataModel,
		private readonly convertedAction: EdmAction,
		private readonly parameters: OperationParametersType
	) {
		this.contexts = parameters.contexts ?? [];

		this.setMessageCollectedPromise();

		// If entitySetName is not provided, it is derived from the first context as fallback.
		this.entitySetName =
			parameters.entitySetName ??
			(this.convertedAction.isBound && this.contexts[0] !== undefined
				? this.model.getMetaModel().getMetaContext(this.contexts[0].getPath()).getObject("@sapui.name")
				: undefined);

		this.operationMessage = new OperationMessage({
			messageHandler: this.parameters.messageHandler,
			action: this.convertedAction,
			contexts: this.contexts,
			label: this.parameters.label,
			invocationGrouping: this.parameters.invocationGrouping,
			disableNotification: this.parameters.skipMessages,
			entitySetName: this.entitySetName,
			events: {
				onMessageCollected: (): void => {
					// Due to the mess into the message handling
					// the dialog should be closed or not only after the messages are collected
					// it means in the middle of the message handling workflow via
					// a callback function
					this.manageDialogOnMessages();
					this.messageCollectedResolve();
				},
				onMessagePageNavigationCallback: (): void => {
					this.operationParameters.closeParameterDialog();
				}
			}
		});

		this.operationParameters = new OperationParameters(
			this.appComponent,
			this.model,
			this.convertedAction,
			this.parameters.skipParameterDialog,
			{
				contexts: this.contexts,
				defaultValuesExtensionFunction: this.parameters.defaultValuesExtensionFunction,
				isCreateAction: this.parameters.isCreateAction,
				label: this.parameters.label,
				parameterValues: this.parameters.parameterValues,
				entitySetName: this.entitySetName,
				view: this.parameters.view,
				messageHandler: this.parameters.messageHandler,
				events: {
					onParameterDialogOpened: this.operationMessage.onParameterDialogOpened.bind(this.operationMessage),
					onParameterDialogClosed: this.operationMessage.onParameterDialogClosed.bind(this.operationMessage)
				}
			}
		);
	}

	clear(): void {
		this.operationParameters.closeParameterDialog();
		this.odataOperation?.clear();
	}

	/**
	 * Set the values related to the parameters  for the operation
	 * If the values are set the operation parameter dialog is skipped.
	 * @param parametersValues The values for the parameters
	 */
	public setDefaultParametersValues(parametersValues: Record<string, PrimitiveType>): void {
		this.parametersValues = parametersValues;
		this.externalParametersValues = true;
	}

	/**
	 * Executes the operation.
	 * @returns A promise containing the results
	 */
	public async execute(): Promise<PromiseSettledResult<OperationResult>[]> {
		this.internalExecution();
		return this.executionPromise;
	}

	/**
	 * Executes the operation.
	 */
	private async internalExecution(): Promise<void> {
		let operationResult: PromiseSettledResult<OperationResult>[] = [];
		try {
			this.numberOfODataExecutions++;
			if (!this.externalParametersValues) {
				this.parametersValues = await this.operationParameters.getOperationParameters();
			}
			if (this.numberOfODataExecutions === 1) {
				await this.confirmAction();
			}
			this.odataOperation = new ODataOperation(
				this.convertedAction,
				{
					appComponent: this.appComponent,
					contexts: this.contexts,
					model: this.model,
					label: this.parameters.label,
					invocationGrouping: this.parameters.invocationGrouping,
					disableStrictHandling: this.parameters.oDataProperties?.disableStrictHandling,
					disableSideEffects: this.parameters.oDataProperties?.disableSideEffects,
					ghostContextBindingProtection: this.parameters.oDataProperties?.ghostContextBindingProtection,
					events: {
						onStrictValidation: this.parameters.oDataEvents?.onStrictValidation,
						onStrictCancel: this.parameters.oDataEvents?.onStrictCancel,
						onStrictResponse: (messages412: Message[]): void => {
							this.parameters.messageHandler.addWarningMessagesToMessageHandler(messages412);
							this.operationMessage.onStrictHandling();
						},
						onODataResponse: this.parameters.oDataEvents?.onODataResponse,
						onODataSubmit: this.parameters.oDataEvents?.onODataSubmit,
						onRequestSideEffects: this.parameters.oDataEvents?.onRequestSideEffects
					},
					parametersValues: this.parametersValues
				},
				{
					enhance$select: this.parameters.oDataProperties?.enhance$select,
					groupId: this.parameters.oDataProperties?.groupId,
					replaceWithRVC: this.parameters.oDataProperties?.replaceWithRVC,
					ignoreETag: this.parameters.oDataProperties?.ignoreETag,
					bindingParameters: this.parameters.bindingParameters,
					deferredSubmit: this.parameters.oDataProperties?.deferredSubmit
				}
			);
			operationResult = await this.odataOperation.execute();
			this.operationMessage.reactToOperations(operationResult);

			if (this.operationParameters.isParameterDialog()) {
				if (!operationResult.some(isRejected)) {
					this.closeDialog();
				} else {
					await this.messageCollectedPromise;
				}
			}

			if (this.operationParameters.isParameterDialogOpened()) {
				this.setMessageCollectedPromise();
				this.internalExecution();
			} else {
				this.executionResolve(operationResult);
			}
		} catch (e) {
			this.executionReject(e);
		}
	}

	/**
	 * Manages the parameter dialog after the messages.
	 */

	private manageDialogOnMessages(): void {
		const isErrorIntoParameterDialog = this.operationMessage.isErrorIntoParameterDialog();

		if (actionHelper.isStaticAction(this.convertedAction) || this.contexts.length === 0) {
			// Don't close the dialog if the action is static or an import
			return this.resetDialog();
		} else if (this.parameters.invocationGrouping === InvocationGrouping.ChangeSet) {
			// When the end user cancel the process on the strict dialog, we need to keep the parameter dialog (only on ChangeSet) #6376592
			if (isErrorIntoParameterDialog || this.odataOperation?.isStrictCanceled() === true) {
				return this.resetDialog();
			} else {
				return this.closeDialog();
			}
		} else if ((this.parameters.contexts && this.parameters.contexts.length > 1) || !isErrorIntoParameterDialog) {
			// does not matter if error is in APD or not, if there are multiple contexts selected or if the error is not the APD, we close it.
			return this.closeDialog();
		}
		return this.resetDialog();
	}

	/**
	 * Sets the message collected promise.
	 * This promise is resolved when the messages are collected.
	 */
	private setMessageCollectedPromise(): void {
		this.messageCollectedPromise = new Promise<void>((resolve) => {
			this.messageCollectedResolve = resolve;
		});
	}

	/**
	 * Closes the parameter dialog.
	 */
	private closeDialog(): void {
		this.operationParameters.closeParameterDialog();
	}

	/**
	 * Resets the parameter dialog.
	 */
	private resetDialog(): void {
		this.operationParameters.resetParameterDialogState();
	}

	/**
	 * Gets the result of the operation.
	 * @returns The result
	 */
	public async getOperationResults(): Promise<PromiseSettledResult<OperationResult>[]> {
		return this.executionPromise;
	}

	/**
	 * Checks if action is critical.
	 * @returns True if the action is critical, otherwise false
	 */
	private async isActionCritical(): Promise<boolean> {
		//only works with single context (as former code);
		const context = this.parameters.contexts?.[0];
		// default is true.
		let isActionCriticalValue: boolean | Promise<boolean> = true;
		const isActionCriticalBindingExp = getIsActionCriticalExpression(this.convertedAction, convertTypes(this.model.getMetaModel()));
		if (isConstant(isActionCriticalBindingExp)) {
			isActionCriticalValue = compileConstant(isActionCriticalBindingExp, false, undefined, true) as boolean;
		} else if (context) {
			const anyObject = new Any({ anyBoolean: compileExpression(isActionCriticalBindingExp) });
			anyObject.setModel(context.getModel());
			anyObject.setBindingContext(context);
			const booleanBinding = anyObject.getBinding("anyBoolean") as ODataPropertyBinding | undefined;
			if (booleanBinding) {
				if (booleanBinding.isA<CompositeBinding>("sap.ui.model.CompositeBinding")) {
					await Promise.all(booleanBinding.getBindings().map((nestedBinding) => nestedBinding.requestValue?.()));
				} else {
					await booleanBinding.requestValue?.();
				}
			}
		}
		return isActionCriticalValue;
	}

	/**
	 * Manages the message box to display when an action is critical.
	 * @returns A promise which is resolved if the action is not critical or the message box is closed.
	 */
	private async confirmAction(): Promise<void> {
		if (!this.operationParameters.isParameterDialog()) {
			const isCritical = await this.isActionCritical();
			if (isCritical) {
				const actionName = actionHelper.getActionName(this.convertedAction);
				await new Promise((resolve, reject) => {
					const boundActionName = actionName.includes(".") ? actionName.split(".")[actionName.split(".").length - 1] : actionName;
					const suffixResourceKey = boundActionName && this.entitySetName ? `${this.entitySetName}|${boundActionName}` : "";

					MessageBox.confirm(
						ResourceModelHelper.getResourceModel(this.parameters.view ?? this.appComponent).getText(
							"C_OPERATIONS_ACTION_CONFIRM_MESSAGE",
							undefined,
							suffixResourceKey
						),
						{
							title: this.getConfirmTitle(suffixResourceKey),
							onClose: (action: string) => {
								if (action === MessageBox.Action.OK) {
									resolve(true);
								} else {
									reject(new Error(FELibrary.Constants.CancelActionDialog));
								}
							}
						}
					);
				});
			}
		}
	}

	getConfirmTitle(suffixResourceKey: string): string | undefined {
		// A title only exists if it has been defined in the extension. Otherwise "Confirmation"
		// is used from the MessageBox control.
		if (!this.parameters.view) {
			return undefined;
		}
		const key = "C_OPERATIONS_ACTION_CONFIRM_TITLE";
		const resourceModel = ResourceModelHelper.getResourceModel(this.parameters.view ?? this.appComponent);
		const titleOverrideExists = resourceModel.checkIfResourceKeyExists(`${key}|${suffixResourceKey}`);
		if (titleOverrideExists) {
			return resourceModel.getText(key, undefined, suffixResourceKey);
		}
	}

	/**
	 * Returns the converted operation from its name.
	 * The operation can be an action or an action import.
	 * For the bound operation, the context must be provided and one of the following formats is expected:
	 *  - short name (e.g. "MyAction")
	 *  - short name with entityType (e.g. "MyEntitytype.MyAction")
	 *  - fully qualified name (e.g. "MyService.MyAction")
	 *  - fully qualified name with the overlay (e.g. "MyService.MyAction(MyEntityType)")
	 *  - fully qualified name with the parenthesis for the operations (e.g. "MyService.MyFunction()")
	 * For the imports, one of the following formats is expected:
	 *  - short name (e.g. "MyActionImport")
	 *  - fully qualified name with entity container (e.g. "MyService.entityContainer/MyActionImport")
	 *  - fully qualified name of the related operation (e.g. "MyService.MyActionImport")
	 *  - fully qualified name of the related operation with parenthesis (e.g. "MyService.MyActionImport()").
	 * @param name The name of the operation
	 * @param model The OData model
	 * @param context The context of the operation for bound actions
	 * @returns The converted operation
	 */
	static getOperationFromName(name: string, model: ODataModel, context?: Context): EdmAction | ActionImport | undefined {
		const metaModel = model.getMetaModel();
		const convertedMetaModel = convertTypes(metaModel);
		if (context) {
			//looking for bound action
			const sourceEntityType = getInvolvedDataModelObjects(metaModel.getMetaContext(context.getPath())).targetEntityType.name;
			const actionName = name
				.replace(/\(.*\)$/g, "") // remove the part related to the overlay
				.replace(`${convertedMetaModel.namespace}.`, "") // remove the part related to the service name
				.split(".")
				.pop(); // remove the part related to the entity type
			return convertedMetaModel.actions.find((action: EdmAction) => {
				return (
					action.name === actionName &&
					action.isBound &&
					action.sourceEntityType &&
					sourceEntityType === action.sourceEntityType.name
				);
			});
		}
		const importName = name
			.replace(`${convertedMetaModel.entityContainer.fullyQualifiedName}/`, "")
			.replace(`${convertedMetaModel.namespace}.`, "")
			.replace("()", "");
		// Remove the entityContainer part (sap.fe.MyService.EntityContainer/myImport) or the service name (sap.fe.MyService.myImport) and the parenthesis (sap.fe.MyService.myImport())
		return convertedMetaModel.actionImports.find((actionImport: ActionImport) => {
			return actionImport.name === importName;
		});
	}
}
