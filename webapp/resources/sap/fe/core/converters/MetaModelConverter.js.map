{"version":3,"file":"MetaModelConverter.js","names":["parsePropertyValue","annotationObject","propertyKey","currentTarget","annotationsLists","oCapabilities","value","type","String","Bool","Int","Array","isArray","collectionValue","Collection","map","subAnnotationObject","subAnnotationObjectIndex","parseAnnotationObject","length","hasOwnProperty","$Path","undefined","Path","$Decimal","Decimal","parseFloat","$PropertyPath","PropertyPath","$NavigationPropertyPath","NavigationPropertyPath","$If","$And","$Or","$Not","$Eq","$Ne","$Gt","$Ge","$Lt","$Le","$Apply","$Function","$AnnotationPath","AnnotationPath","$EnumMember","EnumMember","Record","name","currentObjectTarget","parsedAnnotationObject","parsedAnnotationCollection","collection","subAnnotationIndex","parsedAnnotationObjectRecord","propertyValues","$Type","Object","keys","forEach","startsWith","push","createAnnotationLists","getOrCreateAnnotationList","target","annotations","createReferenceFacetId","referenceFacet","id","ID","Target","prepareId","removeChartAnnotations","filter","oRecord","recordAsRefFacet","includes","removeIBNAnnotations","handlePresentationVariant","annotationObjects","annotationTarget","annotationLists","outAnnotationObject","MicroChart","loadLibrary","annotationKey","IntentBasedNavigation","fieldGroupAnnotation","Data","presentationVariant","Chart","Visualizations","filterRestrictions","FilterExpressionRestrictions","some","FilterExpressionRestriction","Property","AllowedExpressions","fullyQualifiedName","currentOutAnnotationObject","finalKey","annotationOfAnnotationSplit","split","annotationQualifierSplit","qualifier","term","currentAnnotationTarget","annotationObjectToParse","record","typeValue","prepareProperty","propertyDefinition","entityTypeObject","propertyName","_type","maxLength","$MaxLength","precision","$Precision","scale","$Scale","nullable","$Nullable","prepareNavigationProperty","navPropertyDefinition","navPropertyName","referentialConstraint","$ReferentialConstraint","sourcePropertyName","sourceTypeName","sourceProperty","targetTypeName","targetProperty","navigationProperty","partner","$Partner","isCollection","$isCollection","containsTarget","$ContainsTarget","prepareNavigationPropertyBinding","navigationPropertyBinding","entityContainerName","fromEntries","entries","_ref","path","prepareEntitySet","entitySetDefinition","entitySetName","$NavigationPropertyBinding","entityTypeName","prepareSingleton","singletonDefinition","singletonName","prepareActionImport","actionImport","actionImportName","actionName","$kind","$Action","prepareTypeDefinition","typeDefinition","typeName","namespacePrefix","typeObject","substring","underlyingType","$UnderlyingType","prepareComplexType","complexTypeDefinition","complexTypeName","complexTypeObject","properties","navigationProperties","complexTypeProperties","propertyNameOrNot","sort","a","b","complexTypeNavigationProperties","prepareEntityKeys","entityTypeDefinition","oMetaModelData","$Key","$BaseType","prepareEntityType","metaModelData","ignoreDatafieldDefault","entityType","entityProperties","actions","key","property","entityKey","find","entityTypeAnnotations","$Annotations","filterFacets","filterFacetAnnotation","headerInfoAnnotation","TypeName","TypeNamePlural","Title","Value","entityProperty","prepareAction","actionRawData","overloadParameters","$Parameter","$IsBound","overload","parameter","join","parameters","isBound","isFunction","sourceType","returnType","$ReturnType","returnCollection","param","$Name","parseEntityContainer","entityContainerMetadata","schema","entityContainer","elementName","elementValue","entitySets","singletons","actionImports","parseAnnotations","capabilities","values","parseSchema","metamodelObject","namespace","slice","entityTypes","complexTypes","typeDefinitions","associations","associationSets","parseMetaModelElement","subElementValue","parseMetaModel","metaModel","arguments","DefaultEnvironmentCapabilities","result","identification","version","references","AnnotationConverter","lazy","getObject","_exports","convertedMetaModelMap","metaModelIDMap","metaModelMap","WeakMap","virtualPropertiesMap","convertTypes","oMetaModel","metaModelID","parsedOutput","convert","criticality","fn","getVirtualCriticalityExpression","metaModelSymbol","set","oError","Error","registerVirtualProperty","convertedTypes","fnVirtualProperty","viewId","getMetaModelById","symbol","get","getConvertedTypes","oContext","getModel","isA","deleteModelCacheData","convertMetaModelContext","oMetaModelContext","bIncludeVisitedObjects","oConvertedMetadata","sPath","getPath","aPathSplit","firstPart","beginIndex","targetEntitySet","entitySet","singleton","relativePath","localObjects","relativeSplit","idx","currentEntitySet","sNavPropToCheck","replace","aNavProps","targetEntityType","sNavProp","targetNavProp","navProp","targetType","shift","oTarget","resolvePath","visitedObjects","concat","action","parameterName","endsWith","getInvolvedDataModelObjects","oEntitySetMetaModelContext","metaModelContext","targetEntitySetLocation","getInvolvedDataModelObjectFromPath","onlyServiceObjects","dataModelObjects","visitedObject","isServiceObject","isEntityType","isEntityContainer","rootEntitySet","currentEntityType","currentObject","navigatedPath","i","isNavigationProperty","boundEntitySet","isEntitySet","isSingleton","startingEntitySet","startingIndex","indexOf","requiredDataModelObjects","outDataModelPath","targetObject","contextLocation","getInvolvedDataModelObjectEntityKeys","context","getMetaModel","metaPath","getMetaPath","dataModel","getMetaContext","rootSemanticKeys","Common","SemanticKey","semanticKeys","rootTechnicalKeys","technicalKeys","extractModelAndPath","modelId","targetPath","getInvolvedDataModelObjectsForTargetPath","metaContext","getContext","getVirtualBindingExpression","virtualKey","pathInfos","method","virtualProperty","virtualPropertyFn","expression","constant","criticalityProperty","Criticality","criticalityExpression","getExpressionFromAnnotation","bindingPath","formatResult"],"sources":["./MetaModelConverter.ts"],"sourcesContent":["// This file is retrieved from @sap-ux/annotation-converter, shared code with tool suite\nimport type {\n\tActionParameter,\n\tAnnotationList,\n\tAnnotationRecord,\n\tAnnotationTerm,\n\tConvertedMetadata,\n\tEntitySet,\n\tEntityType,\n\tExpression,\n\tNavigationProperty,\n\tRawAction,\n\tRawActionImport,\n\tRawAnnotation,\n\tRawComplexType,\n\tRawEntitySet,\n\tRawEntityType,\n\tRawMetadata,\n\tRawNavigationPropertyBinding,\n\tRawProperty,\n\tRawSchema,\n\tRawSingleton,\n\tRawTypeDefinition,\n\tRawV4NavigationProperty,\n\tReferentialConstraint,\n\tServiceObject,\n\tServiceObjectAndAnnotation,\n\tSingleton\n} from \"@sap-ux/vocabularies-types\";\nimport type { ApplyExpression, Collection, CollectionExpression, PropertyValue } from \"@sap-ux/vocabularies-types/BaseEdm\";\nimport type { AnnotationPath, PrimitiveType, PropertyAnnotationValue, RecordComplexType } from \"@sap-ux/vocabularies-types/Edm\";\nimport type { PropertyAnnotations_Analytics } from \"@sap-ux/vocabularies-types/vocabularies/Analytics_Edm\";\nimport type { FilterRestrictions } from \"@sap-ux/vocabularies-types/vocabularies/Capabilities\";\nimport type {\n\tEntitySetAnnotations_Capabilities,\n\tEntityTypeAnnotations_Capabilities,\n\tPropertyAnnotations_Capabilities\n} from \"@sap-ux/vocabularies-types/vocabularies/Capabilities_Edm\";\nimport type { PropertyAnnotations_Common } from \"@sap-ux/vocabularies-types/vocabularies/Common_Edm\";\nimport type { PropertyAnnotations_Communication } from \"@sap-ux/vocabularies-types/vocabularies/Communication_Edm\";\nimport type { PropertyAnnotations_Core } from \"@sap-ux/vocabularies-types/vocabularies/Core_Edm\";\nimport type { PropertyAnnotations_Measures } from \"@sap-ux/vocabularies-types/vocabularies/Measures_Edm\";\nimport type { PropertyAnnotations_PersonalData } from \"@sap-ux/vocabularies-types/vocabularies/PersonalData_Edm\";\nimport type { PropertyAnnotations_Session } from \"@sap-ux/vocabularies-types/vocabularies/Session_Edm\";\nimport type {\n\tChart,\n\tDataField,\n\tDataFieldAbstractTypes,\n\tDataPoint,\n\tDataPointType,\n\tFacetTypes,\n\tFieldGroup,\n\tFilterFacets,\n\tHeaderFacets,\n\tHeaderInfo,\n\tLineItem,\n\tPresentationVariant,\n\tReferenceFacet,\n\tTextArrangement\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTerms, UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type {\n\tEntitySetAnnotations_UI,\n\tEntityTypeAnnotations_UI,\n\tPropertyAnnotations_UI\n} from \"@sap-ux/vocabularies-types/vocabularies/UI_Edm\";\nimport type { BindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport { constant, formatResult, getExpressionFromAnnotation } from \"sap/fe/base/BindingToolkit\";\nimport { AnnotationConverter } from \"sap/fe/core/converters/common\";\nimport {\n\tisEntityContainer,\n\tisEntitySet,\n\tisEntityType,\n\tisNavigationProperty,\n\tisServiceObject,\n\tisSingleton\n} from \"sap/fe/core/helpers/TypeGuards\";\nimport type { EnvironmentCapabilities } from \"sap/fe/core/services/EnvironmentServiceFactory\";\nimport { DefaultEnvironmentCapabilities } from \"sap/fe/core/services/EnvironmentServiceFactory\";\nimport type { DataModelObjectContext, DataModelObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport type Context from \"sap/ui/model/Context\";\nimport type { default as ODataV4Context } from \"sap/ui/model/odata/v4/Context\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\nimport type { ExpandPathType, MetaModelEnum, MetaModelType, Rename } from \"types/metamodel_types\";\nimport { prepareId } from \"../helpers/StableIdHelper\";\n\nexport type MetaModelActionParameter = {\n\t$Type: string;\n\t$Name: string;\n\t$Nullable?: boolean;\n\t$MaxLength?: number;\n\t$Precision?: number;\n\t$Scale?: number;\n\t$isCollection?: boolean;\n};\nexport type MetaModelAction = {\n\t$kind: \"Action\" | \"Function\";\n\t$IsBound: boolean;\n\t$EntitySetPath: string;\n\t$Parameter: MetaModelActionParameter[];\n\t$ReturnType: {\n\t\t$Type: string;\n\t\t$isCollection?: boolean;\n\t};\n};\n\ntype MetaModelAnnotation = null | string | boolean | number | MetaModelAnnotationRecord;\ntype MetaModelAnnotationRecord = {\n\t$Type: string;\n\t$PropertyPath?: string;\n\t$Path?: string;\n\t$Decimal?: string;\n\t$If?: unknown;\n\t$And?: unknown;\n\t$Or?: unknown;\n\t$Not?: unknown;\n\t$Eq?: unknown;\n\t$Ne?: unknown;\n\t$Gt?: unknown;\n\t$Ge?: unknown;\n\t$Lt?: unknown;\n\t$Le?: unknown;\n\t$Apply?: unknown;\n\t$Function?: unknown;\n\t$AnnotationPath?: string;\n\t$EnumMember?: string;\n\t$NavigationPropertyPath?: string;\n} & {\n\t[propertyKey: string]: MetaModelAnnotation;\n};\nfunction parsePropertyValue(\n\tannotationObject: MetaModelAnnotation,\n\tpropertyKey: string,\n\tcurrentTarget: string,\n\tannotationsLists: Record<string, AnnotationList>,\n\toCapabilities: EnvironmentCapabilities\n): { name: string; value: Expression } {\n\tlet value!: Expression;\n\tif (annotationObject === null) {\n\t\tvalue = { type: \"Null\" };\n\t} else if (typeof annotationObject === \"string\") {\n\t\tvalue = { type: \"String\", String: annotationObject };\n\t} else if (typeof annotationObject === \"boolean\") {\n\t\tvalue = { type: \"Bool\", Bool: annotationObject };\n\t} else if (typeof annotationObject === \"number\") {\n\t\tvalue = { type: \"Int\", Int: annotationObject };\n\t} else if (Array.isArray(annotationObject)) {\n\t\tconst collectionValue: CollectionExpression = {\n\t\t\ttype: \"Collection\",\n\t\t\tCollection: annotationObject.map((subAnnotationObject, subAnnotationObjectIndex) =>\n\t\t\t\tparseAnnotationObject(\n\t\t\t\t\tsubAnnotationObject,\n\t\t\t\t\t`${currentTarget}/${propertyKey}/${subAnnotationObjectIndex}`,\n\t\t\t\t\tannotationsLists,\n\t\t\t\t\toCapabilities\n\t\t\t\t)\n\t\t\t) as Collection\n\t\t};\n\t\tif (annotationObject.length > 0) {\n\t\t\tif (annotationObject[0].hasOwnProperty(\"$PropertyPath\")) {\n\t\t\t\tcollectionValue.Collection.type = \"PropertyPath\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Path\")) {\n\t\t\t\tcollectionValue.Collection.type = \"Path\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$NavigationPropertyPath\")) {\n\t\t\t\tcollectionValue.Collection.type = \"NavigationPropertyPath\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$AnnotationPath\")) {\n\t\t\t\tcollectionValue.Collection.type = \"AnnotationPath\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Type\")) {\n\t\t\t\tcollectionValue.Collection.type = \"Record\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$If\")) {\n\t\t\t\tcollectionValue.Collection.type = \"If\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Or\")) {\n\t\t\t\tcollectionValue.Collection.type = \"Or\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$And\")) {\n\t\t\t\tcollectionValue.Collection.type = \"And\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Eq\")) {\n\t\t\t\tcollectionValue.Collection.type = \"Eq\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Ne\")) {\n\t\t\t\tcollectionValue.Collection.type = \"Ne\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Not\")) {\n\t\t\t\tcollectionValue.Collection.type = \"Not\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Gt\")) {\n\t\t\t\tcollectionValue.Collection.type = \"Gt\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Ge\")) {\n\t\t\t\tcollectionValue.Collection.type = \"Ge\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Lt\")) {\n\t\t\t\tcollectionValue.Collection.type = \"Lt\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Le\")) {\n\t\t\t\tcollectionValue.Collection.type = \"Le\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Apply\")) {\n\t\t\t\tcollectionValue.Collection.type = \"Apply\";\n\t\t\t} else if (typeof annotationObject[0] === \"object\") {\n\t\t\t\t// $Type is optional...\n\t\t\t\tcollectionValue.Collection.type = \"Record\";\n\t\t\t} else {\n\t\t\t\tcollectionValue.Collection.type = \"String\";\n\t\t\t}\n\t\t}\n\t\tvalue = collectionValue;\n\t} else if (typeof annotationObject === \"object\") {\n\t\tif (annotationObject.$Path !== undefined) {\n\t\t\tvalue = { type: \"Path\", Path: annotationObject.$Path };\n\t\t} else if (annotationObject.$Decimal !== undefined) {\n\t\t\tvalue = { type: \"Decimal\", Decimal: parseFloat(annotationObject.$Decimal) };\n\t\t} else if (annotationObject.$PropertyPath !== undefined) {\n\t\t\tvalue = { type: \"PropertyPath\", PropertyPath: annotationObject.$PropertyPath };\n\t\t} else if (annotationObject.$NavigationPropertyPath !== undefined) {\n\t\t\tvalue = { type: \"NavigationPropertyPath\", NavigationPropertyPath: annotationObject.$NavigationPropertyPath };\n\t\t} else if (annotationObject.$If !== undefined) {\n\t\t\tvalue = { type: \"If\", $If: annotationObject.$If as [Expression, Expression, Expression] };\n\t\t} else if (annotationObject.$And !== undefined) {\n\t\t\tvalue = { type: \"And\", $And: annotationObject.$And as [Expression, Expression] };\n\t\t} else if (annotationObject.$Or !== undefined) {\n\t\t\tvalue = { type: \"Or\", $Or: annotationObject.$Or as [Expression, Expression] };\n\t\t} else if (annotationObject.$Not !== undefined) {\n\t\t\tvalue = { type: \"Not\", $Not: annotationObject.$Not as Expression };\n\t\t} else if (annotationObject.$Eq !== undefined) {\n\t\t\tvalue = { type: \"Eq\", $Eq: annotationObject.$Eq as [Expression, Expression] };\n\t\t} else if (annotationObject.$Ne !== undefined) {\n\t\t\tvalue = { type: \"Ne\", $Ne: annotationObject.$Ne as [Expression, Expression] };\n\t\t} else if (annotationObject.$Gt !== undefined) {\n\t\t\tvalue = { type: \"Gt\", $Gt: annotationObject.$Gt as [Expression, Expression] };\n\t\t} else if (annotationObject.$Ge !== undefined) {\n\t\t\tvalue = { type: \"Ge\", $Ge: annotationObject.$Ge as [Expression, Expression] };\n\t\t} else if (annotationObject.$Lt !== undefined) {\n\t\t\tvalue = { type: \"Lt\", $Lt: annotationObject.$Lt as [Expression, Expression] };\n\t\t} else if (annotationObject.$Le !== undefined) {\n\t\t\tvalue = { type: \"Le\", $Le: annotationObject.$Le as [Expression, Expression] };\n\t\t} else if (annotationObject.$Apply !== undefined) {\n\t\t\tvalue = { type: \"Apply\", $Apply: annotationObject.$Apply, $Function: annotationObject.$Function } as ApplyExpression;\n\t\t} else if (annotationObject.$AnnotationPath !== undefined) {\n\t\t\tvalue = { type: \"AnnotationPath\", AnnotationPath: annotationObject.$AnnotationPath };\n\t\t} else if (annotationObject.$EnumMember !== undefined) {\n\t\t\tvalue = { type: \"EnumMember\", EnumMember: annotationObject.$EnumMember };\n\t\t} else {\n\t\t\tvalue = {\n\t\t\t\ttype: \"Record\",\n\t\t\t\tRecord: parseAnnotationObject(annotationObject, currentTarget, annotationsLists, oCapabilities) as AnnotationRecord\n\t\t\t};\n\t\t}\n\t}\n\treturn {\n\t\tname: propertyKey,\n\t\tvalue\n\t};\n}\n\nfunction parseAnnotationObject(\n\tannotationObject: MetaModelAnnotation,\n\tcurrentObjectTarget: string,\n\tannotationsLists: Record<string, AnnotationList>,\n\toCapabilities: EnvironmentCapabilities\n): Expression | AnnotationRecord {\n\tlet parsedAnnotationObject: Expression | AnnotationRecord;\n\tif (annotationObject === null) {\n\t\tparsedAnnotationObject = { type: \"Null\" };\n\t} else if (typeof annotationObject === \"string\") {\n\t\tparsedAnnotationObject = { type: \"String\", String: annotationObject };\n\t} else if (typeof annotationObject === \"boolean\") {\n\t\tparsedAnnotationObject = { type: \"Bool\", Bool: annotationObject };\n\t} else if (typeof annotationObject === \"number\") {\n\t\tparsedAnnotationObject = { type: \"Int\", Int: annotationObject };\n\t} else if (Array.isArray(annotationObject)) {\n\t\tconst parsedAnnotationCollection = {\n\t\t\tcollection: annotationObject.map((subAnnotationObject, subAnnotationIndex) =>\n\t\t\t\tparseAnnotationObject(subAnnotationObject, `${currentObjectTarget}/${subAnnotationIndex}`, annotationsLists, oCapabilities)\n\t\t\t) as Collection\n\t\t};\n\t\tif (annotationObject.length > 0) {\n\t\t\tif (annotationObject[0].hasOwnProperty(\"$PropertyPath\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"PropertyPath\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Path\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"Path\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$NavigationPropertyPath\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"NavigationPropertyPath\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$AnnotationPath\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"AnnotationPath\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Type\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"Record\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$If\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"If\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$And\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"And\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Or\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"Or\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Eq\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"Eq\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Ne\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"Ne\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Not\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"Not\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Gt\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"Gt\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Ge\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"Ge\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Lt\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"Lt\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Le\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"Le\";\n\t\t\t} else if (annotationObject[0].hasOwnProperty(\"$Apply\")) {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"Apply\";\n\t\t\t} else if (typeof annotationObject[0] === \"object\") {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"Record\";\n\t\t\t} else {\n\t\t\t\tparsedAnnotationCollection.collection.type = \"String\";\n\t\t\t}\n\t\t}\n\t} else if (typeof annotationObject === \"object\") {\n\t\tif (annotationObject.$AnnotationPath !== undefined) {\n\t\t\tparsedAnnotationObject = { type: \"AnnotationPath\", AnnotationPath: annotationObject.$AnnotationPath };\n\t\t} else if (annotationObject.$Path !== undefined) {\n\t\t\tparsedAnnotationObject = { type: \"Path\", Path: annotationObject.$Path };\n\t\t} else if (annotationObject.$Decimal !== undefined) {\n\t\t\tparsedAnnotationObject = { type: \"Decimal\", Decimal: parseFloat(annotationObject.$Decimal) };\n\t\t} else if (annotationObject.$PropertyPath !== undefined) {\n\t\t\tparsedAnnotationObject = { type: \"PropertyPath\", PropertyPath: annotationObject.$PropertyPath };\n\t\t} else if (annotationObject.$If !== undefined) {\n\t\t\tparsedAnnotationObject = { type: \"If\", $If: annotationObject.$If as [Expression, Expression, Expression] };\n\t\t} else if (annotationObject.$And !== undefined) {\n\t\t\tparsedAnnotationObject = { type: \"And\", $And: annotationObject.$And as [Expression, Expression] };\n\t\t} else if (annotationObject.$Or !== undefined) {\n\t\t\tparsedAnnotationObject = { type: \"Or\", $Or: annotationObject.$Or as [Expression, Expression] };\n\t\t} else if (annotationObject.$Not !== undefined) {\n\t\t\tparsedAnnotationObject = { type: \"Not\", $Not: annotationObject.$Not as Expression };\n\t\t} else if (annotationObject.$Eq !== undefined) {\n\t\t\tparsedAnnotationObject = { type: \"Eq\", $Eq: annotationObject.$Eq as [Expression, Expression] };\n\t\t} else if (annotationObject.$Ne !== undefined) {\n\t\t\tparsedAnnotationObject = { type: \"Ne\", $Ne: annotationObject.$Ne as [Expression, Expression] };\n\t\t} else if (annotationObject.$Gt !== undefined) {\n\t\t\tparsedAnnotationObject = { type: \"Gt\", $Gt: annotationObject.$Gt as [Expression, Expression] };\n\t\t} else if (annotationObject.$Ge !== undefined) {\n\t\t\tparsedAnnotationObject = { type: \"Ge\", $Ge: annotationObject.$Ge as [Expression, Expression] };\n\t\t} else if (annotationObject.$Lt !== undefined) {\n\t\t\tparsedAnnotationObject = { type: \"Lt\", $Lt: annotationObject.$Lt as [Expression, Expression] };\n\t\t} else if (annotationObject.$Le !== undefined) {\n\t\t\tparsedAnnotationObject = { type: \"Le\", $Le: annotationObject.$Le as [Expression, Expression] };\n\t\t} else if (annotationObject.$Apply !== undefined) {\n\t\t\tparsedAnnotationObject = {\n\t\t\t\ttype: \"Apply\",\n\t\t\t\t$Apply: annotationObject.$Apply,\n\t\t\t\t$Function: annotationObject.$Function\n\t\t\t} as ApplyExpression;\n\t\t} else if (annotationObject.$NavigationPropertyPath !== undefined) {\n\t\t\tparsedAnnotationObject = {\n\t\t\t\ttype: \"NavigationPropertyPath\",\n\t\t\t\tNavigationPropertyPath: annotationObject.$NavigationPropertyPath\n\t\t\t};\n\t\t} else if (annotationObject.$EnumMember !== undefined) {\n\t\t\tparsedAnnotationObject = {\n\t\t\t\ttype: \"EnumMember\",\n\t\t\t\tEnumMember: annotationObject.$EnumMember\n\t\t\t};\n\t\t} else {\n\t\t\tconst parsedAnnotationObjectRecord: AnnotationRecord = {\n\t\t\t\ttype: \"Record\",\n\t\t\t\tpropertyValues: []\n\t\t\t};\n\t\t\tif (annotationObject.$Type) {\n\t\t\t\tparsedAnnotationObjectRecord.type = annotationObject.$Type;\n\t\t\t}\n\t\t\tconst propertyValues: PropertyValue[] = [];\n\t\t\tObject.keys(annotationObject).forEach((propertyKey) => {\n\t\t\t\tif (\n\t\t\t\t\tpropertyKey !== \"$Type\" &&\n\t\t\t\t\tpropertyKey !== \"$If\" &&\n\t\t\t\t\tpropertyKey !== \"$Apply\" &&\n\t\t\t\t\tpropertyKey !== \"$And\" &&\n\t\t\t\t\tpropertyKey !== \"$Or\" &&\n\t\t\t\t\tpropertyKey !== \"$Ne\" &&\n\t\t\t\t\tpropertyKey !== \"$Gt\" &&\n\t\t\t\t\tpropertyKey !== \"$Ge\" &&\n\t\t\t\t\tpropertyKey !== \"$Lt\" &&\n\t\t\t\t\tpropertyKey !== \"$Le\" &&\n\t\t\t\t\tpropertyKey !== \"$Not\" &&\n\t\t\t\t\tpropertyKey !== \"$Eq\" &&\n\t\t\t\t\t!propertyKey.startsWith(\"@\")\n\t\t\t\t) {\n\t\t\t\t\tpropertyValues.push(\n\t\t\t\t\t\tparsePropertyValue(annotationObject[propertyKey], propertyKey, currentObjectTarget, annotationsLists, oCapabilities)\n\t\t\t\t\t);\n\t\t\t\t} else if (propertyKey.startsWith(\"@\")) {\n\t\t\t\t\t// Annotation of annotation\n\t\t\t\t\tcreateAnnotationLists(\n\t\t\t\t\t\t{ [propertyKey]: annotationObject[propertyKey] },\n\t\t\t\t\t\tcurrentObjectTarget,\n\t\t\t\t\t\tannotationsLists,\n\t\t\t\t\t\toCapabilities\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\tparsedAnnotationObjectRecord.propertyValues = propertyValues;\n\t\t\tparsedAnnotationObject = parsedAnnotationObjectRecord;\n\t\t}\n\t}\n\treturn parsedAnnotationObject!;\n}\nfunction getOrCreateAnnotationList(target: string, annotationsLists: Record<string, AnnotationList>): AnnotationList {\n\tif (!annotationsLists.hasOwnProperty(target)) {\n\t\tannotationsLists[target] = {\n\t\t\ttarget: target,\n\t\t\tannotations: []\n\t\t};\n\t}\n\treturn annotationsLists[target];\n}\n\nfunction createReferenceFacetId(referenceFacet: MetaModelType<ReferenceFacet>): string | undefined {\n\tconst id = referenceFacet.ID ?? referenceFacet.Target?.$AnnotationPath;\n\treturn id ? prepareId(id) : id;\n}\n\nfunction removeChartAnnotations(annotationObject: MetaModelType<HeaderFacets> | MetaModelType<DataFieldAbstractTypes>[]): unknown[] {\n\treturn annotationObject.filter((oRecord: MetaModelType<FacetTypes> | MetaModelType<DataFieldAbstractTypes>): boolean => {\n\t\tconst recordAsRefFacet = oRecord as MetaModelType<ReferenceFacet>;\n\t\tif (recordAsRefFacet.Target && recordAsRefFacet.Target.$AnnotationPath) {\n\t\t\treturn !recordAsRefFacet.Target.$AnnotationPath.includes(`@${UIAnnotationTerms.Chart}`);\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t});\n}\n\nfunction removeIBNAnnotations(annotationObject: MetaModelType<DataFieldAbstractTypes>[]): MetaModelType<DataFieldAbstractTypes>[] {\n\treturn annotationObject.filter((oRecord: MetaModelType<DataFieldAbstractTypes>): boolean => {\n\t\treturn oRecord.$Type !== UIAnnotationTypes.DataFieldForIntentBasedNavigation;\n\t});\n}\n\nfunction handlePresentationVariant(\n\tannotationObject: ExpandPathType<AnnotationPath<Chart | DataPoint | LineItem>>[]\n): ExpandPathType<AnnotationPath<Chart | DataPoint | LineItem>>[] {\n\treturn annotationObject.filter((oRecord): boolean => {\n\t\treturn oRecord.$AnnotationPath !== `@${UIAnnotationTerms.Chart}`;\n\t});\n}\n\nfunction createAnnotationLists(\n\tannotationObjects: Record<string, unknown>,\n\tannotationTarget: string,\n\tannotationLists: Record<string, AnnotationList>,\n\toCapabilities: EnvironmentCapabilities\n): void {\n\tif (Object.keys(annotationObjects).length === 0) {\n\t\treturn;\n\t}\n\tconst outAnnotationObject = getOrCreateAnnotationList(annotationTarget, annotationLists);\n\tif (!oCapabilities.MicroChart) {\n\t\tdelete annotationObjects[`@${UIAnnotationTerms.Chart}`];\n\t} else {\n\t\toCapabilities.loadLibrary?.(\"sap.suite.ui.microchart\");\n\t}\n\n\tfor (const annotationKey in annotationObjects) {\n\t\tlet annotationObject = annotationObjects[annotationKey];\n\t\tswitch (annotationKey) {\n\t\t\tcase `@${UIAnnotationTerms.HeaderFacets}`:\n\t\t\t\tif (!oCapabilities.MicroChart) {\n\t\t\t\t\tannotationObject = removeChartAnnotations(annotationObject as MetaModelType<HeaderFacets>);\n\t\t\t\t\tannotationObjects[annotationKey] = annotationObject;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase `@${UIAnnotationTerms.Identification}`:\n\t\t\t\tif (!oCapabilities.IntentBasedNavigation) {\n\t\t\t\t\tannotationObject = removeIBNAnnotations(annotationObject as MetaModelType<DataFieldAbstractTypes>[]);\n\t\t\t\t\tannotationObjects[annotationKey] = annotationObject;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase `@${UIAnnotationTerms.LineItem}`:\n\t\t\t\tif (!oCapabilities.IntentBasedNavigation) {\n\t\t\t\t\tannotationObject = removeIBNAnnotations(annotationObject as MetaModelType<DataFieldAbstractTypes>[]);\n\t\t\t\t\tannotationObjects[annotationKey] = annotationObject;\n\t\t\t\t}\n\t\t\t\tif (!oCapabilities.MicroChart) {\n\t\t\t\t\tannotationObject = removeChartAnnotations(annotationObject as MetaModelType<DataFieldAbstractTypes>[]);\n\t\t\t\t\tannotationObjects[annotationKey] = annotationObject;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase `@${UIAnnotationTerms.FieldGroup}`:\n\t\t\t\tconst fieldGroupAnnotation = annotationObject as MetaModelType<FieldGroup>;\n\t\t\t\tif (!oCapabilities.IntentBasedNavigation && fieldGroupAnnotation.Data) {\n\t\t\t\t\tfieldGroupAnnotation.Data = removeIBNAnnotations(fieldGroupAnnotation.Data);\n\t\t\t\t\tannotationObjects[annotationKey] = annotationObject;\n\t\t\t\t}\n\t\t\t\tif (!oCapabilities.MicroChart && fieldGroupAnnotation.Data) {\n\t\t\t\t\tfieldGroupAnnotation.Data = removeChartAnnotations(\n\t\t\t\t\t\tfieldGroupAnnotation.Data\n\t\t\t\t\t) as MetaModelType<DataFieldAbstractTypes>[];\n\t\t\t\t\tannotationObjects[annotationKey] = annotationObject;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase `@${UIAnnotationTerms.PresentationVariant}`:\n\t\t\t\tconst presentationVariant = annotationObject as MetaModelType<PresentationVariant>;\n\t\t\t\tif (!oCapabilities.Chart && presentationVariant.Visualizations) {\n\t\t\t\t\tpresentationVariant.Visualizations = handlePresentationVariant(presentationVariant.Visualizations);\n\t\t\t\t\tannotationObjects[annotationKey] = annotationObject;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase `@com.sap.vocabularies.Common.v1.DraftRoot`:\n\t\t\t\t// This scenario is needed for enabling semantic filtering on DraftAdministrativeData-filters. As of now the SingleRange annotation is read by the\n\t\t\t\t// FieldHelper, which should not include any propertyspecific logic. We will remove this once the FieldHelper receives the SingleRange data from\n\t\t\t\t// the converter or having it set is no longer a prerequisite for the semantic filtering.\n\t\t\t\tconst filterRestrictions = annotationObjects[`@Org.OData.Capabilities.V1.FilterRestrictions`] as\n\t\t\t\t\t| MetaModelType<FilterRestrictions>\n\t\t\t\t\t| undefined;\n\t\t\t\tif (filterRestrictions?.FilterExpressionRestrictions?.length) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!filterRestrictions.FilterExpressionRestrictions.some((FilterExpressionRestriction) => {\n\t\t\t\t\t\t\treturn FilterExpressionRestriction?.Property?.$PropertyPath.includes(\"DraftAdministrativeData\");\n\t\t\t\t\t\t})\n\t\t\t\t\t) {\n\t\t\t\t\t\tfilterRestrictions.FilterExpressionRestrictions.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$Type: \"Org.OData.Capabilities.V1.FilterExpressionRestrictionType\",\n\t\t\t\t\t\t\t\tAllowedExpressions: \"SingleRange\",\n\t\t\t\t\t\t\t\tProperty: {\n\t\t\t\t\t\t\t\t\t$PropertyPath: \"DraftAdministrativeData/CreationDateTime\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfullyQualifiedName: undefined\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$Type: \"Org.OData.Capabilities.V1.FilterExpressionRestrictionType\",\n\t\t\t\t\t\t\t\tAllowedExpressions: \"SingleRange\",\n\t\t\t\t\t\t\t\tProperty: {\n\t\t\t\t\t\t\t\t\t$PropertyPath: \"DraftAdministrativeData/LastChangeDateTime\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfullyQualifiedName: undefined\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet currentOutAnnotationObject = outAnnotationObject;\n\n\t\t// Check for annotation of annotation\n\t\tlet finalKey = annotationKey;\n\t\tconst annotationOfAnnotationSplit = annotationKey.split(\"@\");\n\t\tif (annotationOfAnnotationSplit.length > 2) {\n\t\t\tcurrentOutAnnotationObject = getOrCreateAnnotationList(\n\t\t\t\t`${annotationTarget}@${annotationOfAnnotationSplit[1]}`,\n\t\t\t\tannotationLists\n\t\t\t);\n\t\t\tfinalKey = annotationOfAnnotationSplit[2];\n\t\t} else {\n\t\t\tfinalKey = annotationOfAnnotationSplit[1];\n\t\t}\n\n\t\tconst annotationQualifierSplit = finalKey.split(\"#\");\n\t\tconst qualifier = annotationQualifierSplit[1];\n\t\tfinalKey = annotationQualifierSplit[0];\n\n\t\tconst parsedAnnotationObject: RawAnnotation = {\n\t\t\tterm: finalKey,\n\t\t\tqualifier: qualifier\n\t\t};\n\t\tlet currentAnnotationTarget = `${annotationTarget}@${parsedAnnotationObject.term}`;\n\t\tif (qualifier) {\n\t\t\tcurrentAnnotationTarget += `#${qualifier}`;\n\t\t}\n\t\tconst annotationObjectToParse = annotationObject as MetaModelAnnotation;\n\t\tif (annotationObjectToParse === null) {\n\t\t\tparsedAnnotationObject.value = { type: \"Null\" };\n\t\t} else if (typeof annotationObjectToParse === \"string\") {\n\t\t\tparsedAnnotationObject.value = { type: \"String\", String: annotationObjectToParse };\n\t\t} else if (typeof annotationObjectToParse === \"boolean\") {\n\t\t\tparsedAnnotationObject.value = { type: \"Bool\", Bool: annotationObjectToParse };\n\t\t} else if (typeof annotationObjectToParse === \"number\") {\n\t\t\tparsedAnnotationObject.value = { type: \"Int\", Int: annotationObjectToParse };\n\t\t} else if (Array.isArray(annotationObjectToParse)) {\n\t\t\tparsedAnnotationObject.collection = annotationObjectToParse.map((subAnnotationObject, subAnnotationIndex) =>\n\t\t\t\tparseAnnotationObject(\n\t\t\t\t\tsubAnnotationObject,\n\t\t\t\t\t`${currentAnnotationTarget}/${subAnnotationIndex}`,\n\t\t\t\t\tannotationLists,\n\t\t\t\t\toCapabilities\n\t\t\t\t)\n\t\t\t) as Collection;\n\t\t\tif (annotationObjectToParse.length > 0) {\n\t\t\t\tif (annotationObjectToParse[0].hasOwnProperty(\"$PropertyPath\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"PropertyPath\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$Path\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"Path\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$NavigationPropertyPath\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"NavigationPropertyPath\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$AnnotationPath\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"AnnotationPath\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$Type\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"Record\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$If\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"If\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$Or\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"Or\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$Eq\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"Eq\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$Ne\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"Ne\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$Not\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"Not\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$Gt\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"Gt\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$Ge\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"Ge\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$Lt\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"Lt\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$Le\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"Le\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$And\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"And\";\n\t\t\t\t} else if (annotationObjectToParse[0].hasOwnProperty(\"$Apply\")) {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"Apply\";\n\t\t\t\t} else if (typeof annotationObjectToParse[0] === \"object\") {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"Record\";\n\t\t\t\t} else {\n\t\t\t\t\tparsedAnnotationObject.collection.type = \"String\";\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (typeof annotationObjectToParse === \"object\") {\n\t\t\tif (annotationObjectToParse.$If !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = { type: \"If\", $If: annotationObjectToParse.$If as [Expression, Expression, Expression] };\n\t\t\t} else if (annotationObjectToParse.$And !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = { type: \"And\", $And: annotationObjectToParse.$And as [Expression, Expression] };\n\t\t\t} else if (annotationObjectToParse.$Or !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = { type: \"Or\", $Or: annotationObjectToParse.$Or as [Expression, Expression] };\n\t\t\t} else if (annotationObjectToParse.$Not !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = { type: \"Not\", $Not: annotationObjectToParse.$Not as Expression };\n\t\t\t} else if (annotationObjectToParse.$Eq !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = { type: \"Eq\", $Eq: annotationObjectToParse.$Eq as [Expression, Expression] };\n\t\t\t} else if (annotationObjectToParse.$Ne !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = { type: \"Ne\", $Ne: annotationObjectToParse.$Ne as [Expression, Expression] };\n\t\t\t} else if (annotationObjectToParse.$Gt !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = { type: \"Gt\", $Gt: annotationObjectToParse.$Gt as [Expression, Expression] };\n\t\t\t} else if (annotationObjectToParse.$Ge !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = { type: \"Ge\", $Ge: annotationObjectToParse.$Ge as [Expression, Expression] };\n\t\t\t} else if (annotationObjectToParse.$Lt !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = { type: \"Lt\", $Lt: annotationObjectToParse.$Lt as [Expression, Expression] };\n\t\t\t} else if (annotationObjectToParse.$Le !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = { type: \"Le\", $Le: annotationObjectToParse.$Le as [Expression, Expression] };\n\t\t\t} else if (annotationObjectToParse.$Apply !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = {\n\t\t\t\t\ttype: \"Apply\",\n\t\t\t\t\t$Apply: annotationObjectToParse.$Apply,\n\t\t\t\t\t$Function: annotationObjectToParse.$Function\n\t\t\t\t} as ApplyExpression;\n\t\t\t} else if (annotationObjectToParse.$Path !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = { type: \"Path\", Path: annotationObjectToParse.$Path };\n\t\t\t} else if (annotationObjectToParse.$AnnotationPath !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = {\n\t\t\t\t\ttype: \"AnnotationPath\",\n\t\t\t\t\tAnnotationPath: annotationObjectToParse.$AnnotationPath\n\t\t\t\t};\n\t\t\t} else if (annotationObjectToParse.$Decimal !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = { type: \"Decimal\", Decimal: parseFloat(annotationObjectToParse.$Decimal) };\n\t\t\t} else if (annotationObjectToParse.$EnumMember !== undefined) {\n\t\t\t\tparsedAnnotationObject.value = {\n\t\t\t\t\ttype: \"EnumMember\",\n\t\t\t\t\tEnumMember: annotationObjectToParse.$EnumMember\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tconst record: AnnotationRecord = {\n\t\t\t\t\tpropertyValues: []\n\t\t\t\t};\n\t\t\t\tif (annotationObjectToParse.$Type) {\n\t\t\t\t\tconst typeValue = annotationObjectToParse.$Type;\n\t\t\t\t\trecord.type = `${typeValue}`;\n\t\t\t\t}\n\t\t\t\tconst propertyValues: { name: string; value: Expression }[] = [];\n\t\t\t\tfor (const propertyKey in annotationObjectToParse) {\n\t\t\t\t\tif (propertyKey !== \"$Type\" && !propertyKey.startsWith(\"@\")) {\n\t\t\t\t\t\tpropertyValues.push(\n\t\t\t\t\t\t\tparsePropertyValue(\n\t\t\t\t\t\t\t\tannotationObjectToParse[propertyKey],\n\t\t\t\t\t\t\t\tpropertyKey,\n\t\t\t\t\t\t\t\tcurrentAnnotationTarget,\n\t\t\t\t\t\t\t\tannotationLists,\n\t\t\t\t\t\t\t\toCapabilities\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (propertyKey.startsWith(\"@\")) {\n\t\t\t\t\t\t// Annotation of record\n\t\t\t\t\t\tcreateAnnotationLists(\n\t\t\t\t\t\t\t{ [propertyKey]: annotationObjectToParse[propertyKey] },\n\t\t\t\t\t\t\tcurrentAnnotationTarget,\n\t\t\t\t\t\t\tannotationLists,\n\t\t\t\t\t\t\toCapabilities\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trecord.propertyValues = propertyValues;\n\t\t\t\tparsedAnnotationObject.record = record;\n\t\t\t}\n\t\t}\n\t\tcurrentOutAnnotationObject.annotations.push(parsedAnnotationObject);\n\t}\n}\n\nfunction prepareProperty(\n\tpropertyDefinition: MetaModelProperty,\n\tentityTypeObject: RawEntityType | RawComplexType,\n\tpropertyName: string\n): RawProperty {\n\treturn {\n\t\t_type: \"Property\",\n\t\tname: propertyName,\n\t\tfullyQualifiedName: `${entityTypeObject.fullyQualifiedName}/${propertyName}`,\n\t\ttype: propertyDefinition.$Type,\n\t\tmaxLength: propertyDefinition.$MaxLength,\n\t\tprecision: propertyDefinition.$Precision,\n\t\tscale: propertyDefinition.$Scale,\n\t\tnullable: propertyDefinition.$Nullable ?? true\n\t};\n}\n\nfunction prepareNavigationProperty(\n\tnavPropertyDefinition: MetaModelNavigationProperty,\n\tentityTypeObject: RawEntityType | RawComplexType,\n\tnavPropertyName: string\n): RawV4NavigationProperty {\n\tlet referentialConstraint: ReferentialConstraint[] = [];\n\tif (navPropertyDefinition.$ReferentialConstraint) {\n\t\treferentialConstraint = Object.keys(navPropertyDefinition.$ReferentialConstraint).map((sourcePropertyName) => {\n\t\t\treturn {\n\t\t\t\tsourceTypeName: entityTypeObject.name,\n\t\t\t\tsourceProperty: sourcePropertyName,\n\t\t\t\ttargetTypeName: navPropertyDefinition.$Type,\n\t\t\t\ttargetProperty: navPropertyDefinition.$ReferentialConstraint[sourcePropertyName]\n\t\t\t};\n\t\t});\n\t}\n\tconst navigationProperty: RawV4NavigationProperty = {\n\t\t_type: \"NavigationProperty\",\n\t\tname: navPropertyName,\n\t\tfullyQualifiedName: `${entityTypeObject.fullyQualifiedName}/${navPropertyName}`,\n\t\tpartner: navPropertyDefinition.$Partner,\n\t\tisCollection: navPropertyDefinition.$isCollection ? navPropertyDefinition.$isCollection : false,\n\t\tcontainsTarget: !!navPropertyDefinition.$ContainsTarget,\n\t\ttargetTypeName: navPropertyDefinition.$Type,\n\t\treferentialConstraint\n\t};\n\n\treturn navigationProperty;\n}\n\nfunction prepareNavigationPropertyBinding(\n\tnavigationPropertyBinding: Record<string, string> | undefined,\n\tentityContainerName: string\n): RawNavigationPropertyBinding {\n\tif (navigationPropertyBinding) {\n\t\treturn Object.fromEntries(\n\t\t\tObject.entries(navigationPropertyBinding).map(([path, target]) => [path, `${entityContainerName}/${target}`])\n\t\t);\n\t}\n\n\treturn {};\n}\n\nfunction prepareEntitySet(entitySetDefinition: MetaModelEntitySet, entitySetName: string, entityContainerName: string): RawEntitySet {\n\treturn {\n\t\t_type: \"EntitySet\",\n\t\tname: entitySetName,\n\t\tnavigationPropertyBinding: prepareNavigationPropertyBinding(entitySetDefinition.$NavigationPropertyBinding, entityContainerName),\n\t\tentityTypeName: entitySetDefinition.$Type,\n\t\tfullyQualifiedName: `${entityContainerName}/${entitySetName}`\n\t};\n}\n\nfunction prepareSingleton(singletonDefinition: MetaModelSingleton, singletonName: string, entityContainerName: string): RawSingleton {\n\treturn {\n\t\t_type: \"Singleton\",\n\t\tname: singletonName,\n\t\tnavigationPropertyBinding: prepareNavigationPropertyBinding(singletonDefinition.$NavigationPropertyBinding, entityContainerName),\n\t\tentityTypeName: singletonDefinition.$Type,\n\t\tfullyQualifiedName: `${entityContainerName}/${singletonName}`,\n\t\tnullable: true\n\t};\n}\n\nfunction prepareActionImport(\n\tactionImport: MetaModelActionImport | MetaModelFunctionImport,\n\tactionImportName: string,\n\tentityContainerName: string\n): RawActionImport {\n\treturn {\n\t\t_type: \"ActionImport\",\n\t\tname: actionImportName,\n\t\tfullyQualifiedName: `${entityContainerName}/${actionImportName}`,\n\t\tactionName: actionImport.$kind === \"ActionImport\" ? actionImport.$Action : actionImport.$Function\n\t};\n}\n\nfunction prepareTypeDefinition(typeDefinition: MetaModelTypeDefinition, typeName: string, namespacePrefix: string): RawTypeDefinition {\n\tconst typeObject: RawTypeDefinition = {\n\t\t_type: \"TypeDefinition\",\n\t\tname: typeName.substring(namespacePrefix.length),\n\t\tfullyQualifiedName: typeName,\n\t\tunderlyingType: typeDefinition.$UnderlyingType\n\t};\n\treturn typeObject;\n}\n\nfunction prepareComplexType(complexTypeDefinition: MetaModelComplexType, complexTypeName: string, namespacePrefix: string): RawComplexType {\n\tconst complexTypeObject: RawComplexType = {\n\t\t_type: \"ComplexType\",\n\t\tname: complexTypeName.substring(namespacePrefix.length),\n\t\tfullyQualifiedName: complexTypeName,\n\t\tproperties: [],\n\t\tnavigationProperties: []\n\t};\n\n\tconst complexTypeProperties = Object.keys(complexTypeDefinition)\n\t\t.filter((propertyNameOrNot) => {\n\t\t\tif (propertyNameOrNot != \"$Key\" && propertyNameOrNot != \"$kind\") {\n\t\t\t\treturn complexTypeDefinition[propertyNameOrNot].$kind === \"Property\";\n\t\t\t}\n\t\t})\n\t\t.sort((a, b) => (a > b ? 1 : -1))\n\t\t.map((propertyName) => {\n\t\t\treturn prepareProperty(complexTypeDefinition[propertyName] as MetaModelProperty, complexTypeObject, propertyName);\n\t\t});\n\n\tcomplexTypeObject.properties = complexTypeProperties;\n\tconst complexTypeNavigationProperties = Object.keys(complexTypeDefinition)\n\t\t.filter((propertyNameOrNot) => {\n\t\t\tif (propertyNameOrNot != \"$Key\" && propertyNameOrNot != \"$kind\") {\n\t\t\t\treturn complexTypeDefinition[propertyNameOrNot].$kind === \"NavigationProperty\";\n\t\t\t}\n\t\t})\n\t\t.sort((a, b) => (a > b ? 1 : -1))\n\t\t.map((navPropertyName) => {\n\t\t\treturn prepareNavigationProperty(\n\t\t\t\tcomplexTypeDefinition[navPropertyName] as MetaModelNavigationProperty,\n\t\t\t\tcomplexTypeObject,\n\t\t\t\tnavPropertyName\n\t\t\t);\n\t\t});\n\tcomplexTypeObject.navigationProperties = complexTypeNavigationProperties;\n\treturn complexTypeObject;\n}\n\nfunction prepareEntityKeys(entityTypeDefinition: MetaModelEntityType, oMetaModelData: MetaModelContent): string[] {\n\tif (!entityTypeDefinition.$Key && entityTypeDefinition.$BaseType) {\n\t\treturn prepareEntityKeys(oMetaModelData[entityTypeDefinition.$BaseType] as MetaModelEntityType, oMetaModelData);\n\t}\n\treturn entityTypeDefinition.$Key ?? []; //handling of entity types without key as well as basetype\n}\n\nfunction prepareEntityType(\n\tentityTypeDefinition: MetaModelEntityType,\n\tentityTypeName: string,\n\tnamespacePrefix: string,\n\tmetaModelData: MetaModelContent,\n\tignoreDatafieldDefault: boolean\n): RawEntityType {\n\tconst entityType: RawEntityType = {\n\t\t_type: \"EntityType\",\n\t\tname: entityTypeName.substring(namespacePrefix.length),\n\t\tfullyQualifiedName: entityTypeName,\n\t\tkeys: [],\n\t\tentityProperties: [],\n\t\tnavigationProperties: [],\n\t\tactions: {}\n\t};\n\n\tfor (const key in entityTypeDefinition) {\n\t\tconst value = entityTypeDefinition[key];\n\n\t\tswitch (value.$kind) {\n\t\t\tcase \"Property\":\n\t\t\t\tconst property = prepareProperty(value, entityType, key);\n\t\t\t\tentityType.entityProperties.push(property);\n\t\t\t\tbreak;\n\t\t\tcase \"NavigationProperty\":\n\t\t\t\tconst navigationProperty = prepareNavigationProperty(value, entityType, key);\n\t\t\t\tentityType.navigationProperties.push(navigationProperty);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tentityType.keys = prepareEntityKeys(entityTypeDefinition, metaModelData)\n\t\t.map((entityKey) => entityType.entityProperties.find((property) => property.name === entityKey))\n\t\t.filter((property) => property !== undefined) as RawEntityType[\"keys\"];\n\n\tconst entityTypeAnnotations = metaModelData.$Annotations[entityType.fullyQualifiedName] as MetaModelEntityTypeAnnotations | undefined;\n\t// Check if there are filter facets defined for the entityType and if yes, check if all of them have an ID\n\t// The ID is optional, but it is internally taken for grouping filter fields and if it's not present\n\t// a fallback ID needs to be generated here.\n\tconst filterFacets = entityTypeAnnotations?.[`@${UIAnnotationTerms.FilterFacets}`] as MetaModelType<FilterFacets>;\n\tfilterFacets?.forEach((filterFacetAnnotation: MetaModelType<ReferenceFacet>) => {\n\t\tfilterFacetAnnotation.ID = createReferenceFacetId(filterFacetAnnotation);\n\t});\n\n\t// Check if entityType has not mandatory HeaderInfo\n\tif (\n\t\t!!entityType?.keys.length &&\n\t\tmetaModelData.$Annotations[entityType.fullyQualifiedName] &&\n\t\t!entityTypeAnnotations?.[`@${UIAnnotationTerms.HeaderInfo}`]\n\t) {\n\t\tconst headerInfoAnnotation: MetaModelType<HeaderInfo> = {\n\t\t\t$Type: `${UIAnnotationTypes.HeaderInfoType}`,\n\t\t\tTypeName: `${entityType.name}`,\n\t\t\tTypeNamePlural: \"\",\n\t\t\tTitle: {\n\t\t\t\t$Type: `${UIAnnotationTypes.DataField}`,\n\t\t\t\tValue: {\n\t\t\t\t\t$Path: `${entityType.keys[0].name}`\n\t\t\t\t}\n\t\t\t} as MetaModelType<DataField>,\n\t\t\tterm: UIAnnotationTerms.HeaderInfo\n\t\t};\n\t\t// Add the missing HeaderInfo\n\t\t(metaModelData.$Annotations[entityType.fullyQualifiedName] as MetaModelEntityTypeAnnotations)[`@${UIAnnotationTerms.HeaderInfo}`] =\n\t\t\theaderInfoAnnotation;\n\t}\n\n\tfor (const entityProperty of entityType.entityProperties) {\n\t\tif (!metaModelData.$Annotations[entityProperty.fullyQualifiedName]) {\n\t\t\tmetaModelData.$Annotations[entityProperty.fullyQualifiedName] = {};\n\t\t}\n\t\tif (\n\t\t\t!ignoreDatafieldDefault &&\n\t\t\t!(metaModelData.$Annotations[entityProperty.fullyQualifiedName] as MetaModelPropertyAnnotations)[\n\t\t\t\t`@${UIAnnotationTerms.DataFieldDefault}`\n\t\t\t]\n\t\t) {\n\t\t\t(metaModelData.$Annotations[entityProperty.fullyQualifiedName] as MetaModelPropertyAnnotations)[\n\t\t\t\t`@${UIAnnotationTerms.DataFieldDefault}`\n\t\t\t] = {\n\t\t\t\t$Type: UIAnnotationTypes.DataField,\n\t\t\t\tValue: { $Path: entityProperty.name }\n\t\t\t};\n\t\t}\n\t}\n\n\treturn entityType;\n}\nfunction prepareAction(actionRawData: MetaModelAction, actionName: string, namespacePrefix: string): RawAction {\n\tlet overloadParameters: MetaModelAction[\"$Parameter\"];\n\tif (actionRawData.$kind === \"Function\") {\n\t\t// function - overload includes all parameters (bound entity type _and_ other parameters)\n\t\toverloadParameters = actionRawData.$Parameter ?? [];\n\t} else {\n\t\t// action - overload is the first parameter or the empty unbound overload in case of an unbound action\n\t\toverloadParameters = actionRawData.$IsBound ? [actionRawData.$Parameter[0]] : [];\n\t}\n\n\tconst overload = overloadParameters\n\t\t.map((parameter) => (parameter.$isCollection ? `Collection(${parameter.$Type})` : parameter.$Type))\n\t\t.join(\",\");\n\n\tconst fullyQualifiedName = `${actionName}(${overload})`;\n\n\tconst parameters = actionRawData.$Parameter ?? [];\n\treturn {\n\t\t_type: \"Action\",\n\t\tname: actionName.substring(namespacePrefix.length),\n\t\tfullyQualifiedName,\n\t\tisBound: actionRawData.$IsBound ?? false,\n\t\tisFunction: actionRawData.$kind === \"Function\",\n\t\tsourceType: overloadParameters[0]?.$Type ?? \"\",\n\t\treturnType: actionRawData.$ReturnType?.$Type ?? \"\",\n\t\treturnCollection: actionRawData.$ReturnType?.$isCollection ?? false,\n\t\tparameters: parameters.map((param) => ({\n\t\t\t_type: \"ActionParameter\",\n\t\t\tfullyQualifiedName: `${fullyQualifiedName}/${param.$Name}`,\n\t\t\tisCollection: param.$isCollection ?? false,\n\t\t\tname: param.$Name,\n\t\t\ttype: param.$Type,\n\t\t\tnullable: param.$Nullable ?? false,\n\t\t\tmaxLength: param.$MaxLength,\n\t\t\tprecision: param.$Precision,\n\t\t\tscale: param.$Scale\n\t\t}))\n\t};\n}\n\nfunction parseEntityContainer(\n\tnamespacePrefix: string,\n\tentityContainerName: string,\n\tentityContainerMetadata: MetaModelEntityContainer,\n\tschema: RawSchema\n): void {\n\tschema.entityContainer = {\n\t\t_type: \"EntityContainer\",\n\t\tname: entityContainerName.substring(namespacePrefix.length),\n\t\tfullyQualifiedName: entityContainerName\n\t};\n\n\tfor (const elementName in entityContainerMetadata) {\n\t\tconst elementValue = entityContainerMetadata[elementName];\n\t\tswitch (elementValue.$kind) {\n\t\t\tcase \"EntitySet\":\n\t\t\t\tschema.entitySets.push(prepareEntitySet(elementValue, elementName, entityContainerName));\n\t\t\t\tbreak;\n\n\t\t\tcase \"Singleton\":\n\t\t\t\tschema.singletons.push(prepareSingleton(elementValue, elementName, entityContainerName));\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionImport\":\n\t\t\tcase \"ActionImport\":\n\t\t\t\tschema.actionImports.push(prepareActionImport(elementValue, elementName, entityContainerName));\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction parseAnnotations(annotations: Record<string, MetaModelAnnotations>, capabilities: EnvironmentCapabilities): AnnotationList[] {\n\tconst annotationLists: Record<string, AnnotationList> = {};\n\tfor (const target in annotations) {\n\t\tcreateAnnotationLists(annotations[target], target, annotationLists, capabilities);\n\t}\n\treturn Object.values(annotationLists);\n}\n\ntype MetaModelSchema = {\n\t$kind: \"Schema\";\n};\ntype MetaModelEntitySet = {\n\t$kind: \"EntitySet\";\n\t$Type: string;\n\t$NavigationPropertyBinding?: Record<string, string>;\n};\n\ntype MetaModelTypes<T extends Record<string, unknown>> = {\n\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t// @ts-ignore\n\t[key in keyof T]: MetaModelType<T[key]>;\n};\nexport type MetaModelEntityTypeAnnotations = Rename<\"@Org.OData.Capabilities.V1.\", MetaModelTypes<EntityTypeAnnotations_Capabilities>> &\n\tRename<\"@com.sap.vocabularies.UI.v1.\", MetaModelTypes<EntityTypeAnnotations_UI>>;\n\nexport type MetaModelEntitySetAnnotations = Rename<\"@Org.OData.Capabilities.V1.\", MetaModelTypes<EntitySetAnnotations_Capabilities>> &\n\tRename<\"@com.sap.vocabularies.UI.v1.\", MetaModelTypes<EntitySetAnnotations_UI>>;\n\nexport type MetaModelPropertyAnnotations = Rename<\"@com.sap.vocabularies.Common.v1.\", MetaModelTypes<PropertyAnnotations_Common>> &\n\tRename<\"@com.sap.vocabularies.UI.v1.\", MetaModelTypes<PropertyAnnotations_UI>> &\n\tRename<\"@Org.OData.Core.V1.\", MetaModelTypes<PropertyAnnotations_Core>> &\n\tRename<\"@Org.OData.Capabilities.V1.\", MetaModelTypes<PropertyAnnotations_Capabilities>> &\n\tRename<\"@Org.OData.Measures.V1.\", MetaModelTypes<PropertyAnnotations_Measures>> &\n\tRename<\"@com.sap.vocabularies.Analytics.v1.\", MetaModelTypes<PropertyAnnotations_Analytics>> &\n\tRename<\"@com.sap.vocabularies.Communication.v1.\", MetaModelTypes<PropertyAnnotations_Communication>> &\n\tRename<\"@com.sap.vocabularies.PersonalData.v1.\", MetaModelTypes<PropertyAnnotations_PersonalData>> &\n\tRename<\"@com.sap.vocabularies.Session.v1.\", MetaModelTypes<PropertyAnnotations_Session>> & {\n\t\t\"@com.sap.vocabularies.Common.v1.Text@com.sap.vocabularies.UI.v1.TextArrangement\": MetaModelEnum<TextArrangement>;\n\t};\ntype MetaModelActionImport = {\n\t$kind: \"ActionImport\";\n\t$Action: string;\n};\ntype MetaModelFunctionImport = {\n\t$kind: \"FunctionImport\";\n\t$Function: string;\n};\ntype MetaModelSingleton = {\n\t$kind: \"Singleton\";\n\t$Type: string;\n\t$NavigationPropertyBinding?: Record<string, string>;\n};\ntype MetaModelEntityContainer = {\n\t$kind: \"EntityContainer\";\n} & {\n\t[name: string]: MetaModelEntitySet | MetaModelSingleton | MetaModelActionImport | MetaModelFunctionImport;\n};\ntype MetaModelProperty = {\n\t$kind: \"Property\";\n\t$Type: string;\n\t$MaxLength?: number;\n\t$Precision?: number;\n\t$Scale?: number;\n\t$Nullable?: boolean;\n};\ntype MetaModelNavigationProperty = {\n\t$kind: \"NavigationProperty\";\n\t$Type: string;\n\t$Partner?: string;\n\t$isCollection?: boolean;\n\t$ContainsTarget?: boolean;\n\t$ReferentialConstraint: Record<string, string>;\n};\ntype MetaModelEntityType = {\n\t$kind: \"EntityType\";\n\t$BaseType?: string;\n\t$Key: string[];\n} & {\n\t[name: string]: MetaModelProperty | MetaModelNavigationProperty;\n};\ntype MetaModelComplexType = {\n\t$kind: \"ComplexType\";\n} & {\n\t[name: string]: MetaModelProperty | MetaModelNavigationProperty;\n};\ntype MetaModelTypeDefinition = {\n\t$kind: \"TypeDefinition\";\n\t$UnderlyingType: string;\n};\ntype MetaModelObject =\n\t| MetaModelEntitySet\n\t| MetaModelSchema\n\t| MetaModelEntityContainer\n\t| MetaModelAction\n\t| MetaModelEntityType\n\t| MetaModelComplexType\n\t| MetaModelTypeDefinition;\ntype MetaModelAnnotations = MetaModelEntityTypeAnnotations | MetaModelPropertyAnnotations | MetaModelEntitySetAnnotations;\n\ntype MetaModelContent = {\n\t$Annotations: Record<string, MetaModelAnnotations>;\n} & Record<string, MetaModelObject | MetaModelObject[]>;\nfunction parseSchema(metaModelData: MetaModelContent, ignoreDatafieldDefault: boolean): RawSchema {\n\t// assuming there is only one schema/namespace\n\tconst namespacePrefix =\n\t\tObject.keys(metaModelData).find((key) => {\n\t\t\tconst metamodelObject = metaModelData[key];\n\t\t\treturn !Array.isArray(metamodelObject) && metamodelObject.$kind === \"Schema\";\n\t\t}) ?? \"\";\n\n\tconst schema: RawSchema = {\n\t\tnamespace: namespacePrefix.slice(0, -1),\n\t\tentityContainer: { _type: \"EntityContainer\", name: \"\", fullyQualifiedName: \"\" },\n\t\tentitySets: [],\n\t\tentityTypes: [],\n\t\tcomplexTypes: [],\n\t\ttypeDefinitions: [],\n\t\tsingletons: [],\n\t\tassociations: [],\n\t\tassociationSets: [],\n\t\tactions: [],\n\t\tactionImports: [],\n\t\tannotations: {}\n\t};\n\n\tconst parseMetaModelElement = (name: string, value: MetaModelObject): void => {\n\t\tswitch (value.$kind) {\n\t\t\tcase \"EntityContainer\":\n\t\t\t\tparseEntityContainer(namespacePrefix, name, value, schema);\n\t\t\t\tbreak;\n\n\t\t\tcase \"Action\":\n\t\t\tcase \"Function\":\n\t\t\t\tschema.actions.push(prepareAction(value, name, namespacePrefix));\n\t\t\t\tbreak;\n\n\t\t\tcase \"EntityType\":\n\t\t\t\tschema.entityTypes.push(prepareEntityType(value, name, namespacePrefix, metaModelData, ignoreDatafieldDefault));\n\t\t\t\tbreak;\n\n\t\t\tcase \"ComplexType\":\n\t\t\t\tschema.complexTypes.push(prepareComplexType(value, name, namespacePrefix));\n\t\t\t\tbreak;\n\n\t\t\tcase \"TypeDefinition\":\n\t\t\t\tschema.typeDefinitions.push(prepareTypeDefinition(value, name, namespacePrefix));\n\t\t\t\tbreak;\n\t\t\tcase \"EntitySet\":\n\t\t\tcase \"Schema\":\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\tfor (const elementName in metaModelData) {\n\t\tconst elementValue = metaModelData[elementName];\n\n\t\tif (Array.isArray(elementValue)) {\n\t\t\t// value can be an array in case of actions or functions\n\t\t\tfor (const subElementValue of elementValue) {\n\t\t\t\tparseMetaModelElement(elementName, subElementValue);\n\t\t\t}\n\t\t} else {\n\t\t\tparseMetaModelElement(elementName, elementValue);\n\t\t}\n\t}\n\n\treturn schema;\n}\n\nexport function parseMetaModel(\n\tmetaModel: ODataMetaModel,\n\tcapabilities: EnvironmentCapabilities = DefaultEnvironmentCapabilities,\n\tignoreDatafieldDefault = false\n): RawMetadata {\n\tconst result: Omit<RawMetadata, \"schema\"> = {\n\t\tidentification: \"metamodelResult\",\n\t\tversion: \"4.0\",\n\t\treferences: []\n\t};\n\n\t// parse the schema when it is accessed for the first time\n\tAnnotationConverter.lazy(result as RawMetadata, \"schema\", () => {\n\t\tconst metaModelData = metaModel.getObject(\"/$\");\n\t\tconst schema = parseSchema(metaModelData, ignoreDatafieldDefault);\n\n\t\tAnnotationConverter.lazy(schema.annotations, \"metamodelResult\", () => parseAnnotations(metaModelData.$Annotations, capabilities));\n\n\t\treturn schema;\n\t});\n\n\treturn result as RawMetadata;\n}\n\nconst convertedMetaModelMap: Record<string, ConvertedMetadata> = {};\nconst metaModelIDMap: Record<string, String> = {};\nconst metaModelMap: WeakMap<String, ODataMetaModel> = new WeakMap();\nconst virtualPropertiesMap: Record<\n\tstring,\n\tRecord<\n\t\tstring,\n\t\t{\n\t\t\tfn?: (path: string, convertedTypes: ConvertedMetadata, relativePath?: string) => BindingToolkitExpression<unknown>;\n\t\t\tviewId?: string;\n\t\t}\n\t>\n> = {};\n\n/**\n * Convert the ODataMetaModel into another format that allows for easy manipulation of the annotations.\n * @param oMetaModel The ODataMetaModel\n * @param oCapabilities The current capabilities\n * @returns An object containing object-like annotations\n */\nexport function convertTypes(oMetaModel: ODataMetaModel, oCapabilities?: EnvironmentCapabilities): ConvertedMetadata {\n\tconst metaModelID = (oMetaModel as { id?: string }).id!;\n\tif (!convertedMetaModelMap.hasOwnProperty(metaModelID)) {\n\t\tconst parsedOutput = parseMetaModel(oMetaModel, oCapabilities);\n\t\ttry {\n\t\t\tconvertedMetaModelMap[metaModelID] = AnnotationConverter.convert(parsedOutput);\n\t\t\tvirtualPropertiesMap[metaModelID] = {\n\t\t\t\tcriticality: { fn: getVirtualCriticalityExpression }\n\t\t\t};\n\t\t\tconst metaModelSymbol = new String(metaModelID);\n\t\t\tmetaModelIDMap[metaModelID] = metaModelSymbol;\n\t\t\tmetaModelMap.set(metaModelSymbol, oMetaModel);\n\t\t} catch (oError) {\n\t\t\tthrow new Error(oError as string);\n\t\t}\n\t}\n\treturn convertedMetaModelMap[metaModelID];\n}\n\n/**\n * Registers a virtual property for a given metadata object.\n * This allows for adding custom properties that are not part of the original model but can be computed or derived based on existing metadata.\n * @param convertedTypes The metadata object for which the virtual property is being registered.\n * @param propertyName The name of the virtual property to register.\n * @param fnVirtualProperty A callback function that generates the value of the virtual property. The function takes the path, metadata, and an optional relative path as arguments.\n * @param viewId The identifier for the view associated with the virtual property.\n */\nexport function registerVirtualProperty(\n\tconvertedTypes: ConvertedMetadata,\n\tpropertyName: string,\n\tfnVirtualProperty: (path: string, convertedTypes: ConvertedMetadata, relativePath?: string) => BindingToolkitExpression<unknown>,\n\tviewId: string\n): void {\n\tconst id = Object.keys(convertedMetaModelMap).find((id: string) => convertedMetaModelMap[id] === convertedTypes) ?? \"\";\n\tif (!virtualPropertiesMap[id]) {\n\t\tvirtualPropertiesMap[id] = {};\n\t}\n\tvirtualPropertiesMap[id][propertyName] = { fn: fnVirtualProperty, viewId };\n}\nexport function getMetaModelById(id: string): ODataMetaModel | undefined {\n\tconst symbol = metaModelIDMap[id];\n\treturn metaModelMap.get(symbol);\n}\nexport function getConvertedTypes(oContext: Context): ConvertedMetadata {\n\tconst oMetaModel = oContext.getModel() as unknown as ODataMetaModel;\n\tif (!oMetaModel.isA(\"sap.ui.model.odata.v4.ODataMetaModel\")) {\n\t\tthrow new Error(\"This should only be called on a ODataMetaModel\");\n\t}\n\treturn convertTypes(oMetaModel);\n}\n\nexport function deleteModelCacheData(oMetaModel: ODataMetaModel): void {\n\tif (oMetaModel) {\n\t\tdelete convertedMetaModelMap[(oMetaModel as unknown as { id: string }).id];\n\t}\n}\n\nexport function convertMetaModelContext(oMetaModelContext: Context, bIncludeVisitedObjects: true): undefined | ResolvedTarget;\nexport function convertMetaModelContext(oMetaModelContext: Context): undefined | ServiceObject | ActionParameter | RecordComplexType;\nexport function convertMetaModelContext(\n\toMetaModelContext: Context,\n\tbIncludeVisitedObjects = false\n): undefined | ServiceObject | ActionParameter | RecordComplexType | ResolvedTarget {\n\tconst oConvertedMetadata = convertTypes(oMetaModelContext.getModel() as ODataMetaModel);\n\tconst sPath = oMetaModelContext.getPath();\n\n\tconst aPathSplit = sPath.split(\"/\");\n\tlet firstPart = aPathSplit[1];\n\tlet beginIndex = 2;\n\tif (oConvertedMetadata.entityContainer.fullyQualifiedName === firstPart) {\n\t\tfirstPart = aPathSplit[2];\n\t\tbeginIndex++;\n\t}\n\tlet targetEntitySet: EntitySet | Singleton = oConvertedMetadata.entitySets.find(\n\t\t(entitySet) => entitySet.name === firstPart\n\t) as EntitySet;\n\tif (!targetEntitySet) {\n\t\ttargetEntitySet = oConvertedMetadata.singletons.find((singleton) => singleton.name === firstPart) as Singleton;\n\t}\n\tlet relativePath = aPathSplit.slice(beginIndex).join(\"/\");\n\n\tconst localObjects: ServiceObject[] = [targetEntitySet];\n\twhile (relativePath && relativePath.length > 0 && relativePath.startsWith(\"$NavigationPropertyBinding\")) {\n\t\tlet relativeSplit = relativePath.split(\"/\");\n\t\tlet idx = 0;\n\t\tlet currentEntitySet, sNavPropToCheck;\n\n\t\trelativeSplit = relativeSplit.slice(1); // Removing \"$NavigationPropertyBinding\"\n\t\twhile (!currentEntitySet && relativeSplit.length > idx) {\n\t\t\tif (relativeSplit[idx] !== \"$NavigationPropertyBinding\") {\n\t\t\t\t// Finding the correct entitySet for the navigaiton property binding example: \"Set/_SalesOrder\"\n\t\t\t\tsNavPropToCheck = relativeSplit\n\t\t\t\t\t.slice(0, idx + 1)\n\t\t\t\t\t.join(\"/\")\n\t\t\t\t\t.replace(\"/$NavigationPropertyBinding\", \"\");\n\t\t\t\tcurrentEntitySet = targetEntitySet && targetEntitySet.navigationPropertyBinding[sNavPropToCheck];\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t\tif (!currentEntitySet) {\n\t\t\t// Fall back to Single nav prop if entitySet is not found.\n\t\t\tsNavPropToCheck = relativeSplit[0];\n\t\t}\n\t\tconst aNavProps = sNavPropToCheck?.split(\"/\") || [];\n\t\tlet targetEntityType = targetEntitySet && targetEntitySet.entityType;\n\t\tfor (const sNavProp of aNavProps) {\n\t\t\t// Pushing all nav props to the visited objects. example: \"Set\", \"_SalesOrder\" for \"Set/_SalesOrder\"(in NavigationPropertyBinding)\n\t\t\tconst targetNavProp = targetEntityType && targetEntityType.navigationProperties.find((navProp) => navProp.name === sNavProp);\n\t\t\tif (targetNavProp) {\n\t\t\t\tlocalObjects.push(targetNavProp);\n\t\t\t\ttargetEntityType = targetNavProp.targetType;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttargetEntitySet =\n\t\t\t(targetEntitySet && currentEntitySet) || (targetEntitySet && targetEntitySet.navigationPropertyBinding[relativeSplit[0]]);\n\t\tif (targetEntitySet) {\n\t\t\t// Pushing the target entitySet to visited objects\n\t\t\tlocalObjects.push(targetEntitySet);\n\t\t}\n\t\t// Re-calculating the relative path\n\t\t// As each navigation name is enclosed between '$NavigationPropertyBinding' and '$' (to be able to access the entityset easily in the metamodel)\n\t\t// we need to remove the closing '$' to be able to switch to the next navigation\n\t\trelativeSplit = relativeSplit.slice(aNavProps.length || 1);\n\t\tif (relativeSplit.length && relativeSplit[0] === \"$\") {\n\t\t\trelativeSplit.shift();\n\t\t}\n\t\trelativePath = relativeSplit.join(\"/\");\n\t}\n\tif (relativePath.startsWith(\"$Type\")) {\n\t\t// As $Type@ is allowed as well\n\t\tif (relativePath.startsWith(\"$Type@\")) {\n\t\t\trelativePath = relativePath.replace(\"$Type\", \"\");\n\t\t} else {\n\t\t\t// We're anyway going to look on the entityType...\n\t\t\trelativePath = aPathSplit.slice(3).join(\"/\");\n\t\t}\n\t}\n\tif (targetEntitySet && relativePath.length) {\n\t\tconst oTarget = targetEntitySet.entityType.resolvePath(relativePath, bIncludeVisitedObjects);\n\t\tif (oTarget) {\n\t\t\tif (bIncludeVisitedObjects) {\n\t\t\t\toTarget.visitedObjects = localObjects.concat(oTarget.visitedObjects);\n\t\t\t}\n\t\t} else if (targetEntitySet.entityType && targetEntitySet.entityType.actions) {\n\t\t\t// if target is an action or an action parameter\n\t\t\tconst actions = targetEntitySet.entityType && targetEntitySet.entityType.actions;\n\t\t\tconst relativeSplit = relativePath.split(\"/\");\n\t\t\tif (actions[relativeSplit[0]]) {\n\t\t\t\tconst action = actions[relativeSplit[0]];\n\t\t\t\tif (relativeSplit[1] && action.parameters) {\n\t\t\t\t\tconst parameterName = relativeSplit[1];\n\t\t\t\t\treturn action.parameters.find((parameter) => {\n\t\t\t\t\t\treturn parameter.fullyQualifiedName.endsWith(`/${parameterName}`);\n\t\t\t\t\t});\n\t\t\t\t} else if (relativePath.length === 1) {\n\t\t\t\t\treturn action;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn oTarget;\n\t} else {\n\t\tif (bIncludeVisitedObjects) {\n\t\t\treturn {\n\t\t\t\ttarget: targetEntitySet,\n\t\t\t\tvisitedObjects: localObjects\n\t\t\t};\n\t\t}\n\t\treturn targetEntitySet;\n\t}\n}\n\nexport type ResolvedTarget<T extends ServiceObjectAndAnnotation = ServiceObject> = {\n\ttarget?: T extends ServiceObject ? T : AnnotationTerm<T>;\n\tvisitedObjects: ServiceObjectAndAnnotation[];\n};\n\nexport function getInvolvedDataModelObjects<T>(oMetaModelContext: Context, oEntitySetMetaModelContext?: Context): DataModelObjectPath<T> {\n\tconst oConvertedMetadata = convertTypes(oMetaModelContext.getModel() as ODataMetaModel);\n\tconst metaModelContext = convertMetaModelContext(oMetaModelContext, true) as ResolvedTarget;\n\tlet targetEntitySetLocation;\n\tif (oEntitySetMetaModelContext && oEntitySetMetaModelContext.getPath() !== \"/\") {\n\t\ttargetEntitySetLocation = getInvolvedDataModelObjects(oEntitySetMetaModelContext);\n\t}\n\treturn getInvolvedDataModelObjectFromPath<T>(metaModelContext, oConvertedMetadata, targetEntitySetLocation);\n}\n\nexport function getInvolvedDataModelObjectFromPath<T>(\n\tmetaModelContext: ResolvedTarget,\n\tconvertedTypes: ConvertedMetadata,\n\ttargetEntitySetLocation?: DataModelObjectContext,\n\tonlyServiceObjects = false\n): DataModelObjectPath<T> {\n\tconst dataModelObjects = metaModelContext.visitedObjects.filter(\n\t\t(visitedObject) => isServiceObject(visitedObject) && !isEntityType(visitedObject) && !isEntityContainer(visitedObject)\n\t);\n\tif (\n\t\tisServiceObject(metaModelContext.target) &&\n\t\t!isEntityType(metaModelContext.target) &&\n\t\tdataModelObjects[dataModelObjects.length - 1] !== metaModelContext.target &&\n\t\t!onlyServiceObjects\n\t) {\n\t\tdataModelObjects.push(metaModelContext.target);\n\t}\n\n\tconst navigationProperties: NavigationProperty[] = [];\n\tconst rootEntitySet: EntitySet = dataModelObjects[0] as EntitySet;\n\n\tlet currentEntitySet: EntitySet | Singleton | undefined = rootEntitySet;\n\tlet currentEntityType: EntityType = rootEntitySet.entityType;\n\tlet currentObject: ServiceObjectAndAnnotation | undefined;\n\tlet navigatedPath = [];\n\n\tfor (let i = 1; i < dataModelObjects.length; i++) {\n\t\tcurrentObject = dataModelObjects[i];\n\n\t\tif (isNavigationProperty(currentObject)) {\n\t\t\tnavigatedPath.push(currentObject.name);\n\t\t\tnavigationProperties.push(currentObject);\n\t\t\tcurrentEntityType = currentObject.targetType;\n\t\t\tconst boundEntitySet: EntitySet | Singleton | undefined = currentEntitySet?.navigationPropertyBinding[navigatedPath.join(\"/\")];\n\t\t\tif (boundEntitySet !== undefined) {\n\t\t\t\tcurrentEntitySet = boundEntitySet;\n\t\t\t\tnavigatedPath = [];\n\t\t\t}\n\t\t}\n\t\tif (isEntitySet(currentObject) || isSingleton(currentObject)) {\n\t\t\tcurrentEntitySet = currentObject;\n\t\t\tcurrentEntityType = currentEntitySet.entityType;\n\t\t}\n\t}\n\n\tif (navigatedPath.length > 0) {\n\t\t// Path without NavigationPropertyBinding --> no target entity set\n\t\tcurrentEntitySet = undefined;\n\t}\n\n\tif (targetEntitySetLocation && targetEntitySetLocation.startingEntitySet !== rootEntitySet) {\n\t\t// In case the entityset is not starting from the same location it may mean that we are doing too much work earlier for some reason\n\t\t// As such we need to redefine the context source for the targetEntitySetLocation\n\t\tconst startingIndex = dataModelObjects.indexOf(targetEntitySetLocation.startingEntitySet);\n\t\tif (startingIndex !== -1) {\n\t\t\t// If it's not found I don't know what we can do (probably nothing)\n\t\t\tconst requiredDataModelObjects = dataModelObjects.slice(0, startingIndex);\n\t\t\ttargetEntitySetLocation.startingEntitySet = rootEntitySet;\n\t\t\ttargetEntitySetLocation.navigationProperties = requiredDataModelObjects\n\t\t\t\t.filter(isNavigationProperty)\n\t\t\t\t.concat(targetEntitySetLocation.navigationProperties as NavigationProperty[]);\n\t\t}\n\t}\n\tconst outDataModelPath = {\n\t\tstartingEntitySet: rootEntitySet,\n\t\ttargetEntitySet: currentEntitySet,\n\t\ttargetEntityType: currentEntityType,\n\t\ttargetObject: metaModelContext.target,\n\t\tnavigationProperties,\n\t\tcontextLocation: targetEntitySetLocation,\n\t\tconvertedTypes: convertedTypes\n\t};\n\tif (!isServiceObject(outDataModelPath.targetObject) && onlyServiceObjects) {\n\t\toutDataModelPath.targetObject = isServiceObject(currentObject) ? currentObject : undefined;\n\t}\n\tif (!outDataModelPath.contextLocation) {\n\t\toutDataModelPath.contextLocation = outDataModelPath;\n\t}\n\treturn outDataModelPath as DataModelObjectPath<T>;\n}\n\n/**\n * This function fetches the technical and semantic keys of entity sets.\n * @param context\n * @returns The object containing technical and semantic keys of the entity.\n */\nexport function getInvolvedDataModelObjectEntityKeys(context: ODataV4Context): {\n\ttechnicalKeys: string[];\n\tsemanticKeys: string[];\n} {\n\tconst metaModel = context?.getModel()?.getMetaModel();\n\tif (metaModel) {\n\t\tconst metaPath = metaModel.getMetaPath(context?.getPath());\n\t\tconst dataModel = getInvolvedDataModelObjects(metaModel.getMetaContext(metaPath));\n\t\tconst rootSemanticKeys = dataModel.targetEntityType.annotations.Common?.SemanticKey;\n\t\tlet semanticKeys: string[] = [];\n\t\tif (rootSemanticKeys) {\n\t\t\tsemanticKeys = rootSemanticKeys.map((key) => {\n\t\t\t\treturn key.value;\n\t\t\t});\n\t\t}\n\t\tconst rootTechnicalKeys = dataModel.targetEntityType.keys;\n\t\tlet technicalKeys: string[] = [];\n\t\tif (rootTechnicalKeys) {\n\t\t\ttechnicalKeys = rootTechnicalKeys.map((key) => {\n\t\t\t\treturn key.name;\n\t\t\t});\n\t\t}\n\t\treturn {\n\t\t\tsemanticKeys: semanticKeys,\n\t\t\ttechnicalKeys: technicalKeys\n\t\t};\n\t}\n\treturn { technicalKeys: [], semanticKeys: [] };\n}\n\nexport function extractModelAndPath<T extends string | undefined>(metaPath: T): { id: string | undefined; path: T } {\n\tif (metaPath?.includes(\">\")) {\n\t\tconst [modelId, ...path] = metaPath.split(\">\");\n\t\tconst targetPath = path.join(\">\");\n\t\treturn { id: modelId, path: targetPath as T };\n\t} else {\n\t\treturn { id: undefined, path: metaPath };\n\t}\n}\n\n/**\n * Fetches the DataModel Object Path for a given target path.\n * @param targetPath\n * @param metaModel\n * @returns DataModel Object Path for target path\n */\nexport function getInvolvedDataModelObjectsForTargetPath<T>(\n\ttargetPath: string,\n\tmetaModel?: ODataMetaModel\n): DataModelObjectPath<T> | undefined {\n\tconst metaPath = metaModel?.getMetaPath(targetPath);\n\tconst metaContext = metaPath ? metaModel?.getContext(metaPath) : undefined;\n\treturn metaContext && getInvolvedDataModelObjects(metaContext);\n}\n\n/**\n * Gets the binding expression of a virtual path.\n * @param path The virtual path\n * @param convertedTypes The converted metadata\n * @returns DataModel Object Path for target path\n */\nexport function getVirtualBindingExpression(\n\tpath: string,\n\tconvertedTypes: ConvertedMetadata\n): { expression: BindingToolkitExpression<unknown>; viewId?: string } {\n\tconst virtualKey = \"@$ui5.fe.virtual.\";\n\tif (path.includes(virtualKey)) {\n\t\tconst id = Object.keys(convertedMetaModelMap).find((id) => convertedMetaModelMap[id] === convertedTypes);\n\t\tif (id && virtualPropertiesMap[id]) {\n\t\t\tconst relativePath = path.substring(0, path.indexOf(convertedTypes.namespace));\n\t\t\tconst pathInfos = path.split(virtualKey);\n\t\t\tif (pathInfos.length === 2) {\n\t\t\t\tconst method = pathInfos[1];\n\t\t\t\tconst virtualProperty = pathInfos[0].replace(relativePath, \"\");\n\t\t\t\tconst virtualPropertyFn = virtualPropertiesMap[id][method];\n\t\t\t\tif (virtualPropertyFn?.fn) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\texpression: virtualPropertyFn.fn(virtualProperty, convertedTypes, relativePath),\n\t\t\t\t\t\tviewId: virtualPropertyFn.viewId\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { expression: constant(undefined) };\n\t}\n\treturn { expression: constant(undefined) };\n}\n\n/**\n * Gets the binding expression of a criticality.\n * @param path The path pointing to a DataField or DataPoint\n * @param convertedTypes The converted metadata\n * @param relativePath The relative path of the binding expression\n * @returns The binding expression of the criticality\n */\nfunction getVirtualCriticalityExpression(\n\tpath: string,\n\tconvertedTypes: ConvertedMetadata,\n\trelativePath?: string\n): BindingToolkitExpression<unknown> {\n\tconst criticalityProperty = convertedTypes.resolvePath<DataPointType | DataFieldAbstractTypes>(path)?.target?.Criticality;\n\tconst criticalityExpression = criticalityProperty\n\t\t? getExpressionFromAnnotation(\n\t\t\t\tcriticalityProperty as unknown as PropertyAnnotationValue<PrimitiveType>,\n\t\t\t\t[],\n\t\t\t\tundefined,\n\t\t\t\t(bindingPath: string) => {\n\t\t\t\t\treturn relativePath ? `${relativePath}${bindingPath}` : bindingPath;\n\t\t\t\t}\n\t\t  )\n\t\t: undefined;\n\tif (!criticalityExpression) {\n\t\treturn constant(undefined);\n\t}\n\treturn formatResult([criticalityExpression], \"._formatters.CriticalityFormatter#getCriticality\");\n}\n"],"mappings":"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","ignoreList":[]}