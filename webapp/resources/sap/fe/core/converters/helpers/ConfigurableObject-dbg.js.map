{"version":3,"names":["Placement","_exports","setFirstAnchor","sorted","delayedPositioningItems","firstAnchor","beforePositioningItems","Object","keys","filter","delayedPositioningItemKey","placement","Before","length","firstPositioningItem","find","includes","anchor","push","isAlreadyPositioned","isPositionable","insertIndex","isDelayedItemPositionable","positioningItems","possibleAnchors","map","itemKey","some","delayedAnchorKey","every","reorderPositioningItems","rootElements","itemsPerKey","endElement","sortedKeys","defaultAnchors","first","undefined","last","key","forEach","positionItemKey","orderPositioningItemRecursively","outElements","element","index","position","getInsertIndexOrDelayItem","anchorItem","indexOf","addedAnchor","After","Log","warning","splice","OverrideType","isArrayConfig","config","applyOverride","overwritableKeys","sourceItem","customElement","outItem","overwritableKey","hasOwnProperty","call","overrideConfig","subItem","subConfig","Array","isArray","insertCustomElements","customElements","arguments","rootElement","End","customElementKey","adjustedCustomElementKey"],"sourceRoot":".","sources":["ConfigurableObject.ts"],"sourcesContent":["import Log from \"sap/base/Log\";\n\nexport type Position = {\n\tanchor?: string;\n\tplacement: Placement;\n};\n\nexport enum Placement {\n\tAfter = \"After\",\n\tBefore = \"Before\",\n\tEnd = \"End\"\n}\nexport type ConfigurableObjectKey = string;\nexport type ConfigurableObject = Positionable & {\n\tkey: ConfigurableObjectKey;\n};\n\ntype MakeNestedArrayCustom<T> = {\n\t[K in keyof T]: T[K] extends Array<infer U extends ConfigurableObject> ? Record<string, CustomElement<U>> : T[K];\n};\n\nexport type CustomElement<T extends ConfigurableObject> = MakeNestedArrayCustom<T> & {\n\tposition: Position;\n\tmenu?: unknown[];\n};\n\nexport type Positionable = {\n\tposition?: Position;\n};\n\nexport type ConfigurableRecord<T> = Record<ConfigurableObjectKey, T>;\n\n/**\n * Determine the first anchor among delayedPositioningItems. If multiple items are 'Before' positioned,\n * find one that does not reference another positioning item in the list. If only one is 'Before' positioned,\n * make it the first anchor. If none are 'Before' positioned, use the first item in the list. The selected\n * first anchor is added to the sorted list.\n * @param sorted List of sorted items. The determined first anchor is added to this list.\n * @param delayedPositioningItems Key-value pair where the key is the item and the value is its position.\n * @returns The key of the determined first anchor of the delayedPositioningItems-list.\n * @example\n *   const sorted = [];\n *   const delayedPositioningItems = {\n *     \"item1\": { placement: Placement.Before, anchor: \"item2\" },\n *     \"item2\": { placement: Placement.After, anchor: \"item1\" }\n *   };\n *   setFirstAnchor(sorted, delayedPositioningItems);\n *   ==>\n *   sorted: [\"item1\"]\n */\nconst setFirstAnchor = function (sorted: string[], delayedPositioningItems: Record<string, Position>): string {\n\tlet firstAnchor;\n\t// If all custom elements reference each other, take\n\t// a) a before placed custom element, which is not referencing any other \"before\"-set one,\n\t// b) the first before placed custom element\n\t// c) the first overall custom element\n\tconst beforePositioningItems = Object.keys(delayedPositioningItems).filter(\n\t\t(delayedPositioningItemKey) => delayedPositioningItems[delayedPositioningItemKey].placement === Placement.Before\n\t);\n\tif (beforePositioningItems.length > 1) {\n\t\t// Find positioningItem which does not reference another positioningItem in the list\n\t\tconst firstPositioningItem = beforePositioningItems.find(\n\t\t\t(delayedPositioningItemKey) => !beforePositioningItems.includes(delayedPositioningItems[delayedPositioningItemKey].anchor!)\n\t\t);\n\t\tfirstAnchor = firstPositioningItem || beforePositioningItems[0];\n\t} else if (beforePositioningItems.length) {\n\t\tfirstAnchor = beforePositioningItems[0];\n\t} else {\n\t\tfirstAnchor = Object.keys(delayedPositioningItems)[0];\n\t}\n\tsorted.push(firstAnchor);\n\treturn firstAnchor;\n};\n\n/**\n * Checks if a given anchor string is already present in a sorted array.\n * @param anchor The anchor string related to the item.\n * @param sorted The array of sorted keys.\n * @returns Returns whether the anchor was already positioned.\n */\nconst isAlreadyPositioned = (anchor: string, sorted: string[]): boolean => {\n\treturn sorted.includes(anchor);\n};\n\n/**\n * Checks if an item can be positioned based on its insert index and presence in a sorted array.\n * @param insertIndex The index where an item is intended to be inserted.\n * @param anchor The anchor string related to the item.\n * @param sorted The array of sorted keys.\n * @returns Returns whether the anchor can already be positioned.\n */\nconst isPositionable = (insertIndex: number, anchor: string, sorted: string[]): boolean => {\n\tif (insertIndex === -1) {\n\t\treturn false;\n\t}\n\treturn !isAlreadyPositioned(anchor, sorted);\n};\n\n/**\n * Checks if any item in the delayedPositioningItems object can be positioned based on the presence of its anchor in a sorted array or the fact that all remaining items self reference.\n * @param delayedPositioningItems Key-value pair where the key is the item and the value is its position.\n * @param sorted The array of sorted keys.\n * @param positioningItems\n * @param possibleAnchors\n * @returns Returns whether any delayedPositioningItem can be positioned.\n */\nconst isDelayedItemPositionable = (\n\tdelayedPositioningItems: Record<string, Position>,\n\tsorted: string[],\n\tpositioningItems: Record<string, Position>,\n\tpossibleAnchors: string[]\n): boolean => {\n\treturn (\n\t\t!!(\n\t\t\tObject.keys(delayedPositioningItems).length &&\n\t\t\tObject.keys(delayedPositioningItems)\n\t\t\t\t.map((itemKey) => delayedPositioningItems[itemKey].anchor!)\n\t\t\t\t.some((delayedAnchorKey) => sorted.includes(delayedAnchorKey))\n\t\t) ||\n\t\t// First recursive loop only\n\t\t(Object.keys(positioningItems).length === possibleAnchors.length &&\n\t\t\t// Only if all others were handled\n\t\t\tpossibleAnchors.length - sorted.length === Object.keys(delayedPositioningItems).length &&\n\t\t\t// Check for circular dependency\n\t\t\tObject.keys(delayedPositioningItems).every((itemKey) =>\n\t\t\t\tObject.keys(delayedPositioningItems).includes(delayedPositioningItems[itemKey].anchor!)\n\t\t\t))\n\t);\n};\n\n/**\n * Reorders a given array of elements based on a predefined positioning map.\n * @template T A type that extends the ConfigurableObject.\n * @param rootElements The initial array of elements to reorder.\n * @param itemsPerKey A map of elements to reorder, keyed by an identifier.\n * @param positioningItems A map defining the order of elements, keyed by an identifier.\n * @param endElement Only one element can have position end as of now, only used for StandardAction::Cancel\n * @returns A new array of elements, reordered according to the given positioning map. No default positioning is kept, only the rootElements position configuration is kept\n */\nconst reorderPositioningItems = <T extends ConfigurableObject>(\n\trootElements: T[],\n\titemsPerKey: Record<string, T>,\n\tpositioningItems: Record<string, Position>,\n\tendElement: T | undefined\n): Array<T> => {\n\tconst sortedKeys: string[] = [];\n\n\t// Calculate initial default anchors to place elements without explicit anchors\n\tconst defaultAnchors: { first?: string; last?: string } = { first: undefined, last: undefined };\n\tdefaultAnchors.first = rootElements.length ? rootElements[0].key : undefined;\n\tdefaultAnchors.last = rootElements.length ? rootElements[rootElements.length - 1].key : undefined;\n\n\tconst delayedPositioningItems: Record<string, Required<Position>> = {};\n\tObject.keys(positioningItems).forEach((positionItemKey) => {\n\t\torderPositioningItemRecursively(positioningItems, positionItemKey, sortedKeys, defaultAnchors, delayedPositioningItems, []);\n\t});\n\n\tconst outElements = sortedKeys.map((key) => itemsPerKey[key]);\n\t// Only keep explicitly set positions, needed for using the output of insertCustomElements as next input\n\toutElements.forEach((element, index) => {\n\t\tif (element.position && !itemsPerKey[element.key]?.position) {\n\t\t\tdelete outElements[index].position;\n\t\t}\n\t});\n\n\tif (endElement) {\n\t\toutElements.push(endElement);\n\t}\n\n\treturn outElements;\n};\n\n/**\n * Determines the insertion index for an item in a sorted array, or delays its positioning if necessary.\n * @param sorted The array of sorted keys.\n * @param anchor The anchor string related to the item.\n * @param anchorItem The position metadata for the item to insert.\n * @param delayedPositioningItems Key-value pair where the key is the item and the value is its position.\n * @param positioningItems A map defining the order of elements, keyed by an identifier.\n * @param possibleAnchors\n * @returns The index at which the item should be inserted in the sorted array, or -1 if the item's positioning should be delayed.\n */\nconst getInsertIndexOrDelayItem = (\n\tsorted: string[],\n\tanchor: string,\n\tanchorItem: Position,\n\tdelayedPositioningItems: Record<string, Position>,\n\tpositioningItems: Record<string, Position>,\n\tpossibleAnchors: string[]\n): number => {\n\tlet insertIndex = sorted.indexOf(anchor);\n\n\t// Take out anchor, if it's currently worked on\n\tif (Object.keys(delayedPositioningItems).includes(anchor)) {\n\t\tdelete delayedPositioningItems[anchor];\n\t}\n\n\tif (anchorItem && anchorItem.anchor && anchor !== anchorItem.anchor && !sorted.includes(anchorItem.anchor)) {\n\t\tdelayedPositioningItems[anchor] = positioningItems[anchor];\n\t\t// Solve circular dependency\n\t\tif (\n\t\t\tObject.keys(delayedPositioningItems).length &&\n\t\t\t!Object.keys(delayedPositioningItems).some((itemKey) => sorted.includes(delayedPositioningItems[itemKey].anchor!)) &&\n\t\t\tpossibleAnchors.length - sorted.length === Object.keys(delayedPositioningItems).length\n\t\t) {\n\t\t\tconst addedAnchor = setFirstAnchor(sorted, delayedPositioningItems);\n\t\t\tdelete delayedPositioningItems[addedAnchor];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t} else if (anchor === anchorItem.anchor) {\n\t\t// Anchor references itself\n\t\tinsertIndex = sorted.length;\n\t} else {\n\t\tinsertIndex = sorted.indexOf(anchorItem.anchor!);\n\t\tif (anchorItem.placement === Placement.After) {\n\t\t\tinsertIndex++;\n\t\t}\n\t}\n\treturn insertIndex;\n};\n\n/**\n * Recursive method that order the keys based on a position information.\n * @param positioningItems A map defining the order of elements, keyed by an identifier.\n * @param anchor The anchor string related to the item.\n * @param sorted The array of sorted keys.\n * @param defaultAnchors Default anchors used to place elements without explicit anchors\n * @param defaultAnchors.first\n * @param defaultAnchors.last\n * @param delayedPositioningItems Key-value pair where the key is the item and the value is its position.\n * @param possibleAnchors For recursive addition of delayed custom elements\n */\nconst orderPositioningItemRecursively = (\n\tpositioningItems: Record<string, Position>,\n\tanchor: string,\n\tsorted: string[],\n\tdefaultAnchors: { first?: string; last?: string },\n\tdelayedPositioningItems: Record<string, Position>,\n\tpossibleAnchors: string[]\n): void => {\n\tif (isAlreadyPositioned(anchor, sorted)) {\n\t\treturn;\n\t}\n\tconst anchorItem = positioningItems[anchor];\n\tpossibleAnchors = possibleAnchors.length ? possibleAnchors : Object.keys(positioningItems); // Pass in all possible anchors independent of recursion level\n\n\t// Configuration mistakes\n\tif (anchorItem.anchor && !Object.keys(positioningItems).includes(anchorItem.anchor) && !possibleAnchors.includes(anchorItem.anchor)) {\n\t\tLog.warning(\n\t\t\t`Position anchor '${anchorItem.anchor}' not found for item '${anchor}'. Please check settings. Defaulting as if no Anchor was set.`\n\t\t);\n\t\t//Defaulting in case of misconfiguration\n\t\tpositioningItems[anchor].anchor = anchor;\n\t\tanchorItem.anchor = anchor;\n\t}\n\n\t// General defaulting\n\tif (!anchorItem.anchor) {\n\t\tanchorItem.anchor = anchorItem.placement === Placement.After ? defaultAnchors.last : defaultAnchors.first;\n\t\t// There is no possible reference anchor yet to align to\n\t\tif (anchorItem.anchor === undefined) {\n\t\t\tsetFirstAnchor(sorted, { [anchor]: anchorItem });\n\t\t}\n\t}\n\n\t// If anchor item cannot be assigned yet, delay it, otherwise get insertIndex according to configuration\n\tconst insertIndex = getInsertIndexOrDelayItem(sorted, anchor, anchorItem, delayedPositioningItems, positioningItems, possibleAnchors);\n\n\tif (isPositionable(insertIndex, anchor, sorted)) {\n\t\tsorted.splice(insertIndex, 0, anchor);\n\t}\n\n\t// Make sure that the next element without an anchor is placed after the new last one to prevent reversing the list order\n\tdefaultAnchors.last = sorted[sorted.length - 1];\n\n\t// Every time we successfully added on item we check for those we could not add so far, and add them if they have a reference now\n\tif (\n\t\tObject.keys(delayedPositioningItems).length &&\n\t\tisDelayedItemPositionable(delayedPositioningItems, sorted, positioningItems, possibleAnchors)\n\t) {\n\t\tObject.keys(delayedPositioningItems).forEach((positionItemKey) => {\n\t\t\torderPositioningItemRecursively(\n\t\t\t\t{ ...delayedPositioningItems },\n\t\t\t\tpositionItemKey,\n\t\t\t\tsorted,\n\t\t\t\tdefaultAnchors,\n\t\t\t\tdelayedPositioningItems,\n\t\t\t\tpossibleAnchors\n\t\t\t);\n\t\t});\n\t}\n};\n\nexport enum OverrideType {\n\tmerge = \"merge\",\n\toverwrite = \"overwrite\",\n\tignore = \"ignore\"\n}\ntype ArrayOverrideType<ArrayType> = OverrideKeys<ArrayType>;\n\ntype ElementType<T> = T extends unknown[] ? T[number] : T;\ntype OverrideKeys<T> = {\n\t[P in keyof T]?: OverrideType | ArrayOverrideType<ElementType<T[P]>>;\n};\n\nfunction isArrayConfig<T>(config: OverrideType | ArrayOverrideType<T> | undefined): config is ArrayOverrideType<T> {\n\treturn typeof config === \"object\";\n}\n\nfunction applyOverride<T extends ConfigurableObject>(\n\toverwritableKeys: OverrideKeys<T>,\n\tsourceItem: T | null,\n\tcustomElement: CustomElement<T>\n): T {\n\tconst outItem: T = sourceItem || (customElement as T);\n\tfor (const overwritableKey in overwritableKeys) {\n\t\tif (Object.hasOwnProperty.call(overwritableKeys, overwritableKey)) {\n\t\t\tconst overrideConfig = overwritableKeys[overwritableKey];\n\t\t\tif (sourceItem !== null) {\n\t\t\t\tswitch (overrideConfig) {\n\t\t\t\t\tcase \"overwrite\":\n\t\t\t\t\t\tif (customElement.hasOwnProperty(overwritableKey) && customElement[overwritableKey] !== undefined) {\n\t\t\t\t\t\t\tsourceItem[overwritableKey] = customElement[overwritableKey] as T[typeof overwritableKey];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"merge\":\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconst subItem = sourceItem[overwritableKey] || ([] as ConfigurableObject[]);\n\t\t\t\t\t\tlet subConfig = {};\n\t\t\t\t\t\tif (isArrayConfig(overrideConfig)) {\n\t\t\t\t\t\t\tsubConfig = overrideConfig;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Array.isArray(subItem)) {\n\t\t\t\t\t\t\tsourceItem[overwritableKey] = insertCustomElements(\n\t\t\t\t\t\t\t\tsubItem,\n\t\t\t\t\t\t\t\t(customElement && customElement[overwritableKey]) || {},\n\t\t\t\t\t\t\t\tsubConfig\n\t\t\t\t\t\t\t) as T[typeof overwritableKey];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (overrideConfig) {\n\t\t\t\t\tcase \"overwrite\":\n\t\t\t\t\t\tif (customElement.hasOwnProperty(overwritableKey) && customElement[overwritableKey] !== undefined) {\n\t\t\t\t\t\t\toutItem[overwritableKey] = customElement[overwritableKey] as T[typeof overwritableKey];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"merge\":\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tlet subConfig = {};\n\t\t\t\t\t\tif (isArrayConfig(overrideConfig)) {\n\t\t\t\t\t\t\tsubConfig = overrideConfig;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutItem[overwritableKey] = insertCustomElements(\n\t\t\t\t\t\t\t[] as ConfigurableObject[],\n\t\t\t\t\t\t\t(customElement && customElement[overwritableKey]) || {},\n\t\t\t\t\t\t\tsubConfig\n\t\t\t\t\t\t) as T[typeof overwritableKey];\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn outItem;\n}\n\n/**\n * Insert a set of custom elements in the right position in an original collection.\n *\n * Parameters for overwritableKeys and their implications:\n * \"overwrite\": The whole object gets overwritten - if the customElements include a default, this will overrule the whole rootElements configuration.\n * \"merge\": This is similar to calling insertCustomElements itself. You must include the\n * full CustomElement syntax within the customElements, including anchors, for example.\n * \"ignore\": There are no additions and no combinations. Only the rootElements object is used.\n *\n * Note - Proceed as follows in case you have defined customElements and do not want to overwrite their values with defaults:\n * Hand the rootElements into the creation function of the customElement.\n * Depending on the existence of both rootElement-configuration and customElement-configuration,\n * you must set the customElements property, for which the \"overwrite\"-property is set, explicitly to undefined.\n * @template T\n * @param rootElements A list of \"ConfigurableObject\" which means object that have a unique \"key\"\n * @param customElements An object containing extra object to add, they are indexed by a key and have a \"position\" object\n * @param overwritableKeys The list of keys from the original object that can be overwritten in case a custom element has the same \"key\"\n * @returns An ordered array of elements including the custom ones\n */\nexport function insertCustomElements<T extends ConfigurableObject>(\n\trootElements: T[],\n\tcustomElements: Record<string, CustomElement<T>>,\n\toverwritableKeys: OverrideKeys<T> = {}\n): T[] {\n\tlet endElement: T | undefined;\n\tconst positioningItems: Record<string, Required<Position>> = {};\n\tconst itemsPerKey: Record<string, T> = {};\n\n\t// Creation of initial list\n\trootElements.forEach((rootElement) => {\n\t\tif (rootElement.position?.placement === Placement.End && !endElement) {\n\t\t\tendElement = rootElement;\n\t\t} else {\n\t\t\tpositioningItems[rootElement.key] = {\n\t\t\t\tanchor: rootElement.position?.anchor || rootElement.key,\n\t\t\t\tplacement: rootElement.position?.placement || Placement.After\n\t\t\t};\n\t\t}\n\t\titemsPerKey[rootElement.key] = rootElement;\n\t});\n\n\t// Overriding of properties through customElements, depending on overwritableKeys\n\tObject.keys(customElements).forEach((customElementKey) => {\n\t\tconst customElement = customElements[customElementKey];\n\t\tconst anchor = customElement.position.anchor;\n\t\t// If no placement defined we are After\n\t\tif (!customElement.position.placement) {\n\t\t\tcustomElement.position.placement = Placement.After;\n\t\t}\n\n\t\tconst adjustedCustomElementKey = customElement.key as keyof Record<string, T>;\n\t\tif (itemsPerKey[adjustedCustomElementKey]) {\n\t\t\titemsPerKey[adjustedCustomElementKey] = applyOverride(overwritableKeys, itemsPerKey[adjustedCustomElementKey], customElement);\n\n\t\t\t//Position is overwritten for filter fields if there is a change in manifest\n\t\t\tif (anchor && customElement.position && overwritableKeys.position && overwritableKeys.position === \"overwrite\") {\n\t\t\t\tpositioningItems[adjustedCustomElementKey] = itemsPerKey[adjustedCustomElementKey].position as Required<Position>;\n\t\t\t}\n\t\t\t/**\n\t\t\t * anchor check is added to make sure change in properties in the manifest does not affect the position of the field.\n\t\t\t * Otherwise, when no position is mentioned in manifest for an altered field, the position is changed as\n\t\t\t * per the potential anchor\n\t\t\t */\n\t\t} else {\n\t\t\titemsPerKey[adjustedCustomElementKey] = applyOverride(overwritableKeys, null, customElement);\n\t\t\tpositioningItems[adjustedCustomElementKey] = customElement.position as Required<Position>;\n\t\t}\n\t});\n\n\treturn reorderPositioningItems(rootElements, itemsPerKey, positioningItems, endElement);\n}\n"],"mappings":"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","ignoreList":[],"file":"ConfigurableObject-dbg.js"}