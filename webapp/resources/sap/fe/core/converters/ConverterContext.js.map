{"version":3,"file":"ConverterContext.js","names":["isAnnotationTerm","vAnnotationPath","getDataModelPathForEntitySet","resolvedMetaPath","convertedTypes","rootEntitySet","currentEntitySet","previousEntitySet","currentEntityType","navigatedPaths","navigationProperties","objectPath","forEach","objectPart","isServiceObject","_type","push","name","targetType","navigationPropertyBinding","hasOwnProperty","join","undefined","entityType","dataModelPath","startingEntitySet","targetEntityType","targetEntitySet","contextLocation","targetObject","target","ConverterContext","manifestWrapper","diagnostics","targetDataModelPath","this","baseContextPath","getTargetObjectPath","_proto","prototype","_getEntityTypeFromFullyQualifiedName","fullyQualifiedName","entityTypes","find","startsWith","replaceAnnotation","replace","getAnnotationEntityType","annotation","annotationPath","Error","getManifestControlConfiguration","getControlConfiguration","hasEntitySetKeyInManifest","getEntitySet","length","hasContextPathKeyInManifest","getContextPath","isPathAbsolute","hasMultipleEntitySets","Object","keys","getAbsoluteAnnotationPath","sAnnotationPath","getDataModelObjectPath","getEntityContainer","entityContainer","getEntityType","getParameterEntityType","parameterEntityType","isParameterized","annotations","Common","ResultContext","getEntityTypeAnnotation","includes","isAbsolute","path","base","split","endsWith","resolveAbsolutePath","dataModelObjectPath","getInvolvedDataModelObjectFromPath","visitedObjects","converterContext","getTemplateType","getConvertedTypes","getRelativeAnnotationPath","getEntitySetBasedAnnotationPath","entityTypeFQN","match","replacedAnnotationPath","substring","getManifestWrapper","getDiagnostics","resolvePath","getConverterContextFor","contextPath","targetPath","getAnnotationsByTerm","vocabularyName","annotationTerm","annotationSources","arguments","outAnnotations","annotationSource","filter","term","reduce","previousValue","key","getRelativeModelPathFunction","convertedMetaModel","sPath","singletonPath","singletonPathVisitor","enhancedPath","enhanceDataModelPath","contextRelativePath","getContextRelativeTargetObjectPath","createConverterContextForMacro","entityName","oMetaModelContext","mergeFn","oMetaModel","isA","getModel","oConvertedMetadata","convertTypes","entitySets","entitySet","singletons","ManifestWrapper","fetchTextFromMetaModel","ModelHelper"],"sources":["./ConverterContext.ts"],"sourcesContent":["import type {\n\tAnnotationTerm,\n\tConvertedMetadata,\n\tEntityContainer,\n\tEntitySet,\n\tEntityType,\n\tNavigationProperty,\n\tResolutionTarget,\n\tServiceObject,\n\tServiceObjectAndAnnotation,\n\tSingleton\n} from \"@sap-ux/vocabularies-types\";\nimport type { RecordComplexType } from \"@sap-ux/vocabularies-types/Edm\";\nimport type { EntityTypeAnnotations } from \"@sap-ux/vocabularies-types/vocabularies/Edm_Types\";\nimport type { BaseManifestSettings, ControlManifestConfiguration, TemplateType } from \"sap/fe/core/converters/ManifestSettings\";\nimport ManifestWrapper from \"sap/fe/core/converters/ManifestWrapper\";\nimport { convertTypes, getInvolvedDataModelObjectFromPath } from \"sap/fe/core/converters/MetaModelConverter\";\nimport type { IDiagnostics, PageContextPathTarget } from \"sap/fe/core/converters/TemplateConverter\";\nimport { singletonPathVisitor } from \"sap/fe/core/helpers/BindingHelper\";\nimport ModelHelper from \"sap/fe/core/helpers/ModelHelper\";\nimport { isServiceObject } from \"sap/fe/core/helpers/TypeGuards\";\nimport type { DataModelObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport { enhanceDataModelPath, getContextRelativeTargetObjectPath, getTargetObjectPath } from \"sap/fe/core/templating/DataModelPathHelper\";\nimport type Context from \"sap/ui/model/Context\";\nimport type ODataMetaModel from \"sap/ui/model/odata/v4/ODataMetaModel\";\n\nexport type ResolvedAnnotationContext<T> = {\n\tannotation: AnnotationTerm<T> | undefined;\n\tconverterContext: ConverterContext<PageContextPathTarget>;\n};\n\n/**\n * Checks whether an object is an annotation term.\n * @param vAnnotationPath\n * @returns `true` if it's an annotation term\n */\nconst isAnnotationTerm = function <T>(vAnnotationPath: string | AnnotationTerm<T>): vAnnotationPath is AnnotationTerm<T> {\n\treturn typeof vAnnotationPath === \"object\";\n};\n\nconst getDataModelPathForEntitySet = function <T>(\n\tresolvedMetaPath: ResolutionTarget<T>,\n\tconvertedTypes: ConvertedMetadata\n): DataModelObjectPath<T> {\n\tlet rootEntitySet: EntitySet | undefined;\n\tlet currentEntitySet: EntitySet | undefined;\n\tlet previousEntitySet: EntitySet | undefined;\n\tlet currentEntityType: EntityType | undefined;\n\tlet navigatedPaths: string[] = [];\n\tconst navigationProperties: NavigationProperty[] = [];\n\tresolvedMetaPath.objectPath.forEach((objectPart: ServiceObjectAndAnnotation) => {\n\t\tif (isServiceObject(objectPart)) {\n\t\t\tswitch (objectPart._type) {\n\t\t\t\tcase \"NavigationProperty\":\n\t\t\t\t\tnavigatedPaths.push(objectPart.name);\n\t\t\t\t\tnavigationProperties.push(objectPart);\n\t\t\t\t\tcurrentEntityType = objectPart.targetType;\n\t\t\t\t\tif (previousEntitySet && previousEntitySet.navigationPropertyBinding.hasOwnProperty(navigatedPaths.join(\"/\"))) {\n\t\t\t\t\t\tcurrentEntitySet = previousEntitySet.navigationPropertyBinding[navigatedPaths.join(\"/\")] as EntitySet;\n\t\t\t\t\t\tpreviousEntitySet = currentEntitySet;\n\t\t\t\t\t\tnavigatedPaths = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentEntitySet = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"EntitySet\":\n\t\t\t\t\tif (rootEntitySet === undefined) {\n\t\t\t\t\t\trootEntitySet = objectPart;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentEntitySet = objectPart;\n\t\t\t\t\tpreviousEntitySet = currentEntitySet;\n\t\t\t\t\tcurrentEntityType = currentEntitySet?.entityType;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n\tconst dataModelPath: DataModelObjectPath<T> = {\n\t\tstartingEntitySet: rootEntitySet as EntitySet,\n\t\ttargetEntityType: currentEntityType as EntityType,\n\t\ttargetEntitySet: currentEntitySet,\n\t\tnavigationProperties: navigationProperties,\n\t\tcontextLocation: undefined,\n\t\ttargetObject: resolvedMetaPath.target,\n\t\tconvertedTypes: convertedTypes\n\t};\n\tdataModelPath.contextLocation = dataModelPath;\n\treturn dataModelPath;\n};\n\n/**\n * Create a ConverterContext object that will be used within the converters.\n * @param {ConvertedMetadata} oConvertedTypes The converted annotation and service types\n * @param {BaseManifestSettings} oManifestSettings The manifestSettings that applies to this page\n * @param {TemplateType} templateType The type of template we're looking at right now\n * @param {IDiagnostics} diagnostics The diagnostics shim\n * @param {Function} mergeFn The function to be used to perfom some deep merges between object\n * @param {DataModelObjectPath} targetDataModelPath The global path to reach the entitySet\n * @returns {ConverterContext} A converter context for the converters\n */\nclass ConverterContext<T = PageContextPathTarget> {\n\t//private manifestWrapper: ManifestWrapper;\n\n\tprivate baseContextPath: string;\n\n\tconstructor(\n\t\tprivate convertedTypes: ConvertedMetadata,\n\t\tprivate readonly manifestWrapper: ManifestWrapper,\n\t\tprivate diagnostics: IDiagnostics,\n\t\tprivate targetDataModelPath: DataModelObjectPath<T>\n\t) {\n\t\tthis.baseContextPath = getTargetObjectPath(this.targetDataModelPath);\n\t}\n\n\tprivate _getEntityTypeFromFullyQualifiedName(fullyQualifiedName: string): EntityType | undefined {\n\t\treturn this.convertedTypes.entityTypes.find((entityType) => {\n\t\t\tif (fullyQualifiedName.startsWith(entityType.fullyQualifiedName)) {\n\t\t\t\tconst replaceAnnotation = fullyQualifiedName.replace(entityType.fullyQualifiedName, \"\");\n\t\t\t\treturn replaceAnnotation.startsWith(\"/\") || replaceAnnotation.startsWith(\"@\");\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t}\n\n\t/**\n\t * Retrieve the entityType associated with an annotation object.\n\t * @param annotation The annotation object for which we want to find the entityType\n\t * @returns The EntityType the annotation refers to\n\t */\n\tgetAnnotationEntityType<TT extends ServiceObjectAndAnnotation>(\n\t\tannotation?: TT extends ServiceObject ? TT : AnnotationTerm<TT>\n\t): EntityType {\n\t\tif (annotation && typeof annotation === \"object\") {\n\t\t\tconst annotationPath = annotation.fullyQualifiedName;\n\t\t\tconst targetEntityType = this._getEntityTypeFromFullyQualifiedName(annotationPath);\n\t\t\tif (!targetEntityType) {\n\t\t\t\tthrow new Error(`Cannot find Entity Type for ${annotation.fullyQualifiedName}`);\n\t\t\t}\n\t\t\treturn targetEntityType;\n\t\t} else {\n\t\t\treturn this.targetDataModelPath.targetEntityType;\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve the manifest settings defined for a specific control within controlConfiguration.\n\t * @param annotationPath The annotation path or object to evaluate\n\t * @returns The control configuration for that specific annotation path if it exists\n\t */\n\tgetManifestControlConfiguration<TT = ControlManifestConfiguration>(annotationPath: string | AnnotationTerm<unknown>): TT {\n\t\tif (isAnnotationTerm(annotationPath)) {\n\t\t\treturn this.manifestWrapper.getControlConfiguration<TT>(\n\t\t\t\tannotationPath.fullyQualifiedName.replace(this.targetDataModelPath.targetEntityType.fullyQualifiedName, \"\")\n\t\t\t);\n\t\t}\n\t\tconst hasEntitySetKeyInManifest =\n\t\t\ttypeof this.manifestWrapper.getEntitySet() === \"string\" && this.manifestWrapper.getEntitySet()!.length > 0;\n\t\tconst hasContextPathKeyInManifest =\n\t\t\ttypeof this.manifestWrapper.getContextPath() === \"string\" && this.manifestWrapper.getContextPath()!.length > 0;\n\t\tconst isPathAbsolute = annotationPath.startsWith(\"/\");\n\t\t// In case of multiple-entitySet, we compare the entity set of the ControlConfiguration with what is specified either in the 'entitySet' or 'contextPath' manifest setting.\n\t\tif (!this.manifestWrapper.hasMultipleEntitySets()) {\n\t\t\treturn this.manifestWrapper.getControlConfiguration(annotationPath);\n\t\t} else if (\n\t\t\t!isPathAbsolute &&\n\t\t\t((hasEntitySetKeyInManifest && this.baseContextPath !== `/${this.manifestWrapper.getEntitySet()}`) ||\n\t\t\t\t(hasContextPathKeyInManifest && this.baseContextPath !== this.manifestWrapper.getContextPath()))\n\t\t) {\n\t\t\treturn this.manifestWrapper.getControlConfiguration(`${this.baseContextPath}/${annotationPath}`);\n\t\t} else if (Object.keys(this.manifestWrapper.getControlConfiguration(`${this.baseContextPath}/${annotationPath}`)).length > 0) {\n\t\t\treturn this.manifestWrapper.getControlConfiguration(`${this.baseContextPath}/${annotationPath}`);\n\t\t} else if (Object.keys(this.manifestWrapper.getControlConfiguration(annotationPath)).length > 0) {\n\t\t\treturn this.manifestWrapper.getControlConfiguration(annotationPath);\n\t\t}\n\t\treturn this.manifestWrapper.getControlConfiguration(`${this.baseContextPath}/${annotationPath}`);\n\t}\n\n\t/**\n\t * Create an absolute annotation path based on the current meta model context.\n\t * @param sAnnotationPath The relative annotation path\n\t * @returns The correct annotation path based on the current context\n\t */\n\tgetAbsoluteAnnotationPath(sAnnotationPath: string): string {\n\t\tif (!sAnnotationPath) {\n\t\t\treturn sAnnotationPath;\n\t\t}\n\t\tif (sAnnotationPath[0] === \"/\") {\n\t\t\treturn sAnnotationPath;\n\t\t}\n\t\treturn `${this.baseContextPath}/${sAnnotationPath}`;\n\t}\n\n\t/**\n\t * Retrieve the current entitySet.\n\t * @returns The current EntitySet if it exists.\n\t */\n\tgetEntitySet(): EntitySet | Singleton | undefined {\n\t\treturn this.targetDataModelPath.targetEntitySet as EntitySet | Singleton;\n\t}\n\n\t/**\n\t * Retrieve the context path.\n\t * @returns The context path of the converter.\n\t */\n\tgetContextPath(): string {\n\t\treturn this.baseContextPath;\n\t}\n\n\t/**\n\t * Retrieve the current data model object path.\n\t * @returns The current data model object path\n\t */\n\tgetDataModelObjectPath(): DataModelObjectPath<T> {\n\t\treturn this.targetDataModelPath;\n\t}\n\n\t/**\n\t * Get the EntityContainer.\n\t * @returns The current service EntityContainer\n\t */\n\tgetEntityContainer(): EntityContainer {\n\t\treturn this.convertedTypes.entityContainer;\n\t}\n\n\t/**\n\t * Get the EntityType based on the fully qualified name.\n\t * @returns The current EntityType.\n\t */\n\tgetEntityType(): EntityType {\n\t\treturn this.targetDataModelPath.targetEntityType;\n\t}\n\n\t/**\n\t * Gets the entity type of the parameter in case of a parameterized service.\n\t * @returns The entity type of the parameter\n\t */\n\tgetParameterEntityType(): EntityType {\n\t\tconst parameterEntityType = this.targetDataModelPath.startingEntitySet.entityType;\n\t\tconst isParameterized = !!parameterEntityType.annotations?.Common?.ResultContext;\n\t\treturn (isParameterized && parameterEntityType) as EntityType;\n\t}\n\n\t/**\n\t * Retrieves an annotation from an entity type based on annotation path.\n\t * @param annotationPath The annotation path to be evaluated\n\t * @returns The target annotation path as well as a converter context to go with it\n\t */\n\tgetEntityTypeAnnotation<TT extends ServiceObject | RecordComplexType>(annotationPath: string): ResolvedAnnotationContext<TT> {\n\t\tif (!annotationPath.includes(\"@\")) {\n\t\t\tthrow new Error(`Not an annotation path: '${annotationPath}'`);\n\t\t}\n\n\t\tconst isAbsolute = annotationPath.startsWith(\"/\");\n\t\tlet path: string;\n\n\t\tif (isAbsolute) {\n\t\t\t// path can be used as-is\n\t\t\tpath = annotationPath;\n\t\t} else {\n\t\t\t// build an absolute path based on the entity type (this function works on the type!)\n\t\t\tconst base = this.getContextPath().split(\"@\", 1)[0];\n\t\t\tpath = base.endsWith(\"/\") ? base + annotationPath : `${base}/${annotationPath}`;\n\t\t}\n\n\t\tconst target: ResolutionTarget<AnnotationTerm<TT>> = this.resolveAbsolutePath(path);\n\n\t\tconst dataModelObjectPath = getInvolvedDataModelObjectFromPath<PageContextPathTarget>(\n\t\t\t{ target: target.target as ServiceObject, visitedObjects: target.objectPath },\n\t\t\tthis.convertedTypes,\n\t\t\tisAbsolute ? undefined : this.targetDataModelPath.contextLocation,\n\t\t\ttrue\n\t\t);\n\n\t\treturn {\n\t\t\tannotation: target.target,\n\t\t\tconverterContext: new ConverterContext(this.convertedTypes, this.manifestWrapper, this.diagnostics, dataModelObjectPath)\n\t\t};\n\t}\n\n\t/**\n\t * Retrieve the type of template we're working on (e.g. ListReport / ObjectPage / ...).\n\t * @returns The current tenplate type\n\t */\n\tgetTemplateType(): TemplateType {\n\t\treturn this.manifestWrapper.getTemplateType();\n\t}\n\n\t/**\n\t * Retrieve the converted types.\n\t * @returns The current converted types\n\t */\n\tgetConvertedTypes(): ConvertedMetadata {\n\t\treturn this.convertedTypes;\n\t}\n\n\t/**\n\t * Retrieve a relative annotation path between an annotation path and an entity type.\n\t * @param annotationPath\n\t * @param entityType\n\t * @returns The relative anntotation path.\n\t */\n\tgetRelativeAnnotationPath(annotationPath: string, entityType: EntityType): string {\n\t\treturn annotationPath.replace(entityType.fullyQualifiedName, \"\");\n\t}\n\n\t/**\n\t * Transform an entityType based path to an entitySet based one (ui5 templating generally expect an entitySetBasedPath).\n\t * @param annotationPath\n\t * @returns The EntitySet based annotation path\n\t */\n\tgetEntitySetBasedAnnotationPath(annotationPath: string): string {\n\t\tif (!annotationPath) {\n\t\t\treturn annotationPath;\n\t\t}\n\t\tconst entityTypeFQN = this.targetDataModelPath.targetEntityType.fullyQualifiedName;\n\t\tif (\n\t\t\tthis.targetDataModelPath.targetEntitySet ||\n\t\t\t((this.baseContextPath.startsWith(\"/\") && this.baseContextPath.match(/\\//g)) || []).length > 1\n\t\t) {\n\t\t\tlet replacedAnnotationPath = annotationPath.replace(entityTypeFQN, \"/\");\n\t\t\tif (replacedAnnotationPath.length > 2 && replacedAnnotationPath[0] === \"/\" && replacedAnnotationPath[1] === \"/\") {\n\t\t\t\treplacedAnnotationPath = replacedAnnotationPath.substring(1);\n\t\t\t}\n\t\t\treturn this.baseContextPath + (replacedAnnotationPath.startsWith(\"/\") ? replacedAnnotationPath : `/${replacedAnnotationPath}`);\n\t\t} else {\n\t\t\treturn `/${annotationPath}`;\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve the manifest wrapper for the current context.\n\t * @returns The current manifest wrapper\n\t */\n\tgetManifestWrapper(): ManifestWrapper {\n\t\treturn this.manifestWrapper;\n\t}\n\n\tgetDiagnostics(): IDiagnostics {\n\t\treturn this.diagnostics;\n\t}\n\n\t/**\n\t * Retrieve the target from an absolute path.\n\t * @param path The path we want to get the target\n\t * @returns The absolute path\n\t */\n\tresolveAbsolutePath<TT>(path: string): ResolutionTarget<TT> {\n\t\treturn this.convertedTypes.resolvePath(path);\n\t}\n\n\t/**\n\t * Retrieve a new converter context, scoped for a different context path.\n\t * @param contextPath The path we want to orchestrate the converter context around\n\t * @returns The converted context for the sub path\n\t */\n\tgetConverterContextFor<K>(contextPath: string): ConverterContext<K> {\n\t\tconst resolvedMetaPath: ResolutionTarget<K> = this.convertedTypes.resolvePath<K>(contextPath);\n\t\tconst targetPath = getDataModelPathForEntitySet(resolvedMetaPath, this.convertedTypes);\n\t\treturn new ConverterContext<K>(this.convertedTypes, this.manifestWrapper, this.diagnostics, targetPath);\n\t}\n\n\t/**\n\t * Get all annotations of a given term and vocabulary on an entity type\n\t * (or on the current entity type if entityType isn't specified).\n\t * @param vocabularyName\n\t * @param annotationTerm\n\t * @param [annotationSources]\n\t * @returns All the annotation for a specific term and vocabulary from an entity type\n\t */\n\tgetAnnotationsByTerm<TT>(\n\t\tvocabularyName: keyof EntityTypeAnnotations,\n\t\tannotationTerm: string,\n\t\tannotationSources: (ServiceObject | undefined)[] = [this.getEntityType()]\n\t): AnnotationTerm<TT>[] {\n\t\tlet outAnnotations: AnnotationTerm<TT>[] = [];\n\t\tannotationSources.forEach((annotationSource) => {\n\t\t\tif (annotationSource) {\n\t\t\t\tconst annotations: Record<string, AnnotationTerm<TT> & { term: string }> =\n\t\t\t\t\tannotationSource?.annotations[vocabularyName] || {};\n\t\t\t\tif (annotations) {\n\t\t\t\t\toutAnnotations = Object.keys(annotations)\n\t\t\t\t\t\t.filter((annotation) => annotations[annotation].term === annotationTerm)\n\t\t\t\t\t\t.reduce((previousValue: AnnotationTerm<TT>[], key: string) => {\n\t\t\t\t\t\t\tpreviousValue.push(annotations[key]);\n\t\t\t\t\t\t\treturn previousValue;\n\t\t\t\t\t\t}, outAnnotations);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn outAnnotations;\n\t}\n\n\t/**\n\t * Retrieves the relative model path based on the current context path.\n\t * @returns The relative model path or undefined if the path is not resolveable\n\t */\n\tgetRelativeModelPathFunction(): Function {\n\t\tconst targetDataModelPath = this.targetDataModelPath;\n\t\tconst convertedMetaModel = this.convertedTypes;\n\t\treturn function (sPath: string) {\n\t\t\tconst singletonPath = singletonPathVisitor(sPath, convertedMetaModel, []);\n\t\t\tconst enhancedPath = enhanceDataModelPath(targetDataModelPath, sPath);\n\t\t\tconst contextRelativePath = getContextRelativeTargetObjectPath(enhancedPath, true);\n\t\t\tif (contextRelativePath) {\n\t\t\t\treturn contextRelativePath;\n\t\t\t}\n\t\t\treturn singletonPath;\n\t\t};\n\t}\n\n\t/**\n\t * Create the converter context necessary for a macro based on a metamodel context.\n\t * @param entityName\n\t * @param oMetaModelContext\n\t * @param diagnostics\n\t * @param mergeFn\n\t * @param targetDataModelPath\n\t * @param manifestWrapper\n\t * @returns The current converter context\n\t */\n\tstatic createConverterContextForMacro(\n\t\tentityName: string,\n\t\toMetaModelContext: Context | ODataMetaModel,\n\t\tdiagnostics: IDiagnostics,\n\t\tmergeFn: Function,\n\t\ttargetDataModelPath?: DataModelObjectPath<PageContextPathTarget>,\n\t\tmanifestWrapper?: ManifestWrapper\n\t): ConverterContext<PageContextPathTarget> {\n\t\tconst oMetaModel: ODataMetaModel = oMetaModelContext.isA(\"sap.ui.model.odata.v4.ODataMetaModel\")\n\t\t\t? (oMetaModelContext as ODataMetaModel)\n\t\t\t: ((oMetaModelContext as Context).getModel() as unknown as ODataMetaModel);\n\t\tconst oConvertedMetadata = convertTypes(oMetaModel);\n\t\tlet targetEntitySet: Singleton | EntitySet = oConvertedMetadata.entitySets.find(\n\t\t\t(entitySet) => entitySet.name === entityName\n\t\t) as EntitySet;\n\t\tif (!targetEntitySet) {\n\t\t\ttargetEntitySet = oConvertedMetadata.singletons.find((entitySet) => entitySet.name === entityName) as Singleton;\n\t\t}\n\t\tif (!targetDataModelPath || targetEntitySet !== targetDataModelPath.startingEntitySet) {\n\t\t\ttargetDataModelPath = {\n\t\t\t\tstartingEntitySet: targetEntitySet,\n\t\t\t\tnavigationProperties: [],\n\t\t\t\ttargetEntitySet: targetEntitySet,\n\t\t\t\t// contained entity does not have an entity set but only entity type\n\t\t\t\ttargetEntityType:\n\t\t\t\t\ttargetEntitySet?.entityType || oConvertedMetadata.entityTypes.find((entityType) => entityType.name === entityName),\n\t\t\t\ttargetObject: targetEntitySet as EntitySet,\n\t\t\t\tconvertedTypes: oConvertedMetadata\n\t\t\t};\n\t\t}\n\t\tif (!manifestWrapper) {\n\t\t\tmanifestWrapper = new ManifestWrapper({} as BaseManifestSettings);\n\t\t}\n\t\treturn new ConverterContext(oConvertedMetadata, manifestWrapper, diagnostics, targetDataModelPath);\n\t}\n\n\t/**\n\t * Resolves a metadata binding to its text.\n\t * @param path\n\t * @returns The resolved text if possible, else the input value or an empty string if the path was undefined\n\t */\n\tfetchTextFromMetaModel(path: string | undefined): string {\n\t\treturn ModelHelper.fetchTextFromMetaModel(path, this);\n\t}\n}\n\nexport default ConverterContext;\n"],"mappings":";;;;qfAoCA,MAAMA,EAAmB,SAAaC,GACrC,cAAcA,IAAoB,QACnC,EAEA,MAAMC,EAA+B,SACpCC,EACAC,GAEA,IAAIC,EACJ,IAAIC,EACJ,IAAIC,EACJ,IAAIC,EACJ,IAAIC,EAA2B,GAC/B,MAAMC,EAA6C,GACnDP,EAAiBQ,WAAWC,QAASC,IACpC,GAAIC,EAAgBD,GAAa,CAChC,OAAQA,EAAWE,OAClB,IAAK,qBACJN,EAAeO,KAAKH,EAAWI,MAC/BP,EAAqBM,KAAKH,GAC1BL,EAAoBK,EAAWK,WAC/B,GAAIX,GAAqBA,EAAkBY,0BAA0BC,eAAeX,EAAeY,KAAK,MAAO,CAC9Gf,EAAmBC,EAAkBY,0BAA0BV,EAAeY,KAAK,MACnFd,EAAoBD,EACpBG,EAAiB,EAClB,KAAO,CACNH,EAAmBgB,SACpB,CACA,MACD,IAAK,YACJ,GAAIjB,IAAkBiB,UAAW,CAChCjB,EAAgBQ,CACjB,CACAP,EAAmBO,EACnBN,EAAoBD,EACpBE,EAAoBF,GAAkBiB,WACtC,MACD,QACC,MAEH,IAED,MAAMC,EAAwC,CAC7CC,kBAAmBpB,EACnBqB,iBAAkBlB,EAClBmB,gBAAiBrB,EACjBI,qBAAsBA,EACtBkB,gBAAiBN,UACjBO,aAAc1B,EAAiB2B,OAC/B1B,eAAgBA,GAEjBoB,EAAcI,gBAAkBJ,EAChC,OAAOA,CACR,EAEA,IAUMO,EAAgB,WAKrB,SAAAA,EACS3B,EACS4B,EACTC,EACAC,GACPC,KAJO/B,iBAAiC+B,KACxBH,kBAAgCG,KACzCF,cAAyBE,KACzBD,sBAERC,KAAKC,gBAAkBC,EAAoBF,KAAKD,oBACjD,CAAC,IAAAI,EAAAP,EAAAQ,UAAAD,EAEOE,qCAAR,SAAQA,EAAqCC,GAC5C,OAAON,KAAK/B,eAAesC,YAAYC,KAAMpB,IAC5C,GAAIkB,EAAmBG,WAAWrB,EAAWkB,oBAAqB,CACjE,MAAMI,EAAoBJ,EAAmBK,QAAQvB,EAAWkB,mBAAoB,IACpF,OAAOI,EAAkBD,WAAW,MAAQC,EAAkBD,WAAW,IAC1E,CACA,OAAO,OAET,EAEAN,EAKAS,wBAAA,SAAAA,EACCC,GAEA,GAAIA,UAAqBA,IAAe,SAAU,CACjD,MAAMC,EAAiBD,EAAWP,mBAClC,MAAMf,EAAmBS,KAAKK,qCAAqCS,GACnE,IAAKvB,EAAkB,CACtB,MAAM,IAAIwB,MAAM,+BAA+BF,EAAWP,qBAC3D,CACA,OAAOf,CACR,KAAO,CACN,OAAOS,KAAKD,oBAAoBR,gBACjC,CACD,EAEAY,EAKAa,gCAAA,SAAAA,EAAmEF,GAClE,GAAIjD,EAAiBiD,GAAiB,CACrC,OAAOd,KAAKH,gBAAgBoB,wBAC3BH,EAAeR,mBAAmBK,QAAQX,KAAKD,oBAAoBR,iBAAiBe,mBAAoB,IAE1G,CACA,MAAMY,SACElB,KAAKH,gBAAgBsB,iBAAmB,UAAYnB,KAAKH,gBAAgBsB,eAAgBC,OAAS,EAC1G,MAAMC,SACErB,KAAKH,gBAAgByB,mBAAqB,UAAYtB,KAAKH,gBAAgByB,iBAAkBF,OAAS,EAC9G,MAAMG,EAAiBT,EAAeL,WAAW,KAEjD,IAAKT,KAAKH,gBAAgB2B,wBAAyB,CAClD,OAAOxB,KAAKH,gBAAgBoB,wBAAwBH,EACrD,MAAO,IACLS,IACCL,GAA6BlB,KAAKC,kBAAoB,IAAID,KAAKH,gBAAgBsB,kBAC/EE,GAA+BrB,KAAKC,kBAAoBD,KAAKH,gBAAgByB,kBAC9E,CACD,OAAOtB,KAAKH,gBAAgBoB,wBAAwB,GAAGjB,KAAKC,mBAAmBa,IAChF,MAAO,GAAIW,OAAOC,KAAK1B,KAAKH,gBAAgBoB,wBAAwB,GAAGjB,KAAKC,mBAAmBa,MAAmBM,OAAS,EAAG,CAC7H,OAAOpB,KAAKH,gBAAgBoB,wBAAwB,GAAGjB,KAAKC,mBAAmBa,IAChF,MAAO,GAAIW,OAAOC,KAAK1B,KAAKH,gBAAgBoB,wBAAwBH,IAAiBM,OAAS,EAAG,CAChG,OAAOpB,KAAKH,gBAAgBoB,wBAAwBH,EACrD,CACA,OAAOd,KAAKH,gBAAgBoB,wBAAwB,GAAGjB,KAAKC,mBAAmBa,IAChF,EAEAX,EAKAwB,0BAAA,SAAAA,EAA0BC,GACzB,IAAKA,EAAiB,CACrB,OAAOA,CACR,CACA,GAAIA,EAAgB,KAAO,IAAK,CAC/B,OAAOA,CACR,CACA,MAAO,GAAG5B,KAAKC,mBAAmB2B,GACnC,EAEAzB,EAIAgB,aAAA,SAAAA,IACC,OAAOnB,KAAKD,oBAAoBP,eACjC,EAEAW,EAIAmB,eAAA,SAAAA,IACC,OAAOtB,KAAKC,eACb,EAEAE,EAIA0B,uBAAA,SAAAA,IACC,OAAO7B,KAAKD,mBACb,EAEAI,EAIA2B,mBAAA,SAAAA,IACC,OAAO9B,KAAK/B,eAAe8D,eAC5B,EAEA5B,EAIA6B,cAAA,SAAAA,IACC,OAAOhC,KAAKD,oBAAoBR,gBACjC,EAEAY,EAIA8B,uBAAA,SAAAA,IACC,MAAMC,EAAsBlC,KAAKD,oBAAoBT,kBAAkBF,WACvE,MAAM+C,IAAoBD,EAAoBE,aAAaC,QAAQC,cACnE,OAAQH,GAAmBD,CAC5B,EAEA/B,EAKAoC,wBAAA,SAAAA,EAAsEzB,GACrE,IAAKA,EAAe0B,SAAS,KAAM,CAClC,MAAM,IAAIzB,MAAM,4BAA4BD,KAC7C,CAEA,MAAM2B,EAAa3B,EAAeL,WAAW,KAC7C,IAAIiC,EAEJ,GAAID,EAAY,CAEfC,EAAO5B,CACR,KAAO,CAEN,MAAM6B,EAAO3C,KAAKsB,iBAAiBsB,MAAM,IAAK,GAAG,GACjDF,EAAOC,EAAKE,SAAS,KAAOF,EAAO7B,EAAiB,GAAG6B,KAAQ7B,GAChE,CAEA,MAAMnB,EAA+CK,KAAK8C,oBAAoBJ,GAE9E,MAAMK,EAAsBC,EAC3B,CAAErD,OAAQA,EAAOA,OAAyBsD,eAAgBtD,EAAOnB,YACjEwB,KAAK/B,eACLwE,EAAatD,UAAYa,KAAKD,oBAAoBN,gBAClD,MAGD,MAAO,CACNoB,WAAYlB,EAAOA,OACnBuD,iBAAkB,IAAItD,EAAiBI,KAAK/B,eAAgB+B,KAAKH,gBAAiBG,KAAKF,YAAaiD,GAEtG,EAEA5C,EAIAgD,gBAAA,SAAAA,IACC,OAAOnD,KAAKH,gBAAgBsD,iBAC7B,EAEAhD,EAIAiD,kBAAA,SAAAA,IACC,OAAOpD,KAAK/B,cACb,EAEAkC,EAMAkD,0BAAA,SAAAA,EAA0BvC,EAAwB1B,GACjD,OAAO0B,EAAeH,QAAQvB,EAAWkB,mBAAoB,GAC9D,EAEAH,EAKAmD,gCAAA,SAAAA,EAAgCxC,GAC/B,IAAKA,EAAgB,CACpB,OAAOA,CACR,CACA,MAAMyC,EAAgBvD,KAAKD,oBAAoBR,iBAAiBe,mBAChE,GACCN,KAAKD,oBAAoBP,kBACvBQ,KAAKC,gBAAgBQ,WAAW,MAAQT,KAAKC,gBAAgBuD,MAAM,QAAW,IAAIpC,OAAS,EAC5F,CACD,IAAIqC,EAAyB3C,EAAeH,QAAQ4C,EAAe,KACnE,GAAIE,EAAuBrC,OAAS,GAAKqC,EAAuB,KAAO,KAAOA,EAAuB,KAAO,IAAK,CAChHA,EAAyBA,EAAuBC,UAAU,EAC3D,CACA,OAAO1D,KAAKC,iBAAmBwD,EAAuBhD,WAAW,KAAOgD,EAAyB,IAAIA,IACtG,KAAO,CACN,MAAO,IAAI3C,GACZ,CACD,EAEAX,EAIAwD,mBAAA,SAAAA,IACC,OAAO3D,KAAKH,eACb,EAACM,EAEDyD,eAAA,SAAAA,IACC,OAAO5D,KAAKF,WACb,EAEAK,EAKA2C,oBAAA,SAAAA,EAAwBJ,GACvB,OAAO1C,KAAK/B,eAAe4F,YAAYnB,EACxC,EAEAvC,EAKA2D,uBAAA,SAAAA,EAA0BC,GACzB,MAAM/F,EAAwCgC,KAAK/B,eAAe4F,YAAeE,GACjF,MAAMC,EAAajG,EAA6BC,EAAkBgC,KAAK/B,gBACvE,OAAO,IAAI2B,EAAoBI,KAAK/B,eAAgB+B,KAAKH,gBAAiBG,KAAKF,YAAakE,EAC7F,EAEA7D,EAQA8D,qBAAA,SAAAA,EACCC,EACAC,GAEuB,IADvBC,EAAgDC,UAAAjD,OAAA,GAAAiD,UAAA,KAAAlF,UAAAkF,UAAA,GAAG,CAACrE,KAAKgC,iBAEzD,IAAIsC,EAAuC,GAC3CF,EAAkB3F,QAAS8F,IAC1B,GAAIA,EAAkB,CACrB,MAAMnC,EACLmC,GAAkBnC,YAAY8B,IAAmB,CAAC,EACnD,GAAI9B,EAAa,CAChBkC,EAAiB7C,OAAOC,KAAKU,GAC3BoC,OAAQ3D,GAAeuB,EAAYvB,GAAY4D,OAASN,GACxDO,OAAO,CAACC,EAAqCC,KAC7CD,EAAc9F,KAAKuD,EAAYwC,IAC/B,OAAOD,GACLL,EACL,CACD,IAED,OAAOA,CACR,EAEAnE,EAIA0E,6BAAA,SAAAA,IACC,MAAM9E,EAAsBC,KAAKD,oBACjC,MAAM+E,EAAqB9E,KAAK/B,eAChC,OAAO,SAAU8G,GAChB,MAAMC,EAAgBC,EAAqBF,EAAOD,EAAoB,IACtE,MAAMI,EAAeC,EAAqBpF,EAAqBgF,GAC/D,MAAMK,EAAsBC,EAAmCH,EAAc,MAC7E,GAAIE,EAAqB,CACxB,OAAOA,CACR,CACA,OAAOJ,CACR,CACD,EAEApF,EAUO0F,+BAAP,SAAOA,EACNC,EACAC,EACA1F,EACA2F,EACA1F,EACAF,GAEA,MAAM6F,EAA6BF,EAAkBG,IAAI,wCACrDH,EACCA,EAA8BI,WACnC,MAAMC,EAAqBC,EAAaJ,GACxC,IAAIlG,EAAyCqG,EAAmBE,WAAWvF,KACzEwF,GAAcA,EAAUlH,OAASyG,GAEnC,IAAK/F,EAAiB,CACrBA,EAAkBqG,EAAmBI,WAAWzF,KAAMwF,GAAcA,EAAUlH,OAASyG,EACxF,CACA,IAAKxF,GAAuBP,IAAoBO,EAAoBT,kBAAmB,CACtFS,EAAsB,CACrBT,kBAAmBE,EACnBjB,qBAAsB,GACtBiB,gBAAiBA,EAEjBD,iBACCC,GAAiBJ,YAAcyG,EAAmBtF,YAAYC,KAAMpB,GAAeA,EAAWN,OAASyG,GACxG7F,aAAcF,EACdvB,eAAgB4H,EAElB,CACA,IAAKhG,EAAiB,CACrBA,EAAkB,IAAIqG,EAAgB,CAAC,EACxC,CACA,OAAO,IAAItG,EAAiBiG,EAAoBhG,EAAiBC,EAAaC,EAC/E,EAEAI,EAKAgG,uBAAA,SAAAA,EAAuBzD,GACtB,OAAO0D,EAAYD,uBAAuBzD,EAAM1C,KACjD,EAAC,OAAAJ,CAAA,CA3WoB,GA2WpB,OAGaA,CAAgB","ignoreList":[]}