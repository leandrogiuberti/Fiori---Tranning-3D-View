{"version":3,"file":"AnnotationConverter.js","names":["VocabularyReferences_1","__webpack_require__","utils_1","ANNOTATION_TARGET","Symbol","appendObjectPath","objectPath","visitedObject","length","push","resolveTarget","converter","startElement","path","annotationsTerm","undefined","target","messages","startsWith","substring","pathSegments","split","reduce","targetPath","segment","includes","pathPart","annotationPart","splitAtFirst","rawSchema","namespace","_a","getConvertedEntityContainer","fullyQualifiedName","_d","_c","_b","getConvertedEntityType","getConvertedComplexType","getConvertedAction","shift","_type","parentElementFQN","substringBeforeFirst","_e","result","current","error","message","vocabularyAlias","term","splitTerm","annotation","annotations","$target","subPath","value","subTarget","forEach","visitedSubObject","thisElement","unalias","nextElement","entitySets","by_name","singletons","actionImports","entityType","navigationPropertyBindings","navigationPropertyBinding","property","entityProperties","navigationProperty","navigationProperties","actionName","action","actions","isBound","parameters","find","param","name","type","targetType","properties","referencedType","typeReference","logError","annotationType","inferTypeFromTerm","isAnnotationPath","pathStr","mapPropertyPath","propertyPath","currentTarget","currentTerm","PropertyPath","lazy","mapAnnotationPath","annotationPath","AnnotationPath","mapNavigationPropertyPath","navigationPropertyPath","NavigationPropertyPath","mapPath","Path","getValue","parseValue","currentProperty","currentSource","propertyValue","valueFQN","String","Int","Bool","Decimal","Date","splitEnum","EnumMember","map","enumValue","unaliased","alias","VocabularyReferences","EnumIsFlag","parseRecord","Record","parseCollection","Collection","annotationTarget","TermToTypes","substringBeforeLast","isDataFieldWithForAction","annotationContent","hasOwnProperty","$Type","parseRecordType","recordDefinition","annotationRecord","currentFQN","record","__source","propertyValues","resolveAnnotationsOnAnnotation","Action","toString","actionTarget","getConvertedActionImport","getOrInferCollectionType","collectionDefinition","firstColItem","parentFQN","collectionDefinitionType","index","pathValue","recordIdx","ifValue","stringValue","Error","isV4NavigationProperty","navProp","targetTypeName","convertAnnotation","rawAnnotation","collection","Boolean","Number","vocAlias","vocTerm","qualifier","e","Converter","getAnnotations","this","annotationsByTarget","annotationSources","Object","keys","source","annotationList","mergeAnnotations","rawMetadata","references","getConvertedElement","schema","entityContainer","convertEntityContainer","getConvertedEntitySet","convertedOutput","by_fullyQualifiedName","getConvertedSingleton","entityTypes","complexTypes","getConvertedTypeDefinition","typeDefinitions","actionImport","convert","rawValue","Array","isArray","converted","convertedElements","rawElement","convertedElement","addGetByValue","constructor","Map","get","apply","set","diagnostics","aliased","splitAtLast","resolveEntityType","resolveNavigationPropertyBindings","rawNavigationPropertyBindings","bindingPath","rawBindingTarget","resolveAnnotations","rawAnnotationTarget","nestedAnnotations","createAnnotationsObject","annotationTerm","rawAnnotations","vocabularyAliases","vocTermWithQualifier","rawEntityContainer","convertedEntityContainer","convertEntitySet","convertSingleton","convertActionImport","rawSingleton","convertedSingleton","entityTypeName","_rawNavigationPropertyBindings","rawEntitySet","convertedEntitySet","convertEntityType","rawEntityType","convertedEntityType","keyProp","isKey","convertProperty","convertNavigationProperty","filter","rawAction","sourceType","resolvePath","relativePath","includeVisitedObjects","resolved","visitedObjects","rawProperty","convertedProperty","typeName","rawNavigationProperty","convertedNavigationProperty","referentialConstraint","associationEnd","associations","association","relationship","end","role","toRole","isCollection","multiplicity","rawActionImport","convertedActionImport","rawActions","convertAction","convertedAction","returnType","convertActionParameter","unspecificOverloadTarget","specificOverloadTarget","effectiveAnnotations","unspecificAnnotations","unspecificAnnotation","some","rawActionParameter","convertedActionParameter","indexOf","convertComplexType","rawComplexType","convertedComplexType","convertTypeDefinition","rawTypeDefinition","convertedTypeDefinition","version","targetResolution","exports","__exportStar","EnumIsFlag_1","defineProperty","enumerable","TermToTypes_1","splitAt","string","substringAt","separator","lastIndexOf","unaliasedValue","reverseReferenceMap","ref","reference","preAlias","postAlias","aliasedValue","_unalias","referenceMap","fromEntries","maybeAlias","rest","isAnnotation","valueToUnalias","knownReference","segments","first","subSegment","parameter","slice","join","isComplexTypeDefinition","complexTypeDefinition","isDecimal","valueOf","object","init","initial","_value","createIndexedFind","array","element","indexName","writable","reduceRight","annotationsOnTarget","existingAnnotation","revertObjectToRawType","anno","revertCollectionItemToRawType","call","isString","valueMatches","isInt","isFloat","Float","isDate","_f","isBoolean","$Apply","$Function","prototype","revertValueToRawType","valueConstructor","toFixed","restrictedKeys","revertAnnotationsToRawType","currentAnnotations","targetAnnotations","key","parsedAnnotation","revertTermToGenericType","unaliasedTerm","qualifiedSplit","collectionItem","outItem","collectionKey","baseAnnotation","uri","__webpack_module_cache__","moduleId","cachedModule","module","__webpack_modules__","__webpack_exports__"],"sources":["webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+annotation-converter@0.9.6/node_modules/@sap-ux/annotation-converter/src/converter.ts","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+annotation-converter@0.9.6/node_modules/@sap-ux/annotation-converter/src/index.ts","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+annotation-converter@0.9.6/node_modules/@sap-ux/annotation-converter/src/utils.ts","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+annotation-converter@0.9.6/node_modules/@sap-ux/annotation-converter/src/writeback.ts","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+vocabularies-types@0.11.4/node_modules/@sap-ux/vocabularies-types/vocabularies/EnumIsFlag.js","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+vocabularies-types@0.11.4/node_modules/@sap-ux/vocabularies-types/vocabularies/TermToTypes.js","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+vocabularies-types@0.11.4/node_modules/@sap-ux/vocabularies-types/vocabularies/VocabularyReferences.js","webpack://AnnotationConverter/webpack/bootstrap","webpack://AnnotationConverter/webpack/startup"],"sourcesContent":["import type {\n    Action,\n    ActionImport,\n    ActionParameter,\n    Annotation,\n    AnnotationPath,\n    AnnotationRecord,\n    ArrayWithIndex,\n    BaseNavigationProperty,\n    ComplexType,\n    ConvertedMetadata,\n    EntityContainer,\n    EntitySet,\n    EntityType,\n    Expression,\n    FullyQualifiedName,\n    NavigationProperty,\n    NavigationPropertyPath,\n    PathAnnotationExpression,\n    Property,\n    PropertyPath,\n    RawAction,\n    RawActionImport,\n    RawAnnotation,\n    RawComplexType,\n    RawEntityContainer,\n    RawEntitySet,\n    RawEntityType,\n    RawMetadata,\n    RawNavigationPropertyBinding,\n    RawProperty,\n    RawSchema,\n    RawSingleton,\n    RawTypeDefinition,\n    RawV2NavigationProperty,\n    RawV4NavigationProperty,\n    RemoveAnnotationAndType,\n    ResolutionTarget,\n    Singleton,\n    TypeDefinition\n} from '@sap-ux/vocabularies-types';\nimport { VocabularyReferences } from '@sap-ux/vocabularies-types/vocabularies/VocabularyReferences';\nimport {\n    addGetByValue,\n    alias,\n    Decimal,\n    EnumIsFlag,\n    lazy,\n    mergeAnnotations,\n    splitAtFirst,\n    splitAtLast,\n    substringBeforeFirst,\n    substringBeforeLast,\n    TermToTypes,\n    unalias\n} from './utils';\n\n/**\n * Symbol to extend an annotation with the reference to its target.\n */\nconst ANNOTATION_TARGET = Symbol('Annotation Target');\n\n/**\n * Append an object to the list of visited objects if it is different from the last object in the list.\n *\n * @param objectPath    The list of visited objects\n * @param visitedObject The object\n * @returns The list of visited objects\n */\nfunction appendObjectPath(objectPath: any[], visitedObject: any): any[] {\n    if (objectPath[objectPath.length - 1] !== visitedObject) {\n        objectPath.push(visitedObject);\n    }\n    return objectPath;\n}\n\n/**\n * Resolves a (possibly relative) path.\n *\n * @param converter         Converter\n * @param startElement      The starting point in case of relative path resolution\n * @param path              The path to resolve\n * @param annotationsTerm   Only for error reporting: The annotation term\n * @returns An object containing the resolved target and the elements that were visited while getting to the target.\n */\nfunction resolveTarget<T>(\n    converter: Converter,\n    startElement: any,\n    path: string | undefined,\n    annotationsTerm?: string\n): ResolutionTarget<T> {\n    if (path === undefined) {\n        return { target: undefined, objectPath: [], messages: [] };\n    }\n\n    // absolute paths always start at the entity container\n    if (path.startsWith('/')) {\n        path = path.substring(1);\n        startElement = undefined; // will resolve to the entity container (see below)\n    }\n\n    const pathSegments = path.split('/').reduce((targetPath, segment) => {\n        if (segment.includes('@')) {\n            // Separate out the annotation\n            const [pathPart, annotationPart] = splitAtFirst(segment, '@');\n            targetPath.push(pathPart);\n            targetPath.push(`@${annotationPart}`);\n        } else {\n            targetPath.push(segment);\n        }\n        return targetPath;\n    }, [] as string[]);\n\n    // determine the starting point for the resolution\n    if (startElement === undefined) {\n        // no starting point given: start at the entity container\n        if (\n            pathSegments[0].startsWith(`${converter.rawSchema.namespace}.`) &&\n            pathSegments[0] !== converter.getConvertedEntityContainer()?.fullyQualifiedName\n        ) {\n            // We have a fully qualified name in the path that is not the entity container.\n            startElement =\n                converter.getConvertedEntityType(pathSegments[0]) ??\n                converter.getConvertedComplexType(pathSegments[0]) ??\n                converter.getConvertedAction(pathSegments[0]) ??\n                converter.getConvertedAction(`${pathSegments[0]}()`); // unbound action\n            pathSegments.shift(); // Let's remove the first path element\n        } else {\n            startElement = converter.getConvertedEntityContainer();\n        }\n    } else if (startElement[ANNOTATION_TARGET] !== undefined) {\n        // annotation: start at the annotation target\n        startElement = startElement[ANNOTATION_TARGET];\n    } else if (startElement._type === 'Property') {\n        // property: start at the entity type or complex type the property belongs to\n        const parentElementFQN = substringBeforeFirst(startElement.fullyQualifiedName, '/');\n        startElement =\n            converter.getConvertedEntityType(parentElementFQN) ?? converter.getConvertedComplexType(parentElementFQN);\n    }\n\n    const result = pathSegments.reduce(\n        (current: ResolutionTarget<any>, segment: string) => {\n            const error = (message: string) => {\n                current.messages.push({ message });\n                current.target = undefined;\n                return current;\n            };\n\n            if (current.target === undefined) {\n                return current;\n            }\n\n            current.objectPath = appendObjectPath(current.objectPath, current.target);\n\n            // Annotation\n            if (segment.startsWith('@') && segment !== '@$ui5.overload') {\n                const [vocabularyAlias, term] = converter.splitTerm(segment);\n                const annotation = current.target.annotations[vocabularyAlias.substring(1)]?.[term];\n\n                if (annotation !== undefined) {\n                    current.target = annotation;\n                    return current;\n                }\n                return error(\n                    `Annotation '${segment.substring(1)}' not found on ${current.target._type} '${\n                        current.target.fullyQualifiedName\n                    }'`\n                );\n            }\n\n            // $Path / $AnnotationPath syntax\n            if (current.target.$target) {\n                let subPath: string | undefined;\n                if (segment === '$AnnotationPath') {\n                    subPath = current.target.value;\n                } else if (segment === '$Path') {\n                    subPath = current.target.path;\n                }\n\n                if (subPath !== undefined) {\n                    const subTarget = resolveTarget(converter, current.target[ANNOTATION_TARGET], subPath);\n                    subTarget.objectPath.forEach((visitedSubObject: any) => {\n                        if (!current.objectPath.includes(visitedSubObject)) {\n                            current.objectPath = appendObjectPath(current.objectPath, visitedSubObject);\n                        }\n                    });\n\n                    current.target = subTarget.target;\n                    current.objectPath = appendObjectPath(current.objectPath, current.target);\n                    return current;\n                }\n            }\n\n            // traverse based on the element type\n            switch (current.target?._type) {\n                case 'Schema':\n                    // next element: EntityType, ComplexType, Action, EntityContainer ?\n\n                    break;\n                case 'EntityContainer':\n                    {\n                        const thisElement = current.target as EntityContainer;\n\n                        if (segment === '' || converter.unalias(segment) === thisElement.fullyQualifiedName) {\n                            return current;\n                        }\n\n                        // next element: EntitySet, Singleton or ActionImport?\n                        const nextElement: EntitySet | Singleton | ActionImport | undefined =\n                            thisElement.entitySets.by_name(segment) ??\n                            thisElement.singletons.by_name(segment) ??\n                            thisElement.actionImports.by_name(segment);\n\n                        if (nextElement) {\n                            current.target = nextElement;\n                            return current;\n                        }\n                    }\n                    break;\n\n                case 'EntitySet':\n                case 'Singleton': {\n                    const thisElement = current.target as EntitySet | Singleton;\n\n                    if (segment === '' || segment === '$Type') {\n                        // Empty Path after an EntitySet or Singleton means EntityType\n                        current.target = thisElement.entityType;\n                        return current;\n                    }\n\n                    if (segment === '$') {\n                        return current;\n                    }\n\n                    if (segment === '$NavigationPropertyBinding') {\n                        const navigationPropertyBindings = thisElement.navigationPropertyBinding;\n                        current.target = navigationPropertyBindings;\n                        return current;\n                    }\n\n                    // continue resolving at the EntitySet's or Singleton's type\n                    const result = resolveTarget(converter, thisElement.entityType, segment);\n                    current.target = result.target;\n                    current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);\n                    return current;\n                }\n\n                case 'EntityType':\n                    {\n                        const thisElement = current.target as EntityType;\n\n                        if (segment === '' || segment === '$Type') {\n                            return current;\n                        }\n\n                        const property = thisElement.entityProperties.by_name(segment);\n                        if (property) {\n                            current.target = property;\n                            return current;\n                        }\n\n                        const navigationProperty = thisElement.navigationProperties.by_name(segment);\n                        if (navigationProperty) {\n                            current.target = navigationProperty;\n                            return current;\n                        }\n\n                        const actionName = substringBeforeFirst(converter.unalias(segment), '(');\n                        const action = thisElement.actions[actionName];\n                        if (action) {\n                            current.target = action;\n                            return current;\n                        }\n                    }\n                    break;\n\n                case 'ActionImport': {\n                    // continue resolving at the Action\n                    const result = resolveTarget(converter, current.target.action, segment);\n                    current.target = result.target;\n                    current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);\n                    return current;\n                }\n\n                case 'Action': {\n                    const thisElement = current.target as Action;\n\n                    if (segment === '') {\n                        return current;\n                    }\n\n                    if (segment === '@$ui5.overload' || segment === '0') {\n                        return current;\n                    }\n\n                    if (segment === '$Parameter' && thisElement.isBound) {\n                        current.target = thisElement.parameters;\n                        return current;\n                    }\n\n                    const nextElement =\n                        thisElement.parameters[segment as any] ??\n                        thisElement.parameters.find((param: ActionParameter) => param.name === segment);\n\n                    if (nextElement) {\n                        current.target = nextElement;\n                        return current;\n                    }\n                    break;\n                }\n\n                case 'Property':\n                    {\n                        const thisElement = current.target as Property;\n\n                        // Property or NavigationProperty of the ComplexType\n                        const type = thisElement.targetType as ComplexType | undefined;\n                        if (type !== undefined) {\n                            const property = type.properties.by_name(segment);\n                            if (property) {\n                                current.target = property;\n                                return current;\n                            }\n\n                            const navigationProperty = type.navigationProperties.by_name(segment);\n                            if (navigationProperty) {\n                                current.target = navigationProperty;\n                                return current;\n                            }\n                        }\n                    }\n                    break;\n\n                case 'ActionParameter':\n                    const referencedType = (current.target as ActionParameter).typeReference;\n                    if (referencedType !== undefined) {\n                        const result = resolveTarget(converter, referencedType, segment);\n                        current.target = result.target;\n                        current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);\n                        return current;\n                    }\n                    break;\n\n                case 'NavigationProperty':\n                    // continue at the NavigationProperty's target type\n                    const result = resolveTarget(converter, (current.target as NavigationProperty).targetType, segment);\n                    current.target = result.target;\n                    current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);\n                    return current;\n\n                default:\n                    if (segment === '') {\n                        return current;\n                    }\n\n                    if (current.target[segment]) {\n                        current.target = current.target[segment];\n                        current.objectPath = appendObjectPath(current.objectPath, current.target);\n                        return current;\n                    }\n            }\n\n            return error(\n                `Element '${segment}' not found at ${current.target._type} '${current.target.fullyQualifiedName}'`\n            );\n        },\n        { target: startElement, objectPath: [], messages: [] }\n    );\n\n    // Diagnostics\n    result.messages.forEach((message) => converter.logError(message.message));\n    if (!result.target) {\n        if (annotationsTerm) {\n            const annotationType = inferTypeFromTerm(converter, annotationsTerm, startElement.fullyQualifiedName);\n            converter.logError(\n                'Unable to resolve the path expression: ' +\n                    '\\n' +\n                    path +\n                    '\\n' +\n                    '\\n' +\n                    'Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \\n\\n' +\n                    '<Annotation Term = ' +\n                    annotationsTerm +\n                    '>' +\n                    '\\n' +\n                    '<Record Type = ' +\n                    annotationType +\n                    '>' +\n                    '\\n' +\n                    '<AnnotationPath = ' +\n                    path +\n                    '>'\n            );\n        } else {\n            converter.logError(\n                'Unable to resolve the path expression: ' +\n                    path +\n                    '\\n' +\n                    '\\n' +\n                    'Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \\n\\n' +\n                    '<Annotation Term = ' +\n                    pathSegments[0] +\n                    '>' +\n                    '\\n' +\n                    '<PropertyValue  Path= ' +\n                    pathSegments[1] +\n                    '>'\n            );\n        }\n    }\n\n    return result;\n}\n\n/**\n * Typeguard to check if the path contains an annotation.\n *\n * @param pathStr the path to evaluate\n * @returns true if there is an annotation in the path.\n */\nfunction isAnnotationPath(pathStr: string): boolean {\n    return pathStr.includes('@');\n}\n\ntype AnnotationValue<T> = T & { [ANNOTATION_TARGET]: any };\n\nfunction mapPropertyPath(\n    converter: Converter,\n    propertyPath: { type: 'PropertyPath'; PropertyPath: string },\n    fullyQualifiedName: FullyQualifiedName,\n    currentTarget: any,\n    currentTerm: string\n) {\n    const result: Omit<AnnotationValue<PropertyPath>, '$target'> = {\n        type: 'PropertyPath',\n        value: propertyPath.PropertyPath,\n        fullyQualifiedName: fullyQualifiedName,\n        [ANNOTATION_TARGET]: currentTarget\n    };\n\n    lazy(\n        result as AnnotationValue<PropertyPath>,\n        '$target',\n        () => resolveTarget<Property>(converter, currentTarget, propertyPath.PropertyPath, currentTerm).target\n    );\n\n    return result as AnnotationValue<PropertyPath>;\n}\n\nfunction mapAnnotationPath(\n    converter: Converter,\n    annotationPath: { type: 'AnnotationPath'; AnnotationPath: string },\n    fullyQualifiedName: FullyQualifiedName,\n    currentTarget: any,\n    currentTerm: string\n) {\n    const result: Omit<AnnotationValue<AnnotationPath<any>>, '$target'> = {\n        type: 'AnnotationPath',\n        value: converter.unalias(annotationPath.AnnotationPath),\n        fullyQualifiedName: fullyQualifiedName,\n        [ANNOTATION_TARGET]: currentTarget\n    };\n\n    lazy(\n        result as AnnotationValue<AnnotationPath<any>>,\n        '$target',\n        () => resolveTarget(converter, currentTarget, result.value, currentTerm).target\n    );\n\n    return result as AnnotationValue<AnnotationPath<any>>;\n}\n\nfunction mapNavigationPropertyPath(\n    converter: Converter,\n    navigationPropertyPath: { type: 'NavigationPropertyPath'; NavigationPropertyPath: string },\n    fullyQualifiedName: FullyQualifiedName,\n    currentTarget: any,\n    currentTerm: string\n) {\n    const result: Omit<AnnotationValue<NavigationPropertyPath>, '$target'> = {\n        type: 'NavigationPropertyPath',\n        value: navigationPropertyPath.NavigationPropertyPath ?? '',\n        fullyQualifiedName: fullyQualifiedName,\n        [ANNOTATION_TARGET]: currentTarget\n    };\n\n    lazy(\n        result as AnnotationValue<NavigationPropertyPath>,\n        '$target',\n        () =>\n            resolveTarget<NavigationProperty>(\n                converter,\n                currentTarget,\n                navigationPropertyPath.NavigationPropertyPath,\n                currentTerm\n            ).target\n    );\n\n    return result as AnnotationValue<NavigationPropertyPath>;\n}\n\nfunction mapPath(\n    converter: Converter,\n    path: { type: 'Path'; Path: string },\n    fullyQualifiedName: FullyQualifiedName,\n    currentTarget: any,\n    currentTerm: string\n) {\n    const result: Omit<AnnotationValue<PathAnnotationExpression<any>>, '$target'> = {\n        type: 'Path',\n        path: path.Path,\n        fullyQualifiedName: fullyQualifiedName,\n        getValue(): any {\n            return undefined; // TODO: Required according to the type...\n        },\n        [ANNOTATION_TARGET]: currentTarget\n    };\n\n    lazy(\n        result as AnnotationValue<PathAnnotationExpression<any>>,\n        '$target',\n        () => resolveTarget<Property>(converter, currentTarget, path.Path, currentTerm).target\n    );\n\n    return result as AnnotationValue<PathAnnotationExpression<any>>;\n}\n\nfunction parseValue(\n    converter: Converter,\n    currentTarget: any,\n    currentTerm: string,\n    currentProperty: string,\n    currentSource: string,\n    propertyValue: Expression,\n    valueFQN: string\n) {\n    if (propertyValue === undefined) {\n        return undefined;\n    }\n    switch (propertyValue.type) {\n        case 'String':\n            return propertyValue.String;\n        case 'Int':\n            return propertyValue.Int;\n        case 'Bool':\n            return propertyValue.Bool;\n        case 'Decimal':\n            return Decimal(propertyValue.Decimal);\n        case 'Date':\n            return propertyValue.Date;\n        case 'EnumMember':\n            const splitEnum = propertyValue.EnumMember.split(' ').map((enumValue) => {\n                const unaliased = converter.unalias(enumValue) ?? '';\n                return alias(VocabularyReferences, unaliased);\n            });\n            if (splitEnum[0] !== undefined && EnumIsFlag[substringBeforeFirst(splitEnum[0], '/')]) {\n                return splitEnum;\n            }\n            return splitEnum[0];\n\n        case 'PropertyPath':\n            return mapPropertyPath(converter, propertyValue, valueFQN, currentTarget, currentTerm);\n\n        case 'NavigationPropertyPath':\n            return mapNavigationPropertyPath(converter, propertyValue, valueFQN, currentTarget, currentTerm);\n\n        case 'AnnotationPath':\n            return mapAnnotationPath(converter, propertyValue, valueFQN, currentTarget, currentTerm);\n\n        case 'Path': {\n            if (isAnnotationPath(propertyValue.Path)) {\n                // inline the target\n                return resolveTarget(converter, currentTarget, propertyValue.Path, currentTerm).target;\n            } else {\n                return mapPath(converter, propertyValue, valueFQN, currentTarget, currentTerm);\n            }\n        }\n\n        case 'Record':\n            return parseRecord(\n                converter,\n                currentTerm,\n                currentTarget,\n                currentProperty,\n                currentSource,\n                propertyValue.Record,\n                valueFQN\n            );\n\n        case 'Collection':\n            return parseCollection(\n                converter,\n                currentTarget,\n                currentTerm,\n                currentProperty,\n                currentSource,\n                propertyValue.Collection,\n                valueFQN\n            );\n        case 'Apply':\n        case 'Null':\n        case 'Not':\n        case 'Eq':\n        case 'Ne':\n        case 'Gt':\n        case 'Ge':\n        case 'Lt':\n        case 'Le':\n        case 'If':\n        case 'And':\n        case 'Or':\n        default:\n            return propertyValue;\n    }\n}\n\n/**\n * Infer the type of a term based on its type.\n *\n * @param converter         Converter\n * @param annotationsTerm   The annotation term\n * @param annotationTarget  The annotation target\n * @param currentProperty   The current property of the record\n * @returns The inferred type.\n */\nfunction inferTypeFromTerm(\n    converter: Converter,\n    annotationsTerm: string,\n    annotationTarget: string,\n    currentProperty?: string\n) {\n    let targetType = (TermToTypes as any)[annotationsTerm];\n    if (currentProperty) {\n        annotationsTerm = `${substringBeforeLast(annotationsTerm, '.')}.${currentProperty}`;\n        targetType = (TermToTypes as any)[annotationsTerm];\n    }\n\n    converter.logError(\n        `The type of the record used within the term ${annotationsTerm} was not defined and was inferred as ${targetType}.\nHint: If possible, try to maintain the Type property for each Record.\n<Annotations Target=\"${annotationTarget}\">\n\t<Annotation Term=\"${annotationsTerm}\">\n\t\t<Record>...</Record>\n\t</Annotation>\n</Annotations>`\n    );\n\n    return targetType;\n}\n\nfunction isDataFieldWithForAction(annotationContent: any) {\n    return (\n        annotationContent.hasOwnProperty('Action') &&\n        (annotationContent.$Type === 'com.sap.vocabularies.UI.v1.DataFieldForAction' ||\n            annotationContent.$Type === 'com.sap.vocabularies.UI.v1.DataFieldWithAction')\n    );\n}\n\nfunction parseRecordType(\n    converter: Converter,\n    currentTerm: string,\n    currentTarget: any,\n    currentProperty: string | undefined,\n    recordDefinition: AnnotationRecord\n) {\n    let targetType;\n    if (!recordDefinition.type && currentTerm) {\n        targetType = inferTypeFromTerm(converter, currentTerm, currentTarget.fullyQualifiedName, currentProperty);\n    } else {\n        targetType = converter.unalias(recordDefinition.type);\n    }\n    return targetType;\n}\n\nfunction parseRecord(\n    converter: Converter,\n    currentTerm: string,\n    currentTarget: any,\n    currentProperty: string | undefined,\n    currentSource: string,\n    annotationRecord: AnnotationRecord,\n    currentFQN: string\n) {\n    const record: any = {\n        $Type: parseRecordType(converter, currentTerm, currentTarget, currentProperty, annotationRecord),\n        fullyQualifiedName: currentFQN,\n        [ANNOTATION_TARGET]: currentTarget,\n        __source: currentSource\n    };\n\n    for (const propertyValue of annotationRecord.propertyValues) {\n        lazy(record, propertyValue.name, () =>\n            parseValue(\n                converter,\n                currentTarget,\n                currentTerm,\n                propertyValue.name,\n                currentSource,\n                propertyValue.value,\n                `${currentFQN}/${propertyValue.name}`\n            )\n        );\n    }\n\n    // annotations on the record\n    lazy(record, 'annotations', resolveAnnotationsOnAnnotation(converter, annotationRecord, record));\n\n    if (isDataFieldWithForAction(record)) {\n        lazy(record, 'ActionTarget', () => {\n            const actionName = converter.unalias(record.Action?.toString());\n\n            // (1) Bound action of the annotation target?\n            let actionTarget = currentTarget.actions[actionName];\n\n            if (!actionTarget) {\n                // (2) ActionImport (= unbound action)?\n                actionTarget = converter.getConvertedActionImport(actionName)?.action;\n            }\n\n            if (!actionTarget) {\n                // (3) Bound action of a different EntityType (the actionName is fully qualified in this case)\n                actionTarget = converter.getConvertedAction(actionName);\n                if (!actionTarget?.isBound) {\n                    actionTarget = undefined;\n                }\n            }\n\n            if (!actionTarget) {\n                converter.logError(\n                    `${record.fullyQualifiedName}: Unable to resolve '${record.Action}' ('${actionName}')`\n                );\n            }\n            return actionTarget;\n        });\n    }\n    return record;\n}\n\nexport type CollectionType =\n    | 'PropertyPath'\n    | 'Path'\n    | 'If'\n    | 'Apply'\n    | 'Null'\n    | 'And'\n    | 'Eq'\n    | 'Ne'\n    | 'Not'\n    | 'Gt'\n    | 'Ge'\n    | 'Lt'\n    | 'Le'\n    | 'Or'\n    | 'AnnotationPath'\n    | 'NavigationPropertyPath'\n    | 'Record'\n    | 'String'\n    | 'EmptyCollection';\n\n/**\n * Retrieve or infer the collection type based on its content.\n *\n * @param collectionDefinition\n * @returns the type of the collection\n */\nfunction getOrInferCollectionType(collectionDefinition: any[]): CollectionType {\n    let type: CollectionType = (collectionDefinition as any).type;\n    if (type === undefined && collectionDefinition.length > 0) {\n        const firstColItem = collectionDefinition[0];\n        if (firstColItem.hasOwnProperty('PropertyPath')) {\n            type = 'PropertyPath';\n        } else if (firstColItem.hasOwnProperty('Path')) {\n            type = 'Path';\n        } else if (firstColItem.hasOwnProperty('AnnotationPath')) {\n            type = 'AnnotationPath';\n        } else if (firstColItem.hasOwnProperty('NavigationPropertyPath')) {\n            type = 'NavigationPropertyPath';\n        } else if (\n            typeof firstColItem === 'object' &&\n            (firstColItem.hasOwnProperty('type') || firstColItem.hasOwnProperty('propertyValues'))\n        ) {\n            type = 'Record';\n        } else if (typeof firstColItem === 'string') {\n            type = 'String';\n        }\n    } else if (type === undefined) {\n        type = 'EmptyCollection';\n    }\n    return type;\n}\n\nfunction parseCollection(\n    converter: Converter,\n    currentTarget: any,\n    currentTerm: string,\n    currentProperty: string,\n    currentSource: string,\n    collectionDefinition: any[],\n    parentFQN: string\n) {\n    const collectionDefinitionType = getOrInferCollectionType(collectionDefinition);\n\n    switch (collectionDefinitionType) {\n        case 'PropertyPath':\n            return collectionDefinition.map((path, index) =>\n                mapPropertyPath(converter, path, `${parentFQN}/${index}`, currentTarget, currentTerm)\n            );\n\n        case 'Path':\n            // TODO: make lazy?\n            return collectionDefinition.map((pathValue) => {\n                return resolveTarget(converter, currentTarget, pathValue.Path, currentTerm).target;\n            });\n\n        case 'AnnotationPath':\n            return collectionDefinition.map((path, index) =>\n                mapAnnotationPath(converter, path, `${parentFQN}/${index}`, currentTarget, currentTerm)\n            );\n\n        case 'NavigationPropertyPath':\n            return collectionDefinition.map((path, index) =>\n                mapNavigationPropertyPath(converter, path, `${parentFQN}/${index}`, currentTarget, currentTerm)\n            );\n\n        case 'Record':\n            return collectionDefinition.map((recordDefinition, recordIdx) => {\n                return parseRecord(\n                    converter,\n                    currentTerm,\n                    currentTarget,\n                    currentProperty,\n                    currentSource,\n                    recordDefinition,\n                    `${parentFQN}/${recordIdx}`\n                );\n            });\n\n        case 'Apply':\n        case 'Null':\n        case 'If':\n        case 'Eq':\n        case 'Ne':\n        case 'Lt':\n        case 'Gt':\n        case 'Le':\n        case 'Ge':\n        case 'Not':\n        case 'And':\n        case 'Or':\n            return collectionDefinition.map((ifValue) => ifValue);\n\n        case 'String':\n            return collectionDefinition.map((stringValue) => {\n                if (typeof stringValue === 'string' || stringValue === undefined) {\n                    return stringValue;\n                } else {\n                    return stringValue.String;\n                }\n            });\n\n        default:\n            if (collectionDefinition.length === 0) {\n                return [];\n            }\n            throw new Error('Unsupported case');\n    }\n}\n\nfunction isV4NavigationProperty(\n    navProp: RawV2NavigationProperty | RawV4NavigationProperty\n): navProp is RawV4NavigationProperty {\n    return !!(navProp as BaseNavigationProperty).targetTypeName;\n}\n\nfunction convertAnnotation(converter: Converter, target: any, rawAnnotation: RawAnnotation): Annotation {\n    let annotation: any;\n    if (rawAnnotation.record) {\n        annotation = parseRecord(\n            converter,\n            rawAnnotation.term,\n            target,\n            '',\n            (rawAnnotation as any).__source,\n            rawAnnotation.record,\n            (rawAnnotation as any).fullyQualifiedName\n        );\n    } else if (rawAnnotation.collection === undefined) {\n        annotation = parseValue(\n            converter,\n            target,\n            rawAnnotation.term,\n            '',\n            (rawAnnotation as any).__source,\n            rawAnnotation.value ?? { type: 'Bool', Bool: true },\n            (rawAnnotation as any).fullyQualifiedName\n        );\n    } else if (rawAnnotation.collection) {\n        annotation = parseCollection(\n            converter,\n            target,\n            rawAnnotation.term,\n            '',\n            (rawAnnotation as any).__source,\n            rawAnnotation.collection,\n            (rawAnnotation as any).fullyQualifiedName\n        );\n    } else {\n        throw new Error('Unsupported case');\n    }\n\n    switch (typeof annotation) {\n        case 'string':\n            // eslint-disable-next-line no-new-wrappers\n            annotation = new String(annotation);\n            break;\n        case 'boolean':\n            // eslint-disable-next-line no-new-wrappers\n            annotation = new Boolean(annotation);\n            break;\n        case 'number':\n            annotation = new Number(annotation);\n            break;\n        default:\n            // do nothing\n            break;\n    }\n\n    annotation.fullyQualifiedName = (rawAnnotation as any).fullyQualifiedName;\n    annotation[ANNOTATION_TARGET] = target;\n\n    const [vocAlias, vocTerm] = converter.splitTerm(rawAnnotation.term);\n\n    annotation.term = converter.unalias(`${vocAlias}.${vocTerm}`, VocabularyReferences);\n    annotation.qualifier = rawAnnotation.qualifier;\n    annotation.__source = (rawAnnotation as any).__source;\n\n    try {\n        lazy(annotation, 'annotations', resolveAnnotationsOnAnnotation(converter, rawAnnotation, annotation));\n    } catch (e) {\n        // not an error: parseRecord() already adds annotations, but the other parseXXX functions don't, so this can happen\n    }\n\n    return annotation as Annotation;\n}\n\nclass Converter {\n    private annotationsByTarget: Record<FullyQualifiedName, Annotation[]>;\n\n    /**\n     * Get preprocessed annotations on the specified target.\n     *\n     * @param target    The annotation target\n     * @returns An array of annotations\n     */\n    getAnnotations(target: FullyQualifiedName): Annotation[] {\n        if (this.annotationsByTarget === undefined) {\n            const annotationSources = Object.keys(this.rawSchema.annotations).map((source) => ({\n                name: source,\n                annotationList: this.rawSchema.annotations[source]\n            }));\n\n            this.annotationsByTarget = mergeAnnotations(this.rawMetadata.references, ...annotationSources);\n        }\n\n        return this.annotationsByTarget[target] ?? [];\n    }\n\n    getConvertedEntityContainer() {\n        return this.getConvertedElement(\n            this.rawMetadata.schema.entityContainer.fullyQualifiedName,\n            this.rawMetadata.schema.entityContainer,\n            convertEntityContainer\n        );\n    }\n\n    getConvertedEntitySet(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.entitySets.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedSingleton(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.singletons.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedEntityType(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.entityTypes.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedComplexType(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.complexTypes.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedTypeDefinition(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.typeDefinitions.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedActionImport(fullyQualifiedName: FullyQualifiedName) {\n        let actionImport = this.convertedOutput.actionImports.by_fullyQualifiedName(fullyQualifiedName);\n        if (!actionImport) {\n            actionImport = this.convertedOutput.actionImports.by_name(fullyQualifiedName);\n        }\n        return actionImport;\n    }\n\n    getConvertedAction(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.actions.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    convert<Converted, Raw extends RawType<Converted>>(\n        rawValue: Raw,\n        map: (converter: Converter, raw: Raw) => Converted\n    ): () => Converted;\n    convert<Converted, Raw extends RawType<Converted>, IndexProperty extends Extract<keyof Converted, string>>(\n        rawValue: Raw[],\n        map: (converter: Converter, raw: Raw) => Converted\n    ): () => ArrayWithIndex<Converted, IndexProperty>;\n    convert<Converted, Raw extends RawType<Converted>, IndexProperty extends Extract<keyof Converted, string>>(\n        rawValue: Raw | Raw[],\n        map: (converter: Converter, raw: Raw) => Converted\n    ): (() => Converted) | (() => ArrayWithIndex<Converted, IndexProperty>) {\n        if (Array.isArray(rawValue)) {\n            return () => {\n                const converted = rawValue.reduce((convertedElements, rawElement) => {\n                    const convertedElement = this.getConvertedElement(\n                        (rawElement as any).fullyQualifiedName,\n                        rawElement,\n                        map\n                    );\n                    if (convertedElement) {\n                        convertedElements.push(convertedElement);\n                    }\n                    return convertedElements;\n                }, [] as Converted[]);\n                addGetByValue(converted, 'name' as any);\n                addGetByValue(converted, 'fullyQualifiedName' as any);\n                return converted as ArrayWithIndex<Converted, IndexProperty>;\n            };\n        } else {\n            return () => this.getConvertedElement(rawValue.fullyQualifiedName, rawValue, map)!;\n        }\n    }\n\n    private rawMetadata: RawMetadata;\n    private convertedElements: Map<FullyQualifiedName, any> = new Map();\n    private convertedOutput: ConvertedMetadata;\n\n    rawSchema: RawSchema;\n\n    constructor(rawMetadata: RawMetadata, convertedOutput: ConvertedMetadata) {\n        this.rawMetadata = rawMetadata;\n        this.rawSchema = rawMetadata.schema;\n        this.convertedOutput = convertedOutput;\n    }\n\n    getConvertedElement<ConvertedType, RawType extends RemoveAnnotationAndType<ConvertedType>>(\n        fullyQualifiedName: FullyQualifiedName,\n        rawElement: RawType | undefined | ((fullyQualifiedName: FullyQualifiedName) => RawType | undefined),\n        map: (converter: Converter, raw: RawType) => ConvertedType\n    ): ConvertedType | undefined {\n        let converted: ConvertedType | undefined = this.convertedElements.get(fullyQualifiedName);\n        if (converted === undefined) {\n            const rawMetadata =\n                typeof rawElement === 'function' ? rawElement.apply(undefined, [fullyQualifiedName]) : rawElement;\n            if (rawMetadata !== undefined) {\n                converted = map.apply(undefined, [this, rawMetadata]);\n                this.convertedElements.set(fullyQualifiedName, converted);\n            }\n        }\n        return converted;\n    }\n\n    logError(message: string) {\n        this.convertedOutput.diagnostics.push({ message });\n    }\n\n    /**\n     * Split the alias from the term value.\n     *\n     * @param term the value of the term\n     * @returns the term alias and the actual term value\n     */\n    splitTerm(term: string) {\n        const aliased = alias(VocabularyReferences, term);\n        return splitAtLast(aliased, '.');\n    }\n\n    unalias(value: string | undefined, references = this.rawMetadata.references) {\n        return unalias(references, value, this.rawSchema.namespace) ?? '';\n    }\n}\n\ntype RawType<T> = RemoveAnnotationAndType<T> & { fullyQualifiedName: FullyQualifiedName };\n\nfunction resolveEntityType(converter: Converter, fullyQualifiedName: FullyQualifiedName) {\n    return () => {\n        let entityType = converter.getConvertedEntityType(fullyQualifiedName);\n\n        if (!entityType) {\n            converter.logError(`EntityType '${fullyQualifiedName}' not found`);\n            entityType = {} as EntityType;\n        }\n        return entityType;\n    };\n}\n\nfunction resolveNavigationPropertyBindings(\n    converter: Converter,\n    rawNavigationPropertyBindings: RawNavigationPropertyBinding\n) {\n    return () =>\n        Object.keys(rawNavigationPropertyBindings).reduce((navigationPropertyBindings, bindingPath) => {\n            const rawBindingTarget = rawNavigationPropertyBindings[bindingPath];\n\n            lazy(\n                navigationPropertyBindings,\n                bindingPath,\n                () =>\n                    // the NavigationPropertyBinding will lead to either an EntitySet or a Singleton, it cannot be undefined\n                    (converter.getConvertedEntitySet(rawBindingTarget) ??\n                        converter.getConvertedSingleton(rawBindingTarget))!\n            );\n            return navigationPropertyBindings;\n        }, {} as EntitySet['navigationPropertyBinding'] | Singleton['navigationPropertyBinding']);\n}\n\nfunction resolveAnnotations(converter: Converter, rawAnnotationTarget: any) {\n    const nestedAnnotations = rawAnnotationTarget.annotations;\n\n    return () =>\n        createAnnotationsObject(\n            converter,\n            rawAnnotationTarget,\n            nestedAnnotations ?? converter.getAnnotations(rawAnnotationTarget.fullyQualifiedName)\n        );\n}\n\nfunction resolveAnnotationsOnAnnotation(\n    converter: Converter,\n    annotationRecord: AnnotationRecord | RawAnnotation,\n    annotationTerm: any\n) {\n    return () => {\n        const currentFQN = annotationTerm.fullyQualifiedName;\n\n        // be graceful when resolving annotations on annotations: Sometimes they are referenced directly, sometimes they\n        // are part of the global annotations list\n        let annotations;\n        if (annotationRecord.annotations && annotationRecord.annotations.length > 0) {\n            annotations = annotationRecord.annotations;\n        } else {\n            annotations = converter.getAnnotations(currentFQN);\n        }\n\n        annotations?.forEach((annotation: any) => {\n            annotation.target = currentFQN;\n            annotation.__source = annotationTerm.__source;\n            annotation[ANNOTATION_TARGET] = annotationTerm[ANNOTATION_TARGET];\n            annotation.fullyQualifiedName = `${currentFQN}@${annotation.term}`;\n        });\n\n        return createAnnotationsObject(converter, annotationTerm, annotations ?? []);\n    };\n}\n\nfunction createAnnotationsObject(converter: Converter, target: any, rawAnnotations: RawAnnotation[]) {\n    return rawAnnotations.reduce((vocabularyAliases, annotation) => {\n        const [vocAlias, vocTerm] = converter.splitTerm(annotation.term);\n        const vocTermWithQualifier = `${vocTerm}${annotation.qualifier ? '#' + annotation.qualifier : ''}`;\n\n        if (vocabularyAliases[vocAlias] === undefined) {\n            vocabularyAliases[vocAlias] = {};\n        }\n\n        if (!vocabularyAliases[vocAlias].hasOwnProperty(vocTermWithQualifier)) {\n            lazy(vocabularyAliases[vocAlias], vocTermWithQualifier, () =>\n                converter.getConvertedElement(\n                    (annotation as Annotation).fullyQualifiedName,\n                    annotation,\n                    (converter, rawAnnotation) => convertAnnotation(converter, target, rawAnnotation)\n                )\n            );\n        }\n        return vocabularyAliases;\n    }, {} as any);\n}\n\n/**\n * Converts an EntityContainer.\n *\n * @param converter     Converter\n * @param rawEntityContainer    Unconverted EntityContainer\n * @returns The converted EntityContainer\n */\nfunction convertEntityContainer(converter: Converter, rawEntityContainer: RawEntityContainer): EntityContainer {\n    const convertedEntityContainer = rawEntityContainer as EntityContainer;\n\n    lazy(convertedEntityContainer, 'annotations', resolveAnnotations(converter, rawEntityContainer));\n\n    lazy(convertedEntityContainer, 'entitySets', converter.convert(converter.rawSchema.entitySets, convertEntitySet));\n\n    lazy(convertedEntityContainer, 'singletons', converter.convert(converter.rawSchema.singletons, convertSingleton));\n\n    lazy(\n        convertedEntityContainer,\n        'actionImports',\n        converter.convert(converter.rawSchema.actionImports, convertActionImport)\n    );\n\n    return convertedEntityContainer;\n}\n\n/**\n * Converts a Singleton.\n *\n * @param converter   Converter\n * @param rawSingleton  Unconverted Singleton\n * @returns The converted Singleton\n */\nfunction convertSingleton(converter: Converter, rawSingleton: RawSingleton): Singleton {\n    const convertedSingleton = rawSingleton as unknown as Singleton;\n\n    lazy(convertedSingleton, 'entityType', resolveEntityType(converter, rawSingleton.entityTypeName));\n    lazy(convertedSingleton, 'annotations', resolveAnnotations(converter, convertedSingleton));\n\n    const _rawNavigationPropertyBindings = rawSingleton.navigationPropertyBinding;\n    lazy(\n        convertedSingleton,\n        'navigationPropertyBinding',\n        resolveNavigationPropertyBindings(converter, _rawNavigationPropertyBindings)\n    );\n\n    return convertedSingleton;\n}\n\n/**\n * Converts an EntitySet.\n *\n * @param converter   Converter\n * @param rawEntitySet  Unconverted EntitySet\n * @returns The converted EntitySet\n */\nfunction convertEntitySet(converter: Converter, rawEntitySet: RawEntitySet): EntitySet {\n    const convertedEntitySet = rawEntitySet as unknown as EntitySet;\n\n    lazy(convertedEntitySet, 'entityType', resolveEntityType(converter, rawEntitySet.entityTypeName));\n    lazy(convertedEntitySet, 'annotations', resolveAnnotations(converter, convertedEntitySet));\n\n    const _rawNavigationPropertyBindings = rawEntitySet.navigationPropertyBinding;\n    lazy(\n        convertedEntitySet,\n        'navigationPropertyBinding',\n        resolveNavigationPropertyBindings(converter, _rawNavigationPropertyBindings)\n    );\n\n    return convertedEntitySet;\n}\n\n/**\n * Converts an EntityType.\n *\n * @param converter   Converter\n * @param rawEntityType  Unconverted EntityType\n * @returns The converted EntityType\n */\nfunction convertEntityType(converter: Converter, rawEntityType: RawEntityType): EntityType {\n    const convertedEntityType = rawEntityType as EntityType;\n\n    rawEntityType.keys.forEach((keyProp: any) => {\n        keyProp.isKey = true;\n    });\n\n    lazy(convertedEntityType, 'annotations', resolveAnnotations(converter, rawEntityType));\n\n    lazy(convertedEntityType, 'keys', converter.convert(rawEntityType.keys, convertProperty));\n    lazy(convertedEntityType, 'entityProperties', converter.convert(rawEntityType.entityProperties, convertProperty));\n    lazy(\n        convertedEntityType,\n        'navigationProperties',\n        converter.convert(rawEntityType.navigationProperties as any[], convertNavigationProperty)\n    );\n\n    lazy(convertedEntityType, 'actions', () =>\n        converter.rawSchema.actions\n            .filter(\n                (rawAction) =>\n                    rawAction.isBound &&\n                    (rawAction.sourceType === rawEntityType.fullyQualifiedName ||\n                        rawAction.sourceType === `Collection(${rawEntityType.fullyQualifiedName})`)\n            )\n            .reduce((actions, rawAction) => {\n                const name = `${converter.rawSchema.namespace}.${rawAction.name}`;\n                actions[name] = converter.getConvertedAction(rawAction.fullyQualifiedName)!;\n                return actions;\n            }, {} as EntityType['actions'])\n    );\n\n    convertedEntityType.resolvePath = (relativePath: string, includeVisitedObjects?: boolean) => {\n        const resolved = resolveTarget(converter, rawEntityType, relativePath);\n        if (includeVisitedObjects) {\n            return { target: resolved.target, visitedObjects: resolved.objectPath, messages: resolved.messages };\n        } else {\n            return resolved.target;\n        }\n    };\n\n    return convertedEntityType;\n}\n\n/**\n * Converts a Property.\n *\n * @param converter   Converter\n * @param rawProperty  Unconverted Property\n * @returns The converted Property\n */\nfunction convertProperty(converter: Converter, rawProperty: RawProperty): Property {\n    const convertedProperty = rawProperty as Property;\n\n    lazy(convertedProperty, 'annotations', resolveAnnotations(converter, rawProperty));\n\n    lazy(convertedProperty, 'targetType', () => {\n        const type = rawProperty.type;\n        const typeName = type.startsWith('Collection') ? type.substring(11, type.length - 1) : type;\n\n        return converter.getConvertedComplexType(typeName) ?? converter.getConvertedTypeDefinition(typeName);\n    });\n\n    return convertedProperty;\n}\n\n/**\n * Converts a NavigationProperty.\n *\n * @param converter   Converter\n * @param rawNavigationProperty  Unconverted NavigationProperty\n * @returns The converted NavigationProperty\n */\nfunction convertNavigationProperty(\n    converter: Converter,\n    rawNavigationProperty: RawV2NavigationProperty | RawV4NavigationProperty\n): NavigationProperty {\n    const convertedNavigationProperty = rawNavigationProperty as NavigationProperty;\n\n    convertedNavigationProperty.referentialConstraint = convertedNavigationProperty.referentialConstraint ?? [];\n\n    if (!isV4NavigationProperty(rawNavigationProperty)) {\n        const associationEnd = converter.rawSchema.associations\n            .find((association) => association.fullyQualifiedName === rawNavigationProperty.relationship)\n            ?.associationEnd.find((end) => end.role === rawNavigationProperty.toRole);\n\n        convertedNavigationProperty.isCollection = associationEnd?.multiplicity === '*';\n        convertedNavigationProperty.targetTypeName = associationEnd?.type ?? '';\n    }\n\n    lazy(\n        convertedNavigationProperty,\n        'targetType',\n        resolveEntityType(converter, (rawNavigationProperty as NavigationProperty).targetTypeName)\n    );\n\n    lazy(convertedNavigationProperty, 'annotations', resolveAnnotations(converter, rawNavigationProperty));\n\n    return convertedNavigationProperty;\n}\n\n/**\n * Converts an ActionImport.\n *\n * @param converter   Converter\n * @param rawActionImport  Unconverted ActionImport\n * @returns The converted ActionImport\n */\nfunction convertActionImport(converter: Converter, rawActionImport: RawActionImport): ActionImport {\n    const convertedActionImport = rawActionImport as ActionImport;\n\n    lazy(convertedActionImport, 'annotations', resolveAnnotations(converter, rawActionImport));\n\n    lazy(convertedActionImport, 'action', () => {\n        const rawActions = converter.rawSchema.actions.filter(\n            (rawAction) => !rawAction.isBound && rawAction.fullyQualifiedName.startsWith(rawActionImport.actionName)\n        );\n\n        // this always resolves to a unique unbound action, but resolution of unbound functions can be ambiguous:\n        // unbound function FQNs have overloads depending on all of their parameters\n        if (rawActions.length > 1) {\n            converter.logError(`Ambiguous reference in action import: ${rawActionImport.fullyQualifiedName}`);\n        }\n\n        // return the first matching action or function\n        return converter.getConvertedAction(rawActions[0].fullyQualifiedName)!;\n    });\n\n    return convertedActionImport;\n}\n\n/**\n * Converts an Action.\n *\n * @param converter   Converter\n * @param rawAction  Unconverted Action\n * @returns The converted Action\n */\nfunction convertAction(converter: Converter, rawAction: RawAction): Action {\n    const convertedAction = rawAction as Action;\n\n    if (convertedAction.sourceType) {\n        lazy(convertedAction, 'sourceEntityType', resolveEntityType(converter, rawAction.sourceType));\n    }\n\n    if (convertedAction.returnType) {\n        lazy(convertedAction, 'returnEntityType', resolveEntityType(converter, rawAction.returnType));\n    }\n\n    lazy(convertedAction, 'parameters', converter.convert(rawAction.parameters, convertActionParameter));\n\n    lazy(convertedAction, 'annotations', () => {\n        /*\n            Annotation resolution rule for actions:\n\n            (1) annotation target: the specific unbound or bound overload, e.g.\n                    - for actions:   \"x.y.z.unboundAction()\" / \"x.y.z.boundAction(x.y.z.Entity)\"\n                    - for functions: \"x.y.z.unboundFunction(Edm.String)\" / \"x.y.z.unboundFunction(x.y.z.Entity,Edm.String)\"\n            (2) annotation target: unspecified overload, e.g.\n                - for actions:   \"x.y.z.unboundAction\" / \"x.y.z.boundAction\"\n                - for functions: \"x.y.z.unboundFunction\" / \"x.y.z.unboundFunction\"\n\n            When resolving (1) takes precedence over (2). That is, annotations on the specific overload overwrite\n            annotations on the unspecific overload, on term/qualifier level.\n        */\n\n        const unspecificOverloadTarget = substringBeforeFirst(rawAction.fullyQualifiedName, '(');\n        const specificOverloadTarget = rawAction.fullyQualifiedName;\n\n        const effectiveAnnotations = converter.getAnnotations(specificOverloadTarget);\n        const unspecificAnnotations = converter.getAnnotations(unspecificOverloadTarget);\n\n        for (const unspecificAnnotation of unspecificAnnotations) {\n            if (\n                !effectiveAnnotations.some(\n                    (annotation) =>\n                        annotation.term === unspecificAnnotation.term &&\n                        annotation.qualifier === unspecificAnnotation.qualifier\n                )\n            ) {\n                effectiveAnnotations.push(unspecificAnnotation);\n            }\n        }\n\n        return createAnnotationsObject(converter, rawAction, effectiveAnnotations);\n    });\n\n    return convertedAction;\n}\n\n/**\n * Converts an ActionParameter.\n *\n * @param converter   Converter\n * @param rawActionParameter  Unconverted ActionParameter\n * @returns The converted ActionParameter\n */\nfunction convertActionParameter(\n    converter: Converter,\n    rawActionParameter: RawAction['parameters'][number]\n): ActionParameter {\n    const convertedActionParameter = rawActionParameter as ActionParameter;\n\n    lazy(\n        convertedActionParameter,\n        'typeReference',\n        () =>\n            converter.getConvertedEntityType(rawActionParameter.type) ??\n            converter.getConvertedComplexType(rawActionParameter.type) ??\n            converter.getConvertedTypeDefinition(rawActionParameter.type)\n    );\n\n    lazy(convertedActionParameter, 'annotations', () => {\n        // annotations on action parameters are resolved following the rules for actions\n        const unspecificOverloadTarget =\n            rawActionParameter.fullyQualifiedName.substring(0, rawActionParameter.fullyQualifiedName.indexOf('(')) +\n            rawActionParameter.fullyQualifiedName.substring(rawActionParameter.fullyQualifiedName.indexOf(')') + 1);\n        const specificOverloadTarget = rawActionParameter.fullyQualifiedName;\n\n        const effectiveAnnotations = converter.getAnnotations(specificOverloadTarget);\n        const unspecificAnnotations = converter.getAnnotations(unspecificOverloadTarget);\n\n        for (const unspecificAnnotation of unspecificAnnotations) {\n            if (\n                !effectiveAnnotations.some(\n                    (annotation) =>\n                        annotation.term === unspecificAnnotation.term &&\n                        annotation.qualifier === unspecificAnnotation.qualifier\n                )\n            ) {\n                effectiveAnnotations.push(unspecificAnnotation);\n            }\n        }\n\n        return createAnnotationsObject(converter, rawActionParameter, effectiveAnnotations);\n    });\n\n    return convertedActionParameter;\n}\n\n/**\n * Converts a ComplexType.\n *\n * @param converter   Converter\n * @param rawComplexType  Unconverted ComplexType\n * @returns The converted ComplexType\n */\nfunction convertComplexType(converter: Converter, rawComplexType: RawComplexType): ComplexType {\n    const convertedComplexType = rawComplexType as ComplexType;\n\n    lazy(convertedComplexType, 'properties', converter.convert(rawComplexType.properties, convertProperty));\n    lazy(\n        convertedComplexType,\n        'navigationProperties',\n        converter.convert(rawComplexType.navigationProperties as any[], convertNavigationProperty)\n    );\n    lazy(convertedComplexType, 'annotations', resolveAnnotations(converter, rawComplexType));\n\n    return convertedComplexType;\n}\n\n/**\n * Converts a TypeDefinition.\n *\n * @param converter   Converter\n * @param rawTypeDefinition  Unconverted TypeDefinition\n * @returns The converted TypeDefinition\n */\nfunction convertTypeDefinition(converter: Converter, rawTypeDefinition: RawTypeDefinition): TypeDefinition {\n    const convertedTypeDefinition = rawTypeDefinition as TypeDefinition;\n\n    lazy(convertedTypeDefinition, 'annotations', resolveAnnotations(converter, rawTypeDefinition));\n\n    return convertedTypeDefinition;\n}\n\n/**\n * Convert a RawMetadata into an object representation to be used to easily navigate a metadata object and its annotation.\n *\n * @param rawMetadata\n * @returns the converted representation of the metadata.\n */\nexport function convert(rawMetadata: RawMetadata): ConvertedMetadata {\n    // Converter Output\n    const convertedOutput: ConvertedMetadata = {\n        version: rawMetadata.version,\n        namespace: rawMetadata.schema.namespace,\n        annotations: rawMetadata.schema.annotations,\n        references: VocabularyReferences,\n        diagnostics: []\n    } as any;\n\n    // Converter\n    const converter = new Converter(rawMetadata, convertedOutput);\n\n    lazy(\n        convertedOutput,\n        'entityContainer',\n        converter.convert(converter.rawSchema.entityContainer, convertEntityContainer)\n    );\n    lazy(convertedOutput, 'entitySets', converter.convert(converter.rawSchema.entitySets, convertEntitySet));\n    lazy(convertedOutput, 'singletons', converter.convert(converter.rawSchema.singletons, convertSingleton));\n    lazy(convertedOutput, 'entityTypes', converter.convert(converter.rawSchema.entityTypes, convertEntityType));\n    lazy(convertedOutput, 'actions', converter.convert(converter.rawSchema.actions, convertAction));\n    lazy(convertedOutput, 'complexTypes', converter.convert(converter.rawSchema.complexTypes, convertComplexType));\n    lazy(convertedOutput, 'actionImports', converter.convert(converter.rawSchema.actionImports, convertActionImport));\n    lazy(\n        convertedOutput,\n        'typeDefinitions',\n        converter.convert(converter.rawSchema.typeDefinitions, convertTypeDefinition)\n    );\n\n    convertedOutput.resolvePath = function resolvePath<T>(path: string): ResolutionTarget<T> {\n        const targetResolution = resolveTarget<T>(converter, undefined, path);\n        if (targetResolution.target) {\n            appendObjectPath(targetResolution.objectPath, targetResolution.target);\n        }\n        return targetResolution;\n    };\n\n    return convertedOutput;\n}\n","export * from './converter';\nexport * from './utils';\nexport * from './writeback';\n","import type {\n    Annotation,\n    AnnotationList,\n    ArrayWithIndex,\n    ComplexType,\n    Index,\n    Reference,\n    TypeDefinition\n} from '@sap-ux/vocabularies-types';\n\nexport { EnumIsFlag } from '@sap-ux/vocabularies-types/vocabularies/EnumIsFlag';\nexport { TermToTypes } from '@sap-ux/vocabularies-types/vocabularies/TermToTypes';\nexport { VocabularyReferences as defaultReferences } from '@sap-ux/vocabularies-types/vocabularies/VocabularyReferences';\n\nexport type ReferencesWithMap = Reference[] & {\n    referenceMap?: Record<string, Reference>;\n    reverseReferenceMap?: Record<string, Reference>;\n};\n\nfunction splitAt(string: string, index: number): [string, string] {\n    return index < 0 ? [string, ''] : [string.substring(0, index), string.substring(index + 1)];\n}\n\nfunction substringAt(string: string, index: number) {\n    return index < 0 ? string : string.substring(0, index);\n}\n\n/**\n * Splits a string at the first occurrence of a separator.\n *\n * @param string    The string to split\n * @param separator Separator, e.g. a single character.\n * @returns An array consisting of two elements: the part before the first occurrence of the separator and the part after it. If the string does not contain the separator, the second element is the empty string.\n */\nexport function splitAtFirst(string: string, separator: string): [string, string] {\n    return splitAt(string, string.indexOf(separator));\n}\n\n/**\n * Splits a string at the last occurrence of a separator.\n *\n * @param string    The string to split\n * @param separator Separator, e.g. a single character.\n * @returns An array consisting of two elements: the part before the last occurrence of the separator and the part after it. If the string does not contain the separator, the second element is the empty string.\n */\nexport function splitAtLast(string: string, separator: string): [string, string] {\n    return splitAt(string, string.lastIndexOf(separator));\n}\n\n/**\n * Returns the substring before the first occurrence of a separator.\n *\n * @param string    The string\n * @param separator Separator, e.g. a single character.\n * @returns The substring before the first occurrence of the separator, or the input string if it does not contain the separator.\n */\nexport function substringBeforeFirst(string: string, separator: string): string {\n    return substringAt(string, string.indexOf(separator));\n}\n\n/**\n * Returns the substring before the last occurrence of a separator.\n *\n * @param string    The string\n * @param separator Separator, e.g. a single character.\n * @returns The substring before the last occurrence of the separator, or the input string if it does not contain the separator.\n */\nexport function substringBeforeLast(string: string, separator: string): string {\n    return substringAt(string, string.lastIndexOf(separator));\n}\n\n/**\n * Transform an unaliased string representation annotation to the aliased version.\n *\n * @param references currentReferences for the project\n * @param unaliasedValue the unaliased value\n * @returns the aliased string representing the same\n */\nexport function alias(references: ReferencesWithMap, unaliasedValue: string): string {\n    if (!references.reverseReferenceMap) {\n        references.reverseReferenceMap = references.reduce((map: Record<string, Reference>, ref) => {\n            map[ref.namespace] = ref;\n            return map;\n        }, {});\n    }\n    if (!unaliasedValue) {\n        return unaliasedValue;\n    }\n    const [namespace, value] = splitAtLast(unaliasedValue, '.');\n    const reference = references.reverseReferenceMap[namespace];\n    if (reference) {\n        return `${reference.alias}.${value}`;\n    } else if (unaliasedValue.includes('@')) {\n        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem\n        const [preAlias, postAlias] = splitAtFirst(unaliasedValue, '@');\n        return `${preAlias}@${alias(references, postAlias)}`;\n    } else {\n        return unaliasedValue;\n    }\n}\n\n/**\n * Transform an aliased string to its unaliased version given a set of references.\n *\n * @param references The references to use for unaliasing.\n * @param aliasedValue The aliased value\n * @param namespace The fallback namespace\n * @returns The equal unaliased string.\n */\nexport function unalias(\n    references: ReferencesWithMap,\n    aliasedValue: string | undefined,\n    namespace?: string\n): string | undefined {\n    const _unalias = (value: string) => {\n        if (!references.referenceMap) {\n            references.referenceMap = Object.fromEntries(references.map((ref) => [ref.alias, ref]));\n        }\n\n        // Aliases are of type 'SimpleIdentifier' and must not contain dots\n        const [maybeAlias, rest] = splitAtFirst(value, '.');\n\n        if (!rest || rest.includes('.')) {\n            // either there is no dot in the value or there is more than one --> nothing to do\n            return value;\n        }\n\n        const isAnnotation = maybeAlias.startsWith('@');\n        const valueToUnalias = isAnnotation ? maybeAlias.substring(1) : maybeAlias;\n        const knownReference = references.referenceMap[valueToUnalias];\n        if (knownReference) {\n            return isAnnotation ? `@${knownReference.namespace}.${rest}` : `${knownReference.namespace}.${rest}`;\n        }\n\n        // The alias could not be resolved using the references. Assume it is the \"global\" alias (= namespace)\n        return namespace && !isAnnotation ? `${namespace}.${rest}` : value;\n    };\n\n    return aliasedValue\n        ?.split('/')\n        .reduce((segments, segment) => {\n            // the segment could be an action, like \"doSomething(foo.bar)\"\n            const [first, rest] = splitAtFirst(segment, '(');\n            const subSegment = [_unalias(first)];\n\n            if (rest) {\n                const parameter = rest.slice(0, -1); // remove trailing \")\"\n                subSegment.push(`(${_unalias(parameter)})`);\n            }\n            segments.push(subSegment.join(''));\n\n            return segments;\n        }, [] as string[])\n        ?.join('/');\n}\n\n/**\n * Differentiate between a ComplexType and a TypeDefinition.\n *\n * @param complexTypeDefinition\n * @returns true if the value is a complex type\n */\nexport function isComplexTypeDefinition(\n    complexTypeDefinition?: ComplexType | TypeDefinition\n): complexTypeDefinition is ComplexType {\n    return (\n        !!complexTypeDefinition && complexTypeDefinition._type === 'ComplexType' && !!complexTypeDefinition.properties\n    );\n}\n\nexport function Decimal(value: number) {\n    return {\n        isDecimal() {\n            return true;\n        },\n        valueOf() {\n            return value;\n        },\n        toString() {\n            return value.toString();\n        }\n    };\n}\n\n/**\n * Defines a lazy property.\n *\n * The property is initialized by calling the init function on the first read access, or by directly assigning a value.\n *\n * @param object    The host object\n * @param property  The lazy property to add\n * @param init      The function that initializes the property's value\n */\nexport function lazy<Type, Key extends keyof Type>(object: Type, property: Key, init: () => Type[Key]) {\n    const initial = Symbol('initial');\n    let _value: Type[Key] | typeof initial = initial;\n\n    Object.defineProperty(object, property, {\n        enumerable: true,\n\n        get() {\n            if (_value === initial) {\n                _value = init();\n            }\n            return _value;\n        },\n\n        set(value: Type[Key]) {\n            _value = value;\n        }\n    });\n}\n\n/**\n * Creates a function that allows to find an array element by property value.\n *\n * @param array     The array\n * @param property  Elements in the array are searched by this property\n * @returns A function that can be used to find an element of the array by property value.\n */\nexport function createIndexedFind<T>(array: Array<T>, property: keyof T) {\n    const index: Map<T[keyof T], T | undefined> = new Map();\n\n    return function find(value: T[keyof T]) {\n        const element = index.get(value);\n\n        if (element?.[property] === value) {\n            return element;\n        }\n\n        return array.find((element) => {\n            if (!element?.hasOwnProperty(property)) {\n                return false;\n            }\n\n            const propertyValue = element[property];\n            index.set(propertyValue, element);\n            return propertyValue === value;\n        });\n    };\n}\n\n/**\n * Adds a 'get by value' function to an array.\n *\n * If this function is called with addIndex(myArray, 'name'), a new function 'by_name(value)' will be added that allows to\n * find a member of the array by the value of its 'name' property.\n *\n * @param array      The array\n * @param property   The property that will be used by the 'by_{property}()' function\n * @returns The array with the added function\n */\nexport function addGetByValue<T, P extends Extract<keyof T, string>>(array: Array<T>, property: P) {\n    const indexName: keyof Index<T, P> = `by_${property}`;\n\n    if (!array.hasOwnProperty(indexName)) {\n        Object.defineProperty(array, indexName, { writable: false, value: createIndexedFind(array, property) });\n    } else {\n        throw new Error(`Property '${indexName}' already exists`);\n    }\n    return array as ArrayWithIndex<T, P>;\n}\n\n/**\n * Merge annotations from different sources together by overwriting at the term level.\n *\n * @param references        References, used to resolve aliased annotation targets and aliased annotation terms.\n * @param annotationSources Annotation sources\n * @returns the resulting merged annotations\n */\nexport function mergeAnnotations(\n    references: Reference[],\n    ...annotationSources: { name: string; annotationList: AnnotationList[] }[]\n): Record<string, Annotation[]> {\n    return annotationSources.reduceRight((result, { name, annotationList }) => {\n        for (const { target, annotations } of annotationList) {\n            const annotationTarget = unalias(references, target) ?? target;\n            if (!result[annotationTarget]) {\n                result[annotationTarget] = [];\n            }\n\n            const annotationsOnTarget = annotations\n                .map((rawAnnotation): Annotation => {\n                    rawAnnotation.term = unalias(references, rawAnnotation.term) ?? rawAnnotation.term;\n\n                    (rawAnnotation as any).fullyQualifiedName = rawAnnotation.qualifier\n                        ? `${annotationTarget}@${rawAnnotation.term}#${rawAnnotation.qualifier}`\n                        : `${annotationTarget}@${rawAnnotation.term}`;\n\n                    (rawAnnotation as any).__source = name;\n\n                    return rawAnnotation as Annotation;\n                })\n                .filter(\n                    (annotation) =>\n                        !result[annotationTarget].some(\n                            (existingAnnotation) =>\n                                existingAnnotation.term === annotation.term &&\n                                existingAnnotation.qualifier === annotation.qualifier\n                        )\n                );\n\n            result[annotationTarget].push(...annotationsOnTarget);\n        }\n\n        return result;\n    }, {} as Record<string, Annotation[]>);\n}\n","import type {\n    AnnotationPathExpression,\n    AnnotationRecord,\n    AnnotationTerm,\n    Expression,\n    NavigationPropertyPathExpression,\n    PathExpression,\n    PropertyPathExpression,\n    RawAnnotation,\n    Reference\n} from '@sap-ux/vocabularies-types';\nimport { unalias } from './utils';\n\n/**\n * Revert an object to its raw type equivalent.\n *\n * @param references the current reference\n * @param value the value to revert\n * @returns the raw value\n */\nfunction revertObjectToRawType(references: Reference[], value: any) {\n    let result: Expression | undefined;\n    if (Array.isArray(value)) {\n        result = {\n            type: 'Collection',\n            Collection: value.map((anno) => revertCollectionItemToRawType(references, anno)) as any[]\n        };\n    } else if (value.isDecimal?.()) {\n        result = {\n            type: 'Decimal',\n            Decimal: value.valueOf()\n        };\n    } else if (value.isString?.()) {\n        const valueMatches = value.valueOf().split('.');\n        if (valueMatches.length > 1 && references.find((ref) => ref.alias === valueMatches[0])) {\n            result = {\n                type: 'EnumMember',\n                EnumMember: value.valueOf()\n            };\n        } else {\n            result = {\n                type: 'String',\n                String: value.valueOf()\n            };\n        }\n    } else if (value.isInt?.()) {\n        result = {\n            type: 'Int',\n            Int: value.valueOf()\n        };\n    } else if (value.isFloat?.()) {\n        result = {\n            type: 'Float',\n            Float: value.valueOf()\n        };\n    } else if (value.isDate?.()) {\n        result = {\n            type: 'Date',\n            Date: value.valueOf()\n        };\n    } else if (value.isBoolean?.()) {\n        result = {\n            type: 'Bool',\n            Bool: value.valueOf()\n        };\n    } else if (value.type === 'Path') {\n        result = {\n            type: 'Path',\n            Path: value.path\n        };\n    } else if (value.type === 'AnnotationPath') {\n        result = {\n            type: 'AnnotationPath',\n            AnnotationPath: value.value\n        };\n    } else if (value.type === 'Apply') {\n        result = {\n            type: 'Apply',\n            $Apply: value.$Apply,\n            $Function: value.$Function\n        };\n    } else if (value.type === 'Null') {\n        result = {\n            type: 'Null'\n        };\n    } else if (value.type === 'PropertyPath') {\n        result = {\n            type: 'PropertyPath',\n            PropertyPath: value.value\n        };\n    } else if (value.type === 'NavigationPropertyPath') {\n        result = {\n            type: 'NavigationPropertyPath',\n            NavigationPropertyPath: value.value\n        };\n    } else if (Object.prototype.hasOwnProperty.call(value, '$Type')) {\n        result = {\n            type: 'Record',\n            Record: revertCollectionItemToRawType(references, value) as AnnotationRecord\n        };\n    }\n    return result;\n}\n\n/**\n * Revert a value to its raw value depending on its type.\n *\n * @param references the current set of reference\n * @param value the value to revert\n * @returns the raw expression\n */\nfunction revertValueToRawType(references: Reference[], value: any): Expression | undefined {\n    let result: Expression | undefined;\n    const valueConstructor = value?.constructor.name;\n    switch (valueConstructor) {\n        case 'String':\n        case 'string':\n            const valueMatches = value.toString().split('.');\n            if (valueMatches.length > 1 && references.find((ref) => ref.alias === valueMatches[0])) {\n                result = {\n                    type: 'EnumMember',\n                    EnumMember: value.toString()\n                };\n            } else {\n                result = {\n                    type: 'String',\n                    String: value.toString()\n                };\n            }\n            break;\n        case 'Boolean':\n        case 'boolean':\n            result = {\n                type: 'Bool',\n                Bool: value.valueOf()\n            };\n            break;\n\n        case 'Number':\n        case 'number':\n            if (value.toString() === value.toFixed()) {\n                result = {\n                    type: 'Int',\n                    Int: value.valueOf()\n                };\n            } else {\n                result = {\n                    type: 'Decimal',\n                    Decimal: value.valueOf()\n                };\n            }\n            break;\n        case 'object':\n        default:\n            result = revertObjectToRawType(references, value);\n            break;\n    }\n    return result;\n}\n\nconst restrictedKeys = ['$Type', 'term', '__source', 'qualifier', 'ActionTarget', 'fullyQualifiedName', 'annotations'];\n\n/**\n * Revert the current embedded annotations to their raw type.\n *\n * @param references the current set of reference\n * @param currentAnnotations the collection item to evaluate\n * @param targetAnnotations the place where we need to add the annotation\n */\nfunction revertAnnotationsToRawType(\n    references: Reference[],\n    currentAnnotations: any,\n    targetAnnotations: RawAnnotation[]\n) {\n    Object.keys(currentAnnotations)\n        .filter((key) => key !== '_annotations')\n        .forEach((key) => {\n            Object.keys(currentAnnotations[key]).forEach((term) => {\n                const parsedAnnotation = revertTermToGenericType(references, currentAnnotations[key][term]);\n                if (!parsedAnnotation.term) {\n                    const unaliasedTerm = unalias(references, `${key}.${term}`);\n                    if (unaliasedTerm) {\n                        const qualifiedSplit = unaliasedTerm.split('#');\n                        parsedAnnotation.term = qualifiedSplit[0];\n                        if (qualifiedSplit.length > 1) {\n                            // Sub Annotation with a qualifier, not sure when that can happen in real scenarios\n                            parsedAnnotation.qualifier = qualifiedSplit[1];\n                        }\n                    }\n                }\n                targetAnnotations.push(parsedAnnotation);\n            });\n        });\n}\n\n/**\n * Revert the current collection item to the corresponding raw annotation.\n *\n * @param references the current set of reference\n * @param collectionItem the collection item to evaluate\n * @returns the raw type equivalent\n */\nfunction revertCollectionItemToRawType(\n    references: Reference[],\n    collectionItem: any\n):\n    | AnnotationRecord\n    | string\n    | PropertyPathExpression\n    | PathExpression\n    | NavigationPropertyPathExpression\n    | AnnotationPathExpression\n    | undefined {\n    if (typeof collectionItem === 'string') {\n        return collectionItem;\n    } else if (typeof collectionItem === 'object') {\n        if (collectionItem.hasOwnProperty('$Type')) {\n            // Annotation Record\n            const outItem: AnnotationRecord = {\n                type: collectionItem.$Type,\n                propertyValues: [] as any[]\n            };\n            // Could validate keys and type based on $Type\n            Object.keys(collectionItem).forEach((collectionKey) => {\n                if (restrictedKeys.indexOf(collectionKey) === -1) {\n                    const value = collectionItem[collectionKey];\n                    outItem.propertyValues.push({\n                        name: collectionKey,\n                        value: revertValueToRawType(references, value) as Expression\n                    });\n                } else if (collectionKey === 'annotations' && Object.keys(collectionItem[collectionKey]).length > 0) {\n                    outItem.annotations = [];\n                    revertAnnotationsToRawType(references, collectionItem[collectionKey], outItem.annotations);\n                }\n            });\n            return outItem;\n        } else if (collectionItem.type === 'PropertyPath') {\n            return {\n                type: 'PropertyPath',\n                PropertyPath: collectionItem.value\n            };\n        } else if (collectionItem.type === 'AnnotationPath') {\n            return {\n                type: 'AnnotationPath',\n                AnnotationPath: collectionItem.value\n            };\n        } else if (collectionItem.type === 'NavigationPropertyPath') {\n            return {\n                type: 'NavigationPropertyPath',\n                NavigationPropertyPath: collectionItem.value\n            };\n        }\n    }\n    return undefined;\n}\n\n/**\n * Revert an annotation term to it's generic or raw equivalent.\n *\n * @param references the reference of the current context\n * @param annotation the annotation term to revert\n * @returns the raw annotation\n */\nexport function revertTermToGenericType(references: Reference[], annotation: AnnotationTerm<any>): RawAnnotation {\n    const baseAnnotation: RawAnnotation = {\n        term: annotation.term,\n        qualifier: annotation.qualifier\n    };\n    if (Array.isArray(annotation)) {\n        // Collection\n        if (annotation.hasOwnProperty('annotations') && Object.keys((annotation as any).annotations).length > 0) {\n            // Annotation on a collection itself, not sure when that happens if at all\n            baseAnnotation.annotations = [];\n            revertAnnotationsToRawType(references, (annotation as any).annotations, baseAnnotation.annotations);\n        }\n        return {\n            ...baseAnnotation,\n            collection: annotation.map((anno) => revertCollectionItemToRawType(references, anno)) as any[]\n        };\n    } else if (annotation.hasOwnProperty('$Type')) {\n        return { ...baseAnnotation, record: revertCollectionItemToRawType(references, annotation) as any };\n    } else {\n        return { ...baseAnnotation, value: revertValueToRawType(references, annotation) };\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EnumIsFlag = void 0;\nexports.EnumIsFlag = {\n    \"Authorization.KeyLocation\": false,\n    \"Core.RevisionKind\": false,\n    \"Core.DataModificationOperationKind\": false,\n    \"Core.Permission\": true,\n    \"Capabilities.ConformanceLevelType\": false,\n    \"Capabilities.IsolationLevel\": true,\n    \"Capabilities.NavigationType\": false,\n    \"Capabilities.SearchExpressions\": true,\n    \"Capabilities.HttpMethod\": true,\n    \"Aggregation.RollupType\": false,\n    \"Common.TextFormatType\": false,\n    \"Common.FilterExpressionType\": false,\n    \"Common.FieldControlType\": false,\n    \"Common.EffectType\": true,\n    \"Communication.KindType\": false,\n    \"Communication.ContactInformationType\": true,\n    \"Communication.PhoneType\": true,\n    \"Communication.GenderType\": false,\n    \"UI.VisualizationType\": false,\n    \"UI.CriticalityType\": false,\n    \"UI.ImprovementDirectionType\": false,\n    \"UI.TrendType\": false,\n    \"UI.ChartType\": false,\n    \"UI.ChartAxisScaleBehaviorType\": false,\n    \"UI.ChartAxisAutoScaleDataScopeType\": false,\n    \"UI.ChartDimensionRoleType\": false,\n    \"UI.ChartMeasureRoleType\": false,\n    \"UI.SelectionRangeSignType\": false,\n    \"UI.SelectionRangeOptionType\": false,\n    \"UI.TextArrangementType\": false,\n    \"UI.ImportanceType\": false,\n    \"UI.CriticalityRepresentationType\": false,\n    \"UI.OperationGroupingType\": false,\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TermToTypes = void 0;\nvar TermToTypes;\n(function (TermToTypes) {\n    TermToTypes[\"Org.OData.Authorization.V1.SecuritySchemes\"] = \"Org.OData.Authorization.V1.SecurityScheme\";\n    TermToTypes[\"Org.OData.Authorization.V1.Authorizations\"] = \"Org.OData.Authorization.V1.Authorization\";\n    TermToTypes[\"Org.OData.Core.V1.Revisions\"] = \"Org.OData.Core.V1.RevisionType\";\n    TermToTypes[\"Org.OData.Core.V1.Links\"] = \"Org.OData.Core.V1.Link\";\n    TermToTypes[\"Org.OData.Core.V1.Example\"] = \"Org.OData.Core.V1.ExampleValue\";\n    TermToTypes[\"Org.OData.Core.V1.Messages\"] = \"Org.OData.Core.V1.MessageType\";\n    TermToTypes[\"Org.OData.Core.V1.ValueException\"] = \"Org.OData.Core.V1.ValueExceptionType\";\n    TermToTypes[\"Org.OData.Core.V1.ResourceException\"] = \"Org.OData.Core.V1.ResourceExceptionType\";\n    TermToTypes[\"Org.OData.Core.V1.DataModificationException\"] = \"Org.OData.Core.V1.DataModificationExceptionType\";\n    TermToTypes[\"Org.OData.Core.V1.IsLanguageDependent\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.AppliesViaContainer\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.DereferenceableIDs\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.ConventionalIDs\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.Permissions\"] = \"Org.OData.Core.V1.Permission\";\n    TermToTypes[\"Org.OData.Core.V1.DefaultNamespace\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.Immutable\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.Computed\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.ComputedDefaultValue\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.IsURL\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.IsMediaType\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.ContentDisposition\"] = \"Org.OData.Core.V1.ContentDispositionType\";\n    TermToTypes[\"Org.OData.Core.V1.OptimisticConcurrency\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"Org.OData.Core.V1.AdditionalProperties\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.AutoExpand\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.AutoExpandReferences\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.MayImplement\"] = \"Org.OData.Core.V1.QualifiedTypeName\";\n    TermToTypes[\"Org.OData.Core.V1.Ordered\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.PositionalInsert\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.AlternateKeys\"] = \"Org.OData.Core.V1.AlternateKey\";\n    TermToTypes[\"Org.OData.Core.V1.OptionalParameter\"] = \"Org.OData.Core.V1.OptionalParameterType\";\n    TermToTypes[\"Org.OData.Core.V1.OperationAvailable\"] = \"Edm.Boolean\";\n    TermToTypes[\"Org.OData.Core.V1.RequiresExplicitBinding\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.ExplicitOperationBindings\"] = \"Org.OData.Core.V1.QualifiedBoundOperationName\";\n    TermToTypes[\"Org.OData.Core.V1.SymbolicName\"] = \"Org.OData.Core.V1.SimpleIdentifier\";\n    TermToTypes[\"Org.OData.Core.V1.GeometryFeature\"] = \"Org.OData.Core.V1.GeometryFeatureType\";\n    TermToTypes[\"Org.OData.Core.V1.AnyStructure\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.IsDelta\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ConformanceLevel\"] = \"Org.OData.Capabilities.V1.ConformanceLevelType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.AsynchronousRequestsSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.BatchContinueOnErrorSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.IsolationSupported\"] = \"Org.OData.Capabilities.V1.IsolationLevel\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CrossJoinSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CallbackSupported\"] = \"Org.OData.Capabilities.V1.CallbackType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ChangeTracking\"] = \"Org.OData.Capabilities.V1.ChangeTrackingType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CountRestrictions\"] = \"Org.OData.Capabilities.V1.CountRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.NavigationRestrictions\"] = \"Org.OData.Capabilities.V1.NavigationRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.IndexableByKey\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.TopSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.SkipSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ComputeSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.SelectSupport\"] = \"Org.OData.Capabilities.V1.SelectSupportType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.BatchSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.BatchSupport\"] = \"Org.OData.Capabilities.V1.BatchSupportType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.FilterRestrictions\"] = \"Org.OData.Capabilities.V1.FilterRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.SortRestrictions\"] = \"Org.OData.Capabilities.V1.SortRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ExpandRestrictions\"] = \"Org.OData.Capabilities.V1.ExpandRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.SearchRestrictions\"] = \"Org.OData.Capabilities.V1.SearchRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.KeyAsSegmentSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.QuerySegmentSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.InsertRestrictions\"] = \"Org.OData.Capabilities.V1.InsertRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.DeepInsertSupport\"] = \"Org.OData.Capabilities.V1.DeepInsertSupportType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.UpdateRestrictions\"] = \"Org.OData.Capabilities.V1.UpdateRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.DeepUpdateSupport\"] = \"Org.OData.Capabilities.V1.DeepUpdateSupportType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.DeleteRestrictions\"] = \"Org.OData.Capabilities.V1.DeleteRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CollectionPropertyRestrictions\"] = \"Org.OData.Capabilities.V1.CollectionPropertyRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.OperationRestrictions\"] = \"Org.OData.Capabilities.V1.OperationRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.AnnotationValuesInQuerySupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ModificationQueryOptions\"] = \"Org.OData.Capabilities.V1.ModificationQueryOptionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ReadRestrictions\"] = \"Org.OData.Capabilities.V1.ReadRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CustomHeaders\"] = \"Org.OData.Capabilities.V1.CustomParameter\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CustomQueryOptions\"] = \"Org.OData.Capabilities.V1.CustomParameter\";\n    TermToTypes[\"Org.OData.Capabilities.V1.MediaLocationUpdateSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.DefaultCapabilities\"] = \"Org.OData.Capabilities.V1.DefaultCapabilitiesType\";\n    TermToTypes[\"Org.OData.Aggregation.V1.ApplySupported\"] = \"Org.OData.Aggregation.V1.ApplySupportedType\";\n    TermToTypes[\"Org.OData.Aggregation.V1.ApplySupportedDefaults\"] = \"Org.OData.Aggregation.V1.ApplySupportedBase\";\n    TermToTypes[\"Org.OData.Aggregation.V1.Groupable\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Aggregation.V1.Aggregatable\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Aggregation.V1.ContextDefiningProperties\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"Org.OData.Aggregation.V1.LeveledHierarchy\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"Org.OData.Aggregation.V1.RecursiveHierarchy\"] = \"Org.OData.Aggregation.V1.RecursiveHierarchyType\";\n    TermToTypes[\"Org.OData.Aggregation.V1.AvailableOnAggregates\"] = \"Org.OData.Aggregation.V1.AvailableOnAggregatesType\";\n    TermToTypes[\"Org.OData.Validation.V1.Minimum\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"Org.OData.Validation.V1.Maximum\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"Org.OData.Validation.V1.Exclusive\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Validation.V1.AllowedValues\"] = \"Org.OData.Validation.V1.AllowedValue\";\n    TermToTypes[\"Org.OData.Validation.V1.MultipleOf\"] = \"Edm.Decimal\";\n    TermToTypes[\"Org.OData.Validation.V1.Constraint\"] = \"Org.OData.Validation.V1.ConstraintType\";\n    TermToTypes[\"Org.OData.Validation.V1.ItemsOf\"] = \"Org.OData.Validation.V1.ItemsOfType\";\n    TermToTypes[\"Org.OData.Validation.V1.OpenPropertyTypeConstraint\"] = \"Org.OData.Validation.V1.SingleOrCollectionType\";\n    TermToTypes[\"Org.OData.Validation.V1.DerivedTypeConstraint\"] = \"Org.OData.Validation.V1.SingleOrCollectionType\";\n    TermToTypes[\"Org.OData.Validation.V1.AllowedTerms\"] = \"Org.OData.Core.V1.QualifiedTermName\";\n    TermToTypes[\"Org.OData.Validation.V1.ApplicableTerms\"] = \"Org.OData.Core.V1.QualifiedTermName\";\n    TermToTypes[\"Org.OData.Validation.V1.MaxItems\"] = \"Edm.Int64\";\n    TermToTypes[\"Org.OData.Validation.V1.MinItems\"] = \"Edm.Int64\";\n    TermToTypes[\"Org.OData.Measures.V1.Scale\"] = \"Edm.Byte\";\n    TermToTypes[\"Org.OData.Measures.V1.DurationGranularity\"] = \"Org.OData.Measures.V1.DurationGranularityType\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.Dimension\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.Measure\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.AccumulativeMeasure\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.RolledUpPropertyCount\"] = \"Edm.Int16\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.PlanningAction\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.AggregatedProperties\"] = \"com.sap.vocabularies.Analytics.v1.AggregatedPropertyType\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.AggregatedProperty\"] = \"com.sap.vocabularies.Analytics.v1.AggregatedPropertyType\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.AnalyticalContext\"] = \"com.sap.vocabularies.Analytics.v1.AnalyticalContextType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ServiceVersion\"] = \"Edm.Int32\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ServiceSchemaVersion\"] = \"Edm.Int32\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.TextFor\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsLanguageIdentifier\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.TextFormat\"] = \"com.sap.vocabularies.Common.v1.TextFormatType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsTimezone\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsDigitSequence\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsUpperCase\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCurrency\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsUnit\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.UnitSpecificScale\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.UnitSpecificPrecision\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SecondaryKey\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.MinOccurs\"] = \"Edm.Int64\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.MaxOccurs\"] = \"Edm.Int64\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.AssociationEntity\"] = \"Edm.NavigationPropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DerivedNavigation\"] = \"Edm.NavigationPropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Masked\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.RevealOnDemand\"] = \"Edm.Boolean\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SemanticObjectMapping\"] = \"com.sap.vocabularies.Common.v1.SemanticObjectMappingAbstract\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsInstanceAnnotation\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.FilterExpressionRestrictions\"] = \"com.sap.vocabularies.Common.v1.FilterExpressionRestrictionType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.FieldControl\"] = \"com.sap.vocabularies.Common.v1.FieldControlType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Application\"] = \"com.sap.vocabularies.Common.v1.ApplicationType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Timestamp\"] = \"Edm.DateTimeOffset\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ErrorResolution\"] = \"com.sap.vocabularies.Common.v1.ErrorResolutionType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Messages\"] = \"Edm.ComplexType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.numericSeverity\"] = \"com.sap.vocabularies.Common.v1.NumericMessageSeverityType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.MaximumNumericMessageSeverity\"] = \"com.sap.vocabularies.Common.v1.NumericMessageSeverityType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsActionCritical\"] = \"Edm.Boolean\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Attributes\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.RelatedRecursiveHierarchy\"] = \"Edm.AnnotationPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Interval\"] = \"com.sap.vocabularies.Common.v1.IntervalType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ResultContext\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SAPObjectNodeType\"] = \"com.sap.vocabularies.Common.v1.SAPObjectNodeTypeType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Composition\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsNaturalPerson\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ValueList\"] = \"com.sap.vocabularies.Common.v1.ValueListType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ValueListRelevantQualifiers\"] = \"Org.OData.Core.V1.SimpleIdentifier\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ValueListWithFixedValues\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ValueListShowValuesImmediately\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ValueListMapping\"] = \"com.sap.vocabularies.Common.v1.ValueListMappingType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarHalfyear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarQuarter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarMonth\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarWeek\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsDayOfCalendarMonth\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsDayOfCalendarYear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYearHalfyear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYearQuarter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYearMonth\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYearWeek\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarDate\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalPeriod\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYearPeriod\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalQuarter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYearQuarter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalWeek\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYearWeek\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsDayOfFiscalYear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYearVariant\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.MutuallyExclusiveTerm\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DraftRoot\"] = \"com.sap.vocabularies.Common.v1.DraftRootType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DraftNode\"] = \"com.sap.vocabularies.Common.v1.DraftNodeType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DraftActivationVia\"] = \"Org.OData.Core.V1.SimpleIdentifier\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.EditableFieldFor\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SemanticKey\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SideEffects\"] = \"com.sap.vocabularies.Common.v1.SideEffectsType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DefaultValuesFunction\"] = \"com.sap.vocabularies.Common.v1.QualifiedName\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.FilterDefaultValue\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.FilterDefaultValueHigh\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SortOrder\"] = \"com.sap.vocabularies.Common.v1.SortOrderType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.RecursiveHierarchy\"] = \"com.sap.vocabularies.Common.v1.RecursiveHierarchyType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.CreatedAt\"] = \"Edm.DateTimeOffset\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.CreatedBy\"] = \"com.sap.vocabularies.Common.v1.UserID\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ChangedAt\"] = \"Edm.DateTimeOffset\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ChangedBy\"] = \"com.sap.vocabularies.Common.v1.UserID\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ApplyMultiUnitBehaviorForSortingAndFiltering\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.PrimitivePropertyPath\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.CurrencyCodes\"] = \"com.sap.vocabularies.CodeList.v1.CodeListSource\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.UnitsOfMeasure\"] = \"com.sap.vocabularies.CodeList.v1.CodeListSource\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.StandardCode\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.ExternalCode\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.IsConfigurationDeprecationCode\"] = \"Edm.Boolean\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Contact\"] = \"com.sap.vocabularies.Communication.v1.ContactType\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Address\"] = \"com.sap.vocabularies.Communication.v1.AddressType\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.IsEmailAddress\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.IsPhoneNumber\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Event\"] = \"com.sap.vocabularies.Communication.v1.EventData\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Task\"] = \"com.sap.vocabularies.Communication.v1.TaskData\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Message\"] = \"com.sap.vocabularies.Communication.v1.MessageData\";\n    TermToTypes[\"com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchy\"] = \"com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchyType\";\n    TermToTypes[\"com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchyActions\"] = \"com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchyActionsType\";\n    TermToTypes[\"com.sap.vocabularies.Hierarchy.v1.MatchCount\"] = \"Edm.Int64\";\n    TermToTypes[\"com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchySupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.PersonalData.v1.EntitySemantics\"] = \"com.sap.vocabularies.PersonalData.v1.EntitySemanticsType\";\n    TermToTypes[\"com.sap.vocabularies.PersonalData.v1.FieldSemantics\"] = \"com.sap.vocabularies.PersonalData.v1.FieldSemanticsType\";\n    TermToTypes[\"com.sap.vocabularies.PersonalData.v1.IsPotentiallyPersonal\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.PersonalData.v1.IsPotentiallySensitive\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Session.v1.StickySessionSupported\"] = \"com.sap.vocabularies.Session.v1.StickySessionSupportedType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.HeaderInfo\"] = \"com.sap.vocabularies.UI.v1.HeaderInfoType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Identification\"] = \"com.sap.vocabularies.UI.v1.DataFieldAbstract\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Badge\"] = \"com.sap.vocabularies.UI.v1.BadgeType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.LineItem\"] = \"com.sap.vocabularies.UI.v1.DataFieldAbstract\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.StatusInfo\"] = \"com.sap.vocabularies.UI.v1.DataFieldAbstract\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.FieldGroup\"] = \"com.sap.vocabularies.UI.v1.FieldGroupType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ConnectedFields\"] = \"com.sap.vocabularies.UI.v1.ConnectedFieldsType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.GeoLocations\"] = \"com.sap.vocabularies.UI.v1.GeoLocationType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.GeoLocation\"] = \"com.sap.vocabularies.UI.v1.GeoLocationType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Contacts\"] = \"Edm.AnnotationPath\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.MediaResource\"] = \"com.sap.vocabularies.UI.v1.MediaResourceType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.DataPoint\"] = \"com.sap.vocabularies.UI.v1.DataPointType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.KPI\"] = \"com.sap.vocabularies.UI.v1.KPIType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Chart\"] = \"com.sap.vocabularies.UI.v1.ChartDefinitionType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ValueCriticality\"] = \"com.sap.vocabularies.UI.v1.ValueCriticalityType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.CriticalityLabels\"] = \"com.sap.vocabularies.UI.v1.CriticalityLabelType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.SelectionFields\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Facets\"] = \"com.sap.vocabularies.UI.v1.Facet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.HeaderFacets\"] = \"com.sap.vocabularies.UI.v1.Facet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.QuickViewFacets\"] = \"com.sap.vocabularies.UI.v1.Facet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.QuickCreateFacets\"] = \"com.sap.vocabularies.UI.v1.Facet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.FilterFacets\"] = \"com.sap.vocabularies.UI.v1.ReferenceFacet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.SelectionPresentationVariant\"] = \"com.sap.vocabularies.UI.v1.SelectionPresentationVariantType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.PresentationVariant\"] = \"com.sap.vocabularies.UI.v1.PresentationVariantType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.SelectionVariant\"] = \"com.sap.vocabularies.UI.v1.SelectionVariantType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ThingPerspective\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.IsSummary\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.PartOfPreview\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Map\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Gallery\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.IsImageURL\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.IsImage\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.MultiLineText\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.InputMask\"] = \"com.sap.vocabularies.UI.v1.InputMaskType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.TextArrangement\"] = \"com.sap.vocabularies.UI.v1.TextArrangementType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Note\"] = \"com.sap.vocabularies.UI.v1.NoteType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Importance\"] = \"com.sap.vocabularies.UI.v1.ImportanceType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Hidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.IsCopyAction\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.IsAIOperation\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.CreateHidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.UpdateHidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.DeleteHidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.HiddenFilter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.AdaptationHidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.DataFieldDefault\"] = \"com.sap.vocabularies.UI.v1.DataFieldAbstract\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Criticality\"] = \"com.sap.vocabularies.UI.v1.CriticalityType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.CriticalityCalculation\"] = \"com.sap.vocabularies.UI.v1.CriticalityCalculationType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Emphasized\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.OrderBy\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ParameterDefaultValue\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.RecommendationState\"] = \"com.sap.vocabularies.UI.v1.RecommendationStateType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.RecommendationList\"] = \"com.sap.vocabularies.UI.v1.RecommendationListType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Recommendations\"] = \"Edm.ComplexType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ExcludeFromNavigationContext\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.DoNotCheckScaleOfMeasuredQuantity\"] = \"Edm.Boolean\";\n    TermToTypes[\"com.sap.vocabularies.HTML5.v1.CssDefaults\"] = \"com.sap.vocabularies.HTML5.v1.CssDefaultsType\";\n    TermToTypes[\"com.sap.vocabularies.HTML5.v1.LinkTarget\"] = \"com.sap.vocabularies.HTML5.v1.LinkTargetType\";\n    TermToTypes[\"com.sap.vocabularies.HTML5.v1.RowSpanForDuplicateValues\"] = \"Org.OData.Core.V1.Tag\";\n})(TermToTypes = exports.TermToTypes || (exports.TermToTypes = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VocabularyReferences = void 0;\n/**\n * The list of vocabularies with default aliases.\n */\nexports.VocabularyReferences = [\n    { alias: \"Authorization\", namespace: \"Org.OData.Authorization.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml\" },\n    { alias: \"Core\", namespace: \"Org.OData.Core.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml\" },\n    { alias: \"Capabilities\", namespace: \"Org.OData.Capabilities.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml\" },\n    { alias: \"Aggregation\", namespace: \"Org.OData.Aggregation.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml\" },\n    { alias: \"Validation\", namespace: \"Org.OData.Validation.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Validation.V1.xml\" },\n    { alias: \"Measures\", namespace: \"Org.OData.Measures.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Measures.V1.xml\" },\n    { alias: \"Analytics\", namespace: \"com.sap.vocabularies.Analytics.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Analytics.xml\" },\n    { alias: \"Common\", namespace: \"com.sap.vocabularies.Common.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Common.xml\" },\n    { alias: \"CodeList\", namespace: \"com.sap.vocabularies.CodeList.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/CodeList.xml\" },\n    { alias: \"Communication\", namespace: \"com.sap.vocabularies.Communication.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Communication.xml\" },\n    { alias: \"Hierarchy\", namespace: \"com.sap.vocabularies.Hierarchy.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Hierarchy.xml\" },\n    { alias: \"PersonalData\", namespace: \"com.sap.vocabularies.PersonalData.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/PersonalData.xml\" },\n    { alias: \"Session\", namespace: \"com.sap.vocabularies.Session.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Session.xml\" },\n    { alias: \"UI\", namespace: \"com.sap.vocabularies.UI.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/UI.xml\" },\n    { alias: \"HTML5\", namespace: \"com.sap.vocabularies.HTML5.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/HTML5.xml\" }\n];\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n",null],"mappings":"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","ignoreList":[]}