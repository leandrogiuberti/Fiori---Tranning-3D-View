{"version":3,"sources":["webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+annotation-converter@0.9.6/node_modules/@sap-ux/annotation-converter/src/converter.ts","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+annotation-converter@0.9.6/node_modules/@sap-ux/annotation-converter/src/index.ts","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+annotation-converter@0.9.6/node_modules/@sap-ux/annotation-converter/src/utils.ts","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+annotation-converter@0.9.6/node_modules/@sap-ux/annotation-converter/src/writeback.ts","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+vocabularies-types@0.11.4/node_modules/@sap-ux/vocabularies-types/vocabularies/EnumIsFlag.js","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+vocabularies-types@0.11.4/node_modules/@sap-ux/vocabularies-types/vocabularies/TermToTypes.js","webpack://AnnotationConverter/node_modules/.pnpm/@sap-ux+vocabularies-types@0.11.4/node_modules/@sap-ux/vocabularies-types/vocabularies/VocabularyReferences.js","webpack://AnnotationConverter/webpack/bootstrap","webpack://AnnotationConverter/webpack/startup"],"names":[],"mappings":"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AM,IAAI,UAAU,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE;QAC3C,OAAO,EAAE,GAAG,cAAc,EAAE,MAAM,EAAE,6BAA6B,CAAC,UAAU,EAAE,UAAU,CAAQ,EAAE,CAAC;KACtG;SAAM;QACH,OAAO,EAAE,GAAG,cAAc,EAAE,KAAK,EAAE,oBAAoB,CAAC,UAAU,EAAE,UAAU,CAAC,EAAE,CAAC;KACrF;AACL,CAAC;AArBD,0DAqBC;;;;;;;;AC5RY;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;;;;;;;;AC9QpD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B,MAAM,oKAAoK;AAC1K,MAAM,yIAAyI;AAC/I,MAAM,iKAAiK;AACvK,MAAM,8JAA8J;AACpK,MAAM,2JAA2J;AACjK,MAAM,qJAAqJ;AAC3J,MAAM,gJAAgJ;AACtJ,MAAM,uIAAuI;AAC7I,MAAM,6IAA6I;AACnJ,MAAM,4JAA4J;AAClK,MAAM,gJAAgJ;AACtJ,MAAM,yJAAyJ;AAC/J,MAAM,0IAA0I;AAChJ,MAAM,2HAA2H;AACjI,MAAM;AACN;;;;;;;UCtBA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UCtBA;UACA;UACA;UACA","file":"AnnotationConverter-dbg.js","sourceRoot":"","sourcesContent":["import type {\n    Action,\n    ActionImport,\n    ActionParameter,\n    Annotation,\n    AnnotationPath,\n    AnnotationRecord,\n    ArrayWithIndex,\n    BaseNavigationProperty,\n    ComplexType,\n    ConvertedMetadata,\n    EntityContainer,\n    EntitySet,\n    EntityType,\n    Expression,\n    FullyQualifiedName,\n    NavigationProperty,\n    NavigationPropertyPath,\n    PathAnnotationExpression,\n    Property,\n    PropertyPath,\n    RawAction,\n    RawActionImport,\n    RawAnnotation,\n    RawComplexType,\n    RawEntityContainer,\n    RawEntitySet,\n    RawEntityType,\n    RawMetadata,\n    RawNavigationPropertyBinding,\n    RawProperty,\n    RawSchema,\n    RawSingleton,\n    RawTypeDefinition,\n    RawV2NavigationProperty,\n    RawV4NavigationProperty,\n    RemoveAnnotationAndType,\n    ResolutionTarget,\n    Singleton,\n    TypeDefinition\n} from '@sap-ux/vocabularies-types';\nimport { VocabularyReferences } from '@sap-ux/vocabularies-types/vocabularies/VocabularyReferences';\nimport {\n    addGetByValue,\n    alias,\n    Decimal,\n    EnumIsFlag,\n    lazy,\n    mergeAnnotations,\n    splitAtFirst,\n    splitAtLast,\n    substringBeforeFirst,\n    substringBeforeLast,\n    TermToTypes,\n    unalias\n} from './utils';\n\n/**\n * Symbol to extend an annotation with the reference to its target.\n */\nconst ANNOTATION_TARGET = Symbol('Annotation Target');\n\n/**\n * Append an object to the list of visited objects if it is different from the last object in the list.\n *\n * @param objectPath    The list of visited objects\n * @param visitedObject The object\n * @returns The list of visited objects\n */\nfunction appendObjectPath(objectPath: any[], visitedObject: any): any[] {\n    if (objectPath[objectPath.length - 1] !== visitedObject) {\n        objectPath.push(visitedObject);\n    }\n    return objectPath;\n}\n\n/**\n * Resolves a (possibly relative) path.\n *\n * @param converter         Converter\n * @param startElement      The starting point in case of relative path resolution\n * @param path              The path to resolve\n * @param annotationsTerm   Only for error reporting: The annotation term\n * @returns An object containing the resolved target and the elements that were visited while getting to the target.\n */\nfunction resolveTarget<T>(\n    converter: Converter,\n    startElement: any,\n    path: string | undefined,\n    annotationsTerm?: string\n): ResolutionTarget<T> {\n    if (path === undefined) {\n        return { target: undefined, objectPath: [], messages: [] };\n    }\n\n    // absolute paths always start at the entity container\n    if (path.startsWith('/')) {\n        path = path.substring(1);\n        startElement = undefined; // will resolve to the entity container (see below)\n    }\n\n    const pathSegments = path.split('/').reduce((targetPath, segment) => {\n        if (segment.includes('@')) {\n            // Separate out the annotation\n            const [pathPart, annotationPart] = splitAtFirst(segment, '@');\n            targetPath.push(pathPart);\n            targetPath.push(`@${annotationPart}`);\n        } else {\n            targetPath.push(segment);\n        }\n        return targetPath;\n    }, [] as string[]);\n\n    // determine the starting point for the resolution\n    if (startElement === undefined) {\n        // no starting point given: start at the entity container\n        if (\n            pathSegments[0].startsWith(`${converter.rawSchema.namespace}.`) &&\n            pathSegments[0] !== converter.getConvertedEntityContainer()?.fullyQualifiedName\n        ) {\n            // We have a fully qualified name in the path that is not the entity container.\n            startElement =\n                converter.getConvertedEntityType(pathSegments[0]) ??\n                converter.getConvertedComplexType(pathSegments[0]) ??\n                converter.getConvertedAction(pathSegments[0]) ??\n                converter.getConvertedAction(`${pathSegments[0]}()`); // unbound action\n            pathSegments.shift(); // Let's remove the first path element\n        } else {\n            startElement = converter.getConvertedEntityContainer();\n        }\n    } else if (startElement[ANNOTATION_TARGET] !== undefined) {\n        // annotation: start at the annotation target\n        startElement = startElement[ANNOTATION_TARGET];\n    } else if (startElement._type === 'Property') {\n        // property: start at the entity type or complex type the property belongs to\n        const parentElementFQN = substringBeforeFirst(startElement.fullyQualifiedName, '/');\n        startElement =\n            converter.getConvertedEntityType(parentElementFQN) ?? converter.getConvertedComplexType(parentElementFQN);\n    }\n\n    const result = pathSegments.reduce(\n        (current: ResolutionTarget<any>, segment: string) => {\n            const error = (message: string) => {\n                current.messages.push({ message });\n                current.target = undefined;\n                return current;\n            };\n\n            if (current.target === undefined) {\n                return current;\n            }\n\n            current.objectPath = appendObjectPath(current.objectPath, current.target);\n\n            // Annotation\n            if (segment.startsWith('@') && segment !== '@$ui5.overload') {\n                const [vocabularyAlias, term] = converter.splitTerm(segment);\n                const annotation = current.target.annotations[vocabularyAlias.substring(1)]?.[term];\n\n                if (annotation !== undefined) {\n                    current.target = annotation;\n                    return current;\n                }\n                return error(\n                    `Annotation '${segment.substring(1)}' not found on ${current.target._type} '${\n                        current.target.fullyQualifiedName\n                    }'`\n                );\n            }\n\n            // $Path / $AnnotationPath syntax\n            if (current.target.$target) {\n                let subPath: string | undefined;\n                if (segment === '$AnnotationPath') {\n                    subPath = current.target.value;\n                } else if (segment === '$Path') {\n                    subPath = current.target.path;\n                }\n\n                if (subPath !== undefined) {\n                    const subTarget = resolveTarget(converter, current.target[ANNOTATION_TARGET], subPath);\n                    subTarget.objectPath.forEach((visitedSubObject: any) => {\n                        if (!current.objectPath.includes(visitedSubObject)) {\n                            current.objectPath = appendObjectPath(current.objectPath, visitedSubObject);\n                        }\n                    });\n\n                    current.target = subTarget.target;\n                    current.objectPath = appendObjectPath(current.objectPath, current.target);\n                    return current;\n                }\n            }\n\n            // traverse based on the element type\n            switch (current.target?._type) {\n                case 'Schema':\n                    // next element: EntityType, ComplexType, Action, EntityContainer ?\n\n                    break;\n                case 'EntityContainer':\n                    {\n                        const thisElement = current.target as EntityContainer;\n\n                        if (segment === '' || converter.unalias(segment) === thisElement.fullyQualifiedName) {\n                            return current;\n                        }\n\n                        // next element: EntitySet, Singleton or ActionImport?\n                        const nextElement: EntitySet | Singleton | ActionImport | undefined =\n                            thisElement.entitySets.by_name(segment) ??\n                            thisElement.singletons.by_name(segment) ??\n                            thisElement.actionImports.by_name(segment);\n\n                        if (nextElement) {\n                            current.target = nextElement;\n                            return current;\n                        }\n                    }\n                    break;\n\n                case 'EntitySet':\n                case 'Singleton': {\n                    const thisElement = current.target as EntitySet | Singleton;\n\n                    if (segment === '' || segment === '$Type') {\n                        // Empty Path after an EntitySet or Singleton means EntityType\n                        current.target = thisElement.entityType;\n                        return current;\n                    }\n\n                    if (segment === '$') {\n                        return current;\n                    }\n\n                    if (segment === '$NavigationPropertyBinding') {\n                        const navigationPropertyBindings = thisElement.navigationPropertyBinding;\n                        current.target = navigationPropertyBindings;\n                        return current;\n                    }\n\n                    // continue resolving at the EntitySet's or Singleton's type\n                    const result = resolveTarget(converter, thisElement.entityType, segment);\n                    current.target = result.target;\n                    current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);\n                    return current;\n                }\n\n                case 'EntityType':\n                    {\n                        const thisElement = current.target as EntityType;\n\n                        if (segment === '' || segment === '$Type') {\n                            return current;\n                        }\n\n                        const property = thisElement.entityProperties.by_name(segment);\n                        if (property) {\n                            current.target = property;\n                            return current;\n                        }\n\n                        const navigationProperty = thisElement.navigationProperties.by_name(segment);\n                        if (navigationProperty) {\n                            current.target = navigationProperty;\n                            return current;\n                        }\n\n                        const actionName = substringBeforeFirst(converter.unalias(segment), '(');\n                        const action = thisElement.actions[actionName];\n                        if (action) {\n                            current.target = action;\n                            return current;\n                        }\n                    }\n                    break;\n\n                case 'ActionImport': {\n                    // continue resolving at the Action\n                    const result = resolveTarget(converter, current.target.action, segment);\n                    current.target = result.target;\n                    current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);\n                    return current;\n                }\n\n                case 'Action': {\n                    const thisElement = current.target as Action;\n\n                    if (segment === '') {\n                        return current;\n                    }\n\n                    if (segment === '@$ui5.overload' || segment === '0') {\n                        return current;\n                    }\n\n                    if (segment === '$Parameter' && thisElement.isBound) {\n                        current.target = thisElement.parameters;\n                        return current;\n                    }\n\n                    const nextElement =\n                        thisElement.parameters[segment as any] ??\n                        thisElement.parameters.find((param: ActionParameter) => param.name === segment);\n\n                    if (nextElement) {\n                        current.target = nextElement;\n                        return current;\n                    }\n                    break;\n                }\n\n                case 'Property':\n                    {\n                        const thisElement = current.target as Property;\n\n                        // Property or NavigationProperty of the ComplexType\n                        const type = thisElement.targetType as ComplexType | undefined;\n                        if (type !== undefined) {\n                            const property = type.properties.by_name(segment);\n                            if (property) {\n                                current.target = property;\n                                return current;\n                            }\n\n                            const navigationProperty = type.navigationProperties.by_name(segment);\n                            if (navigationProperty) {\n                                current.target = navigationProperty;\n                                return current;\n                            }\n                        }\n                    }\n                    break;\n\n                case 'ActionParameter':\n                    const referencedType = (current.target as ActionParameter).typeReference;\n                    if (referencedType !== undefined) {\n                        const result = resolveTarget(converter, referencedType, segment);\n                        current.target = result.target;\n                        current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);\n                        return current;\n                    }\n                    break;\n\n                case 'NavigationProperty':\n                    // continue at the NavigationProperty's target type\n                    const result = resolveTarget(converter, (current.target as NavigationProperty).targetType, segment);\n                    current.target = result.target;\n                    current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);\n                    return current;\n\n                default:\n                    if (segment === '') {\n                        return current;\n                    }\n\n                    if (current.target[segment]) {\n                        current.target = current.target[segment];\n                        current.objectPath = appendObjectPath(current.objectPath, current.target);\n                        return current;\n                    }\n            }\n\n            return error(\n                `Element '${segment}' not found at ${current.target._type} '${current.target.fullyQualifiedName}'`\n            );\n        },\n        { target: startElement, objectPath: [], messages: [] }\n    );\n\n    // Diagnostics\n    result.messages.forEach((message) => converter.logError(message.message));\n    if (!result.target) {\n        if (annotationsTerm) {\n            const annotationType = inferTypeFromTerm(converter, annotationsTerm, startElement.fullyQualifiedName);\n            converter.logError(\n                'Unable to resolve the path expression: ' +\n                    '\\n' +\n                    path +\n                    '\\n' +\n                    '\\n' +\n                    'Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \\n\\n' +\n                    '<Annotation Term = ' +\n                    annotationsTerm +\n                    '>' +\n                    '\\n' +\n                    '<Record Type = ' +\n                    annotationType +\n                    '>' +\n                    '\\n' +\n                    '<AnnotationPath = ' +\n                    path +\n                    '>'\n            );\n        } else {\n            converter.logError(\n                'Unable to resolve the path expression: ' +\n                    path +\n                    '\\n' +\n                    '\\n' +\n                    'Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \\n\\n' +\n                    '<Annotation Term = ' +\n                    pathSegments[0] +\n                    '>' +\n                    '\\n' +\n                    '<PropertyValue  Path= ' +\n                    pathSegments[1] +\n                    '>'\n            );\n        }\n    }\n\n    return result;\n}\n\n/**\n * Typeguard to check if the path contains an annotation.\n *\n * @param pathStr the path to evaluate\n * @returns true if there is an annotation in the path.\n */\nfunction isAnnotationPath(pathStr: string): boolean {\n    return pathStr.includes('@');\n}\n\ntype AnnotationValue<T> = T & { [ANNOTATION_TARGET]: any };\n\nfunction mapPropertyPath(\n    converter: Converter,\n    propertyPath: { type: 'PropertyPath'; PropertyPath: string },\n    fullyQualifiedName: FullyQualifiedName,\n    currentTarget: any,\n    currentTerm: string\n) {\n    const result: Omit<AnnotationValue<PropertyPath>, '$target'> = {\n        type: 'PropertyPath',\n        value: propertyPath.PropertyPath,\n        fullyQualifiedName: fullyQualifiedName,\n        [ANNOTATION_TARGET]: currentTarget\n    };\n\n    lazy(\n        result as AnnotationValue<PropertyPath>,\n        '$target',\n        () => resolveTarget<Property>(converter, currentTarget, propertyPath.PropertyPath, currentTerm).target\n    );\n\n    return result as AnnotationValue<PropertyPath>;\n}\n\nfunction mapAnnotationPath(\n    converter: Converter,\n    annotationPath: { type: 'AnnotationPath'; AnnotationPath: string },\n    fullyQualifiedName: FullyQualifiedName,\n    currentTarget: any,\n    currentTerm: string\n) {\n    const result: Omit<AnnotationValue<AnnotationPath<any>>, '$target'> = {\n        type: 'AnnotationPath',\n        value: converter.unalias(annotationPath.AnnotationPath),\n        fullyQualifiedName: fullyQualifiedName,\n        [ANNOTATION_TARGET]: currentTarget\n    };\n\n    lazy(\n        result as AnnotationValue<AnnotationPath<any>>,\n        '$target',\n        () => resolveTarget(converter, currentTarget, result.value, currentTerm).target\n    );\n\n    return result as AnnotationValue<AnnotationPath<any>>;\n}\n\nfunction mapNavigationPropertyPath(\n    converter: Converter,\n    navigationPropertyPath: { type: 'NavigationPropertyPath'; NavigationPropertyPath: string },\n    fullyQualifiedName: FullyQualifiedName,\n    currentTarget: any,\n    currentTerm: string\n) {\n    const result: Omit<AnnotationValue<NavigationPropertyPath>, '$target'> = {\n        type: 'NavigationPropertyPath',\n        value: navigationPropertyPath.NavigationPropertyPath ?? '',\n        fullyQualifiedName: fullyQualifiedName,\n        [ANNOTATION_TARGET]: currentTarget\n    };\n\n    lazy(\n        result as AnnotationValue<NavigationPropertyPath>,\n        '$target',\n        () =>\n            resolveTarget<NavigationProperty>(\n                converter,\n                currentTarget,\n                navigationPropertyPath.NavigationPropertyPath,\n                currentTerm\n            ).target\n    );\n\n    return result as AnnotationValue<NavigationPropertyPath>;\n}\n\nfunction mapPath(\n    converter: Converter,\n    path: { type: 'Path'; Path: string },\n    fullyQualifiedName: FullyQualifiedName,\n    currentTarget: any,\n    currentTerm: string\n) {\n    const result: Omit<AnnotationValue<PathAnnotationExpression<any>>, '$target'> = {\n        type: 'Path',\n        path: path.Path,\n        fullyQualifiedName: fullyQualifiedName,\n        getValue(): any {\n            return undefined; // TODO: Required according to the type...\n        },\n        [ANNOTATION_TARGET]: currentTarget\n    };\n\n    lazy(\n        result as AnnotationValue<PathAnnotationExpression<any>>,\n        '$target',\n        () => resolveTarget<Property>(converter, currentTarget, path.Path, currentTerm).target\n    );\n\n    return result as AnnotationValue<PathAnnotationExpression<any>>;\n}\n\nfunction parseValue(\n    converter: Converter,\n    currentTarget: any,\n    currentTerm: string,\n    currentProperty: string,\n    currentSource: string,\n    propertyValue: Expression,\n    valueFQN: string\n) {\n    if (propertyValue === undefined) {\n        return undefined;\n    }\n    switch (propertyValue.type) {\n        case 'String':\n            return propertyValue.String;\n        case 'Int':\n            return propertyValue.Int;\n        case 'Bool':\n            return propertyValue.Bool;\n        case 'Decimal':\n            return Decimal(propertyValue.Decimal);\n        case 'Date':\n            return propertyValue.Date;\n        case 'EnumMember':\n            const splitEnum = propertyValue.EnumMember.split(' ').map((enumValue) => {\n                const unaliased = converter.unalias(enumValue) ?? '';\n                return alias(VocabularyReferences, unaliased);\n            });\n            if (splitEnum[0] !== undefined && EnumIsFlag[substringBeforeFirst(splitEnum[0], '/')]) {\n                return splitEnum;\n            }\n            return splitEnum[0];\n\n        case 'PropertyPath':\n            return mapPropertyPath(converter, propertyValue, valueFQN, currentTarget, currentTerm);\n\n        case 'NavigationPropertyPath':\n            return mapNavigationPropertyPath(converter, propertyValue, valueFQN, currentTarget, currentTerm);\n\n        case 'AnnotationPath':\n            return mapAnnotationPath(converter, propertyValue, valueFQN, currentTarget, currentTerm);\n\n        case 'Path': {\n            if (isAnnotationPath(propertyValue.Path)) {\n                // inline the target\n                return resolveTarget(converter, currentTarget, propertyValue.Path, currentTerm).target;\n            } else {\n                return mapPath(converter, propertyValue, valueFQN, currentTarget, currentTerm);\n            }\n        }\n\n        case 'Record':\n            return parseRecord(\n                converter,\n                currentTerm,\n                currentTarget,\n                currentProperty,\n                currentSource,\n                propertyValue.Record,\n                valueFQN\n            );\n\n        case 'Collection':\n            return parseCollection(\n                converter,\n                currentTarget,\n                currentTerm,\n                currentProperty,\n                currentSource,\n                propertyValue.Collection,\n                valueFQN\n            );\n        case 'Apply':\n        case 'Null':\n        case 'Not':\n        case 'Eq':\n        case 'Ne':\n        case 'Gt':\n        case 'Ge':\n        case 'Lt':\n        case 'Le':\n        case 'If':\n        case 'And':\n        case 'Or':\n        default:\n            return propertyValue;\n    }\n}\n\n/**\n * Infer the type of a term based on its type.\n *\n * @param converter         Converter\n * @param annotationsTerm   The annotation term\n * @param annotationTarget  The annotation target\n * @param currentProperty   The current property of the record\n * @returns The inferred type.\n */\nfunction inferTypeFromTerm(\n    converter: Converter,\n    annotationsTerm: string,\n    annotationTarget: string,\n    currentProperty?: string\n) {\n    let targetType = (TermToTypes as any)[annotationsTerm];\n    if (currentProperty) {\n        annotationsTerm = `${substringBeforeLast(annotationsTerm, '.')}.${currentProperty}`;\n        targetType = (TermToTypes as any)[annotationsTerm];\n    }\n\n    converter.logError(\n        `The type of the record used within the term ${annotationsTerm} was not defined and was inferred as ${targetType}.\nHint: If possible, try to maintain the Type property for each Record.\n<Annotations Target=\"${annotationTarget}\">\n\t<Annotation Term=\"${annotationsTerm}\">\n\t\t<Record>...</Record>\n\t</Annotation>\n</Annotations>`\n    );\n\n    return targetType;\n}\n\nfunction isDataFieldWithForAction(annotationContent: any) {\n    return (\n        annotationContent.hasOwnProperty('Action') &&\n        (annotationContent.$Type === 'com.sap.vocabularies.UI.v1.DataFieldForAction' ||\n            annotationContent.$Type === 'com.sap.vocabularies.UI.v1.DataFieldWithAction')\n    );\n}\n\nfunction parseRecordType(\n    converter: Converter,\n    currentTerm: string,\n    currentTarget: any,\n    currentProperty: string | undefined,\n    recordDefinition: AnnotationRecord\n) {\n    let targetType;\n    if (!recordDefinition.type && currentTerm) {\n        targetType = inferTypeFromTerm(converter, currentTerm, currentTarget.fullyQualifiedName, currentProperty);\n    } else {\n        targetType = converter.unalias(recordDefinition.type);\n    }\n    return targetType;\n}\n\nfunction parseRecord(\n    converter: Converter,\n    currentTerm: string,\n    currentTarget: any,\n    currentProperty: string | undefined,\n    currentSource: string,\n    annotationRecord: AnnotationRecord,\n    currentFQN: string\n) {\n    const record: any = {\n        $Type: parseRecordType(converter, currentTerm, currentTarget, currentProperty, annotationRecord),\n        fullyQualifiedName: currentFQN,\n        [ANNOTATION_TARGET]: currentTarget,\n        __source: currentSource\n    };\n\n    for (const propertyValue of annotationRecord.propertyValues) {\n        lazy(record, propertyValue.name, () =>\n            parseValue(\n                converter,\n                currentTarget,\n                currentTerm,\n                propertyValue.name,\n                currentSource,\n                propertyValue.value,\n                `${currentFQN}/${propertyValue.name}`\n            )\n        );\n    }\n\n    // annotations on the record\n    lazy(record, 'annotations', resolveAnnotationsOnAnnotation(converter, annotationRecord, record));\n\n    if (isDataFieldWithForAction(record)) {\n        lazy(record, 'ActionTarget', () => {\n            const actionName = converter.unalias(record.Action?.toString());\n\n            // (1) Bound action of the annotation target?\n            let actionTarget = currentTarget.actions[actionName];\n\n            if (!actionTarget) {\n                // (2) ActionImport (= unbound action)?\n                actionTarget = converter.getConvertedActionImport(actionName)?.action;\n            }\n\n            if (!actionTarget) {\n                // (3) Bound action of a different EntityType (the actionName is fully qualified in this case)\n                actionTarget = converter.getConvertedAction(actionName);\n                if (!actionTarget?.isBound) {\n                    actionTarget = undefined;\n                }\n            }\n\n            if (!actionTarget) {\n                converter.logError(\n                    `${record.fullyQualifiedName}: Unable to resolve '${record.Action}' ('${actionName}')`\n                );\n            }\n            return actionTarget;\n        });\n    }\n    return record;\n}\n\nexport type CollectionType =\n    | 'PropertyPath'\n    | 'Path'\n    | 'If'\n    | 'Apply'\n    | 'Null'\n    | 'And'\n    | 'Eq'\n    | 'Ne'\n    | 'Not'\n    | 'Gt'\n    | 'Ge'\n    | 'Lt'\n    | 'Le'\n    | 'Or'\n    | 'AnnotationPath'\n    | 'NavigationPropertyPath'\n    | 'Record'\n    | 'String'\n    | 'EmptyCollection';\n\n/**\n * Retrieve or infer the collection type based on its content.\n *\n * @param collectionDefinition\n * @returns the type of the collection\n */\nfunction getOrInferCollectionType(collectionDefinition: any[]): CollectionType {\n    let type: CollectionType = (collectionDefinition as any).type;\n    if (type === undefined && collectionDefinition.length > 0) {\n        const firstColItem = collectionDefinition[0];\n        if (firstColItem.hasOwnProperty('PropertyPath')) {\n            type = 'PropertyPath';\n        } else if (firstColItem.hasOwnProperty('Path')) {\n            type = 'Path';\n        } else if (firstColItem.hasOwnProperty('AnnotationPath')) {\n            type = 'AnnotationPath';\n        } else if (firstColItem.hasOwnProperty('NavigationPropertyPath')) {\n            type = 'NavigationPropertyPath';\n        } else if (\n            typeof firstColItem === 'object' &&\n            (firstColItem.hasOwnProperty('type') || firstColItem.hasOwnProperty('propertyValues'))\n        ) {\n            type = 'Record';\n        } else if (typeof firstColItem === 'string') {\n            type = 'String';\n        }\n    } else if (type === undefined) {\n        type = 'EmptyCollection';\n    }\n    return type;\n}\n\nfunction parseCollection(\n    converter: Converter,\n    currentTarget: any,\n    currentTerm: string,\n    currentProperty: string,\n    currentSource: string,\n    collectionDefinition: any[],\n    parentFQN: string\n) {\n    const collectionDefinitionType = getOrInferCollectionType(collectionDefinition);\n\n    switch (collectionDefinitionType) {\n        case 'PropertyPath':\n            return collectionDefinition.map((path, index) =>\n                mapPropertyPath(converter, path, `${parentFQN}/${index}`, currentTarget, currentTerm)\n            );\n\n        case 'Path':\n            // TODO: make lazy?\n            return collectionDefinition.map((pathValue) => {\n                return resolveTarget(converter, currentTarget, pathValue.Path, currentTerm).target;\n            });\n\n        case 'AnnotationPath':\n            return collectionDefinition.map((path, index) =>\n                mapAnnotationPath(converter, path, `${parentFQN}/${index}`, currentTarget, currentTerm)\n            );\n\n        case 'NavigationPropertyPath':\n            return collectionDefinition.map((path, index) =>\n                mapNavigationPropertyPath(converter, path, `${parentFQN}/${index}`, currentTarget, currentTerm)\n            );\n\n        case 'Record':\n            return collectionDefinition.map((recordDefinition, recordIdx) => {\n                return parseRecord(\n                    converter,\n                    currentTerm,\n                    currentTarget,\n                    currentProperty,\n                    currentSource,\n                    recordDefinition,\n                    `${parentFQN}/${recordIdx}`\n                );\n            });\n\n        case 'Apply':\n        case 'Null':\n        case 'If':\n        case 'Eq':\n        case 'Ne':\n        case 'Lt':\n        case 'Gt':\n        case 'Le':\n        case 'Ge':\n        case 'Not':\n        case 'And':\n        case 'Or':\n            return collectionDefinition.map((ifValue) => ifValue);\n\n        case 'String':\n            return collectionDefinition.map((stringValue) => {\n                if (typeof stringValue === 'string' || stringValue === undefined) {\n                    return stringValue;\n                } else {\n                    return stringValue.String;\n                }\n            });\n\n        default:\n            if (collectionDefinition.length === 0) {\n                return [];\n            }\n            throw new Error('Unsupported case');\n    }\n}\n\nfunction isV4NavigationProperty(\n    navProp: RawV2NavigationProperty | RawV4NavigationProperty\n): navProp is RawV4NavigationProperty {\n    return !!(navProp as BaseNavigationProperty).targetTypeName;\n}\n\nfunction convertAnnotation(converter: Converter, target: any, rawAnnotation: RawAnnotation): Annotation {\n    let annotation: any;\n    if (rawAnnotation.record) {\n        annotation = parseRecord(\n            converter,\n            rawAnnotation.term,\n            target,\n            '',\n            (rawAnnotation as any).__source,\n            rawAnnotation.record,\n            (rawAnnotation as any).fullyQualifiedName\n        );\n    } else if (rawAnnotation.collection === undefined) {\n        annotation = parseValue(\n            converter,\n            target,\n            rawAnnotation.term,\n            '',\n            (rawAnnotation as any).__source,\n            rawAnnotation.value ?? { type: 'Bool', Bool: true },\n            (rawAnnotation as any).fullyQualifiedName\n        );\n    } else if (rawAnnotation.collection) {\n        annotation = parseCollection(\n            converter,\n            target,\n            rawAnnotation.term,\n            '',\n            (rawAnnotation as any).__source,\n            rawAnnotation.collection,\n            (rawAnnotation as any).fullyQualifiedName\n        );\n    } else {\n        throw new Error('Unsupported case');\n    }\n\n    switch (typeof annotation) {\n        case 'string':\n            // eslint-disable-next-line no-new-wrappers\n            annotation = new String(annotation);\n            break;\n        case 'boolean':\n            // eslint-disable-next-line no-new-wrappers\n            annotation = new Boolean(annotation);\n            break;\n        case 'number':\n            annotation = new Number(annotation);\n            break;\n        default:\n            // do nothing\n            break;\n    }\n\n    annotation.fullyQualifiedName = (rawAnnotation as any).fullyQualifiedName;\n    annotation[ANNOTATION_TARGET] = target;\n\n    const [vocAlias, vocTerm] = converter.splitTerm(rawAnnotation.term);\n\n    annotation.term = converter.unalias(`${vocAlias}.${vocTerm}`, VocabularyReferences);\n    annotation.qualifier = rawAnnotation.qualifier;\n    annotation.__source = (rawAnnotation as any).__source;\n\n    try {\n        lazy(annotation, 'annotations', resolveAnnotationsOnAnnotation(converter, rawAnnotation, annotation));\n    } catch (e) {\n        // not an error: parseRecord() already adds annotations, but the other parseXXX functions don't, so this can happen\n    }\n\n    return annotation as Annotation;\n}\n\nclass Converter {\n    private annotationsByTarget: Record<FullyQualifiedName, Annotation[]>;\n\n    /**\n     * Get preprocessed annotations on the specified target.\n     *\n     * @param target    The annotation target\n     * @returns An array of annotations\n     */\n    getAnnotations(target: FullyQualifiedName): Annotation[] {\n        if (this.annotationsByTarget === undefined) {\n            const annotationSources = Object.keys(this.rawSchema.annotations).map((source) => ({\n                name: source,\n                annotationList: this.rawSchema.annotations[source]\n            }));\n\n            this.annotationsByTarget = mergeAnnotations(this.rawMetadata.references, ...annotationSources);\n        }\n\n        return this.annotationsByTarget[target] ?? [];\n    }\n\n    getConvertedEntityContainer() {\n        return this.getConvertedElement(\n            this.rawMetadata.schema.entityContainer.fullyQualifiedName,\n            this.rawMetadata.schema.entityContainer,\n            convertEntityContainer\n        );\n    }\n\n    getConvertedEntitySet(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.entitySets.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedSingleton(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.singletons.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedEntityType(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.entityTypes.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedComplexType(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.complexTypes.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedTypeDefinition(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.typeDefinitions.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    getConvertedActionImport(fullyQualifiedName: FullyQualifiedName) {\n        let actionImport = this.convertedOutput.actionImports.by_fullyQualifiedName(fullyQualifiedName);\n        if (!actionImport) {\n            actionImport = this.convertedOutput.actionImports.by_name(fullyQualifiedName);\n        }\n        return actionImport;\n    }\n\n    getConvertedAction(fullyQualifiedName: FullyQualifiedName) {\n        return this.convertedOutput.actions.by_fullyQualifiedName(fullyQualifiedName);\n    }\n\n    convert<Converted, Raw extends RawType<Converted>>(\n        rawValue: Raw,\n        map: (converter: Converter, raw: Raw) => Converted\n    ): () => Converted;\n    convert<Converted, Raw extends RawType<Converted>, IndexProperty extends Extract<keyof Converted, string>>(\n        rawValue: Raw[],\n        map: (converter: Converter, raw: Raw) => Converted\n    ): () => ArrayWithIndex<Converted, IndexProperty>;\n    convert<Converted, Raw extends RawType<Converted>, IndexProperty extends Extract<keyof Converted, string>>(\n        rawValue: Raw | Raw[],\n        map: (converter: Converter, raw: Raw) => Converted\n    ): (() => Converted) | (() => ArrayWithIndex<Converted, IndexProperty>) {\n        if (Array.isArray(rawValue)) {\n            return () => {\n                const converted = rawValue.reduce((convertedElements, rawElement) => {\n                    const convertedElement = this.getConvertedElement(\n                        (rawElement as any).fullyQualifiedName,\n                        rawElement,\n                        map\n                    );\n                    if (convertedElement) {\n                        convertedElements.push(convertedElement);\n                    }\n                    return convertedElements;\n                }, [] as Converted[]);\n                addGetByValue(converted, 'name' as any);\n                addGetByValue(converted, 'fullyQualifiedName' as any);\n                return converted as ArrayWithIndex<Converted, IndexProperty>;\n            };\n        } else {\n            return () => this.getConvertedElement(rawValue.fullyQualifiedName, rawValue, map)!;\n        }\n    }\n\n    private rawMetadata: RawMetadata;\n    private convertedElements: Map<FullyQualifiedName, any> = new Map();\n    private convertedOutput: ConvertedMetadata;\n\n    rawSchema: RawSchema;\n\n    constructor(rawMetadata: RawMetadata, convertedOutput: ConvertedMetadata) {\n        this.rawMetadata = rawMetadata;\n        this.rawSchema = rawMetadata.schema;\n        this.convertedOutput = convertedOutput;\n    }\n\n    getConvertedElement<ConvertedType, RawType extends RemoveAnnotationAndType<ConvertedType>>(\n        fullyQualifiedName: FullyQualifiedName,\n        rawElement: RawType | undefined | ((fullyQualifiedName: FullyQualifiedName) => RawType | undefined),\n        map: (converter: Converter, raw: RawType) => ConvertedType\n    ): ConvertedType | undefined {\n        let converted: ConvertedType | undefined = this.convertedElements.get(fullyQualifiedName);\n        if (converted === undefined) {\n            const rawMetadata =\n                typeof rawElement === 'function' ? rawElement.apply(undefined, [fullyQualifiedName]) : rawElement;\n            if (rawMetadata !== undefined) {\n                converted = map.apply(undefined, [this, rawMetadata]);\n                this.convertedElements.set(fullyQualifiedName, converted);\n            }\n        }\n        return converted;\n    }\n\n    logError(message: string) {\n        this.convertedOutput.diagnostics.push({ message });\n    }\n\n    /**\n     * Split the alias from the term value.\n     *\n     * @param term the value of the term\n     * @returns the term alias and the actual term value\n     */\n    splitTerm(term: string) {\n        const aliased = alias(VocabularyReferences, term);\n        return splitAtLast(aliased, '.');\n    }\n\n    unalias(value: string | undefined, references = this.rawMetadata.references) {\n        return unalias(references, value, this.rawSchema.namespace) ?? '';\n    }\n}\n\ntype RawType<T> = RemoveAnnotationAndType<T> & { fullyQualifiedName: FullyQualifiedName };\n\nfunction resolveEntityType(converter: Converter, fullyQualifiedName: FullyQualifiedName) {\n    return () => {\n        let entityType = converter.getConvertedEntityType(fullyQualifiedName);\n\n        if (!entityType) {\n            converter.logError(`EntityType '${fullyQualifiedName}' not found`);\n            entityType = {} as EntityType;\n        }\n        return entityType;\n    };\n}\n\nfunction resolveNavigationPropertyBindings(\n    converter: Converter,\n    rawNavigationPropertyBindings: RawNavigationPropertyBinding\n) {\n    return () =>\n        Object.keys(rawNavigationPropertyBindings).reduce((navigationPropertyBindings, bindingPath) => {\n            const rawBindingTarget = rawNavigationPropertyBindings[bindingPath];\n\n            lazy(\n                navigationPropertyBindings,\n                bindingPath,\n                () =>\n                    // the NavigationPropertyBinding will lead to either an EntitySet or a Singleton, it cannot be undefined\n                    (converter.getConvertedEntitySet(rawBindingTarget) ??\n                        converter.getConvertedSingleton(rawBindingTarget))!\n            );\n            return navigationPropertyBindings;\n        }, {} as EntitySet['navigationPropertyBinding'] | Singleton['navigationPropertyBinding']);\n}\n\nfunction resolveAnnotations(converter: Converter, rawAnnotationTarget: any) {\n    const nestedAnnotations = rawAnnotationTarget.annotations;\n\n    return () =>\n        createAnnotationsObject(\n            converter,\n            rawAnnotationTarget,\n            nestedAnnotations ?? converter.getAnnotations(rawAnnotationTarget.fullyQualifiedName)\n        );\n}\n\nfunction resolveAnnotationsOnAnnotation(\n    converter: Converter,\n    annotationRecord: AnnotationRecord | RawAnnotation,\n    annotationTerm: any\n) {\n    return () => {\n        const currentFQN = annotationTerm.fullyQualifiedName;\n\n        // be graceful when resolving annotations on annotations: Sometimes they are referenced directly, sometimes they\n        // are part of the global annotations list\n        let annotations;\n        if (annotationRecord.annotations && annotationRecord.annotations.length > 0) {\n            annotations = annotationRecord.annotations;\n        } else {\n            annotations = converter.getAnnotations(currentFQN);\n        }\n\n        annotations?.forEach((annotation: any) => {\n            annotation.target = currentFQN;\n            annotation.__source = annotationTerm.__source;\n            annotation[ANNOTATION_TARGET] = annotationTerm[ANNOTATION_TARGET];\n            annotation.fullyQualifiedName = `${currentFQN}@${annotation.term}`;\n        });\n\n        return createAnnotationsObject(converter, annotationTerm, annotations ?? []);\n    };\n}\n\nfunction createAnnotationsObject(converter: Converter, target: any, rawAnnotations: RawAnnotation[]) {\n    return rawAnnotations.reduce((vocabularyAliases, annotation) => {\n        const [vocAlias, vocTerm] = converter.splitTerm(annotation.term);\n        const vocTermWithQualifier = `${vocTerm}${annotation.qualifier ? '#' + annotation.qualifier : ''}`;\n\n        if (vocabularyAliases[vocAlias] === undefined) {\n            vocabularyAliases[vocAlias] = {};\n        }\n\n        if (!vocabularyAliases[vocAlias].hasOwnProperty(vocTermWithQualifier)) {\n            lazy(vocabularyAliases[vocAlias], vocTermWithQualifier, () =>\n                converter.getConvertedElement(\n                    (annotation as Annotation).fullyQualifiedName,\n                    annotation,\n                    (converter, rawAnnotation) => convertAnnotation(converter, target, rawAnnotation)\n                )\n            );\n        }\n        return vocabularyAliases;\n    }, {} as any);\n}\n\n/**\n * Converts an EntityContainer.\n *\n * @param converter     Converter\n * @param rawEntityContainer    Unconverted EntityContainer\n * @returns The converted EntityContainer\n */\nfunction convertEntityContainer(converter: Converter, rawEntityContainer: RawEntityContainer): EntityContainer {\n    const convertedEntityContainer = rawEntityContainer as EntityContainer;\n\n    lazy(convertedEntityContainer, 'annotations', resolveAnnotations(converter, rawEntityContainer));\n\n    lazy(convertedEntityContainer, 'entitySets', converter.convert(converter.rawSchema.entitySets, convertEntitySet));\n\n    lazy(convertedEntityContainer, 'singletons', converter.convert(converter.rawSchema.singletons, convertSingleton));\n\n    lazy(\n        convertedEntityContainer,\n        'actionImports',\n        converter.convert(converter.rawSchema.actionImports, convertActionImport)\n    );\n\n    return convertedEntityContainer;\n}\n\n/**\n * Converts a Singleton.\n *\n * @param converter   Converter\n * @param rawSingleton  Unconverted Singleton\n * @returns The converted Singleton\n */\nfunction convertSingleton(converter: Converter, rawSingleton: RawSingleton): Singleton {\n    const convertedSingleton = rawSingleton as unknown as Singleton;\n\n    lazy(convertedSingleton, 'entityType', resolveEntityType(converter, rawSingleton.entityTypeName));\n    lazy(convertedSingleton, 'annotations', resolveAnnotations(converter, convertedSingleton));\n\n    const _rawNavigationPropertyBindings = rawSingleton.navigationPropertyBinding;\n    lazy(\n        convertedSingleton,\n        'navigationPropertyBinding',\n        resolveNavigationPropertyBindings(converter, _rawNavigationPropertyBindings)\n    );\n\n    return convertedSingleton;\n}\n\n/**\n * Converts an EntitySet.\n *\n * @param converter   Converter\n * @param rawEntitySet  Unconverted EntitySet\n * @returns The converted EntitySet\n */\nfunction convertEntitySet(converter: Converter, rawEntitySet: RawEntitySet): EntitySet {\n    const convertedEntitySet = rawEntitySet as unknown as EntitySet;\n\n    lazy(convertedEntitySet, 'entityType', resolveEntityType(converter, rawEntitySet.entityTypeName));\n    lazy(convertedEntitySet, 'annotations', resolveAnnotations(converter, convertedEntitySet));\n\n    const _rawNavigationPropertyBindings = rawEntitySet.navigationPropertyBinding;\n    lazy(\n        convertedEntitySet,\n        'navigationPropertyBinding',\n        resolveNavigationPropertyBindings(converter, _rawNavigationPropertyBindings)\n    );\n\n    return convertedEntitySet;\n}\n\n/**\n * Converts an EntityType.\n *\n * @param converter   Converter\n * @param rawEntityType  Unconverted EntityType\n * @returns The converted EntityType\n */\nfunction convertEntityType(converter: Converter, rawEntityType: RawEntityType): EntityType {\n    const convertedEntityType = rawEntityType as EntityType;\n\n    rawEntityType.keys.forEach((keyProp: any) => {\n        keyProp.isKey = true;\n    });\n\n    lazy(convertedEntityType, 'annotations', resolveAnnotations(converter, rawEntityType));\n\n    lazy(convertedEntityType, 'keys', converter.convert(rawEntityType.keys, convertProperty));\n    lazy(convertedEntityType, 'entityProperties', converter.convert(rawEntityType.entityProperties, convertProperty));\n    lazy(\n        convertedEntityType,\n        'navigationProperties',\n        converter.convert(rawEntityType.navigationProperties as any[], convertNavigationProperty)\n    );\n\n    lazy(convertedEntityType, 'actions', () =>\n        converter.rawSchema.actions\n            .filter(\n                (rawAction) =>\n                    rawAction.isBound &&\n                    (rawAction.sourceType === rawEntityType.fullyQualifiedName ||\n                        rawAction.sourceType === `Collection(${rawEntityType.fullyQualifiedName})`)\n            )\n            .reduce((actions, rawAction) => {\n                const name = `${converter.rawSchema.namespace}.${rawAction.name}`;\n                actions[name] = converter.getConvertedAction(rawAction.fullyQualifiedName)!;\n                return actions;\n            }, {} as EntityType['actions'])\n    );\n\n    convertedEntityType.resolvePath = (relativePath: string, includeVisitedObjects?: boolean) => {\n        const resolved = resolveTarget(converter, rawEntityType, relativePath);\n        if (includeVisitedObjects) {\n            return { target: resolved.target, visitedObjects: resolved.objectPath, messages: resolved.messages };\n        } else {\n            return resolved.target;\n        }\n    };\n\n    return convertedEntityType;\n}\n\n/**\n * Converts a Property.\n *\n * @param converter   Converter\n * @param rawProperty  Unconverted Property\n * @returns The converted Property\n */\nfunction convertProperty(converter: Converter, rawProperty: RawProperty): Property {\n    const convertedProperty = rawProperty as Property;\n\n    lazy(convertedProperty, 'annotations', resolveAnnotations(converter, rawProperty));\n\n    lazy(convertedProperty, 'targetType', () => {\n        const type = rawProperty.type;\n        const typeName = type.startsWith('Collection') ? type.substring(11, type.length - 1) : type;\n\n        return converter.getConvertedComplexType(typeName) ?? converter.getConvertedTypeDefinition(typeName);\n    });\n\n    return convertedProperty;\n}\n\n/**\n * Converts a NavigationProperty.\n *\n * @param converter   Converter\n * @param rawNavigationProperty  Unconverted NavigationProperty\n * @returns The converted NavigationProperty\n */\nfunction convertNavigationProperty(\n    converter: Converter,\n    rawNavigationProperty: RawV2NavigationProperty | RawV4NavigationProperty\n): NavigationProperty {\n    const convertedNavigationProperty = rawNavigationProperty as NavigationProperty;\n\n    convertedNavigationProperty.referentialConstraint = convertedNavigationProperty.referentialConstraint ?? [];\n\n    if (!isV4NavigationProperty(rawNavigationProperty)) {\n        const associationEnd = converter.rawSchema.associations\n            .find((association) => association.fullyQualifiedName === rawNavigationProperty.relationship)\n            ?.associationEnd.find((end) => end.role === rawNavigationProperty.toRole);\n\n        convertedNavigationProperty.isCollection = associationEnd?.multiplicity === '*';\n        convertedNavigationProperty.targetTypeName = associationEnd?.type ?? '';\n    }\n\n    lazy(\n        convertedNavigationProperty,\n        'targetType',\n        resolveEntityType(converter, (rawNavigationProperty as NavigationProperty).targetTypeName)\n    );\n\n    lazy(convertedNavigationProperty, 'annotations', resolveAnnotations(converter, rawNavigationProperty));\n\n    return convertedNavigationProperty;\n}\n\n/**\n * Converts an ActionImport.\n *\n * @param converter   Converter\n * @param rawActionImport  Unconverted ActionImport\n * @returns The converted ActionImport\n */\nfunction convertActionImport(converter: Converter, rawActionImport: RawActionImport): ActionImport {\n    const convertedActionImport = rawActionImport as ActionImport;\n\n    lazy(convertedActionImport, 'annotations', resolveAnnotations(converter, rawActionImport));\n\n    lazy(convertedActionImport, 'action', () => {\n        const rawActions = converter.rawSchema.actions.filter(\n            (rawAction) => !rawAction.isBound && rawAction.fullyQualifiedName.startsWith(rawActionImport.actionName)\n        );\n\n        // this always resolves to a unique unbound action, but resolution of unbound functions can be ambiguous:\n        // unbound function FQNs have overloads depending on all of their parameters\n        if (rawActions.length > 1) {\n            converter.logError(`Ambiguous reference in action import: ${rawActionImport.fullyQualifiedName}`);\n        }\n\n        // return the first matching action or function\n        return converter.getConvertedAction(rawActions[0].fullyQualifiedName)!;\n    });\n\n    return convertedActionImport;\n}\n\n/**\n * Converts an Action.\n *\n * @param converter   Converter\n * @param rawAction  Unconverted Action\n * @returns The converted Action\n */\nfunction convertAction(converter: Converter, rawAction: RawAction): Action {\n    const convertedAction = rawAction as Action;\n\n    if (convertedAction.sourceType) {\n        lazy(convertedAction, 'sourceEntityType', resolveEntityType(converter, rawAction.sourceType));\n    }\n\n    if (convertedAction.returnType) {\n        lazy(convertedAction, 'returnEntityType', resolveEntityType(converter, rawAction.returnType));\n    }\n\n    lazy(convertedAction, 'parameters', converter.convert(rawAction.parameters, convertActionParameter));\n\n    lazy(convertedAction, 'annotations', () => {\n        /*\n            Annotation resolution rule for actions:\n\n            (1) annotation target: the specific unbound or bound overload, e.g.\n                    - for actions:   \"x.y.z.unboundAction()\" / \"x.y.z.boundAction(x.y.z.Entity)\"\n                    - for functions: \"x.y.z.unboundFunction(Edm.String)\" / \"x.y.z.unboundFunction(x.y.z.Entity,Edm.String)\"\n            (2) annotation target: unspecified overload, e.g.\n                - for actions:   \"x.y.z.unboundAction\" / \"x.y.z.boundAction\"\n                - for functions: \"x.y.z.unboundFunction\" / \"x.y.z.unboundFunction\"\n\n            When resolving (1) takes precedence over (2). That is, annotations on the specific overload overwrite\n            annotations on the unspecific overload, on term/qualifier level.\n        */\n\n        const unspecificOverloadTarget = substringBeforeFirst(rawAction.fullyQualifiedName, '(');\n        const specificOverloadTarget = rawAction.fullyQualifiedName;\n\n        const effectiveAnnotations = converter.getAnnotations(specificOverloadTarget);\n        const unspecificAnnotations = converter.getAnnotations(unspecificOverloadTarget);\n\n        for (const unspecificAnnotation of unspecificAnnotations) {\n            if (\n                !effectiveAnnotations.some(\n                    (annotation) =>\n                        annotation.term === unspecificAnnotation.term &&\n                        annotation.qualifier === unspecificAnnotation.qualifier\n                )\n            ) {\n                effectiveAnnotations.push(unspecificAnnotation);\n            }\n        }\n\n        return createAnnotationsObject(converter, rawAction, effectiveAnnotations);\n    });\n\n    return convertedAction;\n}\n\n/**\n * Converts an ActionParameter.\n *\n * @param converter   Converter\n * @param rawActionParameter  Unconverted ActionParameter\n * @returns The converted ActionParameter\n */\nfunction convertActionParameter(\n    converter: Converter,\n    rawActionParameter: RawAction['parameters'][number]\n): ActionParameter {\n    const convertedActionParameter = rawActionParameter as ActionParameter;\n\n    lazy(\n        convertedActionParameter,\n        'typeReference',\n        () =>\n            converter.getConvertedEntityType(rawActionParameter.type) ??\n            converter.getConvertedComplexType(rawActionParameter.type) ??\n            converter.getConvertedTypeDefinition(rawActionParameter.type)\n    );\n\n    lazy(convertedActionParameter, 'annotations', () => {\n        // annotations on action parameters are resolved following the rules for actions\n        const unspecificOverloadTarget =\n            rawActionParameter.fullyQualifiedName.substring(0, rawActionParameter.fullyQualifiedName.indexOf('(')) +\n            rawActionParameter.fullyQualifiedName.substring(rawActionParameter.fullyQualifiedName.indexOf(')') + 1);\n        const specificOverloadTarget = rawActionParameter.fullyQualifiedName;\n\n        const effectiveAnnotations = converter.getAnnotations(specificOverloadTarget);\n        const unspecificAnnotations = converter.getAnnotations(unspecificOverloadTarget);\n\n        for (const unspecificAnnotation of unspecificAnnotations) {\n            if (\n                !effectiveAnnotations.some(\n                    (annotation) =>\n                        annotation.term === unspecificAnnotation.term &&\n                        annotation.qualifier === unspecificAnnotation.qualifier\n                )\n            ) {\n                effectiveAnnotations.push(unspecificAnnotation);\n            }\n        }\n\n        return createAnnotationsObject(converter, rawActionParameter, effectiveAnnotations);\n    });\n\n    return convertedActionParameter;\n}\n\n/**\n * Converts a ComplexType.\n *\n * @param converter   Converter\n * @param rawComplexType  Unconverted ComplexType\n * @returns The converted ComplexType\n */\nfunction convertComplexType(converter: Converter, rawComplexType: RawComplexType): ComplexType {\n    const convertedComplexType = rawComplexType as ComplexType;\n\n    lazy(convertedComplexType, 'properties', converter.convert(rawComplexType.properties, convertProperty));\n    lazy(\n        convertedComplexType,\n        'navigationProperties',\n        converter.convert(rawComplexType.navigationProperties as any[], convertNavigationProperty)\n    );\n    lazy(convertedComplexType, 'annotations', resolveAnnotations(converter, rawComplexType));\n\n    return convertedComplexType;\n}\n\n/**\n * Converts a TypeDefinition.\n *\n * @param converter   Converter\n * @param rawTypeDefinition  Unconverted TypeDefinition\n * @returns The converted TypeDefinition\n */\nfunction convertTypeDefinition(converter: Converter, rawTypeDefinition: RawTypeDefinition): TypeDefinition {\n    const convertedTypeDefinition = rawTypeDefinition as TypeDefinition;\n\n    lazy(convertedTypeDefinition, 'annotations', resolveAnnotations(converter, rawTypeDefinition));\n\n    return convertedTypeDefinition;\n}\n\n/**\n * Convert a RawMetadata into an object representation to be used to easily navigate a metadata object and its annotation.\n *\n * @param rawMetadata\n * @returns the converted representation of the metadata.\n */\nexport function convert(rawMetadata: RawMetadata): ConvertedMetadata {\n    // Converter Output\n    const convertedOutput: ConvertedMetadata = {\n        version: rawMetadata.version,\n        namespace: rawMetadata.schema.namespace,\n        annotations: rawMetadata.schema.annotations,\n        references: VocabularyReferences,\n        diagnostics: []\n    } as any;\n\n    // Converter\n    const converter = new Converter(rawMetadata, convertedOutput);\n\n    lazy(\n        convertedOutput,\n        'entityContainer',\n        converter.convert(converter.rawSchema.entityContainer, convertEntityContainer)\n    );\n    lazy(convertedOutput, 'entitySets', converter.convert(converter.rawSchema.entitySets, convertEntitySet));\n    lazy(convertedOutput, 'singletons', converter.convert(converter.rawSchema.singletons, convertSingleton));\n    lazy(convertedOutput, 'entityTypes', converter.convert(converter.rawSchema.entityTypes, convertEntityType));\n    lazy(convertedOutput, 'actions', converter.convert(converter.rawSchema.actions, convertAction));\n    lazy(convertedOutput, 'complexTypes', converter.convert(converter.rawSchema.complexTypes, convertComplexType));\n    lazy(convertedOutput, 'actionImports', converter.convert(converter.rawSchema.actionImports, convertActionImport));\n    lazy(\n        convertedOutput,\n        'typeDefinitions',\n        converter.convert(converter.rawSchema.typeDefinitions, convertTypeDefinition)\n    );\n\n    convertedOutput.resolvePath = function resolvePath<T>(path: string): ResolutionTarget<T> {\n        const targetResolution = resolveTarget<T>(converter, undefined, path);\n        if (targetResolution.target) {\n            appendObjectPath(targetResolution.objectPath, targetResolution.target);\n        }\n        return targetResolution;\n    };\n\n    return convertedOutput;\n}\n","export * from './converter';\nexport * from './utils';\nexport * from './writeback';\n","import type {\n    Annotation,\n    AnnotationList,\n    ArrayWithIndex,\n    ComplexType,\n    Index,\n    Reference,\n    TypeDefinition\n} from '@sap-ux/vocabularies-types';\n\nexport { EnumIsFlag } from '@sap-ux/vocabularies-types/vocabularies/EnumIsFlag';\nexport { TermToTypes } from '@sap-ux/vocabularies-types/vocabularies/TermToTypes';\nexport { VocabularyReferences as defaultReferences } from '@sap-ux/vocabularies-types/vocabularies/VocabularyReferences';\n\nexport type ReferencesWithMap = Reference[] & {\n    referenceMap?: Record<string, Reference>;\n    reverseReferenceMap?: Record<string, Reference>;\n};\n\nfunction splitAt(string: string, index: number): [string, string] {\n    return index < 0 ? [string, ''] : [string.substring(0, index), string.substring(index + 1)];\n}\n\nfunction substringAt(string: string, index: number) {\n    return index < 0 ? string : string.substring(0, index);\n}\n\n/**\n * Splits a string at the first occurrence of a separator.\n *\n * @param string    The string to split\n * @param separator Separator, e.g. a single character.\n * @returns An array consisting of two elements: the part before the first occurrence of the separator and the part after it. If the string does not contain the separator, the second element is the empty string.\n */\nexport function splitAtFirst(string: string, separator: string): [string, string] {\n    return splitAt(string, string.indexOf(separator));\n}\n\n/**\n * Splits a string at the last occurrence of a separator.\n *\n * @param string    The string to split\n * @param separator Separator, e.g. a single character.\n * @returns An array consisting of two elements: the part before the last occurrence of the separator and the part after it. If the string does not contain the separator, the second element is the empty string.\n */\nexport function splitAtLast(string: string, separator: string): [string, string] {\n    return splitAt(string, string.lastIndexOf(separator));\n}\n\n/**\n * Returns the substring before the first occurrence of a separator.\n *\n * @param string    The string\n * @param separator Separator, e.g. a single character.\n * @returns The substring before the first occurrence of the separator, or the input string if it does not contain the separator.\n */\nexport function substringBeforeFirst(string: string, separator: string): string {\n    return substringAt(string, string.indexOf(separator));\n}\n\n/**\n * Returns the substring before the last occurrence of a separator.\n *\n * @param string    The string\n * @param separator Separator, e.g. a single character.\n * @returns The substring before the last occurrence of the separator, or the input string if it does not contain the separator.\n */\nexport function substringBeforeLast(string: string, separator: string): string {\n    return substringAt(string, string.lastIndexOf(separator));\n}\n\n/**\n * Transform an unaliased string representation annotation to the aliased version.\n *\n * @param references currentReferences for the project\n * @param unaliasedValue the unaliased value\n * @returns the aliased string representing the same\n */\nexport function alias(references: ReferencesWithMap, unaliasedValue: string): string {\n    if (!references.reverseReferenceMap) {\n        references.reverseReferenceMap = references.reduce((map: Record<string, Reference>, ref) => {\n            map[ref.namespace] = ref;\n            return map;\n        }, {});\n    }\n    if (!unaliasedValue) {\n        return unaliasedValue;\n    }\n    const [namespace, value] = splitAtLast(unaliasedValue, '.');\n    const reference = references.reverseReferenceMap[namespace];\n    if (reference) {\n        return `${reference.alias}.${value}`;\n    } else if (unaliasedValue.includes('@')) {\n        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem\n        const [preAlias, postAlias] = splitAtFirst(unaliasedValue, '@');\n        return `${preAlias}@${alias(references, postAlias)}`;\n    } else {\n        return unaliasedValue;\n    }\n}\n\n/**\n * Transform an aliased string to its unaliased version given a set of references.\n *\n * @param references The references to use for unaliasing.\n * @param aliasedValue The aliased value\n * @param namespace The fallback namespace\n * @returns The equal unaliased string.\n */\nexport function unalias(\n    references: ReferencesWithMap,\n    aliasedValue: string | undefined,\n    namespace?: string\n): string | undefined {\n    const _unalias = (value: string) => {\n        if (!references.referenceMap) {\n            references.referenceMap = Object.fromEntries(references.map((ref) => [ref.alias, ref]));\n        }\n\n        // Aliases are of type 'SimpleIdentifier' and must not contain dots\n        const [maybeAlias, rest] = splitAtFirst(value, '.');\n\n        if (!rest || rest.includes('.')) {\n            // either there is no dot in the value or there is more than one --> nothing to do\n            return value;\n        }\n\n        const isAnnotation = maybeAlias.startsWith('@');\n        const valueToUnalias = isAnnotation ? maybeAlias.substring(1) : maybeAlias;\n        const knownReference = references.referenceMap[valueToUnalias];\n        if (knownReference) {\n            return isAnnotation ? `@${knownReference.namespace}.${rest}` : `${knownReference.namespace}.${rest}`;\n        }\n\n        // The alias could not be resolved using the references. Assume it is the \"global\" alias (= namespace)\n        return namespace && !isAnnotation ? `${namespace}.${rest}` : value;\n    };\n\n    return aliasedValue\n        ?.split('/')\n        .reduce((segments, segment) => {\n            // the segment could be an action, like \"doSomething(foo.bar)\"\n            const [first, rest] = splitAtFirst(segment, '(');\n            const subSegment = [_unalias(first)];\n\n            if (rest) {\n                const parameter = rest.slice(0, -1); // remove trailing \")\"\n                subSegment.push(`(${_unalias(parameter)})`);\n            }\n            segments.push(subSegment.join(''));\n\n            return segments;\n        }, [] as string[])\n        ?.join('/');\n}\n\n/**\n * Differentiate between a ComplexType and a TypeDefinition.\n *\n * @param complexTypeDefinition\n * @returns true if the value is a complex type\n */\nexport function isComplexTypeDefinition(\n    complexTypeDefinition?: ComplexType | TypeDefinition\n): complexTypeDefinition is ComplexType {\n    return (\n        !!complexTypeDefinition && complexTypeDefinition._type === 'ComplexType' && !!complexTypeDefinition.properties\n    );\n}\n\nexport function Decimal(value: number) {\n    return {\n        isDecimal() {\n            return true;\n        },\n        valueOf() {\n            return value;\n        },\n        toString() {\n            return value.toString();\n        }\n    };\n}\n\n/**\n * Defines a lazy property.\n *\n * The property is initialized by calling the init function on the first read access, or by directly assigning a value.\n *\n * @param object    The host object\n * @param property  The lazy property to add\n * @param init      The function that initializes the property's value\n */\nexport function lazy<Type, Key extends keyof Type>(object: Type, property: Key, init: () => Type[Key]) {\n    const initial = Symbol('initial');\n    let _value: Type[Key] | typeof initial = initial;\n\n    Object.defineProperty(object, property, {\n        enumerable: true,\n\n        get() {\n            if (_value === initial) {\n                _value = init();\n            }\n            return _value;\n        },\n\n        set(value: Type[Key]) {\n            _value = value;\n        }\n    });\n}\n\n/**\n * Creates a function that allows to find an array element by property value.\n *\n * @param array     The array\n * @param property  Elements in the array are searched by this property\n * @returns A function that can be used to find an element of the array by property value.\n */\nexport function createIndexedFind<T>(array: Array<T>, property: keyof T) {\n    const index: Map<T[keyof T], T | undefined> = new Map();\n\n    return function find(value: T[keyof T]) {\n        const element = index.get(value);\n\n        if (element?.[property] === value) {\n            return element;\n        }\n\n        return array.find((element) => {\n            if (!element?.hasOwnProperty(property)) {\n                return false;\n            }\n\n            const propertyValue = element[property];\n            index.set(propertyValue, element);\n            return propertyValue === value;\n        });\n    };\n}\n\n/**\n * Adds a 'get by value' function to an array.\n *\n * If this function is called with addIndex(myArray, 'name'), a new function 'by_name(value)' will be added that allows to\n * find a member of the array by the value of its 'name' property.\n *\n * @param array      The array\n * @param property   The property that will be used by the 'by_{property}()' function\n * @returns The array with the added function\n */\nexport function addGetByValue<T, P extends Extract<keyof T, string>>(array: Array<T>, property: P) {\n    const indexName: keyof Index<T, P> = `by_${property}`;\n\n    if (!array.hasOwnProperty(indexName)) {\n        Object.defineProperty(array, indexName, { writable: false, value: createIndexedFind(array, property) });\n    } else {\n        throw new Error(`Property '${indexName}' already exists`);\n    }\n    return array as ArrayWithIndex<T, P>;\n}\n\n/**\n * Merge annotations from different sources together by overwriting at the term level.\n *\n * @param references        References, used to resolve aliased annotation targets and aliased annotation terms.\n * @param annotationSources Annotation sources\n * @returns the resulting merged annotations\n */\nexport function mergeAnnotations(\n    references: Reference[],\n    ...annotationSources: { name: string; annotationList: AnnotationList[] }[]\n): Record<string, Annotation[]> {\n    return annotationSources.reduceRight((result, { name, annotationList }) => {\n        for (const { target, annotations } of annotationList) {\n            const annotationTarget = unalias(references, target) ?? target;\n            if (!result[annotationTarget]) {\n                result[annotationTarget] = [];\n            }\n\n            const annotationsOnTarget = annotations\n                .map((rawAnnotation): Annotation => {\n                    rawAnnotation.term = unalias(references, rawAnnotation.term) ?? rawAnnotation.term;\n\n                    (rawAnnotation as any).fullyQualifiedName = rawAnnotation.qualifier\n                        ? `${annotationTarget}@${rawAnnotation.term}#${rawAnnotation.qualifier}`\n                        : `${annotationTarget}@${rawAnnotation.term}`;\n\n                    (rawAnnotation as any).__source = name;\n\n                    return rawAnnotation as Annotation;\n                })\n                .filter(\n                    (annotation) =>\n                        !result[annotationTarget].some(\n                            (existingAnnotation) =>\n                                existingAnnotation.term === annotation.term &&\n                                existingAnnotation.qualifier === annotation.qualifier\n                        )\n                );\n\n            result[annotationTarget].push(...annotationsOnTarget);\n        }\n\n        return result;\n    }, {} as Record<string, Annotation[]>);\n}\n","import type {\n    AnnotationPathExpression,\n    AnnotationRecord,\n    AnnotationTerm,\n    Expression,\n    NavigationPropertyPathExpression,\n    PathExpression,\n    PropertyPathExpression,\n    RawAnnotation,\n    Reference\n} from '@sap-ux/vocabularies-types';\nimport { unalias } from './utils';\n\n/**\n * Revert an object to its raw type equivalent.\n *\n * @param references the current reference\n * @param value the value to revert\n * @returns the raw value\n */\nfunction revertObjectToRawType(references: Reference[], value: any) {\n    let result: Expression | undefined;\n    if (Array.isArray(value)) {\n        result = {\n            type: 'Collection',\n            Collection: value.map((anno) => revertCollectionItemToRawType(references, anno)) as any[]\n        };\n    } else if (value.isDecimal?.()) {\n        result = {\n            type: 'Decimal',\n            Decimal: value.valueOf()\n        };\n    } else if (value.isString?.()) {\n        const valueMatches = value.valueOf().split('.');\n        if (valueMatches.length > 1 && references.find((ref) => ref.alias === valueMatches[0])) {\n            result = {\n                type: 'EnumMember',\n                EnumMember: value.valueOf()\n            };\n        } else {\n            result = {\n                type: 'String',\n                String: value.valueOf()\n            };\n        }\n    } else if (value.isInt?.()) {\n        result = {\n            type: 'Int',\n            Int: value.valueOf()\n        };\n    } else if (value.isFloat?.()) {\n        result = {\n            type: 'Float',\n            Float: value.valueOf()\n        };\n    } else if (value.isDate?.()) {\n        result = {\n            type: 'Date',\n            Date: value.valueOf()\n        };\n    } else if (value.isBoolean?.()) {\n        result = {\n            type: 'Bool',\n            Bool: value.valueOf()\n        };\n    } else if (value.type === 'Path') {\n        result = {\n            type: 'Path',\n            Path: value.path\n        };\n    } else if (value.type === 'AnnotationPath') {\n        result = {\n            type: 'AnnotationPath',\n            AnnotationPath: value.value\n        };\n    } else if (value.type === 'Apply') {\n        result = {\n            type: 'Apply',\n            $Apply: value.$Apply,\n            $Function: value.$Function\n        };\n    } else if (value.type === 'Null') {\n        result = {\n            type: 'Null'\n        };\n    } else if (value.type === 'PropertyPath') {\n        result = {\n            type: 'PropertyPath',\n            PropertyPath: value.value\n        };\n    } else if (value.type === 'NavigationPropertyPath') {\n        result = {\n            type: 'NavigationPropertyPath',\n            NavigationPropertyPath: value.value\n        };\n    } else if (Object.prototype.hasOwnProperty.call(value, '$Type')) {\n        result = {\n            type: 'Record',\n            Record: revertCollectionItemToRawType(references, value) as AnnotationRecord\n        };\n    }\n    return result;\n}\n\n/**\n * Revert a value to its raw value depending on its type.\n *\n * @param references the current set of reference\n * @param value the value to revert\n * @returns the raw expression\n */\nfunction revertValueToRawType(references: Reference[], value: any): Expression | undefined {\n    let result: Expression | undefined;\n    const valueConstructor = value?.constructor.name;\n    switch (valueConstructor) {\n        case 'String':\n        case 'string':\n            const valueMatches = value.toString().split('.');\n            if (valueMatches.length > 1 && references.find((ref) => ref.alias === valueMatches[0])) {\n                result = {\n                    type: 'EnumMember',\n                    EnumMember: value.toString()\n                };\n            } else {\n                result = {\n                    type: 'String',\n                    String: value.toString()\n                };\n            }\n            break;\n        case 'Boolean':\n        case 'boolean':\n            result = {\n                type: 'Bool',\n                Bool: value.valueOf()\n            };\n            break;\n\n        case 'Number':\n        case 'number':\n            if (value.toString() === value.toFixed()) {\n                result = {\n                    type: 'Int',\n                    Int: value.valueOf()\n                };\n            } else {\n                result = {\n                    type: 'Decimal',\n                    Decimal: value.valueOf()\n                };\n            }\n            break;\n        case 'object':\n        default:\n            result = revertObjectToRawType(references, value);\n            break;\n    }\n    return result;\n}\n\nconst restrictedKeys = ['$Type', 'term', '__source', 'qualifier', 'ActionTarget', 'fullyQualifiedName', 'annotations'];\n\n/**\n * Revert the current embedded annotations to their raw type.\n *\n * @param references the current set of reference\n * @param currentAnnotations the collection item to evaluate\n * @param targetAnnotations the place where we need to add the annotation\n */\nfunction revertAnnotationsToRawType(\n    references: Reference[],\n    currentAnnotations: any,\n    targetAnnotations: RawAnnotation[]\n) {\n    Object.keys(currentAnnotations)\n        .filter((key) => key !== '_annotations')\n        .forEach((key) => {\n            Object.keys(currentAnnotations[key]).forEach((term) => {\n                const parsedAnnotation = revertTermToGenericType(references, currentAnnotations[key][term]);\n                if (!parsedAnnotation.term) {\n                    const unaliasedTerm = unalias(references, `${key}.${term}`);\n                    if (unaliasedTerm) {\n                        const qualifiedSplit = unaliasedTerm.split('#');\n                        parsedAnnotation.term = qualifiedSplit[0];\n                        if (qualifiedSplit.length > 1) {\n                            // Sub Annotation with a qualifier, not sure when that can happen in real scenarios\n                            parsedAnnotation.qualifier = qualifiedSplit[1];\n                        }\n                    }\n                }\n                targetAnnotations.push(parsedAnnotation);\n            });\n        });\n}\n\n/**\n * Revert the current collection item to the corresponding raw annotation.\n *\n * @param references the current set of reference\n * @param collectionItem the collection item to evaluate\n * @returns the raw type equivalent\n */\nfunction revertCollectionItemToRawType(\n    references: Reference[],\n    collectionItem: any\n):\n    | AnnotationRecord\n    | string\n    | PropertyPathExpression\n    | PathExpression\n    | NavigationPropertyPathExpression\n    | AnnotationPathExpression\n    | undefined {\n    if (typeof collectionItem === 'string') {\n        return collectionItem;\n    } else if (typeof collectionItem === 'object') {\n        if (collectionItem.hasOwnProperty('$Type')) {\n            // Annotation Record\n            const outItem: AnnotationRecord = {\n                type: collectionItem.$Type,\n                propertyValues: [] as any[]\n            };\n            // Could validate keys and type based on $Type\n            Object.keys(collectionItem).forEach((collectionKey) => {\n                if (restrictedKeys.indexOf(collectionKey) === -1) {\n                    const value = collectionItem[collectionKey];\n                    outItem.propertyValues.push({\n                        name: collectionKey,\n                        value: revertValueToRawType(references, value) as Expression\n                    });\n                } else if (collectionKey === 'annotations' && Object.keys(collectionItem[collectionKey]).length > 0) {\n                    outItem.annotations = [];\n                    revertAnnotationsToRawType(references, collectionItem[collectionKey], outItem.annotations);\n                }\n            });\n            return outItem;\n        } else if (collectionItem.type === 'PropertyPath') {\n            return {\n                type: 'PropertyPath',\n                PropertyPath: collectionItem.value\n            };\n        } else if (collectionItem.type === 'AnnotationPath') {\n            return {\n                type: 'AnnotationPath',\n                AnnotationPath: collectionItem.value\n            };\n        } else if (collectionItem.type === 'NavigationPropertyPath') {\n            return {\n                type: 'NavigationPropertyPath',\n                NavigationPropertyPath: collectionItem.value\n            };\n        }\n    }\n    return undefined;\n}\n\n/**\n * Revert an annotation term to it's generic or raw equivalent.\n *\n * @param references the reference of the current context\n * @param annotation the annotation term to revert\n * @returns the raw annotation\n */\nexport function revertTermToGenericType(references: Reference[], annotation: AnnotationTerm<any>): RawAnnotation {\n    const baseAnnotation: RawAnnotation = {\n        term: annotation.term,\n        qualifier: annotation.qualifier\n    };\n    if (Array.isArray(annotation)) {\n        // Collection\n        if (annotation.hasOwnProperty('annotations') && Object.keys((annotation as any).annotations).length > 0) {\n            // Annotation on a collection itself, not sure when that happens if at all\n            baseAnnotation.annotations = [];\n            revertAnnotationsToRawType(references, (annotation as any).annotations, baseAnnotation.annotations);\n        }\n        return {\n            ...baseAnnotation,\n            collection: annotation.map((anno) => revertCollectionItemToRawType(references, anno)) as any[]\n        };\n    } else if (annotation.hasOwnProperty('$Type')) {\n        return { ...baseAnnotation, record: revertCollectionItemToRawType(references, annotation) as any };\n    } else {\n        return { ...baseAnnotation, value: revertValueToRawType(references, annotation) };\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EnumIsFlag = void 0;\nexports.EnumIsFlag = {\n    \"Authorization.KeyLocation\": false,\n    \"Core.RevisionKind\": false,\n    \"Core.DataModificationOperationKind\": false,\n    \"Core.Permission\": true,\n    \"Capabilities.ConformanceLevelType\": false,\n    \"Capabilities.IsolationLevel\": true,\n    \"Capabilities.NavigationType\": false,\n    \"Capabilities.SearchExpressions\": true,\n    \"Capabilities.HttpMethod\": true,\n    \"Aggregation.RollupType\": false,\n    \"Common.TextFormatType\": false,\n    \"Common.FilterExpressionType\": false,\n    \"Common.FieldControlType\": false,\n    \"Common.EffectType\": true,\n    \"Communication.KindType\": false,\n    \"Communication.ContactInformationType\": true,\n    \"Communication.PhoneType\": true,\n    \"Communication.GenderType\": false,\n    \"UI.VisualizationType\": false,\n    \"UI.CriticalityType\": false,\n    \"UI.ImprovementDirectionType\": false,\n    \"UI.TrendType\": false,\n    \"UI.ChartType\": false,\n    \"UI.ChartAxisScaleBehaviorType\": false,\n    \"UI.ChartAxisAutoScaleDataScopeType\": false,\n    \"UI.ChartDimensionRoleType\": false,\n    \"UI.ChartMeasureRoleType\": false,\n    \"UI.SelectionRangeSignType\": false,\n    \"UI.SelectionRangeOptionType\": false,\n    \"UI.TextArrangementType\": false,\n    \"UI.ImportanceType\": false,\n    \"UI.CriticalityRepresentationType\": false,\n    \"UI.OperationGroupingType\": false,\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TermToTypes = void 0;\nvar TermToTypes;\n(function (TermToTypes) {\n    TermToTypes[\"Org.OData.Authorization.V1.SecuritySchemes\"] = \"Org.OData.Authorization.V1.SecurityScheme\";\n    TermToTypes[\"Org.OData.Authorization.V1.Authorizations\"] = \"Org.OData.Authorization.V1.Authorization\";\n    TermToTypes[\"Org.OData.Core.V1.Revisions\"] = \"Org.OData.Core.V1.RevisionType\";\n    TermToTypes[\"Org.OData.Core.V1.Links\"] = \"Org.OData.Core.V1.Link\";\n    TermToTypes[\"Org.OData.Core.V1.Example\"] = \"Org.OData.Core.V1.ExampleValue\";\n    TermToTypes[\"Org.OData.Core.V1.Messages\"] = \"Org.OData.Core.V1.MessageType\";\n    TermToTypes[\"Org.OData.Core.V1.ValueException\"] = \"Org.OData.Core.V1.ValueExceptionType\";\n    TermToTypes[\"Org.OData.Core.V1.ResourceException\"] = \"Org.OData.Core.V1.ResourceExceptionType\";\n    TermToTypes[\"Org.OData.Core.V1.DataModificationException\"] = \"Org.OData.Core.V1.DataModificationExceptionType\";\n    TermToTypes[\"Org.OData.Core.V1.IsLanguageDependent\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.AppliesViaContainer\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.DereferenceableIDs\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.ConventionalIDs\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.Permissions\"] = \"Org.OData.Core.V1.Permission\";\n    TermToTypes[\"Org.OData.Core.V1.DefaultNamespace\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.Immutable\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.Computed\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.ComputedDefaultValue\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.IsURL\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.IsMediaType\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.ContentDisposition\"] = \"Org.OData.Core.V1.ContentDispositionType\";\n    TermToTypes[\"Org.OData.Core.V1.OptimisticConcurrency\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"Org.OData.Core.V1.AdditionalProperties\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.AutoExpand\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.AutoExpandReferences\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.MayImplement\"] = \"Org.OData.Core.V1.QualifiedTypeName\";\n    TermToTypes[\"Org.OData.Core.V1.Ordered\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.PositionalInsert\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.AlternateKeys\"] = \"Org.OData.Core.V1.AlternateKey\";\n    TermToTypes[\"Org.OData.Core.V1.OptionalParameter\"] = \"Org.OData.Core.V1.OptionalParameterType\";\n    TermToTypes[\"Org.OData.Core.V1.OperationAvailable\"] = \"Edm.Boolean\";\n    TermToTypes[\"Org.OData.Core.V1.RequiresExplicitBinding\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.ExplicitOperationBindings\"] = \"Org.OData.Core.V1.QualifiedBoundOperationName\";\n    TermToTypes[\"Org.OData.Core.V1.SymbolicName\"] = \"Org.OData.Core.V1.SimpleIdentifier\";\n    TermToTypes[\"Org.OData.Core.V1.GeometryFeature\"] = \"Org.OData.Core.V1.GeometryFeatureType\";\n    TermToTypes[\"Org.OData.Core.V1.AnyStructure\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Core.V1.IsDelta\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ConformanceLevel\"] = \"Org.OData.Capabilities.V1.ConformanceLevelType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.AsynchronousRequestsSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.BatchContinueOnErrorSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.IsolationSupported\"] = \"Org.OData.Capabilities.V1.IsolationLevel\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CrossJoinSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CallbackSupported\"] = \"Org.OData.Capabilities.V1.CallbackType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ChangeTracking\"] = \"Org.OData.Capabilities.V1.ChangeTrackingType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CountRestrictions\"] = \"Org.OData.Capabilities.V1.CountRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.NavigationRestrictions\"] = \"Org.OData.Capabilities.V1.NavigationRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.IndexableByKey\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.TopSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.SkipSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ComputeSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.SelectSupport\"] = \"Org.OData.Capabilities.V1.SelectSupportType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.BatchSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.BatchSupport\"] = \"Org.OData.Capabilities.V1.BatchSupportType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.FilterRestrictions\"] = \"Org.OData.Capabilities.V1.FilterRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.SortRestrictions\"] = \"Org.OData.Capabilities.V1.SortRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ExpandRestrictions\"] = \"Org.OData.Capabilities.V1.ExpandRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.SearchRestrictions\"] = \"Org.OData.Capabilities.V1.SearchRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.KeyAsSegmentSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.QuerySegmentSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.InsertRestrictions\"] = \"Org.OData.Capabilities.V1.InsertRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.DeepInsertSupport\"] = \"Org.OData.Capabilities.V1.DeepInsertSupportType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.UpdateRestrictions\"] = \"Org.OData.Capabilities.V1.UpdateRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.DeepUpdateSupport\"] = \"Org.OData.Capabilities.V1.DeepUpdateSupportType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.DeleteRestrictions\"] = \"Org.OData.Capabilities.V1.DeleteRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CollectionPropertyRestrictions\"] = \"Org.OData.Capabilities.V1.CollectionPropertyRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.OperationRestrictions\"] = \"Org.OData.Capabilities.V1.OperationRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.AnnotationValuesInQuerySupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ModificationQueryOptions\"] = \"Org.OData.Capabilities.V1.ModificationQueryOptionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.ReadRestrictions\"] = \"Org.OData.Capabilities.V1.ReadRestrictionsType\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CustomHeaders\"] = \"Org.OData.Capabilities.V1.CustomParameter\";\n    TermToTypes[\"Org.OData.Capabilities.V1.CustomQueryOptions\"] = \"Org.OData.Capabilities.V1.CustomParameter\";\n    TermToTypes[\"Org.OData.Capabilities.V1.MediaLocationUpdateSupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Capabilities.V1.DefaultCapabilities\"] = \"Org.OData.Capabilities.V1.DefaultCapabilitiesType\";\n    TermToTypes[\"Org.OData.Aggregation.V1.ApplySupported\"] = \"Org.OData.Aggregation.V1.ApplySupportedType\";\n    TermToTypes[\"Org.OData.Aggregation.V1.ApplySupportedDefaults\"] = \"Org.OData.Aggregation.V1.ApplySupportedBase\";\n    TermToTypes[\"Org.OData.Aggregation.V1.Groupable\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Aggregation.V1.Aggregatable\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Aggregation.V1.ContextDefiningProperties\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"Org.OData.Aggregation.V1.LeveledHierarchy\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"Org.OData.Aggregation.V1.RecursiveHierarchy\"] = \"Org.OData.Aggregation.V1.RecursiveHierarchyType\";\n    TermToTypes[\"Org.OData.Aggregation.V1.AvailableOnAggregates\"] = \"Org.OData.Aggregation.V1.AvailableOnAggregatesType\";\n    TermToTypes[\"Org.OData.Validation.V1.Minimum\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"Org.OData.Validation.V1.Maximum\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"Org.OData.Validation.V1.Exclusive\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"Org.OData.Validation.V1.AllowedValues\"] = \"Org.OData.Validation.V1.AllowedValue\";\n    TermToTypes[\"Org.OData.Validation.V1.MultipleOf\"] = \"Edm.Decimal\";\n    TermToTypes[\"Org.OData.Validation.V1.Constraint\"] = \"Org.OData.Validation.V1.ConstraintType\";\n    TermToTypes[\"Org.OData.Validation.V1.ItemsOf\"] = \"Org.OData.Validation.V1.ItemsOfType\";\n    TermToTypes[\"Org.OData.Validation.V1.OpenPropertyTypeConstraint\"] = \"Org.OData.Validation.V1.SingleOrCollectionType\";\n    TermToTypes[\"Org.OData.Validation.V1.DerivedTypeConstraint\"] = \"Org.OData.Validation.V1.SingleOrCollectionType\";\n    TermToTypes[\"Org.OData.Validation.V1.AllowedTerms\"] = \"Org.OData.Core.V1.QualifiedTermName\";\n    TermToTypes[\"Org.OData.Validation.V1.ApplicableTerms\"] = \"Org.OData.Core.V1.QualifiedTermName\";\n    TermToTypes[\"Org.OData.Validation.V1.MaxItems\"] = \"Edm.Int64\";\n    TermToTypes[\"Org.OData.Validation.V1.MinItems\"] = \"Edm.Int64\";\n    TermToTypes[\"Org.OData.Measures.V1.Scale\"] = \"Edm.Byte\";\n    TermToTypes[\"Org.OData.Measures.V1.DurationGranularity\"] = \"Org.OData.Measures.V1.DurationGranularityType\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.Dimension\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.Measure\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.AccumulativeMeasure\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.RolledUpPropertyCount\"] = \"Edm.Int16\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.PlanningAction\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.AggregatedProperties\"] = \"com.sap.vocabularies.Analytics.v1.AggregatedPropertyType\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.AggregatedProperty\"] = \"com.sap.vocabularies.Analytics.v1.AggregatedPropertyType\";\n    TermToTypes[\"com.sap.vocabularies.Analytics.v1.AnalyticalContext\"] = \"com.sap.vocabularies.Analytics.v1.AnalyticalContextType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ServiceVersion\"] = \"Edm.Int32\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ServiceSchemaVersion\"] = \"Edm.Int32\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.TextFor\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsLanguageIdentifier\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.TextFormat\"] = \"com.sap.vocabularies.Common.v1.TextFormatType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsTimezone\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsDigitSequence\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsUpperCase\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCurrency\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsUnit\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.UnitSpecificScale\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.UnitSpecificPrecision\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SecondaryKey\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.MinOccurs\"] = \"Edm.Int64\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.MaxOccurs\"] = \"Edm.Int64\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.AssociationEntity\"] = \"Edm.NavigationPropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DerivedNavigation\"] = \"Edm.NavigationPropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Masked\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.RevealOnDemand\"] = \"Edm.Boolean\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SemanticObjectMapping\"] = \"com.sap.vocabularies.Common.v1.SemanticObjectMappingAbstract\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsInstanceAnnotation\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.FilterExpressionRestrictions\"] = \"com.sap.vocabularies.Common.v1.FilterExpressionRestrictionType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.FieldControl\"] = \"com.sap.vocabularies.Common.v1.FieldControlType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Application\"] = \"com.sap.vocabularies.Common.v1.ApplicationType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Timestamp\"] = \"Edm.DateTimeOffset\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ErrorResolution\"] = \"com.sap.vocabularies.Common.v1.ErrorResolutionType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Messages\"] = \"Edm.ComplexType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.numericSeverity\"] = \"com.sap.vocabularies.Common.v1.NumericMessageSeverityType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.MaximumNumericMessageSeverity\"] = \"com.sap.vocabularies.Common.v1.NumericMessageSeverityType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsActionCritical\"] = \"Edm.Boolean\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Attributes\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.RelatedRecursiveHierarchy\"] = \"Edm.AnnotationPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Interval\"] = \"com.sap.vocabularies.Common.v1.IntervalType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ResultContext\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SAPObjectNodeType\"] = \"com.sap.vocabularies.Common.v1.SAPObjectNodeTypeType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.Composition\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsNaturalPerson\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ValueList\"] = \"com.sap.vocabularies.Common.v1.ValueListType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ValueListRelevantQualifiers\"] = \"Org.OData.Core.V1.SimpleIdentifier\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ValueListWithFixedValues\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ValueListShowValuesImmediately\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ValueListMapping\"] = \"com.sap.vocabularies.Common.v1.ValueListMappingType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarHalfyear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarQuarter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarMonth\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarWeek\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsDayOfCalendarMonth\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsDayOfCalendarYear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYearHalfyear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYearQuarter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYearMonth\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarYearWeek\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsCalendarDate\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalPeriod\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYearPeriod\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalQuarter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYearQuarter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalWeek\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYearWeek\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsDayOfFiscalYear\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.IsFiscalYearVariant\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.MutuallyExclusiveTerm\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DraftRoot\"] = \"com.sap.vocabularies.Common.v1.DraftRootType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DraftNode\"] = \"com.sap.vocabularies.Common.v1.DraftNodeType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DraftActivationVia\"] = \"Org.OData.Core.V1.SimpleIdentifier\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.EditableFieldFor\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SemanticKey\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SideEffects\"] = \"com.sap.vocabularies.Common.v1.SideEffectsType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.DefaultValuesFunction\"] = \"com.sap.vocabularies.Common.v1.QualifiedName\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.FilterDefaultValue\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.FilterDefaultValueHigh\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.SortOrder\"] = \"com.sap.vocabularies.Common.v1.SortOrderType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.RecursiveHierarchy\"] = \"com.sap.vocabularies.Common.v1.RecursiveHierarchyType\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.CreatedAt\"] = \"Edm.DateTimeOffset\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.CreatedBy\"] = \"com.sap.vocabularies.Common.v1.UserID\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ChangedAt\"] = \"Edm.DateTimeOffset\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ChangedBy\"] = \"com.sap.vocabularies.Common.v1.UserID\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.ApplyMultiUnitBehaviorForSortingAndFiltering\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Common.v1.PrimitivePropertyPath\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.CurrencyCodes\"] = \"com.sap.vocabularies.CodeList.v1.CodeListSource\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.UnitsOfMeasure\"] = \"com.sap.vocabularies.CodeList.v1.CodeListSource\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.StandardCode\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.ExternalCode\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.CodeList.v1.IsConfigurationDeprecationCode\"] = \"Edm.Boolean\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Contact\"] = \"com.sap.vocabularies.Communication.v1.ContactType\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Address\"] = \"com.sap.vocabularies.Communication.v1.AddressType\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.IsEmailAddress\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.IsPhoneNumber\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Event\"] = \"com.sap.vocabularies.Communication.v1.EventData\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Task\"] = \"com.sap.vocabularies.Communication.v1.TaskData\";\n    TermToTypes[\"com.sap.vocabularies.Communication.v1.Message\"] = \"com.sap.vocabularies.Communication.v1.MessageData\";\n    TermToTypes[\"com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchy\"] = \"com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchyType\";\n    TermToTypes[\"com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchyActions\"] = \"com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchyActionsType\";\n    TermToTypes[\"com.sap.vocabularies.Hierarchy.v1.MatchCount\"] = \"Edm.Int64\";\n    TermToTypes[\"com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchySupported\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.PersonalData.v1.EntitySemantics\"] = \"com.sap.vocabularies.PersonalData.v1.EntitySemanticsType\";\n    TermToTypes[\"com.sap.vocabularies.PersonalData.v1.FieldSemantics\"] = \"com.sap.vocabularies.PersonalData.v1.FieldSemanticsType\";\n    TermToTypes[\"com.sap.vocabularies.PersonalData.v1.IsPotentiallyPersonal\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.PersonalData.v1.IsPotentiallySensitive\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.Session.v1.StickySessionSupported\"] = \"com.sap.vocabularies.Session.v1.StickySessionSupportedType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.HeaderInfo\"] = \"com.sap.vocabularies.UI.v1.HeaderInfoType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Identification\"] = \"com.sap.vocabularies.UI.v1.DataFieldAbstract\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Badge\"] = \"com.sap.vocabularies.UI.v1.BadgeType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.LineItem\"] = \"com.sap.vocabularies.UI.v1.DataFieldAbstract\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.StatusInfo\"] = \"com.sap.vocabularies.UI.v1.DataFieldAbstract\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.FieldGroup\"] = \"com.sap.vocabularies.UI.v1.FieldGroupType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ConnectedFields\"] = \"com.sap.vocabularies.UI.v1.ConnectedFieldsType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.GeoLocations\"] = \"com.sap.vocabularies.UI.v1.GeoLocationType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.GeoLocation\"] = \"com.sap.vocabularies.UI.v1.GeoLocationType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Contacts\"] = \"Edm.AnnotationPath\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.MediaResource\"] = \"com.sap.vocabularies.UI.v1.MediaResourceType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.DataPoint\"] = \"com.sap.vocabularies.UI.v1.DataPointType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.KPI\"] = \"com.sap.vocabularies.UI.v1.KPIType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Chart\"] = \"com.sap.vocabularies.UI.v1.ChartDefinitionType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ValueCriticality\"] = \"com.sap.vocabularies.UI.v1.ValueCriticalityType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.CriticalityLabels\"] = \"com.sap.vocabularies.UI.v1.CriticalityLabelType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.SelectionFields\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Facets\"] = \"com.sap.vocabularies.UI.v1.Facet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.HeaderFacets\"] = \"com.sap.vocabularies.UI.v1.Facet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.QuickViewFacets\"] = \"com.sap.vocabularies.UI.v1.Facet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.QuickCreateFacets\"] = \"com.sap.vocabularies.UI.v1.Facet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.FilterFacets\"] = \"com.sap.vocabularies.UI.v1.ReferenceFacet\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.SelectionPresentationVariant\"] = \"com.sap.vocabularies.UI.v1.SelectionPresentationVariantType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.PresentationVariant\"] = \"com.sap.vocabularies.UI.v1.PresentationVariantType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.SelectionVariant\"] = \"com.sap.vocabularies.UI.v1.SelectionVariantType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ThingPerspective\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.IsSummary\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.PartOfPreview\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Map\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Gallery\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.IsImageURL\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.IsImage\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.MultiLineText\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.InputMask\"] = \"com.sap.vocabularies.UI.v1.InputMaskType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.TextArrangement\"] = \"com.sap.vocabularies.UI.v1.TextArrangementType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Note\"] = \"com.sap.vocabularies.UI.v1.NoteType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Importance\"] = \"com.sap.vocabularies.UI.v1.ImportanceType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Hidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.IsCopyAction\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.IsAIOperation\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.CreateHidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.UpdateHidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.DeleteHidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.HiddenFilter\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.AdaptationHidden\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.DataFieldDefault\"] = \"com.sap.vocabularies.UI.v1.DataFieldAbstract\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Criticality\"] = \"com.sap.vocabularies.UI.v1.CriticalityType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.CriticalityCalculation\"] = \"com.sap.vocabularies.UI.v1.CriticalityCalculationType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Emphasized\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.OrderBy\"] = \"Edm.PropertyPath\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ParameterDefaultValue\"] = \"Edm.PrimitiveType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.RecommendationState\"] = \"com.sap.vocabularies.UI.v1.RecommendationStateType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.RecommendationList\"] = \"com.sap.vocabularies.UI.v1.RecommendationListType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.Recommendations\"] = \"Edm.ComplexType\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.ExcludeFromNavigationContext\"] = \"Org.OData.Core.V1.Tag\";\n    TermToTypes[\"com.sap.vocabularies.UI.v1.DoNotCheckScaleOfMeasuredQuantity\"] = \"Edm.Boolean\";\n    TermToTypes[\"com.sap.vocabularies.HTML5.v1.CssDefaults\"] = \"com.sap.vocabularies.HTML5.v1.CssDefaultsType\";\n    TermToTypes[\"com.sap.vocabularies.HTML5.v1.LinkTarget\"] = \"com.sap.vocabularies.HTML5.v1.LinkTargetType\";\n    TermToTypes[\"com.sap.vocabularies.HTML5.v1.RowSpanForDuplicateValues\"] = \"Org.OData.Core.V1.Tag\";\n})(TermToTypes = exports.TermToTypes || (exports.TermToTypes = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VocabularyReferences = void 0;\n/**\n * The list of vocabularies with default aliases.\n */\nexports.VocabularyReferences = [\n    { alias: \"Authorization\", namespace: \"Org.OData.Authorization.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml\" },\n    { alias: \"Core\", namespace: \"Org.OData.Core.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml\" },\n    { alias: \"Capabilities\", namespace: \"Org.OData.Capabilities.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml\" },\n    { alias: \"Aggregation\", namespace: \"Org.OData.Aggregation.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml\" },\n    { alias: \"Validation\", namespace: \"Org.OData.Validation.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Validation.V1.xml\" },\n    { alias: \"Measures\", namespace: \"Org.OData.Measures.V1\", uri: \"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Measures.V1.xml\" },\n    { alias: \"Analytics\", namespace: \"com.sap.vocabularies.Analytics.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Analytics.xml\" },\n    { alias: \"Common\", namespace: \"com.sap.vocabularies.Common.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Common.xml\" },\n    { alias: \"CodeList\", namespace: \"com.sap.vocabularies.CodeList.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/CodeList.xml\" },\n    { alias: \"Communication\", namespace: \"com.sap.vocabularies.Communication.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Communication.xml\" },\n    { alias: \"Hierarchy\", namespace: \"com.sap.vocabularies.Hierarchy.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Hierarchy.xml\" },\n    { alias: \"PersonalData\", namespace: \"com.sap.vocabularies.PersonalData.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/PersonalData.xml\" },\n    { alias: \"Session\", namespace: \"com.sap.vocabularies.Session.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/Session.xml\" },\n    { alias: \"UI\", namespace: \"com.sap.vocabularies.UI.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/UI.xml\" },\n    { alias: \"HTML5\", namespace: \"com.sap.vocabularies.HTML5.v1\", uri: \"https://sap.github.io/odata-vocabularies/vocabularies/HTML5.xml\" }\n];\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(131);\n",""]}