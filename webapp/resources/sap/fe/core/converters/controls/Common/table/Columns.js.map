{"version":3,"file":"Columns.js","names":["ColumnType","_exports","getTableColumns","lineItemAnnotation","tableType","visualizationPath","converterContext","annotationColumns","getColumnsFromAnnotations","manifestColumns","getColumnsFromManifest","getManifestControlConfiguration","columns","getAnnotationEntityType","tableColumns","insertCustomElements","width","OverrideType","overwrite","widthIncludingColumnHeader","importance","horizontalAlign","availability","isNavigable","settings","formatOptions","exportSettings","addComputedColumns","findColumnByPath","path","find","column","annotationColumn","propertyInfos","undefined","relativePath","updateLinkedProperties","dataModelObjectPath","getConverterContextFor","getContextPath","getDataModelObjectPath","forEach","oColumn","tableColumn","propertyDataModelObjectPath","enhanceDataModelPath","property","targetObject","addCurrencyOrUoMToProperty","timezoneProperty","getAssociatedTimezoneProperty","timezone","annotations","Common","Timezone","oTimezoneColumn","name","timezoneText","toString","addTextArrangentInfoToProperty","currencyOrUoMProperty","getAssociatedCurrencyPropertyPath","getAssociatedUnitPropertyPath","currencyOrUoMPropertyDataModelObjectPath","currencyOrUoMRelativePath","getContextRelativeTargetObjectPath","unitColumn","unit","Measures","ISOCurrency","Unit","unitText","displayMode","getDisplayMode","textPropertyPath","getAssociatedTextPropertyPath","textPropertyDataModelObjectPath","textRelativePath","textColumn","textArrangement","textProperty","mode","type","getColumnsFromEntityType","columnsToBeCreated","entityType","tableCreationMode","displayModeOfDescriptionPropertiesMap","restrictionsOnProperties","propertiesNotToBeConsidered","aggregationHelper","AggregationHelper","groupableProperties","getGroupableProperties","isAnalyticsSupported","map","$target","filter","target","getAssociatedTextProperty","textProp","isPropertyGroupable","prop","entityProperties","exists","some","targetType","includes","relatedPropertiesInfo","collectRelatedProperties","relatedPropertyNames","Object","keys","properties","additionalPropertyNames","additionalProperties","addPropertyToDisplayModeOfDescriptionPropertiesMap","columnInfo","getColumnDefinitionFromProperty","getEntitySetBasedAnnotationPath","fullyQualifiedName","length","dataPointTargetValue","exportDataPointTargetValue","annotationProperty","additionalPropertyInfos","additionalPropertyName","push","nonSortableProperties","isPathAnnotationExpression","Text","relatedColumns","_createRelatedColumns","concat","fullPropertyPath","useDataFieldPrefix","availableForAdaptation","relativePathForMultiValue","semanticObjectAnnotationPath","getSemanticObjectPath","isHidden","isReferencePropertyStaticallyHidden","groupPath","_sliceAtSlash","isGroup","label","getLabel","dataType","getDataFieldDataType","propertyTypeConfig","getTypeConfig","isAPropertyFromTextOnlyAnnotation","sortable","filterable","nonFilterableProperties","groupable","typeConfig","className","constraints","_isExportableColumn","createColumnExportSettings","collectedNavigationPropertyLabels","_getCollectedNavigationPropertyLabels","key","replaceSpecialChars","Annotation","groupLabel","group","annotationPath","semanticObjectPath","isGroupable","isKey","caseSensitive","isFilteringCaseSensitive","getImportance","UI","DataFieldDefault","required","isRequiredColumn","additionalLabels","_addToolTip","_setExportSettingsForDataPoint","ModelHelper","isObjectPathDraftSupported","extension","technicallyAggregatable","technicallyGroupable","unitProperty","utc","isATimezone","currencyProperty","scale","isProperty","getAssociatedUnitProperty","getAssociatedCurrencyProperty","getStaticUnitOrCurrency","getStaticTimezone","isTimezone","exportType","getExportDataType","inputFormat","getDateInputFormat","delimiter","getDelimiter","template","wrap","autoScale","removeUndefinedFromExportSettings","setting","source","propertyType","dataFieldDefaultProperty","$Type","Target","Value","Core","MediaType","term","isURL","_isValidColumn","dataField","Inline","_getVisibleExpression","dataFieldModelPath","propertyValue","isAnalyticalGroupHeaderExpanded","constant","isAnalyticalLeaf","and","not","equal","getExpressionFromAnnotation","Hidden","ifElse","or","_getFieldGroupHiddenExpressions","dataFieldGroup","fieldGroupHiddenExpressions","compileExpression","Data","innerDataField","arguments","isNavigationProperty","dataFieldDefault","qualifier","Label","isDataFieldTypes","valueOf","_getTooltip","QuickInfo","datapointTarget","getRowStatusVisibility","colName","isSemanticKeyInFieldGroup","formatResult","pathInModel","tableFormatters","getErrorStatusTextVisibilityFormatter","existingColumns","relatedPropertyNameMap","getAbsoluteAnnotationPath","relatedColumn","propertyObjectPath","isMultiValueField","newNameRelativeTargetPath","computeHiddenOnRelatedColumns","newName","propertyInfo","_getAnnotationColumnName","KeyHelper","generateKeyFromDataField","_getShowDataFieldsLabel","fieldGroupName","columnKeys","showDataFieldsLabel","_getRelativePath","value","isLastSlash","isLastPart","iSlashIndex","lastIndexOf","indexOf","substring","_isColumnMultiValued","_isColumnSortable","propertyPath","nonSortableColumns","propName","filterFunctions","_getFilterFunctions","ConverterContext","entitySet","getEntitySet","TypeGuards","isEntitySet","Capabilities","FilterFunctions","getEntityContainer","_getDefaultFormatOptionsForTable","textLinesEdit","_findSemanticKeyValues","semanticKeys","aSemanticKeyValues","bSemanticKeyFound","i","values","semanticKeyFound","_findProperties","semanticKeyValues","fieldGroupProperties","semanticKeyHasPropertyInFieldGroup","sPropertyPath","tmp","fieldGroupPropertyPath","_findSemanticKeyValuesInFieldGroup","aProperties","_propertiesFound","getDefaultDraftIndicatorForColumn","semanticKey","semanticKeyInFieldGroup","fieldGroupDraftIndicatorPropertyPath","showErrorObjectStatus","hasDraftIndicator","_getImpNumber","Importance","_getDataFieldImportance","split","None","targetValuefromDP","getTargetValueOnDataPoint","isDataPointFromDataFieldDefault","_getMaxImportance","fields","maxImpNumber","impNumber","DataFieldWithMaxImportance","field","targetEntityType","SemanticKey","requiredProperties","getRequiredProperties","highKeys","fieldsWithImportance","isAnnotationOfType","dataFieldTarget","fieldGroupData","fieldGroupDataField","High","item","getRestrictionsOnProperties","tableManifestSettings","defaultCreationMode","getManifestWrapper","getSapFeManifestConfiguration","macros","table","CreationMode","InlineCreationRows","tableSettings","creationMode","getAnnotationsByTerm","getEntityType","tableConverterContext","getTargetObjectPath","collectRelatedPropertiesRecursively","isFieldGroupColumn","navigationProperties","situationsNavProps","navigationProperty","isCollection","SAPObjectNodeType","Name","situationsNavProp","hasSituationsIndicator","isMultiValue","visualSettings","widthCalculation","FieldGroupHiddenExpressions","HTML5","CssDefaults","isPartOfLineItem","tooltip","relatedPropertyName","displayModeOfPropertyUsedAsDescription","createPropertyAnnotatedTextOnly","_getPropertyNames","matchedProperties","Array","isArray","resolvePath","isRequiredFieldGroup","fieldGroup","isDataField","isStaticallyMandatory","isAnnotatedRequiredProperty","isRequiredDataFieldForAnnotation","dataFieldForAnnotation","DataFieldForAnnotationFieldControlNotMandatory","hasFieldControlNotMandatory","hasFieldGroupTarget","hasDataPointTarget","Visualization","isRequiredDataPoint","isRequiredProperty","isRatingVisualizationFromDataFieldDefault","dataPoint","getTemplateType","TemplateType","ListReport","AnalyticalListPage","IsEditable","isDataFieldForAnnotation","_appendCustomTemplate","exportProperties","join","internalColumns","isColumnOverride","isSlotColumn","manifestColumn","Slot","isCustomColumn","_updateLinkedPropertiesOnCustomColumns","annotationTableColumns","replace","isPartOfCustomColumn","validateKey","baseTableColumn","position","anchor","placement","Placement","After","propertiesToOverwriteAnnotationColumn","disableExport","getCustomExportSettings","tooltipText","fetchTextFromMetaModel","headerText","header","customColumnExportSettings","baseManifestColumn","HorizontalAlign","Begin","id","customTableColumn","Default","message","getDiagnostics","addIssue","IssueCategory","Manifest","IssueSeverity","Low","IssueCategoryType","AnnotationColumns","InvalidKey","columnWithSituationsIndicator","situationsIndicatorColumn","propertyKey","isSituationsIndicator","Computed","clipboardSettings","indexOfFirstVisibleColumn","findIndex","splice","columnsWithDraftIndicator","isDraftNode","isDraftRoot","columnWithDraftIndicator","draftIndicatorColumn","isDraftIndicator","columnIndexToInsertAfter","getContextPropertyRestriction","capabilities","InsertRestrictions","RequiredProperties","isCurrency","exportDataType","navProperty","lineItem","isPropertyNavigated","inheredPropertyDataModelObjectPath","isInheredPropertyNavigated","targetMapping","isTypeDefinition","EDM_TYPE_MAPPING","underlyingType","setUpConstraints","parseAsString","emptyString","nullable","parseKeepsEmptyString","relatedAnnotationColumns","existingColumn","columnKey","columnFromAnnotations","enableWrapping","customExportSettings","textAlign","trueValue","falseValue","valueMap"],"sources":["./Columns.ts"],"sourcesContent":["import type { EntityType, NavigationProperty, Property, PropertyPath } from \"@sap-ux/vocabularies-types\";\nimport type { FilterFunctions } from \"@sap-ux/vocabularies-types/vocabularies/Capabilities\";\nimport type { EntitySetAnnotations_Capabilities } from \"@sap-ux/vocabularies-types/vocabularies/Capabilities_Edm\";\nimport type { SemanticKey } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport { CommonAnnotationTerms } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport type {\n\tDataField,\n\tDataFieldAbstractTypes,\n\tDataFieldForAnnotation,\n\tDataFieldTypes,\n\tDataPoint,\n\tDataPointTypeTypes,\n\tFieldGroup,\n\tLineItem\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTerms, UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport type { BindingToolkitExpression, CompiledBindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport {\n\tEDM_TYPE_MAPPING,\n\tand,\n\tcompileExpression,\n\tconstant,\n\tequal,\n\tformatResult,\n\tgetExpressionFromAnnotation,\n\tifElse,\n\tnot,\n\tor,\n\tpathInModel,\n\tsetUpConstraints\n} from \"sap/fe/base/BindingToolkit\";\nimport type ConverterContext from \"sap/fe/core/converters/ConverterContext\";\nimport type {\n\tAvailabilityType,\n\tCustomDefinedTableColumn,\n\tCustomDefinedTableColumnForOverride,\n\tFormatOptionsType,\n\tTableColumnSettings,\n\tTableManifestConfiguration\n} from \"sap/fe/core/converters/ManifestSettings\";\nimport { CreationMode, HorizontalAlign, Importance, TemplateType } from \"sap/fe/core/converters/ManifestSettings\";\nimport type { PageContextPathTarget } from \"sap/fe/core/converters/TemplateConverter\";\nimport type { ComplexPropertyInfo } from \"sap/fe/core/converters/annotations/DataField\";\nimport {\n\tcollectRelatedProperties,\n\tcollectRelatedPropertiesRecursively,\n\tgetDataFieldDataType,\n\tgetSemanticObjectPath,\n\tgetTargetValueOnDataPoint,\n\thasDataPointTarget,\n\thasFieldGroupTarget,\n\tisDataField,\n\tisDataFieldForAnnotation,\n\tisDataFieldTypes,\n\tisDataPointFromDataFieldDefault,\n\tisRatingVisualizationFromDataFieldDefault\n} from \"sap/fe/core/converters/annotations/DataField\";\nimport { type TableType } from \"sap/fe/core/converters/controls/Common/Table\";\nimport { AggregationHelper } from \"sap/fe/core/converters/helpers/Aggregation\";\nimport type { ConfigurableObject, CustomElement } from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport { OverrideType, Placement, insertCustomElements } from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport { isReferencePropertyStaticallyHidden } from \"sap/fe/core/converters/helpers/DataFieldHelper\";\nimport { IssueCategory, IssueCategoryType, IssueSeverity } from \"sap/fe/core/converters/helpers/IssueManager\";\nimport { KeyHelper } from \"sap/fe/core/converters/helpers/Key\";\nimport { UI } from \"sap/fe/core/helpers/BindingHelper\";\nimport ModelHelper from \"sap/fe/core/helpers/ModelHelper\";\nimport { replaceSpecialChars } from \"sap/fe/core/helpers/StableIdHelper\";\nimport * as TypeGuards from \"sap/fe/core/helpers/TypeGuards\";\nimport {\n\tisAnnotationOfType,\n\tisNavigationProperty,\n\tisPathAnnotationExpression,\n\tisProperty,\n\tisTypeDefinition\n} from \"sap/fe/core/helpers/TypeGuards\";\nimport {\n\tenhanceDataModelPath,\n\tgetContextPropertyRestriction,\n\tgetContextRelativeTargetObjectPath,\n\tgetTargetObjectPath,\n\ttype DataModelObjectPath\n} from \"sap/fe/core/templating/DataModelPathHelper\";\nimport { getDisplayMode, type DisplayMode } from \"sap/fe/core/templating/DisplayModeFormatter\";\nimport { getRestrictionsOnProperties, type RestrictionsOnProperties } from \"sap/fe/core/templating/EntitySetHelper\";\nimport { hasFieldControlNotMandatory, isStaticallyMandatory } from \"sap/fe/core/templating/FieldControlHelper\";\nimport {\n\tgetAssociatedCurrencyProperty,\n\tgetAssociatedCurrencyPropertyPath,\n\tgetAssociatedTextProperty,\n\tgetAssociatedTextPropertyPath,\n\tgetAssociatedTimezoneProperty,\n\tgetAssociatedUnitProperty,\n\tgetAssociatedUnitPropertyPath,\n\tgetStaticTimezone,\n\tgetStaticUnitOrCurrency,\n\tisTimezone\n} from \"sap/fe/core/templating/PropertyHelper\";\nimport { isMultiValueField } from \"sap/fe/core/templating/UIFormatters\";\nimport type { DefaultTypeForEdmType } from \"sap/fe/core/type/EDM\";\n// eslint-disable-next-line @typescript-eslint/no-restricted-imports\nimport tableFormatters from \"sap/fe/macros/formatters/TableFormatter\";\nimport type Control from \"sap/ui/core/Control\";\nimport type { MDCTablePropertyInfo as PropertyInfo, VisualSettings } from \"sap/ui/mdc/Table\";\nimport type SimpleType from \"sap/ui/model/SimpleType\";\n\n// Custom Column from Manifest\ntype ManifestDefinedCustomColumn = CustomDefinedTableColumn & {\n\ttype?: ColumnType.Default;\n};\n\n// Slot Column from Building Block\ntype FragmentDefinedSlotColumn = CustomDefinedTableColumn & {\n\ttype: ColumnType.Slot;\n};\n// Properties all ColumnTypes have:\ntype BaseTableColumn = ConfigurableObject & {\n\ttype: ColumnType; //Origin of the source where we are getting the templated information from\n\twidth?: string;\n\twidthIncludingColumnHeader?: boolean;\n\timportance?: Importance;\n\thorizontalAlign?: HorizontalAlign;\n\tavailability?: AvailabilityType;\n\tisNavigable?: boolean;\n\tcaseSensitive?: boolean;\n\tlabel?: string;\n\ttooltip?: string;\n\tdisableExport?: boolean;\n};\n\n// Properties on Custom Columns and Slot Columns\nexport type CustomBasedTableColumn = BaseTableColumn & {\n\tid: string;\n\tname: string;\n\theader?: string;\n\ttemplate: string | Control;\n\tpropertyInfos?: string[];\n\texportSettings?: ColumnExportSettings | null;\n\tformatOptions: FormatOptionsType;\n\tisGroupable: boolean;\n\tisNavigable: boolean;\n\tsortable: boolean;\n\tvisualSettings: { widthCalculation: null };\n\tproperties?: string[];\n\trequired?: CompiledBindingToolkitExpression;\n};\n\nexport type ComputedTableColumn = BaseTableColumn & {\n\tname: string;\n\tlabel: string;\n\tpropertyKey: string;\n\tisDraftIndicator?: boolean;\n\tisSituationsIndicator?: boolean;\n\tformatOptions?: FormatOptionsType | null;\n\tpropertyInfos?: string[];\n\texportSettings?: ColumnExportSettings | null;\n\tclipboardSettings?: Object | null;\n\trequired?: CompiledBindingToolkitExpression;\n};\n\n// Properties derived from Manifest to override Annotation configurations\ntype AnnotationTableColumnForOverride = BaseTableColumn & {\n\tsettings?: TableColumnSettings;\n\tformatOptions?: FormatOptionsType;\n\texportSettings?: ColumnExportSettings | null;\n};\n\nexport type PropertyTypeConstraints = Partial<{\n\tscale: number;\n\tprecision: number;\n\tmaxLength: number;\n\tnullable: boolean;\n\tminimum: string;\n\tmaximum: string;\n\tisDigitSequence: boolean;\n}>;\n\nexport type PropertyTypeFormatOptions = Partial<{\n\tparseAsString: boolean;\n\temptyString: string;\n\tparseKeepsEmptyString: boolean;\n\tstyle: string;\n}>;\n\nexport type PropertyTypeConfig = {\n\ttype?: string;\n\tconstraints?: PropertyTypeConstraints;\n\tformatOptions?: PropertyTypeFormatOptions;\n\ttypeInstance?: SimpleType;\n\tbaseType?: string;\n\tclassName?: keyof typeof DefaultTypeForEdmType;\n};\n\nexport type ColumnExportSettings = PropertyInfo[\"exportSettings\"] & {\n\tdataPointTargetValue?: string;\n\tisCurrency?: boolean;\n};\n\n// Properties for Annotation Columns\nexport type AnnotationTableColumn = PropertyInfo &\n\tAnnotationTableColumnForOverride & {\n\t\tname: string;\n\t\tannotationPath: string;\n\t\trelativePath: string;\n\t\ttooltip?: string;\n\t\tgroupLabel?: string;\n\t\tgroup?: string;\n\t\tFieldGroupHiddenExpressions?: CompiledBindingToolkitExpression;\n\t\tshowDataFieldsLabel?: boolean;\n\t\trequired?: CompiledBindingToolkitExpression;\n\t\tisGroupable?: boolean;\n\t\tunitText?: string;\n\t\ttimezoneText?: string;\n\t\ttimezone?: string;\n\t\tsemanticObjectPath?: string;\n\t\ttextArrangement?: {\n\t\t\ttextProperty: string;\n\t\t\tmode: DisplayMode;\n\t\t};\n\t\tadditionalPropertyInfos?: string[];\n\t\ttypeConfig?: PropertyTypeConfig;\n\t\tisPartOfLineItem?: boolean; // temporary indicator to only allow filtering on navigation properties when they're part of a line item\n\t\tisPartOfCustomColumn?: boolean;\n\t\tadditionalLabels?: string[];\n\t\texportDataPointTargetValue?: string;\n\t\textension?: ExtensionForAnalytics;\n\t\tisMultiValue?: boolean;\n\t\tdescriptionProperty?: string;\n\t\tmode?: DisplayMode;\n\t\tvalueProperty?: string;\n\t};\n\nexport type ExtensionForAnalytics = PropertyInfo[\"extension\"] & {\n\tadditionalProperties?: string[];\n};\n\nexport type TableColumn = CustomBasedTableColumn | AnnotationTableColumn | ComputedTableColumn;\n\ntype ManifestColumn = CustomElement<CustomBasedTableColumn | AnnotationTableColumnForOverride>;\n\nexport enum ColumnType {\n\tDefault = \"Default\", // Default Type (Custom Column)\n\tAnnotation = \"Annotation\",\n\tSlot = \"Slot\",\n\tComputed = \"Computed\"\n}\n/**\n * Returns an array of all columns, annotation-based as well as manifest-based.\n * They are sorted and some properties can be overwritten via the manifest (check out the keys that can be overwritten).\n * @param lineItemAnnotation Collection of data fields for representation in a table or list\n * @param tableType The type of the table\n * @param visualizationPath\n * @param converterContext\n * @returns Returns all table columns that should be available, regardless of templating or personalization or their origin\n */\nexport function getTableColumns(\n\tlineItemAnnotation: LineItem,\n\ttableType: TableType,\n\tvisualizationPath: string,\n\tconverterContext: ConverterContext<PageContextPathTarget>\n): TableColumn[] {\n\tconst annotationColumns = getColumnsFromAnnotations(lineItemAnnotation, tableType, visualizationPath, converterContext);\n\tconst manifestColumns = getColumnsFromManifest(\n\t\tconverterContext.getManifestControlConfiguration<TableManifestConfiguration>(visualizationPath).columns ?? {},\n\t\tannotationColumns,\n\t\tconverterContext,\n\t\tconverterContext.getAnnotationEntityType(lineItemAnnotation)\n\t);\n\n\tconst tableColumns: TableColumn[] = insertCustomElements(\n\t\tannotationColumns as TableColumn[],\n\t\tmanifestColumns as Record<string, CustomElement<TableColumn>>,\n\t\t{\n\t\t\twidth: OverrideType.overwrite,\n\t\t\twidthIncludingColumnHeader: OverrideType.overwrite,\n\t\t\timportance: OverrideType.overwrite,\n\t\t\thorizontalAlign: OverrideType.overwrite,\n\t\t\tavailability: OverrideType.overwrite,\n\t\t\tisNavigable: OverrideType.overwrite,\n\t\t\tsettings: OverrideType.overwrite,\n\t\t\tformatOptions: OverrideType.overwrite,\n\t\t\texportSettings: OverrideType.overwrite\n\t\t}\n\t);\n\n\treturn addComputedColumns(tableColumns, tableType, visualizationPath, converterContext);\n}\n\nexport function findColumnByPath(path: string, tableColumns: TableColumn[]): TableColumn | undefined {\n\treturn tableColumns.find((column) => {\n\t\tconst annotationColumn = column as AnnotationTableColumn;\n\t\treturn annotationColumn.propertyInfos === undefined && annotationColumn.relativePath === path;\n\t});\n}\n\n/**\n * Sets the 'unit', 'textArrangement', 'timezone' and 'exportsettings' properties in columns when necessary.\n * @param converterContext The instance of the converter context\n * @param tableColumns The columns to be updated\n */\nexport function updateLinkedProperties(converterContext: ConverterContext, tableColumns: TableColumn[]): void {\n\tconst dataModelObjectPath = converterContext.getConverterContextFor(converterContext.getContextPath()).getDataModelObjectPath();\n\ttableColumns.forEach((oColumn) => {\n\t\tconst tableColumn = oColumn as AnnotationTableColumn;\n\t\tif (tableColumn.propertyInfos === undefined && tableColumn.relativePath) {\n\t\t\tconst propertyDataModelObjectPath = enhanceDataModelPath<Property>(dataModelObjectPath, tableColumn.relativePath);\n\t\t\tconst property = propertyDataModelObjectPath.targetObject;\n\t\t\tif (property) {\n\t\t\t\taddCurrencyOrUoMToProperty(property, propertyDataModelObjectPath, tableColumns, tableColumn);\n\t\t\t\tconst timezoneProperty = getAssociatedTimezoneProperty(property);\n\t\t\t\tconst timezone = property?.annotations?.Common?.Timezone;\n\t\t\t\tif (timezoneProperty) {\n\t\t\t\t\tconst oTimezoneColumn = findColumnByPath(timezoneProperty.name, tableColumns);\n\t\t\t\t\ttableColumn.timezone = oTimezoneColumn?.name;\n\t\t\t\t} else if (timezone) {\n\t\t\t\t\ttableColumn.timezoneText = timezone.toString();\n\t\t\t\t}\n\t\t\t\taddTextArrangentInfoToProperty(property, propertyDataModelObjectPath, tableColumns, tableColumn);\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * Adds the \"unit\" property into the columns when neccesary for columns with unit of measure and currencies.\n * @param property The property referenced on the column\n * @param propertyDataModelObjectPath The property DataModelObjectPath.\n * @param tableColumns The list of columns displayed on the table\n * @param tableColumn The table column which adds the currency or unit\n */\nfunction addCurrencyOrUoMToProperty(\n\tproperty: Property,\n\tpropertyDataModelObjectPath: DataModelObjectPath<Property>,\n\ttableColumns: TableColumn[],\n\ttableColumn: AnnotationTableColumn\n): void {\n\tconst currencyOrUoMProperty = getAssociatedCurrencyPropertyPath(property) || getAssociatedUnitPropertyPath(property);\n\tif (currencyOrUoMProperty) {\n\t\tconst currencyOrUoMPropertyDataModelObjectPath = enhanceDataModelPath<Property>(propertyDataModelObjectPath, currencyOrUoMProperty);\n\t\tconst currencyOrUoMRelativePath = getContextRelativeTargetObjectPath(currencyOrUoMPropertyDataModelObjectPath);\n\t\tif (currencyOrUoMRelativePath) {\n\t\t\tconst unitColumn = findColumnByPath(currencyOrUoMRelativePath, tableColumns);\n\t\t\ttableColumn.unit = unitColumn?.name;\n\t\t}\n\t} else {\n\t\tconst unit = property?.annotations?.Measures?.ISOCurrency || property?.annotations?.Measures?.Unit;\n\t\tif (unit) {\n\t\t\ttableColumn.unitText = `${unit}`;\n\t\t}\n\t}\n}\n\n/**\n * Add the \"textArrangement\" object to columns when necessary for columns containing text, such as descriptions.\n * @param property The property referenced by the column\n * @param propertyDataModelObjectPath The property DataModelObjectPath.\n * @param tableColumns The list of columns displayed on the table\n * @param tableColumn The table column which adds the text\n */\nfunction addTextArrangentInfoToProperty(\n\tproperty: Property,\n\tpropertyDataModelObjectPath: DataModelObjectPath<Property>,\n\ttableColumns: TableColumn[],\n\ttableColumn: AnnotationTableColumn\n): void {\n\tconst displayMode = getDisplayMode(property),\n\t\ttextPropertyPath = getAssociatedTextPropertyPath(property);\n\tif (textPropertyPath && displayMode !== \"Value\") {\n\t\tconst textPropertyDataModelObjectPath = enhanceDataModelPath<Property>(propertyDataModelObjectPath, textPropertyPath);\n\t\tconst textRelativePath = getContextRelativeTargetObjectPath(textPropertyDataModelObjectPath);\n\t\tif (textRelativePath) {\n\t\t\tconst textColumn = findColumnByPath(textRelativePath, tableColumns);\n\t\t\tif (textColumn && textColumn.name !== tableColumn.name) {\n\t\t\t\ttableColumn.textArrangement = {\n\t\t\t\t\ttextProperty: textColumn.name,\n\t\t\t\t\tmode: displayMode\n\t\t\t\t};\n\t\t\t\t// If text properties are used but hidden, we must include them to the export as there are used in the paste\n\t\t\t\tif (!textColumn.exportSettings) {\n\t\t\t\t\ttextColumn.exportSettings = { type: \"String\" };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Retrieve the columns from the entityType.\n * @param columnsToBeCreated The columns to be created.\n * @param entityType The target entity type.\n * @param annotationColumns The array of columns created based on LineItem annotations.\n * @param converterContext The converter context.\n * @param tableType The table type.\n * @param tableCreationMode The creation mode of the table.\n * @param displayModeOfDescriptionPropertiesMap The map of properties referenced as description on a text arrangement annotation.\n * @param restrictionsOnProperties The existing restrictions on properties\n * @returns The column from the entityType\n */\nexport const getColumnsFromEntityType = function (\n\tcolumnsToBeCreated: Record<string, Property>,\n\tentityType: EntityType,\n\tannotationColumns: AnnotationTableColumn[],\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\ttableType: TableType,\n\ttableCreationMode: CreationMode,\n\tdisplayModeOfDescriptionPropertiesMap: Record<string, DisplayMode>,\n\trestrictionsOnProperties?: RestrictionsOnProperties\n): AnnotationTableColumn[] {\n\tif (annotationColumns === undefined) {\n\t\tannotationColumns = [];\n\t}\n\n\tlet propertiesNotToBeConsidered: string[] = [];\n\tconst aggregationHelper = new AggregationHelper(entityType, converterContext);\n\tconst groupableProperties = aggregationHelper.getGroupableProperties();\n\t//For Analytical table, we exclude all properties that are not groupable and used as Text in a groupable Property.\n\tif (tableType === \"AnalyticalTable\" && aggregationHelper.isAnalyticsSupported() && groupableProperties) {\n\t\tpropertiesNotToBeConsidered = groupableProperties\n\t\t\t.map((property) => property.$target)\n\t\t\t.filter((target) => target !== undefined)\n\t\t\t.map((target) => getAssociatedTextProperty(target as Property))\n\t\t\t.filter((textProp) => textProp && !aggregationHelper.isPropertyGroupable(textProp))\n\t\t\t.map((prop) => prop?.name)\n\t\t\t.filter((name) => name !== undefined) as string[];\n\t}\n\tentityType.entityProperties.forEach((property: Property) => {\n\t\t// Catch already existing columns - which were added before by LineItem Annotations\n\t\tconst exists = annotationColumns.some((column) => {\n\t\t\treturn column.name === property.name;\n\t\t});\n\t\t// if target type exists, it is a complex property and should be ignored\n\t\tif (!property.targetType && !exists && !propertiesNotToBeConsidered.includes(property.name)) {\n\t\t\tconst relatedPropertiesInfo: ComplexPropertyInfo = collectRelatedProperties(\n\t\t\t\tproperty.name,\n\t\t\t\tproperty,\n\t\t\t\tconverterContext,\n\t\t\t\ttrue,\n\t\t\t\ttableType\n\t\t\t);\n\t\t\tconst relatedPropertyNames: string[] = Object.keys(relatedPropertiesInfo.properties);\n\t\t\tconst additionalPropertyNames: string[] = Object.keys(relatedPropertiesInfo.additionalProperties);\n\t\t\t// Include the text properties and their corresponding text arrangement\n\t\t\trelatedPropertyNames.forEach((name) => {\n\t\t\t\taddPropertyToDisplayModeOfDescriptionPropertiesMap(displayModeOfDescriptionPropertiesMap, relatedPropertiesInfo, name);\n\t\t\t});\n\n\t\t\tconst columnInfo = getColumnDefinitionFromProperty(\n\t\t\t\tproperty,\n\t\t\t\tconverterContext.getEntitySetBasedAnnotationPath(property.fullyQualifiedName),\n\t\t\t\tproperty.name,\n\t\t\t\ttrue,\n\t\t\t\ttrue,\n\t\t\t\taggregationHelper,\n\t\t\t\tconverterContext,\n\t\t\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\t\t\ttableType,\n\t\t\t\trestrictionsOnProperties,\n\t\t\t\ttableCreationMode,\n\t\t\t\trelatedPropertiesInfo\n\t\t\t);\n\t\t\tif (relatedPropertyNames.length > 0) {\n\t\t\t\tcolumnInfo.propertyInfos = relatedPropertyNames;\n\t\t\t\tif (relatedPropertiesInfo.exportSettings.dataPointTargetValue) {\n\t\t\t\t\tcolumnInfo.exportDataPointTargetValue = relatedPropertiesInfo.exportSettings.dataPointTargetValue;\n\t\t\t\t}\n\t\t\t\t// Collect information of related columns to be created.\n\t\t\t\trelatedPropertyNames.forEach((name) => {\n\t\t\t\t\tcolumnsToBeCreated[name] = relatedPropertiesInfo.properties[name].annotationProperty;\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (additionalPropertyNames.length > 0) {\n\t\t\t\tcolumnInfo.additionalPropertyInfos = additionalPropertyNames;\n\t\t\t\t// Create columns for additional properties identified for ALP use case.\n\t\t\t\tadditionalPropertyNames.forEach((additionalPropertyName) => {\n\t\t\t\t\t// Intentional overwrite as we require only one new PropertyInfo for a related Property.\n\t\t\t\t\tcolumnsToBeCreated[additionalPropertyName] = relatedPropertiesInfo.additionalProperties[additionalPropertyName];\n\t\t\t\t});\n\t\t\t}\n\t\t\tannotationColumns.push(columnInfo);\n\t\t}\n\t\t// In case a property has defined a #TextOnly text arrangement that points to a text property (and not a 'hard coded text') don't only create the complex property with the text property as a child property,\n\t\t// but also the property itself as it can be used as within the sortConditions or on custom columns.\n\t\t// This step must be valid also from the columns added via LineItems or from a column available on the p13n.\n\t\tif (getDisplayMode(property) === \"Description\") {\n\t\t\trestrictionsOnProperties?.nonSortableProperties.push(property.name);\n\t\t\tif (isPathAnnotationExpression(property?.annotations?.Common?.Text)) {\n\t\t\t\tannotationColumns.push(\n\t\t\t\t\tgetColumnDefinitionFromProperty(\n\t\t\t\t\t\tproperty,\n\t\t\t\t\t\tconverterContext.getEntitySetBasedAnnotationPath(property.fullyQualifiedName),\n\t\t\t\t\t\tproperty.name,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\taggregationHelper,\n\t\t\t\t\t\tconverterContext,\n\t\t\t\t\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\t\t\t\t\ttableType,\n\t\t\t\t\t\trestrictionsOnProperties,\n\t\t\t\t\t\ttableCreationMode\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t});\n\t// Create a propertyInfo for each related property.\n\tconst relatedColumns = _createRelatedColumns(\n\t\tcolumnsToBeCreated,\n\t\tannotationColumns,\n\t\tconverterContext,\n\t\tentityType,\n\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\ttableType,\n\t\ttableCreationMode,\n\t\trestrictionsOnProperties\n\t);\n\treturn annotationColumns.concat(relatedColumns);\n};\n\n/**\n * Create a column definition from a property.\n * @param property Entity type property for which the column is created\n * @param fullPropertyPath The full path to the target property\n * @param relativePath The relative path to the target property based on the context\n * @param useDataFieldPrefix Should be prefixed with \"DataField::\", else it will be prefixed with \"Property::\"\n * @param availableForAdaptation Decides whether the column should be available for adaptation\n * @param aggregationHelper The aggregationHelper for the entity\n * @param converterContext The converter context\n * @param displayModeOfDescriptionPropertiesMap The map of properties referenced as description on a text arrangement annotation\n * @param restrictionsOnProperties The existing restrictions on properties\n * @param tableCreationMode The creation mode of the table\n * @param relatedPropertiesInfo The properties identified so far for the column\n * @param relativePathForMultiValue The MDC path used for the 1:n property to allow filtering from MDC\n * @returns The annotation column definition\n */\nconst getColumnDefinitionFromProperty = function (\n\tproperty: Property,\n\tfullPropertyPath: string,\n\trelativePath: string,\n\tuseDataFieldPrefix: boolean,\n\tavailableForAdaptation: boolean,\n\taggregationHelper: AggregationHelper,\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tdisplayModeOfDescriptionPropertiesMap: Record<string, DisplayMode>,\n\ttableType?: TableType,\n\trestrictionsOnProperties?: RestrictionsOnProperties,\n\ttableCreationMode?: CreationMode,\n\trelatedPropertiesInfo?: ComplexPropertyInfo,\n\trelativePathForMultiValue?: string\n): AnnotationTableColumn {\n\tconst semanticObjectAnnotationPath = getSemanticObjectPath(converterContext, property);\n\tconst isHidden = isReferencePropertyStaticallyHidden(property);\n\tconst groupPath: string | undefined = property.name ? _sliceAtSlash(property.name, true, false) : undefined;\n\tconst isGroup: boolean = groupPath != property.name;\n\tconst label = getLabel(property, isGroup);\n\tconst dataType = getDataFieldDataType(property);\n\tconst propertyTypeConfig = getTypeConfig(property, dataType);\n\tconst isAPropertyFromTextOnlyAnnotation = displayModeOfDescriptionPropertiesMap[relativePath] === \"Description\";\n\tconst sortable =\n\t\t(!isHidden || isAPropertyFromTextOnlyAnnotation) && !restrictionsOnProperties?.nonSortableProperties.includes(relativePath);\n\tconst filterable = !restrictionsOnProperties?.nonFilterableProperties.includes(relativePath);\n\tconst groupable =\n\t\taggregationHelper.isAnalyticsSupported() && tableType === \"AnalyticalTable\"\n\t\t\t? !!aggregationHelper.isPropertyGroupable(property)\n\t\t\t: sortable;\n\tconst typeConfig = {\n\t\tclassName: property.type || dataType,\n\t\tformatOptions: propertyTypeConfig.formatOptions,\n\t\tconstraints: propertyTypeConfig.constraints\n\t};\n\tlet exportSettings: PropertyInfo[\"exportSettings\"] = null;\n\tif (_isExportableColumn(property)) {\n\t\texportSettings = createColumnExportSettings(property, relatedPropertiesInfo);\n\t}\n\tconst availability = !isHidden && availableForAdaptation ? \"Adaptation\" : \"Hidden\";\n\tconst collectedNavigationPropertyLabels: string[] | undefined = _getCollectedNavigationPropertyLabels(relativePath, converterContext);\n\tif (relativePathForMultiValue) {\n\t\trelativePath = relativePathForMultiValue;\n\t}\n\tconst name = useDataFieldPrefix ? relativePath : `Property::${relativePath}`;\n\tconst key = (useDataFieldPrefix ? \"DataField::\" : \"Property::\") + replaceSpecialChars(relativePath);\n\n\tconst column: AnnotationTableColumn = {\n\t\tkey: key,\n\t\ttype: ColumnType.Annotation,\n\t\tdataType: dataType ?? property.type,\n\t\tlabel: label ?? property.name,\n\t\tgroupLabel: isGroup ? getLabel(property) : undefined,\n\t\tgroup: isGroup ? groupPath : undefined,\n\t\tannotationPath: fullPropertyPath,\n\t\tsemanticObjectPath: semanticObjectAnnotationPath,\n\t\tavailability: availability,\n\t\tname: name,\n\t\trelativePath: relativePath,\n\t\tsortable: sortable,\n\t\tfilterable: filterable,\n\t\tisGroupable: groupable,\n\t\tisKey: property.isKey,\n\t\texportSettings: exportSettings,\n\t\tcaseSensitive: isFilteringCaseSensitive(converterContext),\n\t\ttypeConfig: typeConfig as PropertyTypeConfig,\n\t\timportance: getImportance(converterContext, property.annotations?.UI?.DataFieldDefault),\n\t\trequired: isRequiredColumn(converterContext, property, tableCreationMode),\n\t\tadditionalLabels: collectedNavigationPropertyLabels\n\t};\n\t_addToolTip(property, column);\n\t_setExportSettingsForDataPoint(property, column);\n\n\tif (\n\t\taggregationHelper.isAnalyticsSupported() &&\n\t\tModelHelper.isObjectPathDraftSupported(converterContext.getDataModelObjectPath()) &&\n\t\t(relativePath === \"HasActiveEntity\" || relativePath === \"HasDraftEntity\" || relativePath === \"IsActiveEntity\")\n\t) {\n\t\t// In case of analytical table on a draft-enabled entity, we always consider the HasDraftEntity, HasActiveEntity and IsActiveEntity properties as\n\t\t// technically groupable, as we need to load them for our internal logic.\n\t\tcolumn.extension = {\n\t\t\ttechnicallyAggregatable: false,\n\t\t\ttechnicallyGroupable: true\n\t\t};\n\t}\n\treturn column;\n};\n\n/**\n * Create the export settings for a given column.\n * @param column The given column from a line item as a data field or a property from the entity type\n * @param relatedPropertiesInfo The related properties linked to the column (named also complex property)\n * @returns The export settings in a the given column\n */\nconst createColumnExportSettings = function (\n\tcolumn: Property | DataFieldAbstractTypes,\n\trelatedPropertiesInfo?: ComplexPropertyInfo\n): ColumnExportSettings {\n\tlet unitProperty, timezoneProperty, unitText, timezoneText, utc, isATimezone, currencyProperty, scale;\n\tconst relatedPropertyNames = relatedPropertiesInfo ? Object.keys(relatedPropertiesInfo.properties) : [];\n\tif (relatedPropertiesInfo && relatedPropertyNames?.length === 1) {\n\t\t// Create the export settings of a column based on the related (child) property in case there is only one.\n\t\t// This is required when we have a text only annotation to compute the export settings from the text instead of the value\n\t\tcolumn = relatedPropertiesInfo.properties[relatedPropertyNames[0]].annotationProperty;\n\t}\n\tconst dataType = getDataFieldDataType(column);\n\tif (isProperty(column)) {\n\t\tunitProperty = getAssociatedUnitProperty(column);\n\t\tcurrencyProperty = getAssociatedCurrencyProperty(column);\n\t\ttimezoneProperty = getAssociatedTimezoneProperty(column);\n\t\tunitText = getStaticUnitOrCurrency(column);\n\t\ttimezoneText = getStaticTimezone(column);\n\t\tisATimezone = isTimezone(column);\n\t\tscale = column.scale;\n\t}\n\tunitProperty = relatedPropertiesInfo?.exportSettings?.unitProperty ?? unitProperty?.name ?? currencyProperty?.name;\n\ttimezoneProperty = relatedPropertiesInfo?.exportSettings?.timezoneProperty ?? timezoneProperty?.name;\n\tscale = relatedPropertiesInfo?.exportSettings?.scale ?? scale;\n\tconst exportType = getExportDataType(dataType, isATimezone, !!currencyProperty, relatedPropertiesInfo?.exportSettings);\n\tif (timezoneProperty || (exportType === \"DateTime\" && !timezoneText)) {\n\t\tutc = false;\n\t}\n\tconst exportSettings: ColumnExportSettings = {\n\t\ttype: exportType,\n\t\tinputFormat: getDateInputFormat(dataType),\n\t\tdelimiter: getDelimiter(dataType),\n\t\tscale: scale,\n\t\tunitProperty: unitProperty,\n\t\tunit: relatedPropertiesInfo?.exportSettings.unit ?? unitText,\n\t\ttimezoneProperty: timezoneProperty,\n\t\ttimezone: relatedPropertiesInfo?.exportSettings.timezone ?? timezoneText?.toString(),\n\t\ttemplate: relatedPropertiesInfo?.exportSettings.template,\n\t\t//only in case of complex properties, wrap the cell content\ton the excel exported file\n\t\twrap: relatedPropertiesInfo?.exportSettings.wrap,\n\t\tutc: utc,\n\t\tproperty: relatedPropertiesInfo?.exportSettings.property\n\t};\n\tif (exportSettings.unitProperty || exportSettings.unit) {\n\t\texportSettings.autoScale = true;\n\t}\n\treturn removeUndefinedFromExportSettings(exportSettings);\n};\n\n/**\n * Gets the export format template for columns with dates.\n * @param dataType The data type of the column\n * @returns The inputFormat\n */\nconst getDateInputFormat = function (dataType?: string): string | undefined {\n\treturn dataType === \"Edm.Date\" ? \"YYYY-MM-DD\" : undefined;\n};\n\n/**\n * Gets the delimiter in numeric columns.\n * The delimiter is used to display thousands separator in numeric columns.\n * @param dataType The data type of the column\n * @returns True to display thousands separator in numeric columns\n */\nconst getDelimiter = function (dataType?: string): boolean | undefined {\n\treturn dataType === \"Edm.Int64\" ? true : undefined;\n};\n\n/**\n * Removes undefined values from the export settings object of a column.\n * @param exportSettings The export settings configurations for a column\n * @returns The export settings configurations without undefined values\n */\nconst removeUndefinedFromExportSettings = function (exportSettings: ColumnExportSettings): ColumnExportSettings {\n\t//Remove undefined settings from exportSetting object\n\tfor (const setting in exportSettings) {\n\t\tif (exportSettings[setting as keyof ColumnExportSettings] === undefined) {\n\t\t\tdelete exportSettings[setting as keyof ColumnExportSettings];\n\t\t}\n\t}\n\treturn exportSettings;\n};\n\n/**\n * Returns Boolean true for exportable columns, false for non exportable columns.\n * @param source The dataField or property to be evaluated\n * @returns True for exportable column, false for non exportable column\n */\nfunction _isExportableColumn(source: DataFieldAbstractTypes | Property): boolean {\n\tlet propertyType, property;\n\tconst dataFieldDefaultProperty = (source as Property).annotations.UI?.DataFieldDefault;\n\tif (isProperty(source)) {\n\t\tif (isReferencePropertyStaticallyHidden(source)) {\n\t\t\treturn false;\n\t\t}\n\t\tpropertyType = dataFieldDefaultProperty?.$Type;\n\t} else if (isReferencePropertyStaticallyHidden(source)) {\n\t\treturn false;\n\t} else {\n\t\tproperty = source;\n\t\tpropertyType = property.$Type;\n\t\tif (propertyType === UIAnnotationTypes.DataFieldForAnnotation && (property as DataFieldForAnnotation).Target?.$target?.$Type) {\n\t\t\t//For Chart\n\t\t\tpropertyType = (property as DataFieldForAnnotation).Target?.$target?.$Type;\n\t\t\treturn propertyType !== undefined && !UIAnnotationTypes.ChartDefinitionType.includes(propertyType);\n\t\t} else if (\n\t\t\t(property as DataField).Value?.$target?.annotations?.Core?.MediaType?.term === \"Org.OData.Core.V1.MediaType\" &&\n\t\t\t(property as DataField).Value?.$target?.annotations?.Core?.isURL !== true\n\t\t) {\n\t\t\t//For Stream\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn propertyType\n\t\t? ![\n\t\t\t\tUIAnnotationTypes.DataFieldForAction,\n\t\t\t\tUIAnnotationTypes.DataFieldForIntentBasedNavigation,\n\t\t\t\tUIAnnotationTypes.DataFieldForActionGroup\n\t\t  ].includes(propertyType)\n\t\t: true;\n}\n\n/**\n * Returns Boolean true for valid columns, false for invalid columns.\n * @param dataField Different DataField types defined in the annotations\n * @returns True for valid columns, false for invalid columns\n */\nconst _isValidColumn = function (dataField: DataFieldAbstractTypes): boolean {\n\tswitch (dataField.$Type) {\n\t\tcase UIAnnotationTypes.DataFieldForAction:\n\t\tcase UIAnnotationTypes.DataFieldForIntentBasedNavigation:\n\t\t\treturn !!dataField.Inline;\n\t\tcase UIAnnotationTypes.DataFieldWithAction:\n\t\tcase UIAnnotationTypes.DataFieldWithIntentBasedNavigation:\n\t\tcase UIAnnotationTypes.DataField:\n\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\t// Todo: Replace with proper Log statement once available\n\t\t\t//  throw new Error(\"Unhandled DataField Abstract type: \" + dataField.$Type);\n\t\t\treturn false;\n\t}\n};\n\n/**\n * Returns the binding expression to evaluate the visibility of a DataField or DataPoint annotation.\n *\n * SAP Fiori elements will evaluate either the UI.Hidden annotation defined on the annotation itself or on the target property.\n * @param dataFieldModelPath The metapath referring to the annotation that is evaluated by SAP Fiori elements.\n * @returns An expression that you can bind to the UI.\n */\nconst _getVisibleExpression = function (\n\tdataFieldModelPath: DataModelObjectPath<DataFieldAbstractTypes | DataPointTypeTypes>\n): BindingToolkitExpression<boolean> {\n\tconst targetObject = dataFieldModelPath.targetObject;\n\tlet propertyValue;\n\tif (targetObject) {\n\t\tswitch (targetObject.$Type) {\n\t\t\tcase UIAnnotationTypes.DataField:\n\t\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\t\tcase UIAnnotationTypes.DataFieldWithIntentBasedNavigation:\n\t\t\tcase UIAnnotationTypes.DataFieldWithAction:\n\t\t\tcase UIAnnotationTypes.DataPointType:\n\t\t\t\tpropertyValue = targetObject.Value.$target;\n\t\t\t\tbreak;\n\t\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\t\t\t// if it is a DataFieldForAnnotation pointing to a DataPoint we look at the dataPoint's value\n\t\t\t\tif (targetObject?.Target?.$target?.$Type === UIAnnotationTypes.DataPointType) {\n\t\t\t\t\tpropertyValue = targetObject.Target.$target?.Value.$target;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UIAnnotationTypes.DataFieldForIntentBasedNavigation:\n\t\t\tcase UIAnnotationTypes.DataFieldForAction:\n\t\t\tdefault:\n\t\t\t\tpropertyValue = undefined;\n\t\t}\n\t}\n\tconst isAnalyticalGroupHeaderExpanded = /*formatOptions?.isAnalytics ? UI.IsExpanded :*/ constant(false);\n\tconst isAnalyticalLeaf = /*formatOptions?.isAnalytics ? equal(UI.NodeLevel, 0) :*/ constant(false);\n\t// A data field is visible if:\n\t// - the UI.Hidden expression in the original annotation does not evaluate to 'true'\n\t// - the UI.Hidden expression in the target property does not evaluate to 'true'\n\t// - in case of Analytics it's not visible for an expanded GroupHeader\n\treturn and(\n\t\t...[\n\t\t\tnot(equal(getExpressionFromAnnotation(targetObject?.annotations?.UI?.Hidden), true)),\n\t\t\tifElse(\n\t\t\t\t!!propertyValue,\n\t\t\t\tpropertyValue && not(equal(getExpressionFromAnnotation(propertyValue.annotations?.UI?.Hidden), true)),\n\t\t\t\ttrue\n\t\t\t),\n\t\t\tor(not(isAnalyticalGroupHeaderExpanded), isAnalyticalLeaf)\n\t\t]\n\t);\n};\n\n/**\n * Returns hidden binding expressions for a field group.\n * @param dataFieldGroup DataField defined in the annotations\n * @returns Compile binding of field group expressions.\n */\nconst _getFieldGroupHiddenExpressions = function (dataFieldGroup: DataFieldAbstractTypes): CompiledBindingToolkitExpression | undefined {\n\tconst fieldGroupHiddenExpressions: BindingToolkitExpression<boolean>[] = [];\n\tif (\n\t\tdataFieldGroup.$Type === UIAnnotationTypes.DataFieldForAnnotation &&\n\t\tdataFieldGroup.Target?.$target?.$Type === UIAnnotationTypes.FieldGroupType\n\t) {\n\t\tif (dataFieldGroup?.annotations?.UI?.Hidden) {\n\t\t\treturn compileExpression(not(equal(getExpressionFromAnnotation(dataFieldGroup.annotations.UI.Hidden), true)));\n\t\t} else {\n\t\t\tdataFieldGroup.Target.$target.Data?.forEach((innerDataField: DataFieldAbstractTypes | DataPointTypeTypes) => {\n\t\t\t\tfieldGroupHiddenExpressions.push(\n\t\t\t\t\t_getVisibleExpression({ targetObject: innerDataField } as DataModelObjectPath<\n\t\t\t\t\t\tDataFieldAbstractTypes | DataPointTypeTypes\n\t\t\t\t\t>)\n\t\t\t\t);\n\t\t\t});\n\t\t\treturn compileExpression(ifElse(or(...fieldGroupHiddenExpressions), constant(true), constant(false)));\n\t\t}\n\t} else {\n\t\treturn undefined;\n\t}\n};\n\n/**\n * Returns the label for the property and dataField.\n * @param [property] Property, DataField or Navigation Property defined in the annotations\n * @param isGroup\n * @returns Label of the property or DataField\n */\nconst getLabel = function (property: DataFieldAbstractTypes | Property | NavigationProperty, isGroup = false): string | undefined {\n\tif (!property) {\n\t\treturn undefined;\n\t}\n\tif (isProperty(property) || isNavigationProperty(property)) {\n\t\tconst dataFieldDefault = (property as Property).annotations?.UI?.DataFieldDefault;\n\t\tif (dataFieldDefault && !dataFieldDefault.qualifier && dataFieldDefault.Label) {\n\t\t\treturn dataFieldDefault.Label?.toString();\n\t\t}\n\t\treturn property.annotations.Common?.Label?.toString() ?? property.name;\n\t} else if (isDataFieldTypes(property)) {\n\t\tif (!!isGroup && property.$Type === UIAnnotationTypes.DataFieldWithIntentBasedNavigation) {\n\t\t\treturn property?.Label?.toString();\n\t\t}\n\t\treturn (\n\t\t\tproperty?.Label?.toString() ??\n\t\t\tcompileExpression(\n\t\t\t\tgetExpressionFromAnnotation(property.Value?.$target?.annotations?.Common?.Label, [], property.Value?.$target?.name)\n\t\t\t)\n\t\t);\n\t} else if (property.$Type === UIAnnotationTypes.DataFieldForAnnotation) {\n\t\treturn (\n\t\t\tproperty.Label?.toString() ??\n\t\t\tcompileExpression(\n\t\t\t\tgetExpressionFromAnnotation((property.Target?.$target as DataPoint)?.Value?.$target?.annotations?.Common?.Label?.valueOf())\n\t\t\t)\n\t\t);\n\t} else {\n\t\treturn property.Label?.toString();\n\t}\n};\n\nconst _getTooltip = function (source: DataFieldAbstractTypes | Property): string | undefined {\n\tif (!source) {\n\t\treturn undefined;\n\t}\n\tif (isProperty(source) || source.annotations?.Common?.QuickInfo) {\n\t\treturn source.annotations?.Common?.QuickInfo\n\t\t\t? compileExpression(getExpressionFromAnnotation(source.annotations.Common.QuickInfo))\n\t\t\t: undefined;\n\t} else if (isDataFieldTypes(source)) {\n\t\treturn source.Value?.$target?.annotations?.Common?.QuickInfo\n\t\t\t? compileExpression(getExpressionFromAnnotation(source.Value.$target.annotations.Common.QuickInfo))\n\t\t\t: undefined;\n\t} else if (source.$Type === UIAnnotationTypes.DataFieldForAnnotation) {\n\t\tconst datapointTarget = source.Target?.$target as DataPoint;\n\t\treturn datapointTarget?.Value?.$target?.annotations?.Common?.QuickInfo\n\t\t\t? compileExpression(getExpressionFromAnnotation(datapointTarget.Value.$target.annotations.Common.QuickInfo))\n\t\t\t: undefined;\n\t} else {\n\t\treturn undefined;\n\t}\n};\n\nexport function getRowStatusVisibility(colName: string, isSemanticKeyInFieldGroup?: boolean): BindingToolkitExpression<boolean> {\n\treturn formatResult(\n\t\t[\n\t\t\tpathInModel(`semanticKeyHasDraftIndicator`, \"internal\"),\n\t\t\tpathInModel(`filteredMessages`, \"internal\"),\n\t\t\tcolName,\n\t\t\tisSemanticKeyInFieldGroup\n\t\t],\n\t\ttableFormatters.getErrorStatusTextVisibilityFormatter\n\t);\n}\n\n/**\n * Creates a PropertyInfo for each identified property consumed by a LineItem.\n * @param columnsToBeCreated Identified properties.\n * @param existingColumns The list of columns created for LineItems and Properties of entityType.\n * @param converterContext The converter context.\n * @param entityType The entity type for the LineItem\n * @param displayModeOfDescriptionPropertiesMap The map of properties referenced as text on a text arrangement annotation.\n * @param tableCreationMode The creation mode of the table\n * @param restrictionsOnProperties The existing restrictions on properties\n * @returns The array of columns created.\n */\nconst _createRelatedColumns = function (\n\tcolumnsToBeCreated: Record<string, Property>,\n\texistingColumns: AnnotationTableColumn[],\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tentityType: EntityType,\n\tdisplayModeOfDescriptionPropertiesMap: Record<string, DisplayMode>,\n\ttableType?: TableType,\n\ttableCreationMode?: CreationMode,\n\trestrictionsOnProperties?: RestrictionsOnProperties\n): AnnotationTableColumn[] {\n\tconst relatedColumns: AnnotationTableColumn[] = [];\n\tconst relatedPropertyNameMap: Record<string, string> = {};\n\tconst aggregationHelper = new AggregationHelper(entityType, converterContext);\n\tObject.keys(columnsToBeCreated).forEach((name) => {\n\t\tconst property = columnsToBeCreated[name],\n\t\t\tannotationPath = converterContext.getAbsoluteAnnotationPath(name),\n\t\t\t// Check whether the related column already exists.\n\t\t\trelatedColumn = existingColumns.find((column) => column.name === name);\n\t\tconst dataModelObjectPath = converterContext.getConverterContextFor(converterContext.getContextPath()).getDataModelObjectPath();\n\t\tconst propertyObjectPath = enhanceDataModelPath<PageContextPathTarget>(dataModelObjectPath, name);\n\t\tif (isMultiValueField(propertyObjectPath)) {\n\t\t\tconst newNameRelativeTargetPath = getContextRelativeTargetObjectPath(propertyObjectPath, false, true);\n\t\t\tconst column = getColumnDefinitionFromProperty(\n\t\t\t\tproperty,\n\t\t\t\tannotationPath,\n\t\t\t\tname,\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t\taggregationHelper,\n\t\t\t\tconverterContext,\n\t\t\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\t\t\ttableType,\n\t\t\t\trestrictionsOnProperties,\n\t\t\t\ttableCreationMode,\n\t\t\t\tundefined,\n\t\t\t\tnewNameRelativeTargetPath\n\t\t\t);\n\t\t\tcomputeHiddenOnRelatedColumns(existingColumns, name, column);\n\t\t\trelatedColumns.push(column);\n\t\t\trelatedPropertyNameMap[name] = newNameRelativeTargetPath ?? name;\n\t\t} else if (relatedColumn === undefined) {\n\t\t\t// Case 1: Key contains DataField prefix to ensure all property columns have the same key format.\n\t\t\t// New created property column is set to hidden.\n\t\t\tconst column = getColumnDefinitionFromProperty(\n\t\t\t\tproperty,\n\t\t\t\tannotationPath,\n\t\t\t\tname,\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t\taggregationHelper,\n\t\t\t\tconverterContext,\n\t\t\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\t\t\ttableType,\n\t\t\t\trestrictionsOnProperties,\n\t\t\t\ttableCreationMode\n\t\t\t);\n\t\t\tcomputeHiddenOnRelatedColumns(existingColumns, name, column);\n\t\t\trelatedColumns.push(column);\n\t\t} else if (relatedColumn.annotationPath !== annotationPath || relatedColumn.propertyInfos) {\n\t\t\t// Case 2: The existing column points to a LineItem (or)\n\t\t\t// Case 3: This is a self reference from an existing column\n\t\t\tconst newName = `Property::${name}`;\n\t\t\t// Checking whether the related property column has already been created in a previous iteration.\n\t\t\tif (!existingColumns.some((column) => column.name === newName)) {\n\t\t\t\t// Create a new property column with 'Property::' prefix,\n\t\t\t\t// Set it to hidden as it is only consumed by Complex property infos.\n\t\t\t\tconst column = getColumnDefinitionFromProperty(\n\t\t\t\t\tproperty,\n\t\t\t\t\tannotationPath,\n\t\t\t\t\tname,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\taggregationHelper,\n\t\t\t\t\tconverterContext,\n\t\t\t\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\t\t\t\ttableType,\n\t\t\t\t\trestrictionsOnProperties,\n\t\t\t\t\ttableCreationMode\n\t\t\t\t);\n\t\t\t\tcomputeHiddenOnRelatedColumns(existingColumns, name, column);\n\t\t\t\trelatedColumns.push(column);\n\t\t\t\trelatedPropertyNameMap[name] = newName;\n\t\t\t} else if (\n\t\t\t\texistingColumns.some((column) => column.name === newName) &&\n\t\t\t\texistingColumns.some((column) => column.propertyInfos?.includes(name))\n\t\t\t) {\n\t\t\t\trelatedPropertyNameMap[name] = newName;\n\t\t\t}\n\t\t}\n\t});\n\t// The property 'name' has been prefixed with 'Property::' for uniqueness.\n\t// Update the same in other propertyInfos[] references which point to this property.\n\texistingColumns.forEach((column) => {\n\t\tcolumn.propertyInfos = column.propertyInfos?.map((propertyInfo) => relatedPropertyNameMap[propertyInfo] ?? propertyInfo);\n\t\tcolumn.additionalPropertyInfos = column.additionalPropertyInfos?.map(\n\t\t\t(propertyInfo) => relatedPropertyNameMap[propertyInfo] ?? propertyInfo\n\t\t);\n\t});\n\treturn relatedColumns;\n};\n\n/**\n * Getting the Column Name\n * If it points to a DataField with one property or DataPoint with one property, it will use the property name\n * here to be consistent with the existing flex changes.\n * @param dataField Different DataField types defined in the annotations\n * @returns The name of annotation columns\n */\nconst _getAnnotationColumnName = function (dataField: DataFieldAbstractTypes): string {\n\t// This is needed as we have flexibility changes already that we have to check against\n\tif (isDataFieldTypes(dataField) && dataField.Value?.path) {\n\t\treturn dataField.Value?.path;\n\t} else if (dataField.$Type === UIAnnotationTypes.DataFieldForAnnotation && (dataField.Target?.$target as DataPoint)?.Value?.path) {\n\t\t// This is for removing duplicate properties. For example, 'Progress' Property is removed if it is already defined as a DataPoint\n\t\treturn (dataField.Target?.$target as DataPoint)?.Value.path;\n\t} else {\n\t\treturn KeyHelper.generateKeyFromDataField(dataField);\n\t}\n};\n\n/**\n * Determines if the data field labels have to be displayed in the table.\n * @param fieldGroupName The `DataField` name being processed.\n * @param visualizationPath\n * @param converterContext\n * @returns `showDataFieldsLabel` value from the manifest\n */\nconst _getShowDataFieldsLabel = function (\n\tfieldGroupName: string,\n\tvisualizationPath: string,\n\tconverterContext: ConverterContext<PageContextPathTarget>\n): boolean | undefined {\n\tconst columns = converterContext.getManifestControlConfiguration<TableManifestConfiguration>(visualizationPath)?.columns;\n\tconst columnKeys = columns && Object.keys(columns);\n\treturn (\n\t\tcolumnKeys &&\n\t\t!!columnKeys.find(function (key: string) {\n\t\t\treturn key === fieldGroupName && (columns[key] as CustomDefinedTableColumnForOverride).showDataFieldsLabel;\n\t\t})\n\t);\n};\n\n/**\n * Determines the relative path of the property with respect to the root entity.\n * @param dataField The `DataField` being processed.\n * @returns The relative path\n */\nconst _getRelativePath = function (dataField: DataFieldAbstractTypes): string {\n\tlet relativePath = \"\";\n\tswitch (dataField.$Type) {\n\t\tcase UIAnnotationTypes.DataField:\n\t\tcase UIAnnotationTypes.DataFieldWithNavigationPath:\n\t\tcase UIAnnotationTypes.DataFieldWithUrl:\n\t\tcase UIAnnotationTypes.DataFieldWithIntentBasedNavigation:\n\t\tcase UIAnnotationTypes.DataFieldWithAction:\n\t\t\trelativePath = (dataField as DataField)?.Value?.path;\n\t\t\tbreak;\n\t\tcase UIAnnotationTypes.DataFieldForAnnotation:\n\t\t\trelativePath = dataField?.Target?.value;\n\t\t\tbreak;\n\t\tcase UIAnnotationTypes.DataFieldForAction:\n\t\tcase UIAnnotationTypes.DataFieldForIntentBasedNavigation:\n\t\tcase UIAnnotationTypes.DataFieldForActionGroup:\n\t\tcase UIAnnotationTypes.DataFieldWithActionGroup:\n\t\t\trelativePath = KeyHelper.generateKeyFromDataField(dataField);\n\t\t\tbreak;\n\t}\n\treturn relativePath;\n};\n\nconst _sliceAtSlash = function (path: string, isLastSlash: boolean, isLastPart: boolean): string {\n\tconst iSlashIndex = isLastSlash ? path.lastIndexOf(\"/\") : path.indexOf(\"/\");\n\tif (iSlashIndex === -1) {\n\t\treturn path;\n\t}\n\treturn isLastPart ? path.substring(iSlashIndex + 1, path.length) : path.substring(0, iSlashIndex);\n};\n\n/**\n * Determines if the column contains a multi-value field.\n * @param dataField The DataField being processed\n * @param converterContext The converter context\n * @returns True if the DataField corresponds to a multi-value field.\n */\nconst _isColumnMultiValued = function (\n\tdataField: DataFieldAbstractTypes,\n\tconverterContext: ConverterContext<PageContextPathTarget>\n): boolean {\n\tif (isDataFieldTypes(dataField) && isPathAnnotationExpression(dataField.Value)) {\n\t\tconst propertyObjectPath = enhanceDataModelPath<PageContextPathTarget>(\n\t\t\tconverterContext.getDataModelObjectPath(),\n\t\t\tdataField.Value.path\n\t\t);\n\t\treturn isMultiValueField(propertyObjectPath);\n\t} else {\n\t\treturn false;\n\t}\n};\n\n/**\n * Determine whether a column is sortable.\n * @param dataField The data field being processed\n * @param propertyPath The property path\n * @param nonSortableColumns Collection of non-sortable column names as per annotation\n * @param relatedPropertiesInfo The related properties linked to the column\n * @returns True if the column is sortable\n */\nconst _isColumnSortable = function (\n\tdataField: DataFieldAbstractTypes,\n\tpropertyPath: string,\n\tnonSortableColumns: string[],\n\trelatedPropertiesInfo: ComplexPropertyInfo\n): boolean {\n\treturn (\n\t\t!nonSortableColumns.includes(propertyPath) && // Column is not marked as non-sortable via annotation\n\t\t(((dataField.$Type === UIAnnotationTypes.DataField || dataField.$Type === UIAnnotationTypes.DataFieldForAnnotation) &&\n\t\t\tObject.keys(relatedPropertiesInfo.properties).some((propName) => {\n\t\t\t\tconst isHidden = isReferencePropertyStaticallyHidden(relatedPropertiesInfo.properties[propName].annotationProperty);\n\t\t\t\treturn !isHidden && !nonSortableColumns.includes(propName);\n\t\t\t})) ||\n\t\t\tdataField.$Type === UIAnnotationTypes.DataFieldWithUrl ||\n\t\t\tdataField.$Type === UIAnnotationTypes.DataFieldWithIntentBasedNavigation ||\n\t\t\tdataField.$Type === UIAnnotationTypes.DataFieldWithAction)\n\t);\n};\n\n/**\n * Returns whether filtering on the table is case sensitive.\n * @param converterContext The instance of the converter context\n * @returns Returns 'false' if FilterFunctions annotation supports 'tolower', else 'true'\n */\nexport const isFilteringCaseSensitive = function (converterContext: ConverterContext<PageContextPathTarget>): boolean {\n\tconst filterFunctions: FilterFunctions | undefined = _getFilterFunctions(converterContext);\n\treturn ModelHelper.isFilteringCaseSensitive(undefined, filterFunctions);\n};\n\nfunction _getFilterFunctions(ConverterContext: ConverterContext<PageContextPathTarget>): FilterFunctions | undefined {\n\tconst entitySet = ConverterContext.getEntitySet();\n\tif (TypeGuards.isEntitySet(entitySet)) {\n\t\treturn (\n\t\t\tentitySet.annotations.Capabilities?.FilterFunctions ??\n\t\t\tConverterContext.getEntityContainer().annotations.Capabilities?.FilterFunctions\n\t\t);\n\t}\n\treturn undefined;\n}\n\n/**\n * Returns default format options for text fields in a table.\n * @param formatOptions\n * @returns Collection of format options with default values\n */\nfunction _getDefaultFormatOptionsForTable(formatOptions: FormatOptionsType | undefined): FormatOptionsType | undefined {\n\treturn formatOptions === undefined\n\t\t? undefined\n\t\t: {\n\t\t\t\ttextLinesEdit: 4,\n\t\t\t\t...formatOptions\n\t\t  };\n}\n\nfunction _findSemanticKeyValues(semanticKeys: SemanticKey, name: string): { values: string[]; semanticKeyFound: boolean } {\n\tconst aSemanticKeyValues: string[] = [];\n\tlet bSemanticKeyFound = false;\n\tfor (let i = 0; i < semanticKeys.length; i++) {\n\t\taSemanticKeyValues.push(semanticKeys[i].value);\n\t\tif (semanticKeys[i].value === name) {\n\t\t\tbSemanticKeyFound = true;\n\t\t}\n\t}\n\treturn {\n\t\tvalues: aSemanticKeyValues,\n\t\tsemanticKeyFound: bSemanticKeyFound\n\t};\n}\n\nfunction _findProperties(\n\tsemanticKeyValues: string[],\n\tfieldGroupProperties: string[]\n): { semanticKeyHasPropertyInFieldGroup: boolean; fieldGroupPropertyPath?: string } {\n\tlet semanticKeyHasPropertyInFieldGroup = false;\n\tlet sPropertyPath;\n\tif (semanticKeyValues && semanticKeyValues.length >= 1 && fieldGroupProperties && fieldGroupProperties.length >= 1) {\n\t\tfor (let i = 0; i < semanticKeyValues.length; i++) {\n\t\t\tif ([semanticKeyValues[i]].some((tmp) => fieldGroupProperties.includes(tmp))) {\n\t\t\t\tsemanticKeyHasPropertyInFieldGroup = true;\n\t\t\t\tsPropertyPath = semanticKeyValues[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn {\n\t\tsemanticKeyHasPropertyInFieldGroup: semanticKeyHasPropertyInFieldGroup,\n\t\tfieldGroupPropertyPath: sPropertyPath\n\t};\n}\n\n/**\n * Find the first property in the fieldGroup that is part of the semantic keys.\n * @param dataFieldGroup\n * @param semanticKeyValues\n * @returns An object containing a flag true if a property is found and a propertyPath.\n */\nfunction _findSemanticKeyValuesInFieldGroup(\n\tdataFieldGroup: DataFieldAbstractTypes | null,\n\tsemanticKeyValues: string[]\n): { semanticKeyHasPropertyInFieldGroup: boolean; propertyPath?: string } {\n\t// this info is used in FieldHelper#isDraftIndicatorVisibleInFieldGroup to show a draft indicator at the end of a field group\n\tconst aProperties: string[] = [];\n\tlet _propertiesFound: { semanticKeyHasPropertyInFieldGroup: boolean; fieldGroupPropertyPath?: string } = {\n\t\tsemanticKeyHasPropertyInFieldGroup: false,\n\t\tfieldGroupPropertyPath: undefined\n\t};\n\tif (\n\t\tdataFieldGroup &&\n\t\tdataFieldGroup.$Type === UIAnnotationTypes.DataFieldForAnnotation &&\n\t\tdataFieldGroup.Target?.$target?.$Type === UIAnnotationTypes.FieldGroupType\n\t) {\n\t\tdataFieldGroup.Target.$target.Data?.forEach((innerDataField: DataFieldAbstractTypes) => {\n\t\t\tif (\n\t\t\t\t(innerDataField.$Type === UIAnnotationTypes.DataField || innerDataField.$Type === UIAnnotationTypes.DataFieldWithUrl) &&\n\t\t\t\tinnerDataField.Value\n\t\t\t) {\n\t\t\t\taProperties.push(innerDataField.Value.path);\n\t\t\t}\n\t\t\t_propertiesFound = _findProperties(semanticKeyValues, aProperties);\n\t\t});\n\t}\n\treturn {\n\t\tsemanticKeyHasPropertyInFieldGroup: _propertiesFound.semanticKeyHasPropertyInFieldGroup,\n\t\tpropertyPath: _propertiesFound.fieldGroupPropertyPath\n\t};\n}\n\n/**\n * Returns default format options with draftIndicator for a column.\n * @param name\n * @param semanticKeys\n * @param dataFieldGroup\n * @returns Collection of format options with default values\n */\nfunction getDefaultDraftIndicatorForColumn(\n\tname: string,\n\tsemanticKeys: SemanticKey,\n\tdataFieldGroup: DataFieldAbstractTypes | null\n): Partial<{\n\tfieldGroupDraftIndicatorPropertyPath: string;\n\tfieldGroupName: string;\n\tshowErrorObjectStatus: CompiledBindingToolkitExpression;\n\thasDraftIndicator: boolean;\n}> {\n\tif (!semanticKeys) {\n\t\treturn {};\n\t}\n\tconst semanticKey = _findSemanticKeyValues(semanticKeys, name);\n\tconst semanticKeyInFieldGroup = _findSemanticKeyValuesInFieldGroup(dataFieldGroup, semanticKey.values);\n\tif (semanticKeyInFieldGroup.semanticKeyHasPropertyInFieldGroup) {\n\t\t// Semantic Key has a property in a FieldGroup\n\t\treturn {\n\t\t\t//TODO we should rather store hasSemanticKeyInFieldGroup\n\t\t\tfieldGroupDraftIndicatorPropertyPath: semanticKeyInFieldGroup.propertyPath,\n\t\t\tfieldGroupName: name,\n\t\t\tshowErrorObjectStatus: compileExpression(getRowStatusVisibility(name, true))\n\t\t};\n\t} else if (semanticKey.semanticKeyFound) {\n\t\treturn {\n\t\t\thasDraftIndicator: true,\n\t\t\tshowErrorObjectStatus: compileExpression(getRowStatusVisibility(name, false))\n\t\t};\n\t}\n\treturn {};\n}\n\nfunction _getImpNumber(dataField: DataFieldTypes): number {\n\tconst importance = dataField?.annotations?.UI?.Importance as string;\n\tif (importance && importance.includes(\"UI.ImportanceType/High\")) {\n\t\treturn 3;\n\t}\n\tif (importance && importance.includes(\"UI.ImportanceType/Medium\")) {\n\t\treturn 2;\n\t}\n\tif (importance && importance.includes(\"UI.ImportanceType/Low\")) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nfunction _getDataFieldImportance(dataField: DataFieldTypes): Importance {\n\tconst importance = dataField?.annotations?.UI?.Importance as string;\n\treturn importance ? (importance.split(\"/\")[1] as Importance) : Importance.None;\n}\n\n/**\n * Sets the export settings of a column containing datapoints.\n * @param property The property referenced on a given column\n * @param column The column to be updated\n */\nfunction _setExportSettingsForDataPoint(property: Property, column: AnnotationTableColumn): void {\n\tconst targetValuefromDP = getTargetValueOnDataPoint(property);\n\tif (\n\t\tisDataPointFromDataFieldDefault(property) &&\n\t\ttypeof targetValuefromDP === \"string\" &&\n\t\tcolumn.exportSettings &&\n\t\tcolumn.exportSettings?.unit !== \"%\"\n\t) {\n\t\tcolumn.exportDataPointTargetValue = targetValuefromDP;\n\t\tcolumn.exportSettings.template = \"{0}/\" + targetValuefromDP;\n\t}\n}\n\nfunction _getMaxImportance(fields: DataFieldTypes[]): Importance {\n\tif (fields && fields.length > 0) {\n\t\tlet maxImpNumber = -1;\n\t\tlet impNumber = -1;\n\t\tlet DataFieldWithMaxImportance;\n\t\tfor (const field of fields) {\n\t\t\timpNumber = _getImpNumber(field);\n\t\t\tif (impNumber > maxImpNumber) {\n\t\t\t\tmaxImpNumber = impNumber;\n\t\t\t\tDataFieldWithMaxImportance = field;\n\t\t\t}\n\t\t}\n\t\treturn _getDataFieldImportance(DataFieldWithMaxImportance as DataFieldTypes);\n\t}\n\treturn Importance.None;\n}\n\n/**\n * Returns the importance value for a column.\n * @param converterContext\n * @param dataField\n * @returns The importance value\n */\nexport function getImportance(\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tdataField: DataFieldAbstractTypes | undefined\n): Importance | undefined {\n\tif (!dataField) {\n\t\treturn undefined;\n\t}\n\tconst semanticKeys = converterContext.getDataModelObjectPath().targetEntityType.annotations.Common?.SemanticKey ?? [];\n\tconst requiredProperties = getRequiredProperties(converterContext);\n\tconst highKeys = [...semanticKeys, ...requiredProperties].map((propertyPath) => propertyPath.$target?.fullyQualifiedName);\n\t//Evaluate default Importance is not set explicitly\n\tlet fieldsWithImportance;\n\tif (isAnnotationOfType<DataFieldForAnnotation>(dataField, UIAnnotationTypes.DataFieldForAnnotation)) {\n\t\tconst dataFieldTarget = dataField.Target.$target;\n\t\tif (isAnnotationOfType<FieldGroup>(dataFieldTarget, UIAnnotationTypes.FieldGroupType)) {\n\t\t\tconst fieldGroupData = dataFieldTarget.Data;\n\t\t\t//If a FieldGroup contains a semanticKey or required property, importance set to High\n\t\t\tif (\n\t\t\t\tfieldGroupData.some(function (fieldGroupDataField: DataFieldAbstractTypes): boolean {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tisDataFieldTypes(fieldGroupDataField) && highKeys.includes(fieldGroupDataField.Value?.$target?.fullyQualifiedName)\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\treturn Importance.High;\n\t\t\t} else {\n\t\t\t\t//If the DataFieldForAnnotation has an Importance we take it\n\t\t\t\tif (dataField?.annotations?.UI?.Importance) {\n\t\t\t\t\treturn _getDataFieldImportance(dataField as unknown as DataFieldTypes);\n\t\t\t\t}\n\t\t\t\t// else the highest importance (if any) is returned\n\t\t\t\tfieldsWithImportance = fieldGroupData.filter(function (item) {\n\t\t\t\t\treturn item?.annotations?.UI?.Importance;\n\t\t\t\t});\n\t\t\t\treturn _getMaxImportance(fieldsWithImportance as DataFieldTypes[]);\n\t\t\t}\n\t\t}\n\t}\n\treturn highKeys.includes((dataField as DataFieldTypes).Value?.$target?.fullyQualifiedName)\n\t\t? Importance.High\n\t\t: _getDataFieldImportance(dataField as unknown as DataFieldTypes);\n}\n\n/**\n * Returns line items from metadata annotations.\n * @param lineItemAnnotation Collection of data fields with their annotations\n * @param tableType The table type\n * @param visualizationPath The visualization path\n * @param converterContext The converter context\n * @returns The columns from the annotations\n */\nconst getColumnsFromAnnotations = function (\n\tlineItemAnnotation: LineItem,\n\ttableType: TableType,\n\tvisualizationPath: string,\n\tconverterContext: ConverterContext<PageContextPathTarget>\n): AnnotationTableColumn[] {\n\tconst entityType: EntityType = converterContext.getAnnotationEntityType(lineItemAnnotation),\n\t\tannotationColumns: AnnotationTableColumn[] = [],\n\t\tcolumnsToBeCreated: Record<string, Property> = {},\n\t\tdisplayModeOfDescriptionPropertiesMap: Record<string, DisplayMode> = {},\n\t\trestrictionsOnProperties = getRestrictionsOnProperties(converterContext),\n\t\ttableManifestSettings: TableManifestConfiguration = converterContext.getManifestControlConfiguration(visualizationPath),\n\t\tdefaultCreationMode =\n\t\t\tconverterContext.getManifestWrapper().getSapFeManifestConfiguration()?.macros?.table?.defaultCreationMode ===\n\t\t\t\"InlineCreationRows\"\n\t\t\t\t? CreationMode.InlineCreationRows\n\t\t\t\t: undefined,\n\t\ttableCreationMode: CreationMode =\n\t\t\ttableManifestSettings?.tableSettings?.creationMode?.name ?? defaultCreationMode ?? CreationMode.Inline;\n\tconst semanticKeys: SemanticKey = converterContext.getAnnotationsByTerm(\"Common\", CommonAnnotationTerms.SemanticKey, [\n\t\tconverterContext.getEntityType()\n\t])[0] as SemanticKey;\n\tif (lineItemAnnotation) {\n\t\tconst tableConverterContext = converterContext.getConverterContextFor<PageContextPathTarget>(\n\t\t\tgetTargetObjectPath(converterContext.getDataModelObjectPath())\n\t\t);\n\t\tlineItemAnnotation.forEach((dataField) => {\n\t\t\t// TODO: variable name should be datafield and not lineItem\n\t\t\tif (!_isValidColumn(dataField)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet exportSettings: PropertyInfo[\"exportSettings\"] = null;\n\t\t\tconst semanticObjectAnnotationPath =\n\t\t\t\tisDataFieldTypes(dataField) && dataField.Value?.$target?.fullyQualifiedName\n\t\t\t\t\t? getSemanticObjectPath(converterContext, dataField)\n\t\t\t\t\t: undefined;\n\t\t\tconst relativePath = _getRelativePath(dataField);\n\t\t\t// Determine properties which are consumed by this LineItem.\n\t\t\tconst relatedPropertiesInfo: ComplexPropertyInfo = collectRelatedPropertiesRecursively(dataField, converterContext, tableType);\n\t\t\tconst relatedPropertyNames: string[] = Object.keys(relatedPropertiesInfo.properties);\n\t\t\tconst additionalPropertyNames: string[] = Object.keys(relatedPropertiesInfo.additionalProperties);\n\t\t\tconst groupPath: string | undefined = relativePath ? _sliceAtSlash(relativePath, true, false) : undefined;\n\t\t\tconst isGroup: boolean = groupPath != relativePath;\n\t\t\tconst label = getLabel(dataField, isGroup);\n\t\t\tconst name = _getAnnotationColumnName(dataField);\n\t\t\tconst isFieldGroupColumn: boolean = groupPath ? groupPath.includes(`@${UIAnnotationTerms.FieldGroup}`) : false;\n\t\t\tconst showDataFieldsLabel: boolean | undefined = isFieldGroupColumn\n\t\t\t\t? _getShowDataFieldsLabel(name, visualizationPath, converterContext)\n\t\t\t\t: false;\n\t\t\tconst dataType: string | undefined = getDataFieldDataType(dataField);\n\t\t\tconst formatOptions = _getDefaultFormatOptionsForTable(getDefaultDraftIndicatorForColumn(name, semanticKeys, dataField));\n\t\t\tconst propertyDataModelObjectPath = enhanceDataModelPath<DataFieldAbstractTypes>(\n\t\t\t\tconverterContext.getDataModelObjectPath(),\n\t\t\t\trelativePath\n\t\t\t);\n\t\t\t// Determine if we need a situations indicator\n\t\t\tconst navigationProperties: NavigationProperty[] = propertyDataModelObjectPath.targetEntityType.navigationProperties;\n\t\t\tconst situationsNavProps = navigationProperties.filter(\n\t\t\t\t(navigationProperty) =>\n\t\t\t\t\t!navigationProperty.isCollection &&\n\t\t\t\t\tnavigationProperty.targetType.annotations.Common?.SAPObjectNodeType?.Name === \"BusinessSituation\"\n\t\t\t);\n\t\t\tconst situationsNavProp: NavigationProperty | undefined = situationsNavProps.length >= 1 ? situationsNavProps[0] : undefined;\n\t\t\tif (situationsNavProp && formatOptions) {\n\t\t\t\tformatOptions.hasSituationsIndicator = true;\n\t\t\t}\n\n\t\t\tlet fieldGroupHiddenExpressions: CompiledBindingToolkitExpression;\n\t\t\tif (\n\t\t\t\tdataField.$Type === UIAnnotationTypes.DataFieldForAnnotation &&\n\t\t\t\tdataField.Target?.$target?.$Type === UIAnnotationTypes.FieldGroupType\n\t\t\t) {\n\t\t\t\tfieldGroupHiddenExpressions = _getFieldGroupHiddenExpressions(dataField);\n\t\t\t}\n\t\t\tconst isMultiValue = _isColumnMultiValued(dataField, tableConverterContext);\n\t\t\tif (!isMultiValue && _isExportableColumn(dataField)) {\n\t\t\t\t//exclude the types listed above for the Export (generates error on Export as PDF)\n\t\t\t\texportSettings = createColumnExportSettings(dataField, relatedPropertiesInfo);\n\t\t\t}\n\t\t\tlet propertyTypeConfig: PropertyTypeConfig | undefined;\n\t\t\tif (dataType) {\n\t\t\t\tpropertyTypeConfig = getTypeConfig(dataField, dataType);\n\t\t\t}\n\t\t\tconst typeConfig: PropertyTypeConfig = {\n\t\t\t\tclassName: dataType as keyof typeof DefaultTypeForEdmType,\n\t\t\t\tformatOptions: {\n\t\t\t\t\t...formatOptions,\n\t\t\t\t\t...propertyTypeConfig?.formatOptions\n\t\t\t\t},\n\t\t\t\tconstraints: propertyTypeConfig?.constraints\n\t\t\t};\n\t\t\tconst visualSettings: VisualSettings = {};\n\t\t\tif (!dataType || !typeConfig) {\n\t\t\t\t// for charts\n\t\t\t\tvisualSettings.widthCalculation = null;\n\t\t\t}\n\t\t\tconst sortable =\n\t\t\t\t!isMultiValue &&\n\t\t\t\t_isColumnSortable(dataField, relativePath, restrictionsOnProperties.nonSortableProperties, relatedPropertiesInfo);\n\t\t\tconst availability = isReferencePropertyStaticallyHidden(dataField) ? \"Hidden\" : \"Default\";\n\t\t\tconst column: AnnotationTableColumn = {\n\t\t\t\tkey: KeyHelper.generateKeyFromDataField(dataField),\n\t\t\t\ttype: ColumnType.Annotation,\n\t\t\t\tlabel: label ?? name,\n\t\t\t\tgroupLabel: isGroup ? getLabel(dataField) : undefined,\n\t\t\t\tgroup: isGroup ? groupPath : undefined,\n\t\t\t\tFieldGroupHiddenExpressions: fieldGroupHiddenExpressions,\n\t\t\t\tannotationPath: converterContext.getEntitySetBasedAnnotationPath(dataField.fullyQualifiedName),\n\t\t\t\tsemanticObjectPath: semanticObjectAnnotationPath,\n\t\t\t\tavailability: availability,\n\t\t\t\tname: name,\n\t\t\t\tshowDataFieldsLabel: showDataFieldsLabel,\n\t\t\t\trequired: isRequiredColumn(converterContext, dataField as DataFieldTypes, tableCreationMode),\n\t\t\t\trelativePath: relativePath,\n\t\t\t\tsortable: sortable,\n\t\t\t\tpropertyInfos: relatedPropertyNames.length ? relatedPropertyNames : undefined,\n\t\t\t\tadditionalPropertyInfos: additionalPropertyNames.length > 0 ? additionalPropertyNames : undefined,\n\t\t\t\texportSettings: exportSettings,\n\t\t\t\twidth: (dataField.annotations?.HTML5?.CssDefaults?.width?.valueOf() as string) || undefined,\n\t\t\t\timportance: getImportance(converterContext, dataField as DataFieldTypes),\n\t\t\t\tisNavigable: true,\n\t\t\t\tformatOptions: formatOptions,\n\t\t\t\tcaseSensitive: isFilteringCaseSensitive(converterContext),\n\t\t\t\ttypeConfig: typeConfig,\n\t\t\t\tvisualSettings: visualSettings as PropertyInfo[\"visualSettings\"],\n\t\t\t\ttimezoneText: exportSettings?.timezone,\n\t\t\t\tisPartOfLineItem: true,\n\t\t\t\tdataType: dataType ?? (\"Edm.String\" as keyof typeof DefaultTypeForEdmType),\n\t\t\t\tisMultiValue\n\t\t\t};\n\t\t\tconst tooltip = _getTooltip(dataField) ?? label;\n\t\t\tif (tooltip) {\n\t\t\t\tcolumn.tooltip = tooltip;\n\t\t\t}\n\t\t\tif (relatedPropertiesInfo.exportSettings.dataPointTargetValue) {\n\t\t\t\tcolumn.exportDataPointTargetValue = relatedPropertiesInfo.exportSettings.dataPointTargetValue;\n\t\t\t}\n\t\t\tannotationColumns.push(column);\n\t\t\t// Collect information of related columns to be created.\n\t\t\trelatedPropertyNames.forEach((relatedPropertyName) => {\n\t\t\t\tcolumnsToBeCreated[relatedPropertyName] = relatedPropertiesInfo.properties[relatedPropertyName].annotationProperty;\n\t\t\t\t// In case of a multi-value, related properties cannot be sorted as we go through a 1-n relation\n\t\t\t\tif (isMultiValue) {\n\t\t\t\t\trestrictionsOnProperties.nonSortableProperties.push(relatedPropertyName);\n\t\t\t\t}\n\t\t\t\taddPropertyToDisplayModeOfDescriptionPropertiesMap(\n\t\t\t\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\t\t\t\trelatedPropertiesInfo,\n\t\t\t\t\trelatedPropertyName\n\t\t\t\t);\n\t\t\t\t// In case the lineItem points to a navigation property with a textArrangement TextOnly, we need to create the column with the value navigation property.\n\t\t\t\t// The text property is referenced on the related properties of the lineItem, so will be created on the _createRelatedColumns method.\n\t\t\t\tif (relatedPropertiesInfo.properties[relatedPropertyName].displayModeOfPropertyUsedAsDescription === \"Description\") {\n\t\t\t\t\tcreatePropertyAnnotatedTextOnly(\n\t\t\t\t\t\tconverterContext,\n\t\t\t\t\t\tpropertyDataModelObjectPath,\n\t\t\t\t\t\tdataField,\n\t\t\t\t\t\tcolumnsToBeCreated,\n\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\trestrictionsOnProperties\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// Create columns for additional properties identified for ALP use case.\n\t\t\tadditionalPropertyNames.forEach((additionalPropertyName) => {\n\t\t\t\t// Intentional overwrite as we require only one new PropertyInfo for a related Property.\n\t\t\t\tcolumnsToBeCreated[additionalPropertyName] = relatedPropertiesInfo.additionalProperties[additionalPropertyName];\n\t\t\t});\n\t\t});\n\t}\n\t// Get columns from the Properties of EntityType\n\treturn getColumnsFromEntityType(\n\t\tcolumnsToBeCreated,\n\t\tentityType,\n\t\tannotationColumns,\n\t\tconverterContext,\n\t\ttableType,\n\t\ttableCreationMode,\n\t\tdisplayModeOfDescriptionPropertiesMap,\n\t\trestrictionsOnProperties\n\t);\n};\n\n/**\n * Gets the property names from the manifest and checks against existing properties already added by annotations.\n * If a not yet stored property is found it adds it for sorting and filtering only to the annotationColumns.\n * @param properties\n * @param annotationColumns\n * @param converterContext\n * @param entityType\n * @returns The columns from the annotations\n */\nconst _getPropertyNames = function (\n\tproperties: string[] | string | undefined,\n\tannotationColumns: AnnotationTableColumn[],\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tentityType: EntityType\n): string[] | undefined {\n\tlet matchedProperties: string[] | undefined;\n\tif (Array.isArray(properties)) {\n\t\tmatchedProperties = properties.map(function (propertyPath) {\n\t\t\tconst annotationColumn = annotationColumns.find(function (annotationColumn) {\n\t\t\t\treturn annotationColumn.relativePath === propertyPath && annotationColumn.propertyInfos === undefined;\n\t\t\t});\n\t\t\tif (annotationColumn) {\n\t\t\t\treturn annotationColumn.name;\n\t\t\t} else {\n\t\t\t\tconst relatedColumns = _createRelatedColumns(\n\t\t\t\t\t{ [propertyPath]: entityType.resolvePath(propertyPath) },\n\t\t\t\t\tannotationColumns,\n\t\t\t\t\tconverterContext,\n\t\t\t\t\tentityType,\n\t\t\t\t\t{}\n\t\t\t\t);\n\t\t\t\tannotationColumns.push(relatedColumns[0]);\n\t\t\t\treturn relatedColumns[0].name;\n\t\t\t}\n\t\t});\n\t}\n\treturn matchedProperties;\n};\n\n/**\n * Determines if the field group has to be flagged as required.\n * @param converterContext The converter context\n * @param fieldGroup The fieldGroup being processed\n * @param tableCreationMode The creation mode of the underlying table\n * @returns True if the fieldGroup is required.\n */\nconst isRequiredFieldGroup = function (\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tfieldGroup: FieldGroup,\n\ttableCreationMode: CreationMode\n): boolean {\n\tconst fieldGroupData = fieldGroup.Data;\n\treturn fieldGroupData.some(function (item) {\n\t\t// we exclude boolean type, the end-user may want to keep the underlying check box empty on purpose\n\t\tif (isDataField(item) && item?.Value?.$target.type !== \"Edm.Boolean\") {\n\t\t\treturn (\n\t\t\t\tisStaticallyMandatory(item) ||\n\t\t\t\t(tableCreationMode === CreationMode.InlineCreationRows &&\n\t\t\t\t\tisAnnotatedRequiredProperty(item.Value.$target.fullyQualifiedName, converterContext))\n\t\t\t);\n\t\t}\n\t});\n};\n\n/**\n * Determines if the dataFieldForAnnotation has to be flagged as required.\n * @param converterContext The converter context\n * @param dataFieldForAnnotation The property being processed\n * @param tableCreationMode The creation mode of the underlying table\n * @returns True if the property is required.\n */\nconst isRequiredDataFieldForAnnotation = function (\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tdataFieldForAnnotation: DataFieldForAnnotation,\n\ttableCreationMode: CreationMode\n): boolean {\n\tconst dataFieldTarget = dataFieldForAnnotation.Target.$target;\n\tconst DataFieldForAnnotationFieldControlNotMandatory = hasFieldControlNotMandatory(dataFieldForAnnotation);\n\t// Check if the DataFieldForAnnotation points to a FieldGroup\n\tif (hasFieldGroupTarget(dataFieldForAnnotation)) {\n\t\tif (isRequiredFieldGroup(converterContext, dataFieldTarget as FieldGroup, tableCreationMode)) {\n\t\t\treturn true;\n\t\t}\n\t\tconst fieldGroupData = (dataFieldTarget as FieldGroup).Data;\n\t\treturn fieldGroupData.some((innerDataField: DataFieldAbstractTypes) => {\n\t\t\treturn isRequiredColumn(converterContext, innerDataField, tableCreationMode);\n\t\t});\n\t}\n\t/*If the underlying datapoint is a rating indicator, the end-user may want to keep the rating empty (value 0) on purpose.\n\tBesides, currently, only a fieldControl set on a dataFieldForAnnotation pointing to a dataPoint has an influence in the table.\n\tAccordingly, if a datapoint comes from a dataFieldForAnnotation with a fieldControl set as not mandatory, this dataPoint must not be flagged as \"required\"*/\n\tif (hasDataPointTarget(dataFieldForAnnotation) && (dataFieldTarget as DataPoint).Visualization !== \"UI.VisualizationType/Rating\") {\n\t\tif (DataFieldForAnnotationFieldControlNotMandatory) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isStaticallyMandatory(dataFieldForAnnotation)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn isRequiredDataPoint(converterContext, dataFieldTarget as DataPoint, tableCreationMode);\n\t}\n\treturn false;\n};\n\n/**\n * Determines if the property has to be flagged as required.\n * @param converterContext The converter context\n * @param property The property being processed\n * @param tableCreationMode The creation mode of the underlying table\n * @returns True if the property is required.\n */\nconst isRequiredProperty = function (\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tproperty: Property,\n\ttableCreationMode: CreationMode\n): boolean {\n\treturn (\n\t\tproperty.type !== \"Edm.Boolean\" &&\n\t\t!isRatingVisualizationFromDataFieldDefault(property) &&\n\t\t(isStaticallyMandatory(property) ||\n\t\t\t(tableCreationMode === CreationMode.InlineCreationRows &&\n\t\t\t\tisAnnotatedRequiredProperty(property.fullyQualifiedName, converterContext)))\n\t);\n};\n\n/**\n * Determines if the dataPoint has to be flagged as required.\n * @param converterContext The converter context\n * @param dataPoint The dataPoint being processed\n * @param tableCreationMode The creation mode of the underlying table\n * @returns True if the dataPoint is required.\n */\nconst isRequiredDataPoint = function (\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tdataPoint: DataPoint,\n\ttableCreationMode: CreationMode\n): boolean {\n\treturn (\n\t\tisStaticallyMandatory(dataPoint) ||\n\t\t(tableCreationMode === CreationMode.InlineCreationRows &&\n\t\t\tisAnnotatedRequiredProperty(dataPoint.Value.$target.fullyQualifiedName, converterContext))\n\t);\n};\n\n/**\n * Determines if the underlying column has to be flagged as required.\n * @param converterContext The converter context\n * @param target The target being processed\n * @param tableCreationMode The creation mode of the underlying table\n * @returns The binding expression for the 'required' property of the table column.\n */\nconst isRequiredColumn = function (\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\ttarget: DataFieldAbstractTypes | Property,\n\ttableCreationMode?: CreationMode\n): CompiledBindingToolkitExpression {\n\tconst creationMode = tableCreationMode || CreationMode.Inline;\n\tif (\n\t\tconverterContext.getTemplateType() === TemplateType.ListReport ||\n\t\tconverterContext.getTemplateType() === TemplateType.AnalyticalListPage\n\t) {\n\t\treturn undefined;\n\t}\n\tif (isProperty(target)) {\n\t\treturn isRequiredProperty(converterContext, target, creationMode) ? compileExpression(UI.IsEditable) : undefined;\n\t}\n\t// Check if the dataField is of type DataFieldForAnnotation\n\tif (isDataFieldForAnnotation(target)) {\n\t\treturn isRequiredDataFieldForAnnotation(converterContext, target, creationMode) ? compileExpression(UI.IsEditable) : undefined;\n\t}\n\t//If the underlying property is a boolean, the end-user may want to keep the check box empty on purpose\n\tif (isDataField(target) && target.Value?.$target?.type !== \"Edm.Boolean\") {\n\t\treturn isStaticallyMandatory(target) ||\n\t\t\t(creationMode === CreationMode.InlineCreationRows &&\n\t\t\t\tisAnnotatedRequiredProperty(target.Value.$target.fullyQualifiedName, converterContext))\n\t\t\t? compileExpression(UI.IsEditable)\n\t\t\t: undefined;\n\t}\n\treturn undefined;\n};\n\nconst _appendCustomTemplate = function (\n\tproperties: string[] | undefined,\n\texportProperties: string[] | string | undefined\n): string | undefined {\n\tif (Array.isArray(exportProperties)) {\n\t\tproperties = exportProperties;\n\t}\n\tif (properties) {\n\t\treturn properties\n\t\t\t.map((property) => {\n\t\t\t\treturn `{${properties!.indexOf(property)}}`;\n\t\t\t})\n\t\t\t.join(`${\"\\n\"}`);\n\t}\n\treturn undefined;\n};\n\n/**\n * Returns table column definitions from manifest.\n *\n * These may be custom columns defined in the manifest, slot columns coming through\n * a building block, or annotation columns to overwrite annotation-based columns.\n * @param columns\n * @param annotationColumns\n * @param converterContext\n * @param entityType\n * @returns The columns from the manifest\n */\nconst getColumnsFromManifest = function (\n\tcolumns: Record<string, CustomDefinedTableColumn | CustomDefinedTableColumnForOverride>,\n\tannotationColumns: AnnotationTableColumn[],\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tentityType: EntityType\n): Record<string, ManifestColumn> {\n\tconst internalColumns: Record<string, ManifestColumn> = {};\n\tfunction isColumnOverride(\n\t\tcolumn: CustomDefinedTableColumn | CustomDefinedTableColumnForOverride,\n\t\tkey: string\n\t): column is CustomDefinedTableColumnForOverride {\n\t\treturn annotationColumns.some((annotationColumn) => annotationColumn.key === key);\n\t}\n\tfunction isSlotColumn(manifestColumn: CustomDefinedTableColumn): manifestColumn is FragmentDefinedSlotColumn {\n\t\treturn manifestColumn.type === ColumnType.Slot;\n\t}\n\tfunction isCustomColumn(manifestColumn: CustomDefinedTableColumn): manifestColumn is ManifestDefinedCustomColumn {\n\t\treturn manifestColumn.type === undefined && !!manifestColumn.template;\n\t}\n\tfunction _updateLinkedPropertiesOnCustomColumns(propertyInfos: string[], annotationTableColumns: AnnotationTableColumn[]): void {\n\t\tconst restrictionsOnProperties = getRestrictionsOnProperties(converterContext);\n\t\tpropertyInfos.forEach((property) => {\n\t\t\tannotationTableColumns.forEach((prop) => {\n\t\t\t\tif (prop.name === property) {\n\t\t\t\t\tprop.sortable = !restrictionsOnProperties.nonSortableProperties.includes(property.replace(\"Property::\", \"\"));\n\t\t\t\t\tprop.isGroupable = prop.sortable;\n\t\t\t\t\tprop.filterable = !restrictionsOnProperties.nonFilterableProperties.includes(property.replace(\"Property::\", \"\"));\n\t\t\t\t\tprop.isPartOfCustomColumn = true;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\tfor (const key in columns) {\n\t\tconst manifestColumn = columns[key];\n\t\tKeyHelper.validateKey(key);\n\t\t// BaseTableColumn\n\t\tconst baseTableColumn = {\n\t\t\tkey: key,\n\t\t\twidthIncludingColumnHeader: manifestColumn.widthIncludingColumnHeader,\n\t\t\twidth: manifestColumn.width || undefined,\n\t\t\tposition: {\n\t\t\t\tanchor: manifestColumn.position?.anchor,\n\t\t\t\tplacement: manifestColumn.position === undefined ? Placement.After : manifestColumn.position.placement\n\t\t\t},\n\t\t\tcaseSensitive: isFilteringCaseSensitive(converterContext)\n\t\t};\n\t\tif (isColumnOverride(manifestColumn, key)) {\n\t\t\tconst propertiesToOverwriteAnnotationColumn: CustomElement<AnnotationTableColumnForOverride> = {\n\t\t\t\t...baseTableColumn,\n\t\t\t\timportance: manifestColumn?.importance,\n\t\t\t\thorizontalAlign: manifestColumn?.horizontalAlign,\n\t\t\t\tavailability: manifestColumn?.availability,\n\t\t\t\ttype: ColumnType.Annotation,\n\t\t\t\tisNavigable: undefined,\n\t\t\t\tsettings: manifestColumn.settings,\n\t\t\t\tformatOptions: _getDefaultFormatOptionsForTable(manifestColumn.formatOptions),\n\t\t\t\texportSettings: manifestColumn.disableExport\n\t\t\t\t\t? null\n\t\t\t\t\t: getCustomExportSettings(\n\t\t\t\t\t\t\tmanifestColumn?.exportSettings,\n\t\t\t\t\t\t\tannotationColumns,\n\t\t\t\t\t\t\tconverterContext,\n\t\t\t\t\t\t\tentityType,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tkey\n\t\t\t\t\t  )\n\t\t\t};\n\t\t\tinternalColumns[key] = propertiesToOverwriteAnnotationColumn;\n\t\t} else {\n\t\t\tconst propertyInfos: string[] | undefined = _getPropertyNames(\n\t\t\t\tmanifestColumn.properties,\n\t\t\t\tannotationColumns,\n\t\t\t\tconverterContext,\n\t\t\t\tentityType\n\t\t\t);\n\t\t\tconst tooltipText = converterContext.fetchTextFromMetaModel(manifestColumn.tooltip),\n\t\t\t\theaderText = converterContext.fetchTextFromMetaModel(manifestColumn.header);\n\n\t\t\tconst customColumnExportSettings: ColumnExportSettings | null =\n\t\t\t\tpropertyInfos && !manifestColumn.disableExport\n\t\t\t\t\t? getCustomExportSettings(\n\t\t\t\t\t\t\tmanifestColumn?.exportSettings,\n\t\t\t\t\t\t\tannotationColumns,\n\t\t\t\t\t\t\tconverterContext,\n\t\t\t\t\t\t\tentityType,\n\t\t\t\t\t\t\tpropertyInfos\n\t\t\t\t\t  )\n\t\t\t\t\t: null;\n\t\t\tconst baseManifestColumn = {\n\t\t\t\t...baseTableColumn,\n\t\t\t\theader: headerText,\n\t\t\t\timportance: manifestColumn?.importance || Importance.None,\n\t\t\t\thorizontalAlign: manifestColumn?.horizontalAlign || HorizontalAlign.Begin,\n\t\t\t\tavailability: manifestColumn?.availability || \"Default\",\n\t\t\t\ttemplate: manifestColumn.template,\n\t\t\t\tpropertyInfos: propertyInfos,\n\t\t\t\texportSettings: customColumnExportSettings,\n\t\t\t\tid: `CustomColumn::${key}`,\n\t\t\t\tname: `CustomColumn::${key}`,\n\t\t\t\t//Needed for MDC:\n\t\t\t\tformatOptions: { textLinesEdit: 4 },\n\t\t\t\tisGroupable: false,\n\t\t\t\tisNavigable: false,\n\t\t\t\tsortable: false,\n\t\t\t\tvisualSettings: { widthCalculation: null },\n\t\t\t\ttooltip: tooltipText ? tooltipText : headerText,\n\t\t\t\tproperties: manifestColumn.properties,\n\t\t\t\trequired:\n\t\t\t\t\tmanifestColumn.required &&\n\t\t\t\t\tconverterContext.getTemplateType() !== TemplateType.ListReport &&\n\t\t\t\t\tconverterContext.getTemplateType() !== TemplateType.AnalyticalListPage\n\t\t\t\t\t\t? compileExpression(UI.IsEditable)\n\t\t\t\t\t\t: undefined\n\t\t\t};\n\t\t\tif (propertyInfos) {\n\t\t\t\t_updateLinkedPropertiesOnCustomColumns(propertyInfos, annotationColumns);\n\t\t\t}\n\t\t\tif (isSlotColumn(manifestColumn)) {\n\t\t\t\tconst customTableColumn: CustomElement<CustomBasedTableColumn> = {\n\t\t\t\t\t...baseManifestColumn,\n\t\t\t\t\ttype: ColumnType.Slot\n\t\t\t\t};\n\t\t\t\tinternalColumns[key] = customTableColumn;\n\t\t\t} else if (isCustomColumn(manifestColumn)) {\n\t\t\t\tconst customTableColumn: CustomElement<CustomBasedTableColumn> = {\n\t\t\t\t\t...baseManifestColumn,\n\t\t\t\t\ttype: ColumnType.Default\n\t\t\t\t};\n\t\t\t\tinternalColumns[key] = customTableColumn;\n\t\t\t} else {\n\t\t\t\tconst message = `The annotation column '${key}' referenced in the manifest is not found`;\n\t\t\t\tconverterContext\n\t\t\t\t\t.getDiagnostics()\n\t\t\t\t\t.addIssue(\n\t\t\t\t\t\tIssueCategory.Manifest,\n\t\t\t\t\t\tIssueSeverity.Low,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\tIssueCategoryType,\n\t\t\t\t\t\tIssueCategoryType?.AnnotationColumns?.InvalidKey\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\treturn internalColumns;\n};\n\n/**\n * Adds computed columns such as the draft status and situations status.\n * @param tableColumns The table columns collected so far\n * @param tableType The table type\n * @param visualizationPath\n * @param converterContext\n * @returns The enriched set of table columns\n */\nexport function addComputedColumns(\n\ttableColumns: TableColumn[],\n\ttableType: TableType,\n\tvisualizationPath: string,\n\tconverterContext: ConverterContext<PageContextPathTarget>\n): TableColumn[] {\n\tif (![\"GridTable\", \"TreeTable\", \"AnalyticalTable\"].includes(tableType)) {\n\t\t// Computed columns are not used in Responsive tables\n\t\treturn tableColumns;\n\t}\n\n\t// In case a grid table or tree table is used, we display the situations indicator in a separate column\n\t// so we have to disable it here to ensure, that the field building block\n\t// does not render it into the ID column\n\tconst columnWithSituationsIndicator: TableColumn | undefined = tableColumns.find(\n\t\t(column) => column.formatOptions?.hasSituationsIndicator !== undefined && column.formatOptions?.hasSituationsIndicator === true\n\t);\n\tif (columnWithSituationsIndicator?.formatOptions) {\n\t\t// Switch off the situations indicator in the found column\n\t\tcolumnWithSituationsIndicator.formatOptions.hasSituationsIndicator = false;\n\n\t\t// Insert a separate situations indicator column\n\t\tconst situationsIndicatorColumn: ComputedTableColumn = {\n\t\t\tkey: \"situationsIndicator\",\n\t\t\tname: \"situationsIndicator\",\n\t\t\tpropertyKey: columnWithSituationsIndicator.name,\n\t\t\tisSituationsIndicator: true,\n\t\t\tavailability: \"Default\",\n\t\t\tlabel: \"{sap.fe.i18n>C_SITUATIONS_STATUS_COLUMN_LABEL_TOOLTIP}\",\n\t\t\ttooltip: \"{sap.fe.i18n>C_SITUATIONS_STATUS_COLUMN_LABEL_TOOLTIP}\",\n\t\t\ttype: ColumnType.Computed,\n\t\t\tformatOptions: null,\n\t\t\texportSettings: null,\n\t\t\tclipboardSettings: null,\n\t\t\tpropertyInfos: undefined,\n\t\t\tcaseSensitive: false\n\t\t};\n\n\t\t// Place the draft status column after the first visible column\n\t\tconst indexOfFirstVisibleColumn: int = tableColumns.findIndex((column) => column.availability !== \"Hidden\");\n\t\ttableColumns.splice(indexOfFirstVisibleColumn + 1, 0, situationsIndicatorColumn);\n\t}\n\n\t// In case a grid table or tree table is used, we display the draft indicator in a separate column\n\t// so we have to disable it here to ensure, that the field building block\n\t// does not render it into the ID column\n\t// The additional column is only added for tables on a LR and in case tehe entity is draft enabled!\n\tconst columnsWithDraftIndicator: TableColumn[] = tableColumns.filter((column) => column.formatOptions?.hasDraftIndicator === true);\n\tif (\n\t\tcolumnsWithDraftIndicator.length &&\n\t\tconverterContext.getTemplateType() === TemplateType.ListReport &&\n\t\t(ModelHelper.isDraftNode(converterContext.getEntitySet()) || ModelHelper.isDraftRoot(converterContext.getEntitySet()))\n\t) {\n\t\t// Switch off the draft indicator in the found column\n\t\tcolumnsWithDraftIndicator.forEach((columnWithDraftIndicator: TableColumn) => {\n\t\t\tif (columnWithDraftIndicator?.formatOptions) {\n\t\t\t\tcolumnWithDraftIndicator.formatOptions.hasDraftIndicator = false;\n\t\t\t}\n\t\t});\n\n\t\t// Insert a separate draft indicator column\n\t\tconst draftIndicatorColumn: ComputedTableColumn = {\n\t\t\tkey: \"draftStatus\",\n\t\t\tname: \"draftStatus\",\n\t\t\tpropertyKey: columnsWithDraftIndicator[0].name,\n\t\t\tisDraftIndicator: true,\n\t\t\tavailability: \"Default\",\n\t\t\tlabel: \"{sap.fe.i18n>C_DRAFT_STATUS_COLUMN_LABEL_TOOLTIP}\",\n\t\t\ttooltip: \"{sap.fe.i18n>C_DRAFT_STATUS_COLUMN_LABEL_TOOLTIP}\",\n\t\t\ttype: ColumnType.Computed,\n\t\t\tformatOptions: null,\n\t\t\texportSettings: null,\n\t\t\tcaseSensitive: false,\n\t\t\tclipboardSettings: null\n\t\t};\n\t\tlet columnIndexToInsertAfter: int = 0;\n\t\tif (columnWithSituationsIndicator) {\n\t\t\t// If there's a situations indicator column, place the draft status column before it\n\t\t\tcolumnIndexToInsertAfter =\n\t\t\t\ttableColumns.findIndex((column) => (column as ComputedTableColumn).isSituationsIndicator === true) - 1;\n\t\t} else {\n\t\t\t// Otherwise place the draft status column after the first visible column\n\t\t\tcolumnIndexToInsertAfter = tableColumns.findIndex((column) => column.availability !== \"Hidden\");\n\t\t}\n\t\ttableColumns.splice(columnIndexToInsertAfter + 1, 0, draftIndicatorColumn);\n\t}\n\n\treturn tableColumns;\n}\n\n/**\n * Provides the required properties set on the annotations.\n * @param converterContext  The instance of the converter context\n * @returns The paths of the restricted properties\n */\nexport function getRequiredProperties(converterContext: ConverterContext<PageContextPathTarget>): PropertyPath[] {\n\treturn getContextPropertyRestriction(\n\t\tconverterContext.getDataModelObjectPath(),\n\t\t(capabilities) => {\n\t\t\treturn (capabilities as EntitySetAnnotations_Capabilities | undefined)?.InsertRestrictions?.RequiredProperties;\n\t\t},\n\t\tfalse\n\t);\n}\n\n/**\n * Determines if the property is annotated as a required property.\n * @param name The name of the property\n * @param converterContext The instance of the converter context\n * @returns True if the property is required\n */\nfunction isAnnotatedRequiredProperty(name: string, converterContext: ConverterContext<PageContextPathTarget>): boolean {\n\treturn getRequiredProperties(converterContext)\n\t\t.map((property) => property.$target?.fullyQualifiedName)\n\t\t.includes(name);\n}\n\n/**\n * Gets the data type of a column for the export.\n * @param dataType The data type of a property, column\n * @param isATimezone Is the given property a timezone\n * @param isCurrency Is the given property a currency\n * @param exportSettings The already detected export settings from datafields\n * @returns The supported export type\n */\nfunction getExportDataType(\n\tdataType: string | undefined,\n\tisATimezone = false,\n\tisCurrency = false,\n\texportSettings?: ColumnExportSettings\n): string {\n\tlet exportDataType = \"String\";\n\tif (!dataType || exportSettings?.dataPointTargetValue) {\n\t\treturn exportDataType;\n\t}\n\tif (exportSettings?.isCurrency || isCurrency) {\n\t\treturn \"Currency\";\n\t}\n\tif (isATimezone) {\n\t\treturn \"Timezone\";\n\t}\n\tif (exportSettings?.wrap) {\n\t\treturn exportDataType;\n\t}\n\tswitch (dataType) {\n\t\tcase \"Edm.Decimal\":\n\t\tcase \"Edm.Int32\":\n\t\tcase \"Edm.Int64\":\n\t\tcase \"Edm.Double\":\n\t\tcase \"Edm.Byte\":\n\t\t\texportDataType = \"Number\";\n\t\t\tbreak;\n\t\tcase \"Edm.DateOfTime\":\n\t\tcase \"Edm.Date\":\n\t\t\texportDataType = \"Date\";\n\t\t\tbreak;\n\t\tcase \"Edm.DateTimeOffset\":\n\t\t\texportDataType = \"DateTime\";\n\t\t\tbreak;\n\t\tcase \"Edm.TimeOfDay\":\n\t\t\texportDataType = \"Time\";\n\t\t\tbreak;\n\t\tcase \"Edm.Boolean\":\n\t\t\texportDataType = \"Boolean\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texportDataType = \"String\";\n\t}\n\treturn exportDataType;\n}\n\n/**\n * Adds the tooltip configuration for a given column.\n * @param property The property referenced on the column\n * @param column The column to be updated\n */\nfunction _addToolTip(property: Property, column: AnnotationTableColumn): void {\n\tconst tooltip = _getTooltip(property) ?? column.label;\n\tif (tooltip) {\n\t\tcolumn.tooltip = tooltip;\n\t}\n}\n\nfunction _getCollectedNavigationPropertyLabels(\n\trelativePath: string,\n\tconverterContext: ConverterContext<PageContextPathTarget>\n): string[] | undefined {\n\tconst navigationProperties = enhanceDataModelPath(converterContext.getDataModelObjectPath(), relativePath).navigationProperties;\n\tif (navigationProperties?.length > 0) {\n\t\tconst collectedNavigationPropertyLabels: string[] = [];\n\t\tnavigationProperties.forEach((navProperty) => {\n\t\t\tcollectedNavigationPropertyLabels.push(getLabel(navProperty) || navProperty.name);\n\t\t});\n\t\treturn collectedNavigationPropertyLabels;\n\t}\n}\n\n/**\n * Creates a property using the text arrangement annotation set to text only.\n * @param converterContext The converter context.\n * @param propertyDataModelObjectPath The corresponding DataModelObjectPath.\n * @param lineItem The column to be evaluated.\n * @param columnsToBeCreated The list of columns to be created.\n * @param relativePath The relative path to the target property based on the context.\n * @param restrictionsOnProperties The existing restrictions on properties\n */\nfunction createPropertyAnnotatedTextOnly(\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tpropertyDataModelObjectPath: DataModelObjectPath<DataFieldAbstractTypes>,\n\tlineItem: DataFieldAbstractTypes,\n\tcolumnsToBeCreated: Record<string, Property>,\n\trelativePath: string,\n\trestrictionsOnProperties: RestrictionsOnProperties\n): void {\n\tconst isPropertyNavigated =\n\t\tpropertyDataModelObjectPath.navigationProperties.length !== converterContext.getDataModelObjectPath().navigationProperties.length;\n\tif (isPropertyNavigated && isDataField(lineItem)) {\n\t\tcolumnsToBeCreated[relativePath] = lineItem.Value.$target;\n\t\trestrictionsOnProperties.nonSortableProperties.push(relativePath);\n\t} else if (isDataFieldForAnnotation(lineItem) && hasFieldGroupTarget(lineItem)) {\n\t\t(lineItem.Target.$target as FieldGroup).Data.forEach((field) => {\n\t\t\tif (isDataField(field) && getDisplayMode(field.Value.$target) === \"Description\") {\n\t\t\t\tconst inheredPropertyDataModelObjectPath = enhanceDataModelPath(\n\t\t\t\t\tconverterContext.getDataModelObjectPath(),\n\t\t\t\t\tfield.Value.path\n\t\t\t\t);\n\t\t\t\tconst isInheredPropertyNavigated =\n\t\t\t\t\tinheredPropertyDataModelObjectPath.navigationProperties.length !==\n\t\t\t\t\tconverterContext.getDataModelObjectPath().navigationProperties.length;\n\t\t\t\tif (isInheredPropertyNavigated) {\n\t\t\t\t\tcolumnsToBeCreated[field.Value.path] = field.Value.$target;\n\t\t\t\t\trestrictionsOnProperties.nonSortableProperties.push(field.Value.path);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * Retrieves the property type configuration based on the provided property or data type.\n * @param property The property or data field to determine the type configuration for.\n * @param dataType The data type to use for type configuration if not determined from the property.\n * @returns The property type configuration object.\n */\nexport function getTypeConfig(property: Property | DataFieldAbstractTypes | undefined, dataType?: string): PropertyTypeConfig {\n\tlet targetMapping,\n\t\tformatOptions: PropertyTypeFormatOptions | undefined = {};\n\tif (isProperty(property)) {\n\t\ttargetMapping = isTypeDefinition(property.targetType)\n\t\t\t? EDM_TYPE_MAPPING[property.targetType.underlyingType]\n\t\t\t: EDM_TYPE_MAPPING[property.type];\n\t}\n\tif (!targetMapping && dataType !== undefined) {\n\t\ttargetMapping = EDM_TYPE_MAPPING[dataType];\n\t}\n\tconst propertyTypeConfig: PropertyTypeConfig = {\n\t\ttype: targetMapping?.type\n\t};\n\tif (targetMapping && isProperty(property)) {\n\t\tconst constraints = setUpConstraints(targetMapping, property);\n\t\tif (Object.keys(constraints).length) {\n\t\t\tpropertyTypeConfig.constraints = constraints;\n\t\t}\n\t}\n\tif (propertyTypeConfig.type !== \"sap.ui.model.odata.type.Stream\") {\n\t\tif (\n\t\t\tpropertyTypeConfig?.type?.indexOf(\"sap.ui.model.odata.type.Int\") === 0 ||\n\t\t\tpropertyTypeConfig?.type?.indexOf(\"sap.ui.model.odata.type.Double\") === 0\n\t\t) {\n\t\t\tformatOptions = { parseAsString: false, emptyString: \"\" };\n\t\t}\n\t\tif (propertyTypeConfig.type === \"sap.ui.model.odata.type.String\" && propertyTypeConfig.constraints?.nullable === false) {\n\t\t\tformatOptions = { parseKeepsEmptyString: true };\n\t\t}\n\t}\n\tif (Object.keys(formatOptions).length) {\n\t\tpropertyTypeConfig.formatOptions = formatOptions;\n\t}\n\treturn propertyTypeConfig;\n}\n\n/**\n * Add a description property to the list of description properties used by the columns of a table.\n * @param displayModeOfDescriptionPropertiesMap The list of properties referenced as text on a text arrangement annotation\n * @param relatedPropertiesInfo The related properties linked to the column (named also complex property)\n * @param relatedPropertyName The property name to be added\n */\nfunction addPropertyToDisplayModeOfDescriptionPropertiesMap(\n\tdisplayModeOfDescriptionPropertiesMap: Record<string, DisplayMode>,\n\trelatedPropertiesInfo: ComplexPropertyInfo,\n\trelatedPropertyName: string\n): void {\n\tif (\n\t\trelatedPropertiesInfo.properties[relatedPropertyName].displayModeOfPropertyUsedAsDescription &&\n\t\t!displayModeOfDescriptionPropertiesMap[relatedPropertyName]\n\t) {\n\t\tdisplayModeOfDescriptionPropertiesMap[relatedPropertyName] =\n\t\t\trelatedPropertiesInfo.properties[relatedPropertyName].displayModeOfPropertyUsedAsDescription!;\n\t}\n}\n\n/**\n * Computes the referenced properties of a LineItem in case the LineItem is annotated as hidden.\n * @param existingColumns The list of columns created from LineItems and from properties of entityType\n * @param name The name of the property to be evaluated\n * @param column The given column from lineItem or property of entitySet\n */\nfunction computeHiddenOnRelatedColumns(existingColumns: AnnotationTableColumn[], name: string, column: AnnotationTableColumn): void {\n\tconst relatedAnnotationColumns = existingColumns.filter(\n\t\t(existingColumn) =>\n\t\t\t(existingColumn.propertyInfos?.includes(name) && existingColumn.isPartOfLineItem) ||\n\t\t\t(existingColumn.isPartOfLineItem && existingColumn.relativePath === column.relativePath)\n\t);\n\tcolumn.isPartOfLineItem = !!relatedAnnotationColumns.length;\n\tif (\n\t\trelatedAnnotationColumns.length &&\n\t\t!relatedAnnotationColumns?.some((annotationColumn) => annotationColumn.availability !== \"Hidden\")\n\t) {\n\t\tcolumn.sortable = false;\n\t\tcolumn.isGroupable = false;\n\t\tcolumn.filterable = false;\n\t}\n}\n\n/**\n * Gets the export settings properties of a manifest column.\n * @param exportSettings The customized/overwritten export settings of a manifest column\n * @param annotationColumns The list of columns created from LineItems\n * @param converterContext The converter context\n * @param entityType The target entity type\n * @param propertyInfos The properties linked to a complex column\n * @param columnKey The column key of the column to be overwritten\n * @returns The export settings of the column merging customized export settings with the default values detected on the annotation column\n */\nfunction getCustomExportSettings(\n\texportSettings: ColumnExportSettings | undefined,\n\tannotationColumns: AnnotationTableColumn[],\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tentityType: EntityType,\n\tpropertyInfos?: string[],\n\tcolumnKey?: string\n): ColumnExportSettings | null {\n\tlet columnFromAnnotations;\n\tif (columnKey) {\n\t\tcolumnFromAnnotations = annotationColumns.find((annotationColumn) => annotationColumn.key === columnKey);\n\t\tif (columnFromAnnotations?.exportSettings === null) {\n\t\t\treturn columnFromAnnotations?.exportSettings;\n\t\t}\n\t}\n\tconst enableWrapping =\n\t\texportSettings?.wrap ??\n\t\t(!!(exportSettings?.property && exportSettings.property?.length > 1) || !!(propertyInfos && propertyInfos.length > 1));\n\n\tconst customExportSettings: ColumnExportSettings = {\n\t\t...columnFromAnnotations?.exportSettings,\n\t\ttype: exportSettings?.type ?? columnFromAnnotations?.exportSettings?.type,\n\t\ttemplate:\n\t\t\texportSettings?.template ??\n\t\t\t_appendCustomTemplate(propertyInfos, exportSettings?.property) ??\n\t\t\tcolumnFromAnnotations?.exportSettings?.template,\n\t\tproperty: exportSettings?.property,\n\t\twidth: exportSettings?.width,\n\t\twrap: enableWrapping,\n\t\tlabel: exportSettings?.label,\n\t\ttextAlign: exportSettings?.textAlign,\n\t\ttrueValue: exportSettings?.trueValue,\n\t\tfalseValue: exportSettings?.falseValue,\n\t\tvalueMap: exportSettings?.valueMap\n\t};\n\treturn removeUndefinedFromExportSettings(customExportSettings);\n}\n"],"mappings":"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","ignoreList":[]}