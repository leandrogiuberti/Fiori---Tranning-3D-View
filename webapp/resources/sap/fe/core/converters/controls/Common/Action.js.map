{"version":3,"file":"Action.js","names":["ButtonType","_exports","aiIcon","PRINT_ICON","EXPORT_TO_SPREADSHEET_ICON","EXPORT_TO_CSV_ICON","EXPORT_TO_PDF_ICON","getVisibilityEnablementMenuActions","actions","menuActionNotVisible","menuActionVisiblePaths","atleastOneMenuItemsVisible","menuItemsVisiblePaths","forEach","menuAction","visible","valueOf","push","menu","length","menuItem","menuItemVisible","toString","compileExpression","resolveBindingString","visibleExpressions","map","menuItemVisiblePath","and","or","addCollaborationCondition","action","type","not","equal","UI","hasCollaborationAuthorization","mapActionByKey","manifestActions","annotationActions","actionKey","annotationAction","find","key","manifestAction","resultAction","Object","keys","filter","actionAnnotation","ActionType","Menu","enabled","prop","propKey","canBeMenuItem","DataFieldForAction","DataFieldForIntentBasedNavigation","mapMenuDefaultAction","commandActions","defaultAction","command","mapMenuItems","mappedMenuItems","matchingAnnotationAction","menuItemKey","mappedMenuAction","transformMenuActionsAndIdentifyCommands","allActions","actionKeysToDelete","undefined","_getManifestEnabled","isAnnotationAction","converterContext","forContextMenu","arguments","result","getManifestActionBooleanPropertyWithFormatter","internalModelProperty","ifElse","requiresSelection","enableOnSelect","pathInModel","greaterOrEqual","_getManifestVisible","overrideManifestConfigurationWithAnnotation","annotationPath","press","getActionsFromManifest","navigationSettings","considerNavigationSettings","hiddenActions","facetName","lastDotIndex","lastIndexOf","id","startsWith","getCustomActionID","Default","enabledForContextMenu","handlerModule","substring","replace","handlerMethod","text","noWrap","__noWrap","replaceSpecialChars","defaultValuesExtensionFunction","defaultValuesFunction","position","anchor","placement","Placement","After","isNavigable","isActionNavigable","enableAutoScroll","inline","isAIOperation","priority","group","propertyValue","resolvedBinding","isConstant","value","constant","methodPath","formatResult","fpmFormatter","customBooleanPropertyCheck","getDataModelObjectPath","contextLocation","targetEntityType","getEntityType","removeDuplicateActions","oMenuItemKeys","actionMenu","reduce","item","_ref","getEnabledForAnnotationActionExpression","actionTarget","pathFromContextLocation","annotations","Core","OperationAvailable","dataModelObjectPath","isEnabledExp","getActionEnabledExpression","getConvertedTypes","collaborationOnRoot","ModelHelper","isCollaborationDraftSupportedFromConverterContext","getDraftRoot","getEntitySet","getEnabledForAnnotationAction","getSemanticObjectMapping","mappings","mapping","LocalProperty","$PropertyPath","SemanticObjectProperty","bIsNavigationConfigured","detailOrDisplay","detail","display","route","afterExecution","navigateToInstance","dataFieldIsCopyAction","dataField","IsCopyAction","$Type","getCopyAction","copyDataFields","Log","error","getAnnotationMenuActionItems","menuActionItems","getMatchingManifestAction","annotationMenuItems","matchingManifestActions","prepareMenuActions","unpreparedActions","overrideMenuActions","foundAction","menuItemIndex","overrideMenuAction","splice","isMenuAIOperation","isAIOperationOccurrences","isActionAIOperation","isCustomActionAIOperation","ActionTarget","IsAIOperation","customAction","addSeparators","groupsUsed","includes","Separator","Before"],"sources":["./Action.ts"],"sourcesContent":["import type { Action } from \"@sap-ux/vocabularies-types\";\nimport type { SemanticObjectMappingType } from \"@sap-ux/vocabularies-types/vocabularies/Common\";\nimport type {\n\tDataFieldForActionAbstractTypes,\n\tDataFieldForActionGroupTypes,\n\tDataFieldForActionTypes\n} from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport { UIAnnotationTypes } from \"@sap-ux/vocabularies-types/vocabularies/UI\";\nimport Log from \"sap/base/Log\";\nimport type { BindingToolkitExpression, CompiledBindingToolkitExpression } from \"sap/fe/base/BindingToolkit\";\nimport {\n\tand,\n\tcompileExpression,\n\tconstant,\n\tequal,\n\tformatResult,\n\tgreaterOrEqual,\n\tifElse,\n\tisConstant,\n\tnot,\n\tor,\n\tpathInModel,\n\tresolveBindingString\n} from \"sap/fe/base/BindingToolkit\";\nimport type {\n\tCustomDefinedTableColumnForOverride,\n\tManifestAction,\n\tNavigationSettingsConfiguration\n} from \"sap/fe/core/converters/ManifestSettings\";\nimport { ActionType } from \"sap/fe/core/converters/ManifestSettings\";\nimport type { PageContextPathTarget } from \"sap/fe/core/converters/TemplateConverter\";\nimport type { ConfigurableObject, CustomElement, OverrideType } from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport { Placement } from \"sap/fe/core/converters/helpers/ConfigurableObject\";\nimport { getCustomActionID } from \"sap/fe/core/converters/helpers/ID\";\nimport fpmFormatter from \"sap/fe/core/formatters/FPMFormatter\";\nimport { UI } from \"sap/fe/core/helpers/BindingHelper\";\nimport ModelHelper from \"sap/fe/core/helpers/ModelHelper\";\nimport { replaceSpecialChars } from \"sap/fe/core/helpers/StableIdHelper\";\nimport { getActionEnabledExpression } from \"sap/fe/core/templating/UIFormatters\";\nimport type { OverflowToolbarPriority } from \"sap/m/library\";\nimport type View from \"sap/ui/core/mvc/View\";\nimport type Context from \"sap/ui/model/Context\";\nimport type { MetaModelType } from \"types/metamodel_types\";\nimport type ConverterContext from \"../../ConverterContext\";\n\nexport enum ButtonType {\n\tAccept = \"Accept\",\n\tAttention = \"Attention\",\n\tBack = \"Back\",\n\tCritical = \"Critical\",\n\tDefault = \"Default\",\n\tEmphasized = \"Emphasized\",\n\tGhost = \"Ghost\",\n\tNegative = \"Negative\",\n\tNeutral = \"Neutral\",\n\tReject = \"Reject\",\n\tSuccess = \"Success\",\n\tTransparent = \"Transparent\",\n\tUnstyled = \"Unstyled\",\n\tUp = \"Up\"\n}\n\nexport const aiIcon = \"sap-icon://ai\";\nexport const PRINT_ICON = \"sap-icon://print\";\nexport const EXPORT_TO_SPREADSHEET_ICON = \"sap-icon://excel-attachment\";\nexport const EXPORT_TO_CSV_ICON = \"sap-icon://document\";\nexport const EXPORT_TO_PDF_ICON = \"sap-icon://pdf-attachment\";\n\nexport type BaseAction = ConfigurableObject & {\n\tid?: string;\n\ttext?: string;\n\ttype?: ActionType;\n\tpress?: string;\n\tenabled?: CompiledBindingToolkitExpression;\n\tenabledForContextMenu?: CompiledBindingToolkitExpression;\n\tvisible?: CompiledBindingToolkitExpression;\n\tenableOnSelect?: string;\n\tannotationPath?: string;\n\tdefaultValuesExtensionFunction?: string;\n\tisNavigable?: boolean;\n\tenableAutoScroll?: boolean;\n\tparentEntityDeleteEnabled?: CompiledBindingToolkitExpression;\n\tmenu?: BaseAction[];\n\tfacetName?: string;\n\tcommand?: string | undefined;\n\tisAIOperation?: boolean;\n\tpriority?: OverflowToolbarPriority;\n\tgroup?: number;\n};\n\nexport type AnnotationAction = BaseAction & {\n\ttype: ActionType.DataFieldForIntentBasedNavigation | ActionType.DataFieldForAction | ActionType.Menu | ActionType.Copy;\n\tannotationPath: string;\n\tcustomData?: string;\n\trequiresDialog?: string;\n\tbinding?: string;\n\tbuttonType?: ButtonType.Ghost | ButtonType.Transparent | string;\n};\n\nexport type AnnotationActionActionGroup = BaseAction & {\n\t// implements DataFieldForActionGroup\n\ttype: ActionType.Menu;\n\tmenu: AnnotationAction[];\n};\n\nexport type CustomAction = CustomElement<\n\tBaseAction & {\n\t\thandlerMethod?: string;\n\t\thandlerModule?: string;\n\t\tnoWrap?: boolean; // Indicates that we want to avoid the wrapping from the FPMHelper\n\t\trequiresSelection?: boolean;\n\t\tdefaultAction?: string | BaseAction | CustomAction; // Indicates whether a default action exists in this context\n\t}\n>;\n\nexport type AnnotationActionGroup = BaseAction & {\n\t// implements DataFieldForActionGroup\n\ttype: ActionType.Menu;\n\tmenu: AnnotationAction[];\n};\n\nexport type CombinedAction = {\n\tactions: BaseAction[];\n\tcommandActions: Record<string, CustomAction>;\n};\n\nexport type OverrideTypeAction = {\n\tenableAutoScroll?: OverrideType.overwrite;\n\tdefaultValuesExtensionFunction?: OverrideType.overwrite;\n\tisNavigable?: OverrideType.overwrite;\n\tenableOnSelect?: OverrideType.overwrite;\n\tmenu?: OverrideType.overwrite;\n\n\t// Can be overwritten by manifest configuration and should be aligned for all actions\n\tenabled: OverrideType.overwrite;\n\tvisible: OverrideType.overwrite;\n\tcommand: OverrideType.overwrite;\n\tposition: OverrideType.overwrite;\n\tpriority?: OverrideType.overwrite;\n\tgroup?: OverrideType.overwrite;\n};\n\nexport type DataFieldForActionOrActionGroup = DataFieldForActionTypes | DataFieldForActionGroupTypes;\n\ntype MenuAction =\n\t| BaseAction\n\t| {\n\t\t\tvisible?: string[];\n\t\t\tenabled?: string[];\n\t\t\tmenu?: BaseAction[];\n\t  };\n\n/**\n * Method provides actions collection after calculating the visible setting for all actions of type menu depending on its visible setting and its menu items visible settings.\n * @param actions Collection of actions\n * @returns Collection of actions with visible setting set for actions of type menu\n */\nexport const getVisibilityEnablementMenuActions = (actions: CustomAction[]): CustomAction[] => {\n\tlet menuActionNotVisible: string | boolean,\n\t\tmenuActionVisiblePaths: string[],\n\t\tatleastOneMenuItemsVisible: boolean,\n\t\tmenuItemsVisiblePaths: string[];\n\tactions.forEach((menuAction: MenuAction) => {\n\t\tmenuActionNotVisible = menuAction.visible?.valueOf() === \"false\";\n\t\tatleastOneMenuItemsVisible = false;\n\t\tmenuItemsVisiblePaths = [];\n\t\tmenuActionVisiblePaths = [];\n\t\tif (menuAction.visible && !(menuAction.visible.valueOf() === \"true\" || menuAction.visible.valueOf() === \"false\")) {\n\t\t\tmenuActionVisiblePaths.push(menuAction.visible as string);\n\t\t}\n\t\tif (menuAction?.menu?.length) {\n\t\t\tmenuAction?.menu?.forEach((menuItem: BaseAction): void => {\n\t\t\t\tconst menuItemVisible = menuItem.visible;\n\t\t\t\tif (menuItemVisible && (typeof menuItemVisible === \"boolean\" || menuItemVisible.valueOf() === \"true\")) {\n\t\t\t\t\tatleastOneMenuItemsVisible = true;\n\t\t\t\t} else if (menuItemVisible && menuItemVisible.valueOf() !== \"false\") {\n\t\t\t\t\tmenuItemsVisiblePaths.push(menuItemVisible.valueOf());\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (menuActionNotVisible) {\n\t\t\t\t// if menu is statically visible false\n\t\t\t\tmenuAction.visible = false.toString();\n\t\t\t} else if (!atleastOneMenuItemsVisible && !menuItemsVisiblePaths.length) {\n\t\t\t\t// if all menu items are statically visible false\n\t\t\t\tmenuAction.visible = false.toString();\n\t\t\t} else if (atleastOneMenuItemsVisible && !menuActionVisiblePaths.length) {\n\t\t\t\t// if at least one menu item is statically visible true and no visible setting for menu\n\t\t\t\tmenuAction.visible = true.toString();\n\t\t\t} else if (atleastOneMenuItemsVisible) {\n\t\t\t\t// if at least one menu item, then just consider visible setting of the menu\n\t\t\t\tmenuAction.visible = compileExpression(resolveBindingString(menuAction.visible as string));\n\t\t\t} else if (menuActionVisiblePaths.length || menuItemsVisiblePaths.length) {\n\t\t\t\t// If the menu is set to invisible, it should be invisible, otherwise the visibility should be calculated from the items\n\t\t\t\tconst visibleExpressions: BindingToolkitExpression<boolean>[] = menuItemsVisiblePaths.map((menuItemVisiblePath) =>\n\t\t\t\t\tresolveBindingString(menuItemVisiblePath, \"boolean\")\n\t\t\t\t);\n\t\t\t\tmenuAction.visible = compileExpression(\n\t\t\t\t\tand(resolveBindingString((menuAction.visible as string) || true, \"boolean\"), or(...visibleExpressions))\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmenuAction.visible = (!menuActionNotVisible).toString();\n\t\t\t}\n\t\t}\n\t});\n\treturn actions;\n};\n\n/**\n * Adds the collaboration condition to all actions with type ForAction.\n * This disables the actions if the collaboration is enabled, but the user doesn't have the authorization from the back end.\n * @param actions The list of definitions of the table actions.\n */\nexport function addCollaborationCondition(actions: CustomAction[]): void {\n\tactions.forEach((action) => {\n\t\tif (action.visible?.valueOf() === \"false\") {\n\t\t\treturn;\n\t\t}\n\t\tif (action.type === \"ForAction\") {\n\t\t\taction.visible = compileExpression(\n\t\t\t\tand(resolveBindingString(action.visible as string, \"boolean\"), not(equal(UI.hasCollaborationAuthorization, false)))\n\t\t\t);\n\t\t}\n\t});\n}\n\n/**\n * Maps an action by its key, based on the given annotation actions and manifest configuration. The result already represents the\n * merged action from both configuration sources.\n *\n * This function also returns an indication whether the action can be a menu item, saying whether it is visible or of a specific type\n * that allows this.\n * @param manifestActions Actions defined in the manifest\n * @param annotationActions Actions defined through annotations\n * @param actionKey Action Key to look up\n * @returns Merged action and indicator whether it can be a menu item\n */\nfunction mapActionByKey(\n\tmanifestActions: Record<string, PartiallyConvertedCustomAction>,\n\tannotationActions: BaseAction[],\n\tactionKey: string\n): { action: BaseAction | CustomAction; canBeMenuItem: boolean | CompiledBindingToolkitExpression } {\n\tconst annotationAction = annotationActions.find((action) => action.key === actionKey);\n\tconst manifestAction = manifestActions[actionKey];\n\tlet resultAction: PartiallyConvertedCustomAction | BaseAction = { ...(annotationAction ?? manifestAction) };\n\n\t// actions inside menus can't be found on top level, so assign actions from menu to it\n\tif (Object.keys(resultAction).length === 0) {\n\t\tannotationActions\n\t\t\t.filter((actionAnnotation: BaseAction) => {\n\t\t\t\treturn actionAnnotation.type === ActionType.Menu;\n\t\t\t})\n\t\t\t.forEach((menuAction: BaseAction) => {\n\t\t\t\tmenuAction.menu?.forEach((menuItem: BaseAction) => {\n\t\t\t\t\tif (menuItem.key === actionKey) {\n\t\t\t\t\t\tresultAction = menuItem;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t}\n\n\t// Annotation action and manifest configuration already has to be merged here as insertCustomElements only considers top-level actions\n\tif (annotationAction) {\n\t\t// If enabled or visible is not set in the manifest, use the annotation value and hence do not overwrite\n\t\tresultAction.enabled = manifestAction?.enabled ?? annotationAction.enabled;\n\t\tresultAction.visible = manifestAction?.visible ?? annotationAction.visible;\n\n\t\tfor (const prop in manifestAction || {}) {\n\t\t\tconst propKey = prop as keyof BaseAction;\n\t\t\tif (!annotationAction[propKey] && propKey !== \"menu\") {\n\t\t\t\tresultAction[propKey] = manifestAction[propKey] as never;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst canBeMenuItem =\n\t\tresultAction?.visible ||\n\t\tresultAction?.type === ActionType.DataFieldForAction ||\n\t\tresultAction?.type === ActionType.DataFieldForIntentBasedNavigation;\n\n\treturn {\n\t\taction: resultAction as BaseAction | CustomAction,\n\t\tcanBeMenuItem\n\t};\n}\n\n/**\n * Map the default action key of a menu to its actual action configuration and identify whether this default action is a command.\n * @param menuAction Menu action to map the default action for\n * @param manifestActions Actions defined in the manifest\n * @param annotationActions Actions defined through annotations\n * @param commandActions Array of command actions to push the default action to if applicable\n */\nfunction mapMenuDefaultAction(\n\tmenuAction: PartiallyConvertedCustomAction,\n\tmanifestActions: Record<string, PartiallyConvertedCustomAction>,\n\tannotationActions: BaseAction[],\n\tcommandActions: Record<string, CustomAction | BaseAction>\n): void {\n\tconst { action, canBeMenuItem } = mapActionByKey(manifestActions, annotationActions, menuAction.defaultAction as string);\n\n\tif (canBeMenuItem) {\n\t\tmenuAction.defaultAction = action;\n\t}\n\n\tif (action.command) {\n\t\tcommandActions[action.key] = action;\n\t}\n}\n\n/**\n * Map the menu item keys of a menu to their actual action configurations and identify whether they are commands.\n * @param menuAction Menu action to map the menu items for\n * @param manifestActions Actions defined in the manifest\n * @param annotationActions Actions defined through annotations\n * @param commandActions Array of command actions to push the menu item actions to if applicable\n */\nfunction mapMenuItems(\n\tmenuAction: PartiallyConvertedCustomAction,\n\tmanifestActions: Record<string, PartiallyConvertedCustomAction>,\n\tannotationActions: BaseAction[],\n\tcommandActions: Record<string, BaseAction | CustomAction>\n): void {\n\tconst mappedMenuItems: (CustomAction | BaseAction)[] = [];\n\tconst matchingAnnotationAction = annotationActions.find((annotationAction) => annotationAction.key === menuAction.key);\n\n\tif (menuAction.menu?.length !== 0) {\n\t\tfor (const menuItemKey of menuAction.menu ?? []) {\n\t\t\tconst { action, canBeMenuItem } = mapActionByKey(manifestActions, annotationActions, menuItemKey);\n\n\t\t\tif (canBeMenuItem) {\n\t\t\t\tmappedMenuItems.push(action);\n\t\t\t}\n\n\t\t\tif (action.command) {\n\t\t\t\tcommandActions[menuItemKey] = action;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no menu items are assigned to the manifest-override-menu, it inherits the items from the previous menu\n\telse if (matchingAnnotationAction) {\n\t\tmatchingAnnotationAction.menu?.forEach((menuItem) => mappedMenuItems.push(menuItem));\n\t}\n\n\tconst mappedMenuAction = menuAction as CustomAction;\n\tmappedMenuAction.menu = mappedMenuItems;\n\n\t// If the menu is set to invisible, it should be invisible, otherwise the visibility should be calculated from the items\n\tconst visibleExpressions: BindingToolkitExpression<boolean>[] = mappedMenuItems.map((menuItem) =>\n\t\tresolveBindingString(menuItem.visible as string, \"boolean\")\n\t);\n\tmappedMenuAction.visible = compileExpression(\n\t\tand(resolveBindingString(menuAction.visible as string, \"boolean\"), or(...visibleExpressions))\n\t);\n}\n\n/**\n * Transforms the flat collection of actions into a nested structures of menus. The result is a record of actions that are either menus or\n * ones that do not appear in menus as menu items. It also returns a list of actions that have an assigned command.\n *\n * Note that menu items are already the merged result of annotation actions and their manifest configuration, as {@link insertCustomElements}\n * only considers root-level actions.\n * @param manifestActions Actions defined in the manifest\n * @param annotationActions Actions defined through annotations\n * @returns The transformed actions from the manifest and a list of command actions\n */\nfunction transformMenuActionsAndIdentifyCommands(\n\tmanifestActions: Record<string, PartiallyConvertedCustomAction>,\n\tannotationActions: BaseAction[]\n): Record<string, Record<string, CustomAction>> {\n\tconst allActions: Record<string, CustomAction> = {};\n\tconst actionKeysToDelete: string[] = [];\n\tconst commandActions: Record<string, CustomAction> = {};\n\n\tfor (const actionKey in manifestActions) {\n\t\tconst manifestAction: PartiallyConvertedCustomAction = manifestActions[actionKey];\n\n\t\tif (manifestAction.defaultAction !== undefined) {\n\t\t\tmapMenuDefaultAction(manifestAction, manifestActions, annotationActions, commandActions);\n\t\t}\n\n\t\tif (manifestAction.type === ActionType.Menu) {\n\t\t\tmapMenuItems(manifestAction, manifestActions, annotationActions, commandActions);\n\n\t\t\t// Menu has no visible items, so remove it\n\t\t\tif (!manifestAction.menu?.length) {\n\t\t\t\tactionKeysToDelete.push(manifestAction.key);\n\t\t\t}\n\t\t}\n\n\t\tif (manifestAction.command) {\n\t\t\tcommandActions[actionKey] = manifestAction as CustomAction;\n\t\t}\n\n\t\tallActions[actionKey] = manifestAction as CustomAction;\n\t}\n\n\tactionKeysToDelete.forEach((actionKey: string) => delete allActions[actionKey]);\n\n\treturn {\n\t\tactions: allActions,\n\t\tcommandActions: commandActions\n\t};\n}\n\n/**\n * Gets the binding expression for the enablement of a manifest action.\n * @param manifestAction The action configured in the manifest\n * @param isAnnotationAction Whether the action, defined in manifest, corresponds to an existing annotation action.\n * @param converterContext\n * @param forContextMenu\n * @returns Determined property value for the enablement\n */\nconst _getManifestEnabled = function (\n\tmanifestAction: ManifestAction,\n\tisAnnotationAction: boolean,\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tforContextMenu = false\n): CompiledBindingToolkitExpression | undefined {\n\tif (isAnnotationAction && manifestAction.enabled === undefined) {\n\t\t// If annotation action has no property defined in manifest,\n\t\t// do not overwrite it with manifest action's default value.\n\t\treturn undefined;\n\t}\n\n\tconst result = getManifestActionBooleanPropertyWithFormatter(manifestAction.enabled, converterContext, forContextMenu);\n\n\t// Consider requiresSelection property to include selectedContexts in the binding expression\n\tconst internalModelProperty = !forContextMenu ? \"numberOfSelectedContexts\" : \"contextmenu/numberOfSelectedContexts\";\n\treturn compileExpression(\n\t\tifElse(\n\t\t\tmanifestAction.requiresSelection === true,\n\t\t\tifElse(\n\t\t\t\tmanifestAction.enableOnSelect === \"single\",\n\t\t\t\tand(equal(pathInModel(internalModelProperty, \"internal\"), 1), result),\n\t\t\t\tand(greaterOrEqual(pathInModel(internalModelProperty, \"internal\"), 1), result)\n\t\t\t),\n\t\t\tresult\n\t\t)\n\t);\n};\n\n/**\n * Gets the binding expression for the visibility of a manifest action.\n * @param manifestAction The action configured in the manifest\n * @param isAnnotationAction Whether the action, defined in the manifest, corresponds to an existing annotation action.\n * @param converterContext\n * @param forContextMenu\n * @returns Determined property value for the visibility\n */\nconst _getManifestVisible = function (\n\tmanifestAction: ManifestAction,\n\tisAnnotationAction: boolean,\n\tconverterContext: ConverterContext<PageContextPathTarget>\n): CompiledBindingToolkitExpression | undefined {\n\tif (isAnnotationAction && manifestAction.visible === undefined) {\n\t\t// If annotation action has no property defined in manifest,\n\t\t// do not overwrite it with manifest action's default value.\n\t\treturn undefined;\n\t}\n\n\tconst result = getManifestActionBooleanPropertyWithFormatter(manifestAction.visible, converterContext);\n\treturn compileExpression(result);\n};\n\ntype PartiallyConvertedCustomAction = Omit<CustomAction, \"menu\"> & {\n\tmenu: string[] | undefined;\n\tpriority?: OverflowToolbarPriority;\n\tgroup?: number;\n};\n\n/**\n * As some properties should not be overridable by the manifest, make sure that the manifest configuration gets the annotation values for these.\n * @param manifestAction Action defined in the manifest\n * @param annotationAction Action defined through annotations\n */\nfunction overrideManifestConfigurationWithAnnotation(manifestAction: PartiallyConvertedCustomAction, annotationAction?: BaseAction): void {\n\tif (!annotationAction) {\n\t\treturn;\n\t}\n\n\t// Do not override the 'type' given in an annotation action\n\tmanifestAction.type = annotationAction.type;\n\tmanifestAction.annotationPath = annotationAction.annotationPath;\n\tmanifestAction.press = annotationAction.press;\n\n\t// Only use the annotation values for enablement and visibility if not set in the manifest\n\tmanifestAction.enabled = manifestAction.enabled ?? annotationAction.enabled;\n\tmanifestAction.visible = manifestAction.visible ?? annotationAction.visible;\n}\n\n/**\n * Creates the action configuration based on the manifest settings.\n * @param manifestActions The manifest actions\n * @param converterContext The converter context\n * @param annotationActions The annotation actions definition\n * @param navigationSettings The navigation settings\n * @param considerNavigationSettings The navigation settings to be considered\n * @param hiddenActions Actions that are configured as hidden (additional to the visible property)\n * @param facetName The facet where an action is displayed if it is inline\n * @returns The actions from the manifest\n */\nexport function getActionsFromManifest(\n\tmanifestActions: Record<string, ManifestAction> | undefined,\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tannotationActions?: BaseAction[],\n\tnavigationSettings?: NavigationSettingsConfiguration,\n\tconsiderNavigationSettings?: boolean,\n\thiddenActions?: BaseAction[],\n\tfacetName?: string\n): Record<string, Record<string, CustomAction>> {\n\tconst actions: Record<string, PartiallyConvertedCustomAction> = {};\n\tfor (const actionKey in manifestActions) {\n\t\tconst manifestAction: ManifestAction = manifestActions[actionKey];\n\t\tconst lastDotIndex = manifestAction.press?.lastIndexOf(\".\") || -1;\n\t\tlet annotationAction: BaseAction | undefined;\n\n\t\tif (annotationActions) {\n\t\t\tfor (const action of annotationActions) {\n\t\t\t\t// SubSection.ts#createFormActionReducer uses insertCustomElements which results in annotation actions mixing up with manifest action\n\t\t\t\t// this is why we may find an action that has a CustomAction prefix\n\t\t\t\tif (action.id?.startsWith(\"CustomAction::\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (action.key === actionKey) {\n\t\t\t\t\tannotationAction = action;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (action.type === \"Menu\") {\n\t\t\t\t\t// If not found, check inside menus\n\t\t\t\t\tannotationAction = action.menu?.find((menuItem: BaseAction) => {\n\t\t\t\t\t\treturn menuItem.key === actionKey;\n\t\t\t\t\t});\n\t\t\t\t\tif (annotationAction) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// To identify the annotation action property overwrite via manifest use-case.\n\t\tconst isAnnotationAction = !!annotationAction;\n\t\tif (manifestAction.facetName) {\n\t\t\tfacetName = manifestAction.facetName;\n\t\t}\n\n\t\tactions[actionKey] = {\n\t\t\tid: annotationAction ? actionKey : getCustomActionID(actionKey),\n\t\t\ttype: manifestAction.menu ? ActionType.Menu : ActionType.Default,\n\t\t\tvisible: _getManifestVisible(manifestAction, isAnnotationAction, converterContext),\n\t\t\tenabled: _getManifestEnabled(manifestAction, isAnnotationAction, converterContext),\n\t\t\tenabledForContextMenu: _getManifestEnabled(manifestAction, isAnnotationAction, converterContext, true),\n\t\t\thandlerModule: manifestAction.press && manifestAction.press.substring(0, lastDotIndex).replace(/\\./gi, \"/\"),\n\t\t\thandlerMethod: manifestAction.press && manifestAction.press.substring(lastDotIndex + 1),\n\t\t\tpress: manifestAction.press,\n\t\t\ttext: manifestAction.text,\n\t\t\tnoWrap: manifestAction.__noWrap,\n\t\t\tkey: replaceSpecialChars(actionKey),\n\t\t\tenableOnSelect: manifestAction.enableOnSelect,\n\t\t\tdefaultValuesExtensionFunction: manifestAction.defaultValuesFunction,\n\t\t\tposition: {\n\t\t\t\tanchor: manifestAction.position?.anchor,\n\t\t\t\tplacement: manifestAction.position === undefined ? Placement.After : manifestAction.position.placement\n\t\t\t},\n\t\t\tisNavigable: isActionNavigable(manifestAction, navigationSettings, considerNavigationSettings),\n\t\t\tcommand: manifestAction.command,\n\t\t\trequiresSelection: manifestAction.requiresSelection === undefined ? false : manifestAction.requiresSelection,\n\t\t\tenableAutoScroll: enableAutoScroll(manifestAction),\n\t\t\tmenu: manifestAction.menu ?? (annotationAction?.type === ActionType.Menu ? [] : undefined),\n\t\t\tfacetName: manifestAction.inline ? facetName : undefined,\n\t\t\tdefaultAction: manifestAction.defaultAction,\n\t\t\tisAIOperation: manifestAction?.isAIOperation ?? undefined,\n\t\t\tpriority: manifestAction?.priority ?? undefined,\n\t\t\tgroup: manifestAction?.group ?? undefined\n\t\t};\n\n\t\toverrideManifestConfigurationWithAnnotation(actions[actionKey], annotationAction);\n\t}\n\n\treturn transformMenuActionsAndIdentifyCommands(actions, annotationActions ?? []);\n}\n\n/**\n * Gets a binding expression representing a Boolean manifest property that can either be represented by a static value, a binding string,\n * or a runtime formatter function.\n * @param propertyValue String representing the configured property value\n * @param converterContext\n * @param forContextMenu Indicates whether the property is requested for a context menu action\n * @returns A binding expression representing the property\n */\nfunction getManifestActionBooleanPropertyWithFormatter(\n\tpropertyValue: string | undefined | boolean,\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tforContextMenu = false\n): BindingToolkitExpression<boolean> {\n\tconst resolvedBinding = resolveBindingString<boolean | string>(propertyValue as string, \"boolean\");\n\tlet result: BindingToolkitExpression<boolean>;\n\tif (isConstant(resolvedBinding) && resolvedBinding.value === undefined) {\n\t\t// No property value configured in manifest for the custom action --> default value is true\n\t\tresult = constant(true);\n\t} else if (isConstant(resolvedBinding) && typeof resolvedBinding.value === \"string\") {\n\t\t// Then it's a module-method reference \"sap.xxx.yyy.doSomething\"\n\t\tconst methodPath = resolvedBinding.value;\n\t\t// FIXME: The custom \"isEnabled\" check does not trigger (because none of the bound values changes)\n\t\tresult = formatResult(\n\t\t\t[pathInModel<View>(\"/\", \"$view\"), methodPath, pathInModel<Context[]>(\"selectedContexts\", \"internal\")],\n\t\t\tfpmFormatter.customBooleanPropertyCheck,\n\t\t\t!forContextMenu\n\t\t\t\t? converterContext.getDataModelObjectPath().contextLocation?.targetEntityType || converterContext.getEntityType()\n\t\t\t\t: undefined\n\t\t);\n\t} else {\n\t\t// then it's a binding\n\t\tresult = resolvedBinding as BindingToolkitExpression<boolean>;\n\t}\n\n\treturn result;\n}\n\nexport const removeDuplicateActions = (actions: CustomAction[]): CustomAction[] => {\n\tlet oMenuItemKeys: Record<string, boolean> = {};\n\tactions.forEach((action) => {\n\t\tif (action?.menu?.length) {\n\t\t\tconst actionMenu = action.menu;\n\t\t\toMenuItemKeys = actionMenu.reduce((item: Record<string, boolean>, { key }) => {\n\t\t\t\tif (key && !item[key]) {\n\t\t\t\t\titem[key] = true;\n\t\t\t\t}\n\t\t\t\treturn item;\n\t\t\t}, oMenuItemKeys);\n\t\t}\n\t});\n\treturn actions.filter((action) => !oMenuItemKeys[action.key]);\n};\n\nexport function getEnabledForAnnotationActionExpression(\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tactionTarget: Action | undefined,\n\tpathFromContextLocation = false\n): BindingToolkitExpression<boolean> {\n\tif (actionTarget?.annotations.Core?.OperationAvailable) {\n\t\tconst dataModelObjectPath = converterContext.getDataModelObjectPath();\n\t\tlet isEnabledExp = getActionEnabledExpression(\n\t\t\tactionTarget,\n\t\t\tconverterContext.getConvertedTypes(),\n\t\t\tdataModelObjectPath,\n\t\t\tpathFromContextLocation\n\t\t);\n\t\tconst collaborationOnRoot =\n\t\t\tModelHelper.isCollaborationDraftSupportedFromConverterContext(converterContext) &&\n\t\t\tModelHelper.getDraftRoot(converterContext.getEntitySet());\n\t\tif (collaborationOnRoot) {\n\t\t\tisEnabledExp = and(isEnabledExp, not(equal(UI.hasCollaborationAuthorization, false)));\n\t\t}\n\t\treturn isEnabledExp;\n\t}\n\treturn constant(true);\n}\n\n/**\n * Method to determine the value of the 'enabled' property of an annotation-based action.\n * @param converterContext The instance of the converter context\n * @param actionTarget The instance of the action\n * @param pathFromContextLocation Is the binding path calculated  from the converter context location\n * @returns The binding expression for the 'enabled' property of the action button.\n */\nexport function getEnabledForAnnotationAction(\n\tconverterContext: ConverterContext<PageContextPathTarget>,\n\tactionTarget: Action | undefined,\n\tpathFromContextLocation = false\n): CompiledBindingToolkitExpression {\n\treturn compileExpression(getEnabledForAnnotationActionExpression(converterContext, actionTarget, pathFromContextLocation));\n}\n\nexport function getSemanticObjectMapping(mappings?: SemanticObjectMappingType[]): MetaModelType<SemanticObjectMappingType>[] {\n\treturn mappings\n\t\t? mappings.map((mapping) => {\n\t\t\t\treturn {\n\t\t\t\t\tLocalProperty: {\n\t\t\t\t\t\t$PropertyPath: mapping.LocalProperty.value\n\t\t\t\t\t},\n\t\t\t\t\tSemanticObjectProperty: mapping.SemanticObjectProperty.toString()\n\t\t\t\t};\n\t\t  })\n\t\t: [];\n}\n\nexport function isActionNavigable(\n\taction: ManifestAction | CustomDefinedTableColumnForOverride | undefined,\n\tnavigationSettings?: NavigationSettingsConfiguration,\n\tconsiderNavigationSettings?: boolean\n): boolean {\n\tlet bIsNavigationConfigured = true;\n\tif (considerNavigationSettings) {\n\t\tconst detailOrDisplay = navigationSettings && (navigationSettings.detail || navigationSettings.display);\n\t\tbIsNavigationConfigured = detailOrDisplay?.route ? true : false;\n\t}\n\t// when enableAutoScroll is true the navigateToInstance feature is disabled\n\tif (\n\t\t(action &&\n\t\t\taction.afterExecution &&\n\t\t\t(action.afterExecution?.navigateToInstance === false || action.afterExecution?.enableAutoScroll === true)) ||\n\t\t!bIsNavigationConfigured\n\t) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nexport function enableAutoScroll(action: ManifestAction): boolean {\n\treturn action?.afterExecution?.enableAutoScroll === true;\n}\n\nexport function dataFieldIsCopyAction(dataField: DataFieldForActionTypes): boolean {\n\treturn dataField.annotations?.UI?.IsCopyAction?.valueOf() === true && dataField.$Type === UIAnnotationTypes.DataFieldForAction;\n}\n\nexport function getCopyAction(copyDataFields: DataFieldForActionTypes[]): DataFieldForActionTypes | undefined {\n\tif (copyDataFields.length === 1) {\n\t\treturn copyDataFields[0];\n\t}\n\tif (copyDataFields.length > 1) {\n\t\tLog.error(\"Multiple actions are annotated with isCopyAction. There can be only one standard copy action.\");\n\t}\n\treturn undefined;\n}\n\n/**\n * Method to extract menu items from actions of type menus.\n * @param annotationActions Collection of annotation based actions\n * @returns Collection of actions which are menu items in one of the annotation based menus\n */\nexport function getAnnotationMenuActionItems(annotationActions: BaseAction[]): BaseAction[] {\n\tconst menuActionItems: BaseAction[] = [];\n\n\tannotationActions.forEach((action: BaseAction) => {\n\t\tif (action.type === \"Menu\" && !action.id?.startsWith(\"CustomAction::\") && action.menu) {\n\t\t\tmenuActionItems.push(...action.menu);\n\t\t}\n\t});\n\n\treturn menuActionItems;\n}\n\n/**\n * Method to find the matching manifest actions which override the annotation menu items.\n * @param annotationMenuItems Collection of annotation based menu items\n * @param manifestActions Collection of manifest based actions\n * @returns Collection of actions which are menu items in one of the annotation based menus\n */\nexport function getMatchingManifestAction(\n\tannotationMenuItems: BaseAction[],\n\tmanifestActions: Record<string, CustomAction>\n): Record<string, CustomAction> {\n\tconst matchingManifestActions: Record<string, CustomAction> = {};\n\n\tfor (const manifestAction in manifestActions) {\n\t\tif (\n\t\t\tmanifestAction.startsWith(\"DataFieldForAction::\") &&\n\t\t\tannotationMenuItems.find((menuActionItems) => {\n\t\t\t\treturn menuActionItems.key === manifestAction;\n\t\t\t})\n\t\t) {\n\t\t\tmatchingManifestActions[manifestAction] = manifestActions[manifestAction];\n\t\t}\n\t}\n\n\treturn matchingManifestActions;\n}\n\n/**\n * Method to transform the menus by replacing the menu items with their overriding actions.\n * @param unpreparedActions Collection of all actions after merging manifest and annotation actions\n * @param overrideMenuActions Collection of all overriden menu items\n */\nexport function prepareMenuActions(unpreparedActions: CustomAction[], overrideMenuActions: BaseAction[]): void {\n\tlet foundAction;\n\n\tunpreparedActions.forEach((action: CustomAction) => {\n\t\tif (action.type === ActionType.Menu) {\n\t\t\taction.menu?.forEach((menuItem: BaseAction, menuItemIndex: number) => {\n\t\t\t\tfoundAction = overrideMenuActions.find((overrideMenuAction: BaseAction) => {\n\t\t\t\t\treturn overrideMenuAction.key === menuItem.key;\n\t\t\t\t});\n\n\t\t\t\tif (foundAction) {\n\t\t\t\t\taction.menu?.splice(menuItemIndex, 1, foundAction);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Menu has isAIOperation set to true on each menu item has isAIOperation set to true\n\t\t\tconst isAIOperation = isMenuAIOperation(action.menu as unknown as CustomAction[]);\n\t\t\tif (isAIOperation) {\n\t\t\t\taction.isAIOperation = isAIOperation;\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * Method to determine if the menu consists of all AI operation actions.\n * @param actions Collection of DataFieldForActionAbstractTypes or CustomAction in the menu\n * @returns A boolean true if all records in the menu are AI operations, false otherwise\n */\nexport function isMenuAIOperation(actions: DataFieldForActionAbstractTypes[] | CustomAction[]): boolean {\n\tlet isAIOperationOccurrences = 0;\n\tactions.forEach((action) => {\n\t\tif ((action as DataFieldForActionAbstractTypes).$Type !== undefined) {\n\t\t\tif (isActionAIOperation(action as DataFieldForActionAbstractTypes)) {\n\t\t\t\tisAIOperationOccurrences++;\n\t\t\t}\n\t\t} else if ((action as CustomAction).type !== undefined) {\n\t\t\tif (isCustomActionAIOperation(action as CustomAction)) {\n\t\t\t\tisAIOperationOccurrences++;\n\t\t\t}\n\t\t}\n\t});\n\tif (isAIOperationOccurrences === actions?.length) return true;\n\n\treturn false;\n}\n\n/**\n * Method to determine if the given record is an AI operation.\n * @param dataField The record of type DataFieldForAction or DataFieldForIntentBasedNavigation\n * @returns A boolean true if the given record is an AI operation, false otherwise\n */\nexport function isActionAIOperation(dataField: DataFieldForActionAbstractTypes): boolean {\n\tif (dataField.$Type === UIAnnotationTypes.DataFieldForAction) {\n\t\treturn dataField.ActionTarget?.annotations.UI?.IsAIOperation?.valueOf() === true;\n\t}\n\treturn false;\n}\n\n/**\n * Method to determine if the given custom action is an AI operation.\n * @param customAction The record of type CustomAction\n * @returns A boolean true if the given record is an AI operation, false otherwise\n */\nfunction isCustomActionAIOperation(customAction: CustomAction): boolean {\n\treturn customAction?.isAIOperation === true;\n}\n\n/**\n * Method to add toolbar separators if actions are grouped in more than one group.\n * @param actions Collection of merged actions from annotations and manifest\n * @returns Collection of merged actions with toolbar separators\n */\nexport function addSeparators(actions: BaseAction[]): BaseAction[] {\n\tconst result: BaseAction[] = [];\n\tconst groupsUsed: number[] = [];\n\tactions.forEach((action: BaseAction) => {\n\t\t// if a new group is found\n\t\tif (action.group !== undefined && !groupsUsed.includes(action.group)) {\n\t\t\tgroupsUsed.push(action.group);\n\t\t\t// if there are two or more groups, add separator\n\t\t\tif (groupsUsed.length > 1) {\n\t\t\t\tresult.push({\n\t\t\t\t\ttype: ActionType.Separator,\n\t\t\t\t\tkey: \"Separator::\" + action.group,\n\t\t\t\t\tgroup: action.group,\n\t\t\t\t\tposition: {\n\t\t\t\t\t\tanchor: action.key,\n\t\t\t\t\t\tplacement: Placement.Before\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tresult.push(action);\n\t});\n\treturn result;\n}\n"],"mappings":"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","ignoreList":[]}