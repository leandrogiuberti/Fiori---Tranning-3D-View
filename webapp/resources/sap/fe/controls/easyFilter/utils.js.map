{"version":3,"file":"utils.js","names":["resourceBundle","Lib","getResourceBundleFor","dateTimeOffset","DateTimeOffset","areItemsSame","arr1","arr2","length","i","operator","selectedValues","every","value","index","deepEqual","description","areArraySame","async","areCodeListsSame","arrNew1","getCodeListArray","arrNew2","descriptionNew1","map","data","descriptionNew2","value1","value2","arr","convertDateToString","tokenType","isDateTimeOffset","formattedDateTime","formatValue","DateFormat","getDateInstance","format","getTimeInstance","mapOperator","newValue","convertBoolToString","Date","FilterOperator","GT","LT","GE","LE","EQ","Contains","EndsWith","StartsWith","NE","NotContains","NotEndsWith","NotStartsWith","toString","mapOperatorForValueHelp","mapOperatorForBetweenOperator","values","newValue1","newValue2","BT","isBetweenSelectedValues","NB","getText","isInvalidSingleRange","filterValue","allowed","includes","formatData","tokens","filterValues","filterBarMetadata","setMessageStripForValidatedFilters","visitedMapForMandatoryTokens","nonFilterableTokenLabels","singleRangeTokenLabels","hiddenFilterTokenLabels","filterCriteria","find","field","name","Object","prototype","hasOwnProperty","call","filterable","push","label","hiddenFilter","filterRestriction","type","tokenIndex","findIndex","token","key","keySpecificSelectedValues","EasyFilterUtils","newToken","busy","currentToken","isRequired","messages","nonFilterableTokenLabel","join"],"sources":["./utils.ts"],"sourcesContent":["import type { PrimitiveType } from \"@sap-ux/vocabularies-types/Edm\";\nimport deepEqual from \"sap/base/util/deepEqual\";\nimport Lib from \"sap/ui/core/Lib\";\nimport DateFormat from \"sap/ui/core/format/DateFormat\";\nimport FilterOperator from \"sap/ui/model/FilterOperator\";\nimport DateTimeOffset from \"sap/ui/model/odata/type/DateTimeOffset\";\nimport type { EasyFilterResult, PropertyMetadata } from \"ux/eng/fioriai/reuse/easyfilter/EasyFilter\";\nimport type {\n\tBetweenSelectedValues,\n\tCodeListType,\n\tEasyFilterPropertyMetadata,\n\tTokenDefinition,\n\tTokenSelectedValuesDefinition,\n\tTokenType,\n\tValueHelpBetweenSelectedValues,\n\tValueHelpSelectedValuesDefinition\n} from \"./EasyFilterBarContainer\";\n\ntype codeListType = PropertyMetadata[\"codeList\"];\ntype finalCodeListType = { value: PrimitiveType; description?: string }[];\nconst resourceBundle = Lib.getResourceBundleFor(\"sap.fe.controls\")!;\nconst dateTimeOffset = new DateTimeOffset();\n\nfunction areItemsSame(\n\tarr1: readonly TokenSelectedValuesDefinition[] | ValueHelpSelectedValuesDefinition[],\n\tarr2: readonly TokenSelectedValuesDefinition[] | ValueHelpSelectedValuesDefinition[]\n): boolean {\n\tif (arr1.length !== arr2.length) {\n\t\treturn false;\n\t}\n\t// Compare elements of both arrays\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (\n\t\t\tarr1[i].operator !== arr2[i].operator ||\n\t\t\t!arr1[i].selectedValues.every(\n\t\t\t\t(value, index) =>\n\t\t\t\t\tvalue === arr2[i].selectedValues[index] ||\n\t\t\t\t\t(typeof value === \"object\" &&\n\t\t\t\t\t\tdeepEqual((value as CodeListType).value, (arr2[i].selectedValues[index] as CodeListType).value) &&\n\t\t\t\t\t\t(value as CodeListType).description === (arr2[i].selectedValues[index] as CodeListType).description)\n\t\t\t)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true; // Arrays are the same\n}\n\nfunction areArraySame(arr1: readonly unknown[], arr2: readonly unknown[]): boolean {\n\tif (arr1.length !== arr2.length) {\n\t\treturn false;\n\t}\n\t// Compare elements of both arrays\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (arr1[i] !== arr2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true; // Arrays are the same\n}\n\nasync function areCodeListsSame(arr1: codeListType, arr2: codeListType): Promise<boolean> {\n\tconst arrNew1: finalCodeListType | undefined = await getCodeListArray(arr1);\n\tconst arrNew2: finalCodeListType | undefined = await getCodeListArray(arr2);\n\tconst descriptionNew1 = arrNew1?.map((data) => data.description);\n\tconst descriptionNew2 = arrNew2?.map((data) => data.description);\n\n\tconst value1 = arrNew1?.map((data) => data.value);\n\tconst value2 = arrNew2?.map((data) => data.value);\n\tif (!descriptionNew1 || !descriptionNew2) {\n\t\treturn false;\n\t}\n\treturn areArraySame(descriptionNew1, descriptionNew2) && areArraySame(value1 as PrimitiveType, value2 as PrimitiveType);\n}\n\nasync function getCodeListArray(arr: codeListType): Promise<finalCodeListType | undefined> {\n\tif (typeof arr === \"function\") {\n\t\treturn arr();\n\t}\n\treturn arr;\n}\n\nfunction convertDateToString(value: Date, tokenType: TokenType, isDateTimeOffset: boolean): string {\n\tlet formattedDateTime = \"\";\n\tif (isDateTimeOffset) {\n\t\treturn dateTimeOffset.formatValue(value, \"string\") as string;\n\t}\n\tswitch (tokenType) {\n\t\tcase \"Calendar\":\n\t\t\tformattedDateTime = DateFormat.getDateInstance().format(value);\n\t\t\tbreak;\n\t\tcase \"Time\":\n\t\t\tformattedDateTime = DateFormat.getTimeInstance().format(value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn formattedDateTime;\n}\n\n/**\n * Create a string representation of the operator and value.\n * @param operator The operator to represent\n * @param value The value to represent\n * @param tokenType The token's type\n * @param isDateTimeOffset Checks if the data type is of DateTimeOffset\n * @returns The string representation of the operator and value\n */\nfunction mapOperator(\n\toperator: FilterOperator,\n\tvalue: string | number | boolean | Date,\n\ttokenType: TokenType,\n\tisDateTimeOffset: boolean\n): string {\n\tlet newValue: number | string = \"\";\n\tif (typeof value === \"boolean\") {\n\t\tnewValue = convertBoolToString(value);\n\t} else if (value instanceof Date) {\n\t\tnewValue = convertDateToString(value, tokenType, isDateTimeOffset);\n\t} else {\n\t\tnewValue = value;\n\t}\n\n\tswitch (operator) {\n\t\tcase FilterOperator.GT:\n\t\t\treturn `> ${newValue}`;\n\t\tcase FilterOperator.LT:\n\t\t\treturn `< ${newValue}`;\n\t\tcase FilterOperator.GE:\n\t\t\treturn `>= ${newValue}`;\n\t\tcase FilterOperator.LE:\n\t\t\treturn `<= ${newValue}`;\n\t\tcase FilterOperator.EQ:\n\t\t\treturn `${newValue}`;\n\t\tcase FilterOperator.Contains:\n\t\t\treturn `*${newValue}*`;\n\t\tcase FilterOperator.EndsWith:\n\t\t\treturn `*${newValue}`;\n\t\tcase FilterOperator.StartsWith:\n\t\t\treturn `${newValue}*`;\n\t\tcase FilterOperator.NE:\n\t\t\treturn `!=(${newValue})`;\n\t\tcase FilterOperator.NotContains:\n\t\t\treturn `!(*${newValue}*)`;\n\t\tcase FilterOperator.NotEndsWith:\n\t\t\treturn `!(*${newValue})`;\n\t\tcase FilterOperator.NotStartsWith:\n\t\t\treturn `!(${newValue}*)`;\n\t\tdefault:\n\t\t\treturn newValue?.toString();\n\t}\n}\n\nfunction mapOperatorForValueHelp(operator: FilterOperator, value: CodeListType, tokenType: TokenType, isDateTimeOffset: boolean): string {\n\treturn mapOperator(operator, value.description, tokenType, isDateTimeOffset);\n}\n\nfunction mapOperatorForBetweenOperator(\n\toperator: FilterOperator,\n\tvalues: BetweenSelectedValues | ValueHelpBetweenSelectedValues,\n\ttokenType: TokenType,\n\tisDateTimeOffset: boolean\n): string {\n\tlet newValue1: string | number | Date = \"\";\n\tlet newValue2: string | number | Date = \"\";\n\tif (typeof values[0] === \"boolean\") {\n\t\tnewValue1 = convertBoolToString(values[0]);\n\t} else if (values[0] instanceof Date) {\n\t\tnewValue1 = convertDateToString(values[0], tokenType, isDateTimeOffset);\n\t} else if (typeof values[0] === \"object\") {\n\t\tnewValue1 = values[0].description as string;\n\t} else {\n\t\tnewValue1 = values[0];\n\t}\n\n\tif (typeof values[1] === \"boolean\") {\n\t\tnewValue2 = convertBoolToString(values[1]);\n\t} else if (values[1] instanceof Date) {\n\t\tnewValue2 = convertDateToString(values[1], tokenType, isDateTimeOffset);\n\t} else if (typeof values[0] === \"object\") {\n\t\tnewValue2 = values[1].description as string;\n\t} else {\n\t\tnewValue2 = values[1];\n\t}\n\tif (operator === FilterOperator.BT) {\n\t\treturn `${newValue1}...${newValue2}`;\n\t} else {\n\t\treturn `!(${newValue1}...${newValue2})`;\n\t}\n}\n\nfunction isBetweenSelectedValues(operator: FilterOperator): boolean {\n\treturn operator === FilterOperator.BT || operator === FilterOperator.NB;\n}\n\nfunction convertBoolToString(value: boolean): string {\n\treturn value\n\t\t? resourceBundle.getText(\"M_EASY_FILTER_SELECTED_VALUES_TRUE\")\n\t\t: resourceBundle.getText(\"M_EASY_FILTER_SELECTED_VALUES_FALSE\");\n}\n\n//This function returns true if the filter is not a valid \"SingleRange\" (e.g., wrong operator or too many values), and false if it is valid.\nfunction isInvalidSingleRange(filterValue: { operator: FilterOperator; values: (string | number | Date | boolean)[] }): boolean {\n\tconst allowed = [FilterOperator.EQ, FilterOperator.LE, FilterOperator.LT, FilterOperator.GE, FilterOperator.GT, FilterOperator.BT];\n\n\t// \tfilterValue.operator !== FilterOperator.BT ensures BT is always valid.\n\t// !allowed.includes() blocks unsupported operators.\n\t// filterValue.values.length >= 2 blocks multiple values for single-range filters.\n\t// Together, this returns true when the filter is not a valid single-range.\n\treturn filterValue.operator !== FilterOperator.BT && (!allowed.includes(filterValue.operator) || filterValue.values.length >= 2);\n}\n\nfunction formatData(\n\ttokens: TokenDefinition[],\n\tfilterValues: EasyFilterResult[\"filter\"],\n\tfilterBarMetadata: EasyFilterPropertyMetadata[],\n\tsetMessageStripForValidatedFilters: (msg: string) => void\n): void {\n\tif (filterValues) {\n\t\tconst visitedMapForMandatoryTokens: Record<string, boolean> = {};\n\t\tconst nonFilterableTokenLabels: string[] = [];\n\t\tconst singleRangeTokenLabels: string[] = [];\n\t\tconst hiddenFilterTokenLabels: string[] = [];\n\n\t\tfor (const filterValue of filterValues) {\n\t\t\tconst filterCriteria = filterBarMetadata.find((field) => field.name === filterValue.name);\n\t\t\tif (filterCriteria) {\n\t\t\t\t// Only block if filterable is false\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(filterCriteria, \"filterable\") && !filterCriteria?.filterable) {\n\t\t\t\t\tnonFilterableTokenLabels.push(filterCriteria.label || filterCriteria.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Only block if hiddenFilter is true\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(filterCriteria, \"hiddenFilter\") && filterCriteria?.hiddenFilter) {\n\t\t\t\t\thiddenFilterTokenLabels.push(filterCriteria.label || filterCriteria.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Only apply SingleRange logic if filterRestriction is set to SingleRange\n\t\t\t\tif (filterCriteria?.filterRestriction === \"SingleRange\" && isInvalidSingleRange(filterValue)) {\n\t\t\t\t\tsingleRangeTokenLabels.push(filterCriteria.label || filterCriteria.name);\n\t\t\t\t\tfilterValue.values = []; // Reset values to avoid adding invalid token values\n\t\t\t\t}\n\n\t\t\t\tconst { type } = filterCriteria;\n\t\t\t\tconst tokenIndex = tokens.findIndex((token) => token.key === filterValue.name);\n\t\t\t\tconst { operator, values } = filterValue;\n\t\t\t\tlet keySpecificSelectedValues: TokenSelectedValuesDefinition;\n\t\t\t\tif (EasyFilterUtils.isBetweenSelectedValues(operator)) {\n\t\t\t\t\tkeySpecificSelectedValues = {\n\t\t\t\t\t\toperator,\n\t\t\t\t\t\tselectedValues: values as BetweenSelectedValues\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tkeySpecificSelectedValues = {\n\t\t\t\t\t\toperator: operator as Exclude<FilterOperator, FilterOperator.BT | FilterOperator.NB>,\n\t\t\t\t\t\tselectedValues: values as string[] | Date[] | number[] | boolean[]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (tokenIndex === -1) {\n\t\t\t\t\t// Add new token if it doesn't exist\n\t\t\t\t\tconst newToken: TokenDefinition = {\n\t\t\t\t\t\tkey: filterValue.name,\n\t\t\t\t\t\tlabel: filterCriteria.label as string,\n\t\t\t\t\t\tkeySpecificSelectedValues: [keySpecificSelectedValues],\n\t\t\t\t\t\ttype: type as Exclude<TokenType, \"ValueHelp\">,\n\t\t\t\t\t\tbusy: type === \"ValueHelp\" ? true : false\n\t\t\t\t\t};\n\t\t\t\t\ttokens.push(newToken);\n\t\t\t\t} else {\n\t\t\t\t\t// Update existing token\n\t\t\t\t\tconst currentToken = tokens[tokenIndex];\n\t\t\t\t\t//If its default value , override it\n\t\t\t\t\tif ((currentToken.isRequired ?? false) && !visitedMapForMandatoryTokens[currentToken.key]) {\n\t\t\t\t\t\tcurrentToken.keySpecificSelectedValues = [keySpecificSelectedValues];\n\t\t\t\t\t\tvisitedMapForMandatoryTokens[currentToken.key] = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(currentToken.keySpecificSelectedValues as TokenSelectedValuesDefinition[]).push(keySpecificSelectedValues);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nonFilterableTokenLabels.length > 0 || singleRangeTokenLabels.length > 0 || hiddenFilterTokenLabels.length > 0) {\n\t\t\tconst messages: string[] = [];\n\t\t\tif (nonFilterableTokenLabels.length > 0) {\n\t\t\t\tconst nonFilterableTokenLabel = `<strong>${nonFilterableTokenLabels.join(\", \")}</strong>`;\n\t\t\t\tmessages.push(resourceBundle.getText(\"M_EASY_FILTER_NON_FILTERABLE\", [nonFilterableTokenLabel]));\n\t\t\t}\n\t\t\tif (hiddenFilterTokenLabels.length > 0) {\n\t\t\t\tconst label = `<strong>${hiddenFilterTokenLabels.join(\", \")}</strong>`;\n\t\t\t\tmessages.push(resourceBundle.getText(\"M_EASY_FILTER_HIDDEN_FILTER\", [label]));\n\t\t\t}\n\t\t\tif (singleRangeTokenLabels.length > 0) {\n\t\t\t\tconst label = `<strong>${singleRangeTokenLabels.join(\", \")}</strong>`;\n\t\t\t\tmessages.push(resourceBundle.getText(\"M_EASY_FILTER_SINGLE_RANGE\", [label]));\n\t\t\t}\n\t\t\tsetMessageStripForValidatedFilters(messages.join(\"<br>\"));\n\t\t}\n\t}\n}\n\nconst EasyFilterUtils = {\n\tareItemsSame,\n\tareCodeListsSame,\n\tgetCodeListArray,\n\tareArraySame,\n\tmapOperator,\n\tmapOperatorForBetweenOperator,\n\tisBetweenSelectedValues,\n\tformatData,\n\tmapOperatorForValueHelp\n};\n\nexport default EasyFilterUtils;\n"],"mappings":";;;;oMAoBA,MAAMA,EAAiBC,EAAIC,qBAAqB,mBAChD,MAAMC,EAAiB,IAAIC,EAE3B,SAASC,EACRC,EACAC,GAEA,GAAID,EAAKE,SAAWD,EAAKC,OAAQ,CAChC,OAAO,KACR,CAEA,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAKE,OAAQC,IAAK,CACrC,GACCH,EAAKG,GAAGC,WAAaH,EAAKE,GAAGC,WAC5BJ,EAAKG,GAAGE,eAAeC,MACvB,CAACC,EAAOC,IACPD,IAAUN,EAAKE,GAAGE,eAAeG,WACzBD,IAAU,UACjBE,EAAWF,EAAuBA,MAAQN,EAAKE,GAAGE,eAAeG,GAAwBD,QACxFA,EAAuBG,cAAiBT,EAAKE,GAAGE,eAAeG,GAAwBE,aAE1F,CACD,OAAO,KACR,CACD,CACA,OAAO,IACR,CAEA,SAASC,EAAaX,EAA0BC,GAC/C,GAAID,EAAKE,SAAWD,EAAKC,OAAQ,CAChC,OAAO,KACR,CAEA,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAKE,OAAQC,IAAK,CACrC,GAAIH,EAAKG,KAAOF,EAAKE,GAAI,CACxB,OAAO,KACR,CACD,CACA,OAAO,IACR,CAEAS,eAAeC,EAAiBb,EAAoBC,GACnD,MAAMa,QAA+CC,EAAiBf,GACtE,MAAMgB,QAA+CD,EAAiBd,GACtE,MAAMgB,EAAkBH,GAASI,IAAKC,GAASA,EAAKT,aACpD,MAAMU,EAAkBJ,GAASE,IAAKC,GAASA,EAAKT,aAEpD,MAAMW,EAASP,GAASI,IAAKC,GAASA,EAAKZ,OAC3C,MAAMe,EAASN,GAASE,IAAKC,GAASA,EAAKZ,OAC3C,IAAKU,IAAoBG,EAAiB,CACzC,OAAO,KACR,CACA,OAAOT,EAAaM,EAAiBG,IAAoBT,EAAaU,EAAyBC,EAChG,CAEAV,eAAeG,EAAiBQ,GAC/B,UAAWA,IAAQ,WAAY,CAC9B,OAAOA,GACR,CACA,OAAOA,CACR,CAEA,SAASC,EAAoBjB,EAAakB,EAAsBC,GAC/D,IAAIC,EAAoB,GACxB,GAAID,EAAkB,CACrB,OAAO7B,EAAe+B,YAAYrB,EAAO,SAC1C,CACA,OAAQkB,GACP,IAAK,WACJE,EAAoBE,EAAWC,kBAAkBC,OAAOxB,GACxD,MACD,IAAK,OACJoB,EAAoBE,EAAWG,kBAAkBD,OAAOxB,GACxD,MACD,QACC,MAEF,OAAOoB,CACR,CAUA,SAASM,EACR7B,EACAG,EACAkB,EACAC,GAEA,IAAIQ,EAA4B,GAChC,UAAW3B,IAAU,UAAW,CAC/B2B,EAAWC,EAAoB5B,EAChC,MAAO,GAAIA,aAAiB6B,KAAM,CACjCF,EAAWV,EAAoBjB,EAAOkB,EAAWC,EAClD,KAAO,CACNQ,EAAW3B,CACZ,CAEA,OAAQH,GACP,KAAKiC,EAAeC,GACnB,MAAO,KAAKJ,IACb,KAAKG,EAAeE,GACnB,MAAO,KAAKL,IACb,KAAKG,EAAeG,GACnB,MAAO,MAAMN,IACd,KAAKG,EAAeI,GACnB,MAAO,MAAMP,IACd,KAAKG,EAAeK,GACnB,MAAO,GAAGR,IACX,KAAKG,EAAeM,SACnB,MAAO,IAAIT,KACZ,KAAKG,EAAeO,SACnB,MAAO,IAAIV,IACZ,KAAKG,EAAeQ,WACnB,MAAO,GAAGX,KACX,KAAKG,EAAeS,GACnB,MAAO,MAAMZ,KACd,KAAKG,EAAeU,YACnB,MAAO,MAAMb,MACd,KAAKG,EAAeW,YACnB,MAAO,MAAMd,KACd,KAAKG,EAAeY,cACnB,MAAO,KAAKf,MACb,QACC,OAAOA,GAAUgB,WAEpB,CAEA,SAASC,EAAwB/C,EAA0BG,EAAqBkB,EAAsBC,GACrG,OAAOO,EAAY7B,EAAUG,EAAMG,YAAae,EAAWC,EAC5D,CAEA,SAAS0B,EACRhD,EACAiD,EACA5B,EACAC,GAEA,IAAI4B,EAAoC,GACxC,IAAIC,EAAoC,GACxC,UAAWF,EAAO,KAAO,UAAW,CACnCC,EAAYnB,EAAoBkB,EAAO,GACxC,MAAO,GAAIA,EAAO,aAAcjB,KAAM,CACrCkB,EAAY9B,EAAoB6B,EAAO,GAAI5B,EAAWC,EACvD,MAAO,UAAW2B,EAAO,KAAO,SAAU,CACzCC,EAAYD,EAAO,GAAG3C,WACvB,KAAO,CACN4C,EAAYD,EAAO,EACpB,CAEA,UAAWA,EAAO,KAAO,UAAW,CACnCE,EAAYpB,EAAoBkB,EAAO,GACxC,MAAO,GAAIA,EAAO,aAAcjB,KAAM,CACrCmB,EAAY/B,EAAoB6B,EAAO,GAAI5B,EAAWC,EACvD,MAAO,UAAW2B,EAAO,KAAO,SAAU,CACzCE,EAAYF,EAAO,GAAG3C,WACvB,KAAO,CACN6C,EAAYF,EAAO,EACpB,CACA,GAAIjD,IAAaiC,EAAemB,GAAI,CACnC,MAAO,GAAGF,OAAeC,GAC1B,KAAO,CACN,MAAO,KAAKD,OAAeC,IAC5B,CACD,CAEA,SAASE,EAAwBrD,GAChC,OAAOA,IAAaiC,EAAemB,IAAMpD,IAAaiC,EAAeqB,EACtE,CAEA,SAASvB,EAAoB5B,GAC5B,OAAOA,EACJb,EAAeiE,QAAQ,sCACvBjE,EAAeiE,QAAQ,sCAC3B,CAGA,SAASC,EAAqBC,GAC7B,MAAMC,EAAU,CAACzB,EAAeK,GAAIL,EAAeI,GAAIJ,EAAeE,GAAIF,EAAeG,GAAIH,EAAeC,GAAID,EAAemB,IAM/H,OAAOK,EAAYzD,WAAaiC,EAAemB,MAAQM,EAAQC,SAASF,EAAYzD,WAAayD,EAAYR,OAAOnD,QAAU,EAC/H,CAEA,SAAS8D,EACRC,EACAC,EACAC,EACAC,GAEA,GAAIF,EAAc,CACjB,MAAMG,EAAwD,CAAC,EAC/D,MAAMC,EAAqC,GAC3C,MAAMC,EAAmC,GACzC,MAAMC,EAAoC,GAE1C,IAAK,MAAMX,KAAeK,EAAc,CACvC,MAAMO,EAAiBN,EAAkBO,KAAMC,GAAUA,EAAMC,OAASf,EAAYe,MACpF,GAAIH,EAAgB,CAEnB,GAAII,OAAOC,UAAUC,eAAeC,KAAKP,EAAgB,gBAAkBA,GAAgBQ,WAAY,CACtGX,EAAyBY,KAAKT,EAAeU,OAASV,EAAeG,MACrE,QACD,CAEA,GAAIC,OAAOC,UAAUC,eAAeC,KAAKP,EAAgB,iBAAmBA,GAAgBW,aAAc,CACzGZ,EAAwBU,KAAKT,EAAeU,OAASV,EAAeG,MACpE,QACD,CAEA,GAAIH,GAAgBY,oBAAsB,eAAiBzB,EAAqBC,GAAc,CAC7FU,EAAuBW,KAAKT,EAAeU,OAASV,EAAeG,MACnEf,EAAYR,OAAS,EACtB,CAEA,MAAMiC,KAAEA,GAASb,EACjB,MAAMc,EAAatB,EAAOuB,UAAWC,GAAUA,EAAMC,MAAQ7B,EAAYe,MACzE,MAAMxE,SAAEA,EAAQiD,OAAEA,GAAWQ,EAC7B,IAAI8B,EACJ,GAAIC,EAAgBnC,wBAAwBrD,GAAW,CACtDuF,EAA4B,CAC3BvF,WACAC,eAAgBgD,EAElB,KAAO,CACNsC,EAA4B,CAC3BvF,SAAUA,EACVC,eAAgBgD,EAElB,CACA,GAAIkC,KAAgB,EAAG,CAEtB,MAAMM,EAA4B,CACjCH,IAAK7B,EAAYe,KACjBO,MAAOV,EAAeU,MACtBQ,0BAA2B,CAACA,GAC5BL,KAAMA,EACNQ,KAAMR,IAAS,YAAc,KAAO,OAErCrB,EAAOiB,KAAKW,EACb,KAAO,CAEN,MAAME,EAAe9B,EAAOsB,GAE5B,IAAKQ,EAAaC,YAAc,SAAW3B,EAA6B0B,EAAaL,KAAM,CAC1FK,EAAaJ,0BAA4B,CAACA,GAC1CtB,EAA6B0B,EAAaL,KAAO,IAClD,KAAO,CACLK,EAAaJ,0BAA8DT,KAAKS,EAClF,CACD,CACD,CACD,CACA,GAAIrB,EAAyBpE,OAAS,GAAKqE,EAAuBrE,OAAS,GAAKsE,EAAwBtE,OAAS,EAAG,CACnH,MAAM+F,EAAqB,GAC3B,GAAI3B,EAAyBpE,OAAS,EAAG,CACxC,MAAMgG,EAA0B,WAAW5B,EAAyB6B,KAAK,iBACzEF,EAASf,KAAKxF,EAAeiE,QAAQ,+BAAgC,CAACuC,IACvE,CACA,GAAI1B,EAAwBtE,OAAS,EAAG,CACvC,MAAMiF,EAAQ,WAAWX,EAAwB2B,KAAK,iBACtDF,EAASf,KAAKxF,EAAeiE,QAAQ,8BAA+B,CAACwB,IACtE,CACA,GAAIZ,EAAuBrE,OAAS,EAAG,CACtC,MAAMiF,EAAQ,WAAWZ,EAAuB4B,KAAK,iBACrDF,EAASf,KAAKxF,EAAeiE,QAAQ,6BAA8B,CAACwB,IACrE,CACAf,EAAmC6B,EAASE,KAAK,QAClD,CACD,CACD,CAEA,MAAMP,EAAkB,CACvB7F,eACAc,mBACAE,mBACAJ,eACAsB,cACAmB,gCACAK,0BACAO,aACAb,2BACC,OAEayC,CAAe","ignoreList":[]}